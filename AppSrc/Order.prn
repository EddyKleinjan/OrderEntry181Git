Compiling Program: C:\Test\Order Entry git\AppSrc\Order.src
Memory Available: 2147483646
1>Use OrderPrecompile.pkg
Using pre-compiled package ORDERPRECOMPILE.PKG
Including file: OrderPrecompile.pkd    (C:\Test\Order Entry git\AppSrc\OrderPrecompile.pkd)
75734>
75734>Use DfAllent.pkg
75734>Use cCJStandardCommandBarSystem.pkg
75734>Use cToolTipController.pkg
75734>Use cCJCommandBarSystem.pkg
75734>
75734>Object oHtmlHelp is a cHtmlHelp
75736>End_Object
75737>
75737>Object oApplication is a cApplication
75739>    Set psCompany to "Data Access Worldwide"
75740>    Set psProduct to "DataFlex Examples"
75741>    Set psVersion to "18.2"
75742>    Set psProgram to "Order"
75743>    Set psHelpFile to "Examples.chm"
75744>    Set peHelpType to htHtmlHelp
75745>End_Object
75746>
75746>Object oToolTipController is a cToolTipController
75748>    Move Self to ghoToolTipController
75749>End_Object
75750>
75750>Use oEditContextMenu.pkg
Including file: oEditContextMenu.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\oEditContextMenu.pkg)
75750>>>Use cCJStandardMenuItemClasses.pkg
75750>>>
75750>>>Object oEditContextMenu is a cCJContextMenu
75752>>>    
75752>>>    Move Self to Default_Form_Floating_Menu_ID
75753>>>    
75753>>>    Object oUndoMenuItem is a cCJUndoMenuItem
75755>>>    End_Object
75756>>>    
75756>>>    Object oCutMenuItem is a cCJCutMenuItem
75758>>>        Set pbControlBeginGroup to True
75759>>>    End_Object
75760>>>    
75760>>>    Object oCopyMenuItem is a cCJCopyMenuItem
75762>>>    End_Object
75763>>>
75763>>>    Object oPasteMenuItem is a cCJPasteMenuItem
75765>>>    End_Object
75766>>>
75766>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
75768>>>    End_Object
75769>>>
75769>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
75771>>>        Set pbControlBeginGroup to True
75772>>>    End_Object
75773>>>
75773>>>End_Object
75774>>>
75774>Use oDEOEditContextMenu17.pkg
Including file: oDEOEditContextMenu17.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\oDEOEditContextMenu17.pkg)
75774>>>Use Windows.pkg
75774>>>Use cCJStandardMenuItemClasses.pkg
75774>>>Use cCJDeoMenuItemClasses.pkg
75774>>>
75774>>>
75774>>>Object oDEOEditContextMenu17 is a cCJContextMenu
75776>>>    
75776>>>    Move Self to Default_dbFloating_Menu_ID
75777>>>    
75777>>>    Object oUndoMenuItem is a cCJUndoMenuItem
75779>>>    End_Object
75780>>>    
75780>>>    Object oCutMenuItem is a cCJCutMenuItem
75782>>>        Set pbControlBeginGroup to True
75783>>>    End_Object
75784>>>    
75784>>>    Object oCopyMenuItem is a cCJCopyMenuItem
75786>>>    End_Object
75787>>>
75787>>>    Object oPasteMenuItem is a cCJPasteMenuItem
75789>>>    End_Object
75790>>>
75790>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
75792>>>    End_Object
75793>>>
75793>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
75795>>>        Set pbControlBeginGroup to True
75796>>>    End_Object
75797>>>
75797>>>    Object oPromptMenuItem is a cCJPromptMenuItem
75799>>>        Set pbControlBeginGroup to True
75800>>>    End_Object
75801>>>
75801>>>    Object oFindNextMenu is a cCJFindNextMenuItem
75803>>>        Set pbControlBeginGroup to True
75804>>>    End_Object
75805>>>
75805>>>    Object oFindPreviousMenu is a cCJFindPreviousMenuItem
75807>>>    End_Object
75808>>>
75808>>>    Object oClearMenuItem is a cCJClearMenuItem
75810>>>        Set pbControlBeginGroup to True
75811>>>    End_Object
75812>>>
75812>>>    Object oClearAllMenu is a cCJClearAllMenuItem
75814>>>    End_Object
75815>>>
75815>>>    Object oSaveMenu is a cCJSaveMenuItem
75817>>>    End_Object
75818>>>    
75818>>>    Object oDeleteMenu is a cCJDeleteMenuItem
75820>>>    End_Object
75821>>>
75821>>>    Object oRememberitem is a cCJRememberFieldMenuItem
75823>>>        Set pbControlBeginGroup to True
75824>>>    End_Object
75825>>>
75825>>>    Object oRetainItem is a cCJRememberLastFieldMenuItem
75827>>>    End_Object
75828>>>
75828>>>    Object oUnRememberitem is a cCJUnRememberFieldMenuItem
75830>>>    End_Object
75831>>>
75831>>>    Object oCJClearAllDynamicDefaults is a cCJUnRememberFieldAllMenuItem
75833>>>    End_Object
75834>>>
75834>>>End_Object
75835>
75835>Object oMain is a Panel
75837>    Set Label to "Order Entry Sample Application In Git"
75838>    Set Location to 4 3
75839>    Set Size to 300 450
75840>
75840>    Object oCommandBarSystem is a cCJCommandBarSystem
75842>    
75842>        Set pbTimerUpdate to True
75843>    
75843>        Procedure OnCreateCommandBars
75846>            Handle hoOptions
75846>            Get OptionsObject to hoOptions
75847>            Forward Send OnCreateCommandBars
75849>        End_Procedure
75850>    
75850>        Object oMenuBar is a cCJMenuBar
75852>            
75852>            Object oFileMenu is a cCJMenuItem
75854>                
75854>                Set peControlType to xtpControlPopup          
75855>                Set psCaption   to "&File"
75856>                Set psDescription to "Find, Save, Delete, Clear information or quit this application."
75857>                Set psCategory to "Menus"
75858>    
75858>                Object oClearMenuItem is a cCJClearMenuItem
75860>                    Set pbAddToDesignerMenu to True
75861>                End_Object
75862>    
75862>                Object oClearAllMenu is a cCJClearAllMenuItem
75864>                    Set pbAddToDesignerMenu to True
75865>                End_Object
75866>    
75866>                Object oPromptMenuItem is a cCJPromptMenuItem
75868>                    Set pbAddToDesignerMenu to True
75869>                    Set pbControlBeginGroup to True
75870>                End_Object
75871>    
75871>                Object oFindMenuItem is a cCJFindMenuItem
75873>                    Set pbAddToDesignerMenu to True
75874>                    Set pbControlBeginGroup to True
75875>                End_Object
75876>    
75876>                Object oFindNextMenu is a cCJFindNextMenuItem
75878>                    Set pbAddToDesignerMenu to True
75879>                End_Object
75880>    
75880>                Object oFindPreviousMenu is a cCJFindPreviousMenuItem
75882>                    Set pbAddToDesignerMenu to True
75883>                End_Object
75884>    
75884>                Object oFindFirstMenu is a cCJFindFirstMenuItem
75886>                    Set pbAddToDesignerMenu to True
75887>                End_Object
75888>    
75888>                Object oFindLastMenu is a cCJFindLastMenuItem
75890>                    Set pbAddToDesignerMenu to True
75891>                End_Object
75892>    
75892>                Object oSaveMenuItem is a cCJSaveMenuItem
75894>                    Set pbAddToDesignerMenu to True
75895>                    Set pbControlBeginGroup to True
75896>                End_Object
75897>    
75897>                Object oDeleteMenuItem is a cCJDeleteMenuItem
75899>                    Set pbAddToDesignerMenu to True
75900>                End_Object
75901>    
75901>                Object oExitMenu is a cCJExitMenuItem
75903>                    Set pbControlBeginGroup to True
75904>                End_Object
75905>    
75905>            End_Object
75906>            
75906>            Object oViewMenu is a cCJMenuItem
75908>                
75908>                Set peControlType to xtpControlPopup
75909>                Set psCaption to "&View"
75910>                Set psToolTip to "View"
75911>                Set psDescription to "Available Views"
75912>    
75912>                Object oCustomerEntryViewMenuItem is a cCJMenuItem
75914>                    Set psCaption to "Customer Entry View"
75915>                    Set psShortcut to "Ctrl+1"
75916>                    Set psDescription to "Add, edit and delete Customer data."
75917>                    Set psToolTip to "Customer Entry View"
75918>                
75918>                    Procedure OnExecute Variant vCommandBarControl
75921>                        Handle hoClient
75921>                        Get Client_Id to hoClient
75922>                        Send Activate_oCustomerView of hoClient
75923>                    End_Procedure
75924>                End_Object
75925>    
75925>                Object oInventoryItemViewMenuItem is a cCJMenuItem
75927>                    Set psCaption to "Inventory Item View"
75928>                    Set psShortcut to "Ctrl+2"
75929>                    Set psDescription to "Add, edit and delete Inventory data."
75930>                    Set psToolTip to "Inventory Item View"
75931>                
75931>                    Procedure OnExecute Variant vCommandBarControl
75934>                        Handle hoClient
75934>                        Get Client_Id to hoClient
75935>                        Send Activate_oInventoryView of hoClient
75936>                    End_Procedure
75937>                End_Object
75938>    
75938>                Object oOrderEntryMenuItem is a cCJMenuItem
75940>                    Set psCaption to "Order Entry"
75941>                    Set psShortcut to "Ctrl+3"
75942>                    Set psDescription to "Add, edit and delete Order data."
75943>                    Set psToolTip to "Order Entry"
75944>                
75944>                    Procedure OnExecute Variant vCommandBarControl
75947>                        Handle hoClient
75947>                        Get Client_Id to hoClient
75948>                        Send Activate_oOrderEntryView of hoClient
75949>                    End_Procedure
75950>                End_Object
75951>    
75951>                Object oSalesPersonEntryViewMenuItem is a cCJMenuItem
75953>                    Set psCaption to "Sales Person Entry View"
75954>                    Set psShortcut to "Ctrl+4"
75955>                    Set psDescription to "Add, edit and delete Sales Person data."
75956>                    Set psToolTip to "Sales Person Entry View"
75957>                
75957>                    Procedure OnExecute Variant vCommandBarControl
75960>                        Handle hoClient
75960>                        Get Client_Id to hoClient
75961>                        Send Activate_oSalesPersonView of hoClient
75962>                    End_Procedure
75963>                End_Object
75964>    
75964>                Object oVendorEntryViewMenuItem is a cCJMenuItem
75966>                    Set psCaption to "Vendor Entry View"
75967>                    Set psShortcut to "Ctrl+5"
75968>                    Set psDescription to "Add, edit and delete Vendor data."
75969>                    Set psToolTip to "Vendor Entry View"
75970>                
75970>                    Procedure OnExecute Variant vCommandBarControl
75973>                        Handle hoClient
75973>                        Get Client_Id to hoClient
75974>                        Send Activate_oVendorView of hoClient
75975>                    End_Procedure
75976>                End_Object
75977>    
75977>            End_Object
75978>            
75978>            Object oReportMenu is a cCJMenuItem
75980>                
75980>                Set peControlType to xtpControlPopup          
75981>                Set psCaption to "&Report"
75982>                Set psToolTip to "Report"
75983>                Set psDescription to "Available Reports"
75984>    
75984>                Object oBasicReportsMenuItem is a cCJMenuItem
75986>                    Set psCaption to "Basic Reports"
75987>                    Set peControlType to xtpControlPopup
75988>                    Set psToolTip to "Basic Reports"
75989>                    Set psDescription to "Reports based on the Basic Report class."
75990>    
75990>                    Object oCustomerListMenuItem is a cCJMenuItem
75992>                        Set psCaption to "Customer List"
75993>                        Set psToolTip to "Customer List (Basic)"
75994>                    
75994>                        Procedure OnExecute Variant vCommandBarControl
75997>                            Handle hoClient
75997>                            Get Client_Id to hoClient
75998>                            Send Activate_oCustomerListBR of hoClient
75999>                        End_Procedure
76000>                    End_Object
76001>                End_Object
76002>    
76002>                Object oWinPrintReportsMenuItem is a cCJMenuItem
76004>                    Set psCaption to "WinPrint Reports"
76005>                    Set peControlType to xtpControlPopup
76006>                    Set psToolTip to "WinPrint Reports"
76007>                    Set psDescription to "Reports based on the WinPrint class."
76008>    
76008>                    Object oCustomerListMenuItem2 is a cCJMenuItem
76010>                        Set psCaption to "Customer List"
76011>                        Set psShortcut to "Ctrl+6"
76012>                        Set psToolTip to "Customer List (WinPrint)"
76013>                        Set psDescription to "Print Customer data."
76014>                    
76014>                        Procedure OnExecute Variant vCommandBarControl
76017>                            Handle hoClient
76017>                            Get Client_Id to hoClient
76018>                            Send Activate_oCustomerListWP of hoClient
76019>                        End_Procedure
76020>                    End_Object
76021>    
76021>                    Object oItemsperOrderMenuItem is a cCJMenuItem
76023>                        Set psCaption to "Items per Order"
76024>                        Set psShortcut to "Ctrl+7"
76025>                        Set psToolTip to "Items per Order (WinPrint)"
76026>                        Set psDescription to "Print line items for all Orders."
76027>                    
76027>                        Procedure OnExecute Variant vCommandBarControl
76030>                            Handle hoClient
76030>                            Get Client_Id to hoClient
76031>                            Send Activate_oItemsPerOrderWP of hoClient
76032>                        End_Procedure
76033>                    End_Object
76034>    
76034>                    Object oOrdersbyCustomerMenuItem1 is a cCJMenuItem
76036>                        Set psCaption to "Orders by Customer"
76037>                        Set psShortcut to "Ctrl+8"
76038>                        Set psToolTip to "Orders by Customer (WinPrint)"
76039>                        Set psDescription to "Print Order data sorted by Customer."
76040>                    
76040>                        Procedure OnExecute Variant vCommandBarControl
76043>                            Handle hoClient
76043>                            Get Client_Id to hoClient
76044>                            Send Activate_oOrdersByCustomerWP of hoClient
76045>                        End_Procedure
76046>                    End_Object
76047>    
76047>                    Object oOrdersbyOrderNumberMenuItem is a cCJMenuItem
76049>                        Set psCaption to "Orders by Order Number"
76050>                        Set psShortcut to "Ctrl+9"
76051>                        Set psToolTip to "Orders by Order Number (WinPrint)"
76052>                        Set psDescription to "Print Order data."
76053>                    
76053>                        Procedure OnExecute Variant vCommandBarControl
76056>                            Handle hoClient
76056>                            Get Client_Id to hoClient
76057>                            Send Activate_oOrdersWP of hoClient
76058>                        End_Procedure
76059>                    End_Object
76060>                End_Object
76061>    
76061>            End_Object
76062>                        
76062>            Object oNavigateMenu is a cCJMenuItem
76064>                Set peControlType to xtpControlPopup      
76065>                Set psCaption to "&Navigate"    
76066>                Set psTooltip to "Navigate"    
76067>                Set psDescription to "Move to different areas of the application"
76068>                
76068>                Object oNextAreaMenu is a cCJNextAreaMenu
76070>                End_Object
76071>                
76071>                Object oPriorAreaMenu is a cCJPriorAreaMenu
76073>                End_Object
76074>                
76074>                Object oNextViewMenu is a cCJNextViewMenu
76076>                End_Object
76077>                
76077>                Object oPriorViewMenu is a cCJPriorViewMenu
76079>                End_Object
76080>                
76080>                Object oPromptMenu is a cCJPromptMenuItem
76082>                    Set pbControlBeginGroup to True
76083>                End_Object
76084>    
76084>                Object oZoomMenu is a cCJZoomMenuItem
76086>                End_Object
76087>    
76087>            End_Object
76088>    
76088>            Object oWindowMenu is a cCJMDIWindowsMenuItem
76090>                Set peControlType to xtpControlPopup      
76091>                Set psCaption to "&Window"
76092>                Set psToolTip to "Window"
76093>                Set psDescription to "Display Current Views and set other display options."    
76094>                
76094>                // These are the static windows items. More will be created in onInitPopup 
76094>                Object oDisplayOptionsMenu is a cCJMenuItem
76096>                    Set peControlType to xtpControlPopup          
76097>                    Set psCaption to "&Display Options"
76098>                    Set psToolTip to "Display Options"
76099>                    Set psDescription to "Set display options"
76100>    
76100>                    Object oStatusbarMenu is a cCJStatusbarMenuItem
76102>                    End_Object
76103>    
76103>                    Object oAutoArrangeIconsMenu is a cCJAutoArrangeIconsMenuItem
76105>                    End_Object
76106>    
76106>                    Object oRestoreMenusMenu is a cCJRestoreMenusMenuItem
76108>                        Set pbControlBeginGroup to True
76109>                    End_Object
76110>                    
76110>                End_Object
76111>        
76111>                Object oCascadeMenu is a cCJCascadeMenuItem
76113>                    Set pbControlBeginGroup to True
76114>                End_Object
76115>    
76115>                Object oHorizTile is a cCJTileHorizontally
76117>                End_Object
76118>    
76118>                Object oVertTile is a cCJTileVertically
76120>                End_Object
76121>    
76121>                Object oMinimizeMenuItem is a cCJMinimizeWindowsMenuItem
76123>                    Set pbControlBeginGroup to True
76124>                End_Object
76125>    
76125>                Object oRestoreMenuItem is a cCJRestoreWindowsMenuItem
76127>                End_Object
76128>    
76128>                Object oArrangeIconsMenuItem is a cCJAutoArrangeIconsMenuItem
76130>                    Set pbControlBeginGroup to True
76131>                End_Object
76132>    
76132>            End_Object
76133>
76133>            Object oDemoMenuItem is a cCJMenuItem
76135>                Set psCaption to "&Demo"
76136>                Set psTooltip to "&Demo"
76137>                Set peControlType to xtpControlPopup
76138>                
76138>                Object oParentComboDemoMenuItem is a cCJMenuItem
76140>                    Set psCaption to "Parent Combo Demo"
76141>                    Set psTooltip to "Parent Combo Demo"
76142>                
76142>                    Procedure OnExecute Variant vCommandBarControl
76145>                        Handle hoClient
76145>                        Get Client_Id to hoClient
76146>                        Send Activate_oDemoParentCombos of hoClient
76147>                    End_Procedure
76148>                End_Object
76149>
76149>                Object oSuggestionFormMenuItem is a cCJMenuItem
76151>                    Set psCaption to "Suggestion Form"
76152>                    Set psTooltip to "Suggestion Form"
76153>                
76153>                    Procedure OnExecute Variant vCommandBarControl
76156>                        Handle hoClient
76156>                        Get Client_Id to hoClient
76157>                        Send Activate_oDemoSuggestionForm of hoClient
76158>                    End_Procedure
76159>                End_Object
76160>
76160>                Object oButtonSamplesMenuItem is a cCJMenuItem
76162>                    Set psCaption to "Button Samples"
76163>                    Set psTooltip to "Button Samples"
76164>                
76164>                    Procedure OnExecute Variant vCommandBarControl
76167>                        Handle hoClient
76167>                        Get Client_Id to hoClient
76168>                        Send Activate_oButtonTest of hoClient
76169>                    End_Procedure
76170>                End_Object
76171>
76171>                Object oCalendarControlSampleMenuItem is a cCJMenuItem
76173>                          Set psCaption to "Calendar Control Sample"
76174>                          Set psTooltip to "Calendar Control Sample"
76175>                
76175>                          Procedure OnExecute Variant vCommandBarControl
76178>                                    Handle hoClient
76178>                                    Get Client_Id to hoClient
76179>                                    Send Activate_oDemoCalendarControl of hoClient
76180>                          End_Procedure
76181>                End_Object
76182>            End_Object
76183>            
76183>            Object oHelpMenu is a cCJMenuItem
76185>                Set peControlType to xtpControlPopup    
76186>                Set psCaption to "&Help"
76187>                Set psDescription to "Access Information for learning and using this DataFlex application."
76188>                Set psToolTip to "Help"
76189>                
76189>                Object oHelpMenuItem is a cCJHelpMenuItem 
76191>                End_Object
76192>    
76192>                Object oAboutMenuItem is a cCJAboutMenuItem
76194>                End_Object
76195>           
76195>            End_Object
76196>    
76196>        End_Object
76197>    
76197>        Object oFindToolBar is a cCJToolbar
76199>            Set psTitle to "Finding Toolbar"
76200>    
76200>            Object oFindFirstTool is a cCJFindFirstMenuItem
76202>            End_Object
76203>    
76203>            Object oFindPreviousTool is a cCJFindPreviousMenuItem
76205>            End_Object
76206>    
76206>            Object oFindMenuTool is a cCJFindMenuItem
76208>            End_Object
76209>    
76209>            Object oFindNextTool is a cCJFindNextMenuItem
76211>            End_Object
76212>    
76212>            Object oFindLastTool is a cCJFindLastMenuItem
76214>            End_Object
76215>    
76215>            Object oPromptToolItem is a cCJPromptMenuItem
76217>                Set pbControlBeginGroup to True
76218>            End_Object
76219>    
76219>        End_Object
76220>            
76220>        Object oFileToolBar is a cCJToolbar
76222>            Set psTitle to "Data Entry Toolbar"
76223>    
76223>            Object oClearToolItem is a cCJClearMenuItem
76225>                Set peControlStyle to xtpButtonIconAndCaption
76226>            End_Object
76227>            
76227>            Object oClearAllToolItem2 is a cCJClearAllMenuItem
76229>                Set peControlStyle to xtpButtonIconAndCaption
76230>            End_Object
76231>                
76231>            Object oSaveToolItem is a cCJSaveMenuItem
76233>                Set peControlStyle to xtpButtonIconAndCaption
76234>                Set pbControlBeginGroup to True
76235>            End_Object
76236>    
76236>            Object oDeleteToolItem is a cCJDeleteMenuItem
76238>                Set peControlStyle to xtpButtonIconAndCaption
76239>            End_Object
76240>    
76240>        End_Object
76241>    
76241>        Object oEditToolBar is a cCJToolbar
76243>            Set psTitle to "Edit Toolbar"
76244>            
76244>            Object oCutToolbarItem is a cCJCutMenuItem
76246>            End_Object
76247>    
76247>            Object oCopyToolbarItem is a cCJCopyMenuItem
76249>            End_Object
76250>    
76250>            Object oPasteToolbarItem is a cCJPasteMenuItem
76252>            End_Object
76253>    
76253>            Object oDeleteEditToolbarItem is a cCJDeleteEditMenuItem
76255>                Set pbControlBeginGroup to True
76256>            End_Object
76257>    
76257>        End_Object
76258>                
76258>        Object oRememberToolbar is a cCJToolbar
76260>            Set psTitle to "Remember Toolbar"
76261>
76261>            Object oRememberItems is a cCJMenuItem
76263>
76263>                Set peControlType to xtpControlPopup
76264>                Set peControlStyle to xtpButtonCaption
76265>                Set psCaption to C_$Remember
76266>                
76266>                Object oMenuItem is a cCJRememberFieldMenuItem
76268>                    Set peControlStyle to xtpButtonIconAndCaption
76269>                End_Object
76270>                
76270>                Object oMenuItem is a cCJRememberLastFieldMenuItem
76272>                    Set peControlStyle to xtpButtonIconAndCaption
76273>                End_Object
76274>                
76274>                Object oMenuItem is a cCJUnRememberFieldMenuItem
76276>                    Set peControlStyle to xtpButtonIconAndCaption
76277>                End_Object
76278>                
76278>                Object oMenuItem is a cCJUnRememberFieldAllMenuItem
76280>                    Set peControlStyle to xtpButtonIconAndCaption
76281>                End_Object
76282>
76282>            End_Object
76283>
76283>        End_Object
76284>
76284>
76284>        Object oStatusBar is a cCJStatusBar
76286>            
76286>            Object oStatusPane1 is a cCJStatusBarPane
76288>                Set piID to sbpIDIdlePane
76289>                Set pbStyleStretch to True
76290>            End_Object
76291>    
76291>            Object oStatusPane2 is a cCJStatusBarPane
76293>                Set phoViewPane to Self
76294>                Set pbStyleStretch to True
76295>            End_Object
76296>    
76296>        End_Object
76297>    
76297>    End_Object
76298>
76298>    Object oClientArea is a ClientArea
76300>        Use Customer.vw
Including file: Customer.vw    (C:\Test\Order Entry git\AppSrc\Customer.vw)
76300>>>Use dfClient.pkg
76300>>>Use DataDict.pkg
76300>>>Use dfEntry.pkg
76300>>>Use dfTabDlg.pkg
76300>>>Use dfCEntry.pkg
76300>>>Use cDbTextEdit.Pkg
76300>>>Use Customer.DD
Including file: Customer.dd    (C:\Test\Order Entry git\DDSrc\Customer.dd)
76300>>>>>Use Windows.pkg           // Basic Definitions
76300>>>>>Use DataDict.pkg          // DataDictionary Class Definition
76300>>>>>Use DDvalTbl.pkg          // Validation Table Class Definitions
76300>>>>>
76300>>>>>Open Customer
Including file: Customer.fd    (C:\Test\Order Entry git\DDSrc\Customer.fd)
76302>>>>>Open OrderHea
Including file: OrderHea.fd    (C:\Test\Order Entry git\DDSrc\OrderHea.fd)
76304>>>>>Open Ordsys
Including file: OrdSys.fd    (C:\Test\Order Entry git\DDSrc\OrdSys.fd)
76306>>>>>
76306>>>>>
76306>>>>>Register_Object Customer_State_VT
76306>>>>>Register_Object Customer_sl
76306>>>>>
76306>>>>>Object Customer_State_VT  is a CodeValidationTable
76308>>>>>    Set Type_Value        To "STATES"
76309>>>>>    Set Table_Title       To "States"
76310>>>>>End_Object   // Customer_State_VT
76311>>>>>
76311>>>>>Register_Function ValidateEmail Integer iColumn String sValue Returns Boolean
76311>>>>>
76311>>>>>Class Customer_DataDictionary Is A DataDictionary
76312>>>>>
76312>>>>>    Procedure Construct_Object
76314>>>>>        Forward Send Construct_Object
76316>>>>>
76316>>>>>        Set Main_File To Customer.File_Number
76317>>>>>        Set Cascade_Delete_State To False
76318>>>>>
76318>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_FINDREQ to True
76319>>>>>        Set Foreign_Field_Option DD_INDEXFIELD DD_NOPUT to True
76320>>>>>        Set Foreign_Field_Option DD_DEFAULT DD_DISPLAYONLY to True
76321>>>>>
76321>>>>>        Set Add_Client_File to OrderHea.File_Number
76322>>>>>
76322>>>>>        Set Add_System_File to Ordsys.File_Number DD_LOCK_ON_NEW_SAVE
76323>>>>>
76323>>>>>        Set Field_Auto_Increment Field Customer.Customer_Number to File_Field Ordsys.Cust_Number
76324>>>>>        Set Field_Label_Long Field Customer.Customer_Number To "Customer Number"
76325>>>>>        Set Field_Label_Short Field Customer.Customer_Number To "Number"
76326>>>>>        Set Field_Option Field Customer.Customer_Number DD_AUTOFIND to True
76327>>>>>        Set Field_Option Field Customer.Customer_Number DD_NOPUT to True
76328>>>>>        Set Field_Prompt_Object Field Customer.Customer_Number to Customer_sl
76329>>>>>        Set Key_Field_State Field Customer.Customer_Number To True
76330>>>>>        Set Status_Help Field Customer.Customer_Number To "Customer Id Number (system assigned)."
76331>>>>>
76331>>>>>        Set Field_Label_Long Field Customer.Name To "Customer Name"
76332>>>>>        Set Field_Label_Short Field Customer.Name To "Customer Name"
76333>>>>>        Set Field_Option Field Customer.Name DD_REQUIRED to True
76334>>>>>        Set Field_Prompt_Object Field Customer.Name to Customer_sl
76335>>>>>        Set Status_Help Field Customer.Name To "Customer/Company Name."
76336>>>>>
76336>>>>>        Set Field_Label_Long Field Customer.Address To "Street Address"
76337>>>>>        Set Field_Label_Short Field Customer.Address To "Address"
76338>>>>>        Set Status_Help Field Customer.Address To "Street Address."
76339>>>>>
76339>>>>>        Set Status_Help Field Customer.City To "City Name."
76340>>>>>
76340>>>>>        Set Field_Class_Name Field Customer.State To "dbComboForm"
76341>>>>>        Set Field_Label_Long Field Customer.State To "State"
76342>>>>>        Set Field_Label_Short Field Customer.State To "St."
76343>>>>>        Set Field_Option Field Customer.State DD_CAPSLOCK to True
76344>>>>>        Set Field_Value_Table Field Customer.State to Customer_State_VT
76345>>>>>        Set Status_Help Field Customer.State To "Two letter state ID."
76346>>>>>
76346>>>>>        Set Field_Label_Long Field Customer.Zip To "Zip/Postal Code"
76347>>>>>        Set Field_Label_Short Field Customer.Zip To "Zip"
76348>>>>>        Set Field_Mask Field Customer.Zip To "#####-####"
76349>>>>>        Set Field_Mask_Type Field Customer.Zip To MASK_WINDOW
76350>>>>>        Set Status_Help Field Customer.Zip To "Zip or Postal Code."
76351>>>>>
76351>>>>>        Set Field_Label_Long Field Customer.Phone_Number To "Phone Number"
76352>>>>>        Set Field_Label_Short Field Customer.Phone_Number To "Phone"
76353>>>>>        Set Status_Help Field Customer.Phone_Number To "Phone Number."
76354>>>>>
76354>>>>>        Set Field_Label_Long Field Customer.Fax_Number To "Fax Number"
76355>>>>>        Set Field_Label_Short Field Customer.Fax_Number To "Fax"
76356>>>>>        Set Status_Help Field Customer.Fax_Number To "Fax Phone Number."
76357>>>>>
76357>>>>>        Set Field_Label_Long Field Customer.Email_Address To "E-Mail Address"
76358>>>>>        Set Field_Label_Short Field Customer.Email_Address To "E-Mail"
76359>>>>>        Set Status_Help Field Customer.Email_Address To "E-mail Address (internet)."
76360>>>>>        Set Field_Validate_msg Field Customer.EMail_Address to (RefFunc(ValidateEmail))
76361>>>>>        Set Field_Option Field Customer.EMail_Address DD_REQUIRED to True
76362>>>>>
76362>>>>>        Set Field_Class_Name Field Customer.Credit_Limit To "dbSpinForm"
76363>>>>>        Set Field_Mask_Type Field Customer.Credit_Limit To MASK_CURRENCY_WINDOW
76364>>>>>
76364>>>>>        Set Field_Label_Long Field Customer.Purchases To "Total Purchases"
76365>>>>>        Set Field_Label_Short Field Customer.Purchases To "Purchases"
76366>>>>>        Set Field_Mask_Type Field Customer.Purchases To MASK_CURRENCY_WINDOW
76367>>>>>        Set Field_Option Field Customer.Purchases DD_DISPLAYONLY to True
76368>>>>>
76368>>>>>        Set Field_Label_Long Field Customer.Balance To "Balance Due"
76369>>>>>        Set Field_Label_Short Field Customer.Balance To "Balance"
76370>>>>>        Set Field_Mask_Type Field Customer.Balance To MASK_CURRENCY_WINDOW
76371>>>>>        Set Field_Option Field Customer.Balance DD_DISPLAYONLY to True
76372>>>>>
76372>>>>>        Set Status_Help Field Customer.Comments To "Additional Comments and Notes."
76373>>>>>
76373>>>>>        Set Field_Checkbox_Values Field Customer.Status To "Y" "N"
76374>>>>>        Set Field_Label_Long Field Customer.Status To "Active Status"
76375>>>>>        Set Field_Label_Short Field Customer.Status To "Status"
76376>>>>>        Set Status_Help Field Customer.Status To "Active Inactive Status of customer"
76377>>>>>
76377>>>>>    End_Procedure  //  Construct_Object
76378>>>>>
76378>>>>>    Procedure Field_defaults
76380>>>>>        Forward Send Field_Defaults
76382>>>>>        Set Field_Changed_Value   Field Customer.State To "FL"
76383>>>>>        Set Field_Changed_Value   Field Customer.Credit_Limit To 1000
76384>>>>>        Set Field_Changed_Value   Field Customer.Status To "Y"
76385>>>>>    End_Procedure
76386>>>>>
76386>>>>>    //
76386>>>>>    //  Validates if the field contains a valid email address (it allows empty values to).
76386>>>>>    //
76386>>>>>    Function ValidateEmail Integer iColumn String sValue Returns Boolean
76388>>>>>        Integer iAt iDot
76388>>>>>        Boolean bResult
76388>>>>>        
76388>>>>>        If (Trim(sValue) <> "") Begin
76390>>>>>            Move (Pos("@", sValue)) to iAt
76391>>>>>            Move (RightPos(".", sValue)) to iDot
76392>>>>>            
76392>>>>>            If (not(iAt > 1 and iDot > 0 and iDot > iAt + 1 and iDot < Length(sValue))) Begin
76394>>>>>                Send Data_set_error iColumn DFERR_OPERATOR "Please enter a valid email address"
76395>>>>>                Move True to bResult
76396>>>>>            End
76396>>>>>>
76396>>>>>        End
76396>>>>>>
76396>>>>>        
76396>>>>>        Function_Return bResult
76397>>>>>    End_Function
76398>>>>>
76398>>>>>End_Class    //  Customer_DataDictionary
76399>>>>>
76399>>>>>
76399>>>>>Use Customer.sl      // Customer_sl
Including file: Customer.sl    (C:\Test\Order Entry git\AppSrc\Customer.sl)
76399>>>>>>>Use DFClient.pkg
76399>>>>>>>Use DFSelLst.pkg
76399>>>>>>>Use Windows.pkg
76399>>>>>>>Use cDbCJGridPromptList.pkg
76399>>>>>>>
76399>>>>>>>Use Customer.DD
76399>>>>>>>
76399>>>>>>>CD_Popup_Object Customer_sl is a dbModalPanel
76417>>>>>>>>
76417>>>>>>>
76417>>>>>>>    Set Border_Style to Border_Thick
76418>>>>>>>    Set Minimize_Icon to False
76419>>>>>>>    Set Label to "Customer List by john"
76420>>>>>>>    Set Size to 134 238
76421>>>>>>>    Set Location to 4 5
76422>>>>>>>    Set piMinSize to 134 238
76423>>>>>>>
76423>>>>>>>    Object Customer_DD is a Customer_DataDictionary
76425>>>>>>>    End_Object    // Customer_DD
76426>>>>>>>
76426>>>>>>>    Set Main_DD to Customer_DD
76427>>>>>>>    Set Server to Customer_DD
76428>>>>>>>
76428>>>>>>>    Object oSelList is a cDbCJGridPromptList
76430>>>>>>>        Set Size to 100 224
76431>>>>>>>        Set Location to 9 8
76432>>>>>>>        Set peAnchors to anAll
76433>>>>>>>        Set pbAllowColumnRemove to False
76434>>>>>>>
76434>>>>>>>        Object oNumber is a cDbCJGridColumn
76436>>>>>>>            Entry_Item Customer.Customer_Number
76437>>>>>>>            Set piWidth to 93
76438>>>>>>>            Set psCaption to "Number"
76439>>>>>>>        End_Object
76440>>>>>>>
76440>>>>>>>        Object oCustomerName is a cDbCJGridColumn
76442>>>>>>>            Entry_Item Customer.Name
76443>>>>>>>            Set piWidth to 243
76444>>>>>>>            Set psCaption to "Customer Name"
76445>>>>>>>        End_Object
76446>>>>>>>    End_Object  // oSelList
76447>>>>>>>
76447>>>>>>>    Object oOK_bn is a Button
76449>>>>>>>        Set Label to "&Ok"
76450>>>>>>>        Set Location to 116 77
76451>>>>>>>        Set peAnchors to anBottomRight
76452>>>>>>>
76452>>>>>>>        Procedure OnClick
76455>>>>>>>            Send OK of oSelList
76456>>>>>>>        End_Procedure
76457>>>>>>>
76457>>>>>>>    End_Object    // oOK_bn
76458>>>>>>>
76458>>>>>>>    Object oCancel_bn is a Button
76460>>>>>>>        Set Label to "&Cancel"
76461>>>>>>>        Set Location to 116 130
76462>>>>>>>        Set peAnchors to anBottomRight
76463>>>>>>>
76463>>>>>>>        Procedure OnClick
76466>>>>>>>            Send Cancel of oSelList
76467>>>>>>>        End_Procedure
76468>>>>>>>
76468>>>>>>>    End_Object    // oCancel_bn
76469>>>>>>>
76469>>>>>>>    Object oSearch_bn is a Button
76471>>>>>>>        Set Label to "&Search..."
76472>>>>>>>        Set Location to 116 183
76473>>>>>>>        Set peAnchors to anBottomRight
76474>>>>>>>
76474>>>>>>>        Procedure OnClick
76477>>>>>>>            Send Search of oSelList
76478>>>>>>>        End_Procedure
76479>>>>>>>
76479>>>>>>>    End_Object    // oSearch_bn
76480>>>>>>>
76480>>>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOk_bn
76481>>>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_bn
76482>>>>>>>    On_Key Key_Alt+Key_S Send KeyAction of oSearch_bn
76483>>>>>>>
76483>>>>>>>CD_End_Object    // Customer_sl
76485>>>>>>>>
76485>>>>>
76485>>>>>
76485>>>Use cSplitButton.pkg
Including file: cSplitButton.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cSplitButton.pkg)
76485>>>>>// cSplitButton class
76485>>>>>
76485>>>>>// This requires version 6 of common controls (vista or windows server 2008). If used with
76485>>>>>// older versions you will just get a regular button with no split part.
76485>>>>> 
76485>>>>>Use Windows.pkg
76485>>>>>
76485>>>>>Class cSplitButton is a Button
76486>>>>>
76486>>>>>    Procedure Page Integer iPageObject
76488>>>>>        Integer iStyle
76488>>>>>        Boolean bSupported
76488>>>>>        Get IsExControlSupported to bSupported
76489>>>>>        If (iPageObject=1  and bSupported) Begin
76491>>>>>            Get Form_Style iStyle to iStyle
76492>>>>>            Move (iStyle ior BS_SPLITBUTTON) to iStyle
76493>>>>>            Set Form_Style 0 to iStyle
76494>>>>>        End
76494>>>>>>
76494>>>>>        Forward Send Page iPageObject
76496>>>>>    End_Procedure
76497>>>>>    
76497>>>>>    Procedure Notify Integer wParam Integer lParam
76499>>>>>        tWinNmHdr Hdr
76499>>>>>        tWinNmHdr Hdr
76499>>>>>        Integer iVoid
76499>>>>>        Move (MemCopy(AddressOf(Hdr),lParam,SizeOfType(tWinNmHdr))) to iVoid
76500>>>>>        If (Hdr.code=BCN_DROPDOWN) Begin
76502>>>>>            Send OnDropDown
76503>>>>>        End
76503>>>>>>
76503>>>>>        Else Begin
76504>>>>>            Forward Send Notify wParam lParam
76506>>>>>        End
76506>>>>>>
76506>>>>>    End_Procedure
76507>>>>>    
76507>>>>>End_Class
76508>>>
76508>>>DEFERRED_VIEW Activate_oCustomerView FOR ;;Object oCustomerView is a dbView
76533>>>    Set Border_Style to Border_Thick
76534>>>    Set Label to "Customer Entry View"
76535>>>    Set Location to 7 23
76536>>>    Set Size to 146 277
76537>>>    Set piMaxSize to 300 350
76538>>>    Set piMinSize to 146 277
76539>>>
76539>>>    Object Customer_DD is a Customer_DataDictionary
76541>>>    End_Object    // Customer_DD
76542>>>
76542>>>    Set Main_DD to Customer_DD
76543>>>    Set Server to Customer_DD
76544>>>
76544>>>    Object oCustomer_Number is a dbForm
76546>>>        Entry_Item Customer.Customer_Number
76547>>>        Set Label to "Customer Number:"
76548>>>        Set Size to 13 42
76549>>>        Set Location to 5 72
76550>>>        Set peAnchors to anTopLeft
76551>>>        Set Label_Col_Offset to 2
76552>>>        Set Label_Justification_Mode to jMode_Right
76553>>>    End_Object    // oCustomer_Number
76554>>>
76554>>>    Object oCustomer_Name is a dbForm
76556>>>        Entry_Item Customer.Name
76557>>>        Set Label to "Name:"
76558>>>        Set Size to 13 186
76559>>>        Set Location to 20 72
76560>>>        Set peAnchors to anTopLeftRight
76561>>>        Set Label_Col_Offset to 2
76562>>>        Set Label_Justification_Mode to jMode_Right
76563>>>    End_Object    // oCustomer_Name
76564>>>
76564>>>    Object oCustTD is a dbTabDialog
76566>>>        Set Size to 105 265
76567>>>        Set Location to 36 7
76568>>>        Set Rotate_Mode to RM_Rotate
76569>>>        Set peAnchors to anAll
76570>>>        Object oAddress_TP is a dbTabPage
76572>>>            Set Label to "Address"
76573>>>            Set Tab_ToolTip_Value to "Customer contact information"
76574>>>            Object oCustomer_Address is a dbForm
76576>>>                Entry_Item Customer.Address
76577>>>                Set Label to "Street Address:"
76578>>>                Set Size to 13 180
76579>>>                Set Location to 8 62
76580>>>                Set peAnchors to anTopLeftRight
76581>>>                Set Label_Col_Offset to 2
76582>>>                Set Label_Justification_Mode to jMode_Right
76583>>>            End_Object    // oCustomer_Address
76584>>>
76584>>>            Object oCustomer_City is a dbForm
76586>>>                Entry_Item Customer.City
76587>>>                Set Label to "City/State/Zip:"
76588>>>                Set Size to 13 84
76589>>>                Set Location to 24 62
76590>>>                Set peAnchors to anTopLeftRight
76591>>>                Set Label_Col_Offset to 2
76592>>>                Set Label_Justification_Mode to jMode_Right
76593>>>            End_Object    // oCustomer_City
76594>>>
76594>>>            Object oCustomer_State is a dbComboForm
76596>>>                Entry_Item Customer.State
76597>>>                Set Size to 13 32
76598>>>                Set Location to 24 152
76599>>>                Set peAnchors to anTopRight
76600>>>                Set Form_Border to 0
76601>>>                Set Code_Display_Mode to cb_code_display_code
76602>>>            End_Object    // oCustomer_State
76603>>>
76603>>>            Object oCustomer_Zip is a dbForm
76605>>>                Entry_Item Customer.Zip
76606>>>                Set Size to 13 51
76607>>>                Set Location to 24 191
76608>>>                Set peAnchors to anTopRight
76609>>>            End_Object    // oCustomer_Zip
76610>>>
76610>>>            Object oCustomer_Phone_number is a dbForm
76612>>>                Entry_Item Customer.Phone_Number
76613>>>                Set Label to "Phone Number:"
76614>>>                Set Size to 13 120
76615>>>                Set Location to 39 62
76616>>>                Set peAnchors to anTopLeft
76617>>>                Set Label_Col_Offset to 2
76618>>>                Set Label_Justification_Mode to jMode_Right
76619>>>            End_Object    // oCustomer_Phone_number
76620>>>
76620>>>            Object oCustomer_Fax_number is a dbForm
76622>>>                Entry_Item Customer.Fax_Number
76623>>>                Set Label to "Fax Number:"
76624>>>                Set Size to 13 120
76625>>>                Set Location to 54 62
76626>>>                Set peAnchors to anTopLeft
76627>>>                Set Label_Col_Offset to 2
76628>>>                Set Label_Justification_Mode to jMode_Right
76629>>>            End_Object    // oCustomer_Fax_number
76630>>>
76630>>>            Object oCustomer_Email_address is a dbForm
76632>>>                Entry_Item Customer.EMail_Address
76633>>>                Set Label to "E-Mail Address:"
76634>>>                Set Size to 13 180
76635>>>                Set Location to 69 62
76636>>>                Set peAnchors to anTopLeftRight
76637>>>                Set Label_Col_Offset to 2
76638>>>                Set Label_Justification_Mode to jMode_Right
76639>>>            End_Object    // oCustomer_Email_address
76640>>>
76640>>>        End_Object    // oAddress_TP
76641>>>
76641>>>        Object oBalances_TP is a dbTabPage
76643>>>            Set Label to "Balances"
76644>>>            Set Tab_ToolTip_Value to "Current account balances"
76645>>>            Object oCustomer_Credit_Limit is a dbForm
76647>>>                Entry_Item Customer.Credit_limit
76648>>>                Set Label to "Credit Limit:"
76649>>>                Set Size to 13 48
76650>>>                Set Location to 9 72
76651>>>                Set Label_Col_Offset to 2
76652>>>                Set Label_Justification_Mode to jMode_Right
76653>>>            End_Object    // oCustomer_Credit_Limit
76654>>>
76654>>>            Object oCustomer_Purchases is a dbForm
76656>>>                Entry_Item Customer.Purchases
76657>>>                Set Label to "Total Purchases:"
76658>>>                Set Size to 13 48
76659>>>                Set Location to 24 72
76660>>>                Set Label_Col_Offset to 2
76661>>>                Set Label_Justification_Mode to jMode_Right
76662>>>            End_Object    // oCustomer_Purchases
76663>>>
76663>>>            Object oCustomer_Balance is a dbForm
76665>>>                Entry_Item Customer.Balance
76666>>>                Set Label to "Balance Due:"
76667>>>                Set Size to 13 48
76668>>>                Set Location to 39 72
76669>>>                Set Label_Col_Offset to 2
76670>>>                Set Label_Justification_Mode to jMode_Right
76671>>>            End_Object    // oCustomer_Balance
76672>>>
76672>>>        End_Object    // oBalances_TP
76673>>>
76673>>>        Object oDbTabPage1 is a dbTabPage
76675>>>            Set Label to 'oDbTabPage1'
76676>>>
76676>>>            Object oSplitButton1 is a cSplitButton
76678>>>                Set Location to 36 96
76679>>>                Set Label to 'oSplitButton1'
76680>>>            End_Object
76681>>>        End_Object
76682>>>
76682>>>        Object oComments_TP is a dbTabPage
76684>>>            Set Label to "Comments"
76685>>>            Set Tab_ToolTip_Value to "Notes about this customer"
76686>>>            Object oCustomer_Comments is a cDbTextEdit
76688>>>                Entry_Item Customer.Comments
76689>>>                Set Size to 71 242
76690>>>                Set Location to 9 9
76691>>>                Set peAnchors to anAll
76692>>>            End_Object    // oCustomer_Comments
76693>>>
76693>>>        End_Object    // oComments_TP
76694>>>
76694>>>    End_Object    // oCustTD
76695>>>
76695>>>    Object oCustomer_BSN is a dbForm
76697>>>        Entry_Item Customer.BSN
76698>>>        Set Location to 5 192
76699>>>        Set Size to 13 66
76700>>>        Set Label to "BSN:"
76701>>>    End_Object
76702>>>
76702>>>CD_End_Object    // oCustomerView
76704>>>>
76704>        Use Invt.vw
Including file: Invt.vw    (C:\Test\Order Entry git\AppSrc\Invt.vw)
76704>>>Use dfClient.pkg
76704>>>Use DataDict.pkg
76704>>>Use dfEntry.pkg
76704>>>Use Vendor.DD
Including file: Vendor.dd    (C:\Test\Order Entry git\DDSrc\Vendor.dd)
76704>>>>>Use  Windows.pkg           // Basic Definitions
76704>>>>>Use  DataDict.pkg          // DataDictionary Class Definition
76704>>>>>Use  DDvalTbl.pkg          // Validation Table Class Definitions
76704>>>>>
76704>>>>>Open Vendor
Including file: Vendor.fd    (C:\Test\Order Entry git\DDSrc\Vendor.fd)
76706>>>>>Open Invt
Including file: Invt.fd    (C:\Test\Order Entry git\DDSrc\Invt.fd)
76708>>>>>Open OrdSys
76710>>>>>
76710>>>>>
76710>>>>>Register_Object Vendor_State_VT
76710>>>>>
76710>>>>>Object Vendor_State_VT  is a CodeValidationTable
76712>>>>>    Set Type_Value        To "STATES"
76713>>>>>End_Object   // Vendor_State_VT
76714>>>>>Register_Object Vendor_sl
76714>>>>>
76714>>>>>Class Vendor_DataDictionary Is A DataDictionary
76715>>>>>
76715>>>>>    Procedure Construct_Object
76717>>>>>        Forward Send Construct_Object
76719>>>>>
76719>>>>>        Set Main_File To Vendor.File_Number
76720>>>>>        Set Cascade_Delete_State To False
76721>>>>>
76721>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_FINDREQ to True
76722>>>>>        Set Foreign_Field_Option DD_INDEXFIELD DD_NOPUT to True
76723>>>>>        Set Foreign_Field_Option DD_DEFAULT DD_DISPLAYONLY to True
76724>>>>>
76724>>>>>        Set Add_Client_File to Invt.File_Number
76725>>>>>
76725>>>>>        Set Add_System_File to Ordsys.File_Number DD_LOCK_ON_NEW_SAVE
76726>>>>>
76726>>>>>        Set Field_Auto_Increment Field Vendor.Id to File_Field Ordsys.Vendor_Number
76727>>>>>
76727>>>>>
76727>>>>>        Set Field_Label_Long Field Vendor.ID To "Vendor ID"
76728>>>>>        Set Field_Label_Short Field Vendor.ID To "Vndr ID"
76729>>>>>        Set Field_Option Field Vendor.ID DD_AUTOFIND to True
76730>>>>>        Set Field_Option Field Vendor.ID DD_NOPUT to True
76731>>>>>        Set Field_Prompt_Object Field Vendor.ID to Vendor_sl
76732>>>>>        Set Key_Field_State Field Vendor.ID To True
76733>>>>>        Set Status_Help Field Vendor.ID To "Vendor Id Number (system assigned)."
76734>>>>>
76734>>>>>        Set Field_Label_Long Field Vendor.Name To "Vendor Name"
76735>>>>>        Set Field_Label_Short Field Vendor.Name To "Name"
76736>>>>>        Set Field_Option Field Vendor.Name DD_REQUIRED to True
76737>>>>>        Set Field_Prompt_Object Field Vendor.Name to Vendor_sl
76738>>>>>        Set Status_Help Field Vendor.Name To "Vendor Name."
76739>>>>>
76739>>>>>        Set Field_Label_Long Field Vendor.Address To "Street Address"
76740>>>>>        Set Field_Label_Short Field Vendor.Address To "Address"
76741>>>>>        Set Status_Help Field Vendor.Address To "Street Address."
76742>>>>>
76742>>>>>        Set Status_Help Field Vendor.City To "City Name."
76743>>>>>
76743>>>>>        Set Field_Class_Name Field Vendor.State To "dbComboForm"
76744>>>>>        Set Field_Label_Long Field Vendor.State To "State"
76745>>>>>        Set Field_Label_Short Field Vendor.State To "St."
76746>>>>>        Set Field_Option Field Vendor.State DD_CAPSLOCK to True
76747>>>>>        Set Field_Value_Table Field Vendor.State to Vendor_State_VT
76748>>>>>        Set Status_Help Field Vendor.State To "Two letter state ID."
76749>>>>>
76749>>>>>        Set Field_Label_Long Field Vendor.Zip To "Zip/Postal Code"
76750>>>>>        Set Field_Label_Short Field Vendor.Zip To "Zip"
76751>>>>>        Set Field_Mask Field Vendor.Zip To "#####-####"
76752>>>>>        Set Field_Mask_Type Field Vendor.Zip To MASK_WINDOW
76753>>>>>        Set Status_Help Field Vendor.Zip To "Zip or Postal Code."
76754>>>>>
76754>>>>>        Set Field_Label_Long Field Vendor.Phone_Number To "Phone Number"
76755>>>>>        Set Field_Label_Short Field Vendor.Phone_Number To "Phone"
76756>>>>>        Set Status_Help Field Vendor.Phone_Number To "Phone Number."
76757>>>>>
76757>>>>>        Set Field_Label_Long Field Vendor.Fax_Number To "Fax Number"
76758>>>>>        Set Field_Label_Short Field Vendor.Fax_Number To "Fax"
76759>>>>>        Set Status_Help Field Vendor.Fax_Number To "Fax Phone Number."
76760>>>>>
76760>>>>>
76760>>>>>    End_Procedure  //  Construct_Object
76761>>>>>
76761>>>>>
76761>>>>>
76761>>>>>    Procedure Field_Defaults
76763>>>>>        Forward Send Field_Defaults
76765>>>>>    End_Procedure    // Field_Defaults
76766>>>>>    
76766>>>>>End_Class    //  Vendor_DataDictionary
76767>>>>>
76767>>>>>Use Vendor.sl        // Vendor_sl
Including file: Vendor.sl    (C:\Test\Order Entry git\AppSrc\Vendor.sl)
76767>>>>>>>Use DFClient.pkg
76767>>>>>>>Use DFSelLst.pkg
76767>>>>>>>Use Windows.pkg
76767>>>>>>>Use cDbCJGridPromptList.pkg
76767>>>>>>>
76767>>>>>>>Use Vendor.DD
76767>>>>>>>
76767>>>>>>>CD_Popup_Object Vendor_sl is a dbModalPanel
76785>>>>>>>>
76785>>>>>>>    Set Label to "Vendor List"
76786>>>>>>>    Set Size to 132 238
76787>>>>>>>    Set Location to 4 5
76788>>>>>>>    Set piMinSize to 132 238
76789>>>>>>>
76789>>>>>>>    Object Vendor_DD is a Vendor_DataDictionary
76791>>>>>>>    End_Object    // Vendor_DD
76792>>>>>>>
76792>>>>>>>    Set Main_DD to Vendor_DD
76793>>>>>>>    Set Server to Vendor_DD
76794>>>>>>>
76794>>>>>>>    Object oSelList is a cDbCJGridPromptList
76796>>>>>>>        Set Size to 95 229
76797>>>>>>>        Set Location to 12 4
76798>>>>>>>        Set pbAllowColumnRemove to False
76799>>>>>>>        Set peAnchors to anAll
76800>>>>>>>
76800>>>>>>>        Object oVendor_ID is a cDbCJGridColumn
76802>>>>>>>            Entry_Item Vendor.ID
76803>>>>>>>            Set piWidth to 63
76804>>>>>>>            Set psCaption to "ID"
76805>>>>>>>        End_Object
76806>>>>>>>
76806>>>>>>>        Object oVendor_Name is a cDbCJGridColumn
76808>>>>>>>            Entry_Item Vendor.Name
76809>>>>>>>            Set piWidth to 280
76810>>>>>>>            Set psCaption to "Vendor Name"
76811>>>>>>>        End_Object
76812>>>>>>>    End_Object
76813>>>>>>>
76813>>>>>>>    Object oOK_bn is a Button
76815>>>>>>>        Set Label to "&Ok"
76816>>>>>>>        Set Location to 114 77
76817>>>>>>>        Set peAnchors to anBottomRight
76818>>>>>>>
76818>>>>>>>        Procedure OnClick
76821>>>>>>>            Send OK of oSelList
76822>>>>>>>        End_Procedure
76823>>>>>>>
76823>>>>>>>    End_Object    // oOK_bn
76824>>>>>>>
76824>>>>>>>    Object oCancel_bn is a Button
76826>>>>>>>        Set Label to "&Cancel"
76827>>>>>>>        Set Location to 114 130
76828>>>>>>>        Set peAnchors to anBottomRight
76829>>>>>>>
76829>>>>>>>        Procedure OnClick
76832>>>>>>>            Send Cancel of oSelList
76833>>>>>>>        End_Procedure
76834>>>>>>>
76834>>>>>>>    End_Object    // oCancel_bn
76835>>>>>>>
76835>>>>>>>    Object oSearch_bn is a Button
76837>>>>>>>        Set Label to "&Search..."
76838>>>>>>>        Set Location to 114 183
76839>>>>>>>        Set peAnchors to anBottomRight
76840>>>>>>>
76840>>>>>>>        Procedure OnClick
76843>>>>>>>            Send Search of oSelList
76844>>>>>>>        End_Procedure
76845>>>>>>>
76845>>>>>>>    End_Object    // oSearch_bn
76846>>>>>>>
76846>>>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOk_bn
76847>>>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_bn
76848>>>>>>>    On_Key Key_Alt+Key_S Send KeyAction of oSearch_bn
76849>>>>>>>
76849>>>>>>>CD_End_Object    // Vendor_sl
76851>>>>>>>>
76851>>>>>
76851>>>>>
76851>>>Use Invt.DD
Including file: Invt.dd    (C:\Test\Order Entry git\DDSrc\Invt.dd)
76851>>>>>Use  Windows.pkg           // Basic Definitions
76851>>>>>Use  DataDict.pkg          // DataDictionary Class Definition
76851>>>>>Use  DDvalTbl.pkg          // Validation Table Class Definitions
76851>>>>>
76851>>>>>Open Invt
76853>>>>>Open OrderDtl
Including file: OrderDtl.fd    (C:\Test\Order Entry git\DDSrc\OrderDtl.fd)
76855>>>>>Open Vendor
76857>>>>>
76857>>>>>Register_Object Invt_sl
76857>>>>>
76857>>>>>Class Invt_DataDictionary Is A DataDictionary
76858>>>>>
76858>>>>>    Procedure Construct_Object
76860>>>>>        Forward Send Construct_Object
76862>>>>>
76862>>>>>        Set Main_File To Invt.File_Number
76863>>>>>        Set Cascade_Delete_State To False
76864>>>>>
76864>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_FINDREQ to True
76865>>>>>        Set Foreign_Field_Option DD_INDEXFIELD DD_NOPUT to True
76866>>>>>        Set Foreign_Field_Option DD_DEFAULT DD_DISPLAYONLY to True
76867>>>>>
76867>>>>>        Set Add_Client_File to OrderDtl.File_Number
76868>>>>>
76868>>>>>        Set Add_Server_File to Vendor.File_Number
76869>>>>>
76869>>>>>
76869>>>>>        Set Field_Label_Long Field Invt.Item_ID To "Invt. Item ID"
76870>>>>>        Set Field_Label_Short Field Invt.Item_ID To "Item ID"
76871>>>>>        Set Field_Option Field Invt.Item_ID DD_AUTOFIND to True
76872>>>>>        Set Field_Option Field Invt.Item_ID DD_REQUIRED to True
76873>>>>>        Set Field_Option Field Invt.Item_ID DD_CAPSLOCK to True
76874>>>>>        Set Field_Prompt_Object Field Invt.Item_ID to Invt_sl
76875>>>>>        Set Key_Field_State Field Invt.Item_ID To True
76876>>>>>        Set Status_Help Field Invt.Item_ID To "Inventory Item Id - user defined identification"
76877>>>>>
76877>>>>>        Set Field_Label_Long Field Invt.Description To "Invt. Description"
76878>>>>>        Set Field_Label_Short Field Invt.Description To "Description"
76879>>>>>        Set Field_Option Field Invt.Description DD_REQUIRED to True
76880>>>>>        Set Status_Help Field Invt.Description To "Inventory Part Description"
76881>>>>>
76881>>>>>        Set Field_Option Field Invt.Vendor_ID DD_CAPSLOCK to True
76882>>>>>        Set Status_Help Field Invt.Vendor_ID To "Vendor Number"
76883>>>>>
76883>>>>>        Set Field_Option Field Invt.Vendor_Part_ID DD_REQUIRED to True
76884>>>>>        Set Status_Help Field Invt.Vendor_Part_ID To "Vendor ID name for this item"
76885>>>>>
76885>>>>>        Set Field_Mask_Type Field Invt.Unit_Price To MASK_CURRENCY_WINDOW
76886>>>>>        Set Field_Value_Range Field Invt.Unit_Price To 0 999999.99
76887>>>>>        Set Status_Help Field Invt.Unit_Price To "Retail unit price"
76888>>>>>
76888>>>>>        Set Field_Value_Range Field Invt.On_Hand To -999999 999999
76889>>>>>        Set Status_Help Field Invt.On_Hand To "Units currently available"
76890>>>>>
76890>>>>>    End_Procedure  //  Construct_Object
76891>>>>>  
76891>>>>>    Function Validate_Save Returns Integer
76893>>>>>        Integer iRetVal
76893>>>>>    
76893>>>>>        Forward Get Validate_Save to iRetVal
76895>>>>>        
76895>>>>>        If iRetVal Function_Return iRetVal
76898>>>>>    
76898>>>>>        If Invt.On_Hand Lt 0 Begin
76900>>>>>           Send UserError "Insufficient Inventory Stock" ""
76901>>>>>           Function_Return 1
76902>>>>>        End   
76902>>>>>>
76902>>>>>    End_Function  // Validate_Save
76903>>>>>
76903>>>>>
76903>>>>>    Procedure Field_Defaults
76905>>>>>        Forward Send Field_Defaults
76907>>>>>    End_Procedure    // Field_Defaults
76908>>>>>    
76908>>>>>End_Class    //  Invt_DataDictionary
76909>>>>>
76909>>>>>Use Invt.sl          // Invt_sl
Including file: Invt.sl    (C:\Test\Order Entry git\AppSrc\Invt.sl)
76909>>>>>>>Use DFClient.pkg
76909>>>>>>>Use DFSelLst.pkg
76909>>>>>>>Use Windows.pkg
76909>>>>>>>
76909>>>>>>>Use Vendor.DD
76909>>>>>>>Use Invt.DD
76909>>>>>>>
76909>>>>>>>CD_Popup_Object Invt_sl is a dbModalPanel
76927>>>>>>>>
76927>>>>>>>
76927>>>>>>>    Set Minimize_Icon to False
76928>>>>>>>    Set Label to "Inventory List"
76929>>>>>>>    Set Size to 133 284
76930>>>>>>>    Set Location to 4 4
76931>>>>>>>    Set piMinSize to 133 284
76932>>>>>>>
76932>>>>>>>    Object Vendor_DD is a Vendor_DataDictionary
76934>>>>>>>    End_Object    // Vendor_DD
76935>>>>>>>
76935>>>>>>>    Object Invt_DD is a Invt_DataDictionary
76937>>>>>>>        Set DDO_Server to Vendor_DD
76938>>>>>>>    End_Object    // Invt_DD
76939>>>>>>>
76939>>>>>>>    Set Main_DD to Invt_DD
76940>>>>>>>    Set Server to Invt_DD
76941>>>>>>>
76941>>>>>>>    Object oSelList is a cDbCJGridPromptList
76943>>>>>>>        Set Size to 105 273
76944>>>>>>>        Set Location to 6 6
76945>>>>>>>        Set peAnchors to anAll
76946>>>>>>>        Set pbAllowColumnRemove to False
76947>>>>>>>
76947>>>>>>>        Object oItemID is a cDbCJGridColumn
76949>>>>>>>            Entry_Item Invt.Item_iD
76950>>>>>>>            Set psCaption to "Item ID"
76951>>>>>>>            Set piWidth to 74
76952>>>>>>>        End_Object
76953>>>>>>>        
76953>>>>>>>        Object oDescription is a cDbCJGridColumn
76955>>>>>>>            Entry_Item Invt.Description
76956>>>>>>>            Set psCaption to "Description"
76957>>>>>>>            Set piWidth to 205
76958>>>>>>>        End_Object
76959>>>>>>>        
76959>>>>>>>        Object oUnitPrice is a cDbCJGridColumn
76961>>>>>>>            Entry_Item Invt.Unit_Price
76962>>>>>>>            Set psCaption to "Unit Price"
76963>>>>>>>            Set piWidth to 69
76964>>>>>>>        End_Object
76965>>>>>>>        
76965>>>>>>>        Object oOnHand is a cDbCJGridColumn
76967>>>>>>>            Entry_Item Invt.On_Hand
76968>>>>>>>            Set psCaption to "On Hand"
76969>>>>>>>            Set piWidth to 61
76970>>>>>>>        End_Object
76971>>>>>>>
76971>>>>>>>    End_Object    // oSelList
76972>>>>>>>
76972>>>>>>>    Object oOK_bn is a Button
76974>>>>>>>        Set Label to "&Ok"
76975>>>>>>>        Set Location to 115 123
76976>>>>>>>        Set peAnchors to anBottomRight
76977>>>>>>>
76977>>>>>>>        Procedure OnClick
76980>>>>>>>            Send OK of oSelList
76981>>>>>>>        End_Procedure
76982>>>>>>>
76982>>>>>>>    End_Object    // oOK_bn
76983>>>>>>>
76983>>>>>>>    Object oCancel_bn is a Button
76985>>>>>>>        Set Label to "&Cancel"
76986>>>>>>>        Set Location to 115 176
76987>>>>>>>        Set peAnchors to anBottomRight
76988>>>>>>>
76988>>>>>>>        Procedure OnClick
76991>>>>>>>            Send Cancel of oSelList
76992>>>>>>>        End_Procedure
76993>>>>>>>
76993>>>>>>>    End_Object    // oCancel_bn
76994>>>>>>>
76994>>>>>>>    Object oSearch_bn is a Button
76996>>>>>>>        Set Label to "&Search..."
76997>>>>>>>        Set Location to 115 229
76998>>>>>>>        Set peAnchors to anBottomRight
76999>>>>>>>
76999>>>>>>>        Procedure OnClick
77002>>>>>>>            Send Search of oSelList
77003>>>>>>>        End_Procedure
77004>>>>>>>
77004>>>>>>>    End_Object    // oSearch_bn
77005>>>>>>>
77005>>>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOk_bn
77006>>>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_bn
77007>>>>>>>    On_Key Key_Alt+Key_S Send KeyAction of oSearch_bn
77008>>>>>>>
77008>>>>>>>CD_End_Object    // Invt_sl
77010>>>>>>>>
77010>>>>>
77010>>>>>
77010>>>
77010>>>DEFERRED_VIEW Activate_oInventoryView FOR ;;Object oInventoryView is a dbView
77035>>>    Set Border_Style to Border_Thick
77036>>>    Set Label to "Inventory Item View"
77037>>>    Set Location to 5 8
77038>>>    Set Size to 151 305
77039>>>    Set piMaxSize to 115 350
77040>>>    Set piMinSize to 151 270
77041>>>
77041>>>    Object Vendor_DD is a Vendor_DataDictionary
77043>>>    End_Object    // Vendor_DD
77044>>>
77044>>>    Object Invt_DD is a Invt_DataDictionary
77046>>>        Set DDO_Server to Vendor_DD
77047>>>    End_Object    // Invt_DD
77048>>>
77048>>>    Set Main_DD to Invt_DD
77049>>>    Set Server to Invt_DD
77050>>>
77050>>>    Object oDbCont is a dbContainer3d
77052>>>        Set Size to 140 295
77053>>>        Set Location to 5 4
77054>>>        Set peAnchors to anAll
77055>>>        Object oInvt_Item_ID is a dbForm
77057>>>            Entry_Item Invt.Item_ID
77058>>>            Set Label to "Invt. Item ID:"
77059>>>            Set Size to 13 60
77060>>>            Set Location to 10 70
77061>>>            Set peAnchors to anTopLeft
77062>>>            Set Label_Col_Offset to 2
77063>>>            Set Label_Justification_Mode to jMode_Right
77064>>>        End_Object    // oInvt_Item_Id
77065>>>
77065>>>        Object oInvt_Description is a dbForm
77067>>>            Entry_Item Invt.Description
77068>>>            Set Label to "Invt. Description:"
77069>>>            Set Size to 13 210
77070>>>            Set Location to 25 70
77071>>>            Set peAnchors to anTopLeftRight
77072>>>            Set Label_Col_Offset to 2
77073>>>            Set Label_Justification_Mode to jMode_Right
77074>>>        End_Object    // oInvt_Description
77075>>>
77075>>>        Object oVendorGroup is a dbGroup
77077>>>            Set Size to 58 271
77078>>>            Set Location to 41 9
77079>>>            Set peAnchors to anAll
77080>>>            Set Label to "Vendor"
77081>>>            Object oInvt_Vendor_ID is a dbForm
77083>>>                Entry_Item Vendor.ID
77084>>>                Set Label to "Vendor ID:"
77085>>>                Set Size to 13 42
77086>>>                Set Location to 9 61
77087>>>                Set peAnchors to anTopLeft
77088>>>                Set Label_Col_Offset to 2
77089>>>                Set Label_Justification_Mode to jMode_Right
77090>>>            End_Object    // oInvt_Vendor_Id
77091>>>
77091>>>            Object oVendor_Name is a dbForm
77093>>>                Entry_Item Vendor.Name
77094>>>                Set Label to "Vendor Name:"
77095>>>                Set Size to 13 180
77096>>>                Set Location to 24 61
77097>>>                Set peAnchors to anTopLeftRight
77098>>>                Set Label_Col_Offset to 2
77099>>>                Set Label_Justification_Mode to jMode_Right
77100>>>            End_Object    // oVendor_Name
77101>>>
77101>>>            Object oInvt_Vendor_Part_ID is a dbForm
77103>>>                Entry_Item Invt.Vendor_Part_ID
77104>>>                Set Label to "Vendor Part ID:"
77105>>>                Set Size to 13 90
77106>>>                Set Location to 39 61
77107>>>                Set peAnchors to anTopLeft
77108>>>                Set Label_Col_Offset to 2
77109>>>                Set Label_Justification_Mode to jMode_Right
77110>>>            End_Object    // oInvt_Vendor_Part_ID
77111>>>
77111>>>        End_Object    // oVendorGroup
77112>>>
77112>>>        Object oUnitGroup is a dbGroup
77114>>>            Set Size to 28 271
77115>>>            Set Location to 101 9
77116>>>            Set peAnchors to anAll
77117>>>            Object oInvt_Unit_Price is a dbForm
77119>>>                Entry_Item Invt.Unit_Price
77120>>>                Set Label to "Unit Price:"
77121>>>                Set Size to 13 48
77122>>>                Set Location to 10 61
77123>>>                Set peAnchors to anTopLeft
77124>>>                Set Label_Col_Offset to 2
77125>>>                Set Label_Justification_Mode to jMode_Right
77126>>>            End_Object    // oInvt_Unit_Price
77127>>>
77127>>>            Object oInvt_On_Hand is a dbForm
77129>>>                Entry_Item Invt.On_Hand
77130>>>                Set Label to "On Hand:"
77131>>>                Set Size to 13 36
77132>>>                Set Location to 10 205
77133>>>                Set peAnchors to anTopRight
77134>>>                Set Label_Col_Offset to 2
77135>>>                Set Label_Justification_Mode to jMode_Right
77136>>>            End_Object    // oInvt_On_Hand
77137>>>
77137>>>        End_Object    // oUnitGroup
77138>>>
77138>>>    End_Object    // oDbCont
77139>>>
77139>>>CD_End_Object    // oInventoryView
77141>>>>
77141>        Use Order.vw
Including file: Order.vw    (C:\Test\Order Entry git\AppSrc\Order.vw)
77141>>>Use dfClient.pkg
77141>>>Use DataDict.pkg
77141>>>Use dfEntry.pkg
77141>>>Use dfSpnEnt.pkg
77141>>>Use dfCEntry.pkg
77141>>>Use dfTable.pkg
77141>>>Use Windows.pkg
77141>>>Use Vendor.DD
77141>>>Use Invt.DD
77141>>>Use Customer.DD
77141>>>Use SalesP.DD
Including file: SalesP.dd    (C:\Test\Order Entry git\DDSrc\SalesP.dd)
77141>>>>>Use  Windows.pkg           // Basic Definitions
77141>>>>>Use  DataDict.pkg          // DataDictionary Class Definition
77141>>>>>Use  DDvalTbl.pkg          // Validation Table Class Definitions
77141>>>>>
77141>>>>>Open Salesp
Including file: SalesP.fd    (C:\Test\Order Entry git\DDSrc\SalesP.fd)
77143>>>>>Open Orderhea
77145>>>>>
77145>>>>>Register_Object SalesP_sl
77145>>>>>
77145>>>>>Class SalesP_DataDictionary Is A DataDictionary
77146>>>>>
77146>>>>>    Procedure Construct_Object
77148>>>>>        Forward Send Construct_Object
77150>>>>>
77150>>>>>        Set Main_File To Salesp.File_Number
77151>>>>>        Set Cascade_Delete_State To FALSE
77152>>>>>
77152>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_NOPUT to True
77153>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_FINDREQ to True
77154>>>>>        Set Foreign_Field_Option DD_INDEXFIELD DD_NOPUT to True
77155>>>>>        Set Foreign_Field_Option DD_DEFAULT DD_DISPLAYONLY to True
77156>>>>>
77156>>>>>        Set Add_Client_File to Orderhea.File_Number
77157>>>>>
77157>>>>>
77157>>>>>        Set Field_Label_Long Field Salesp.Id To "Sales Person ID"
77158>>>>>        Set Field_Label_Short Field Salesp.Id To "ID"
77159>>>>>        Set Field_Option Field Salesp.Id DD_AUTOFIND to True
77160>>>>>        Set Field_Option Field Salesp.Id DD_REQUIRED to True
77161>>>>>        Set Field_Option Field Salesp.Id DD_CAPSLOCK to True
77162>>>>>        Set Field_Prompt_Object Field Salesp.Id to SalesP_sl
77163>>>>>        Set Key_Field_State Field Salesp.Id To TRUE
77164>>>>>        Set Status_Help Field Salesp.Id To "Sales person ID code - Upper case alpha"
77165>>>>>
77165>>>>>        Set Field_Label_Long Field Salesp.Name To "Sales Person Name"
77166>>>>>        Set Field_Label_Short Field Salesp.Name To "Sales Person Name"
77167>>>>>        Set Field_Prompt_Object Field Salesp.Name to SalesP_sl
77168>>>>>        Set Status_Help Field Salesp.Name To "Sales person name - first and last"
77169>>>>>
77169>>>>>    End_Procedure  //  Construct_Object
77170>>>>>
77170>>>>>
77170>>>>>    Procedure Field_Defaults
77172>>>>>        Forward Send Field_Defaults
77174>>>>>    End_Procedure    // Field_Defaults
77175>>>>>    
77175>>>>>End_Class    //  Salesp_DataDictionary
77176>>>>>
77176>>>>>Use SalesP.sl        // SalesP_sl
Including file: Salesp.sl    (C:\Test\Order Entry git\AppSrc\Salesp.sl)
77176>>>>>>>Use DFClient.pkg
77176>>>>>>>Use DFSelLst.pkg
77176>>>>>>>Use Windows.pkg
77176>>>>>>>Use cDbCJGridPromptList.pkg
77176>>>>>>>
77176>>>>>>>Use SalesP.DD
77176>>>>>>>
77176>>>>>>>CD_Popup_Object SalesP_sl is a dbModalPanel
77194>>>>>>>>
77194>>>>>>>
77194>>>>>>>    Set Minimize_Icon to False
77195>>>>>>>    Set Label to "Sales Person List"
77196>>>>>>>    Set Size to 99 260
77197>>>>>>>    Set Location to 4 5
77198>>>>>>>    Set piMinSize to 99 180
77199>>>>>>>
77199>>>>>>>    Object SalesP_DD is a SalesP_DataDictionary
77201>>>>>>>    End_Object    // Salesp_DD
77202>>>>>>>
77202>>>>>>>    Set Main_DD to SalesP_DD
77203>>>>>>>    Set Server to SalesP_DD
77204>>>>>>>
77204>>>>>>>    Object oSelList is a cDbCJGridPromptList
77206>>>>>>>        Set Size to 70 249
77207>>>>>>>        Set Location to 6 5
77208>>>>>>>        Set pbAllowColumnRemove to False
77209>>>>>>>        Set peAnchors to anAll
77210>>>>>>>
77210>>>>>>>        Object oSalesP_ID is a cDbCJGridColumn
77212>>>>>>>            Entry_Item SalesP.ID
77213>>>>>>>            Set piWidth to 60
77214>>>>>>>            Set psCaption to "ID"
77215>>>>>>>        End_Object
77216>>>>>>>
77216>>>>>>>        Object oSalesP_Name is a cDbCJGridColumn
77218>>>>>>>            Entry_Item SalesP.Name
77219>>>>>>>            Set piWidth to 313
77220>>>>>>>            Set psCaption to "Sales Person Name"
77221>>>>>>>        End_Object
77222>>>>>>>    End_Object
77223>>>>>>>
77223>>>>>>>    Object oOK_bn is a Button
77225>>>>>>>        Set Label to "&Ok"
77226>>>>>>>        Set Location to 81 99
77227>>>>>>>        Set peAnchors to anBottomRight
77228>>>>>>>        Set Default_State to True
77229>>>>>>>
77229>>>>>>>        Procedure OnClick
77232>>>>>>>            Send OK of oSelList
77233>>>>>>>        End_Procedure
77234>>>>>>>
77234>>>>>>>    End_Object    // oOK_bn
77235>>>>>>>
77235>>>>>>>    Object oCancel_bn is a Button
77237>>>>>>>        Set Label to "&Cancel"
77238>>>>>>>        Set Location to 81 152
77239>>>>>>>        Set peAnchors to anBottomRight
77240>>>>>>>
77240>>>>>>>        Procedure OnClick
77243>>>>>>>            Send Cancel of oSelList
77244>>>>>>>        End_Procedure
77245>>>>>>>
77245>>>>>>>    End_Object    // oCancel_bn
77246>>>>>>>
77246>>>>>>>    Object oSearch_bn is a Button
77248>>>>>>>        Set Label to "&Search..."
77249>>>>>>>        Set Location to 81 205
77250>>>>>>>        Set peAnchors to anBottomRight
77251>>>>>>>
77251>>>>>>>        Procedure OnClick
77254>>>>>>>            Send Search of oSelList
77255>>>>>>>        End_Procedure
77256>>>>>>>
77256>>>>>>>    End_Object    // oSearch_bn
77257>>>>>>>
77257>>>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOk_bn
77258>>>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_bn
77259>>>>>>>    On_Key Key_Alt+Key_S Send KeyAction of oSearch_bn
77260>>>>>>>
77260>>>>>>>CD_End_Object    // SalesP_sl
77262>>>>>>>>
77262>>>>>
77262>>>>>
77262>>>Use OrderHea.DD
Including file: OrderHea.dd    (C:\Test\Order Entry git\DDSrc\OrderHea.dd)
77262>>>>>Use  Windows.pkg           // Basic Definitions
77262>>>>>Use  DataDict.pkg          // DataDictionary Class Definition
77262>>>>>Use  DDvalTbl.pkg          // Validation Table Class Definitions
77262>>>>>
77262>>>>>Open OrderHea
77264>>>>>Open OrderDtl
77266>>>>>Open Customer
77268>>>>>Open SalesP
77270>>>>>Open OrdSys
77272>>>>>
77272>>>>>
77272>>>>>Register_Object Terms_table
77272>>>>>Register_Object Ship_Table
77272>>>>>
77272>>>>>Object Terms_table  is a DescriptionValidationTable
77274>>>>>
77274>>>>>    Procedure Fill_List
77277>>>>>        Forward Send Fill_List
77279>>>>>        Send Add_Table_Value  "NONE"  "None established"
77280>>>>>        Send Add_Table_Value  "COD"  "COD"
77281>>>>>        Send Add_Table_Value  "NET30"  "Net 30"
77282>>>>>        Send Add_Table_Value  "NET60"  "Net 60"
77283>>>>>        Send Add_Table_Value  "NET90"  "Net 90"
77284>>>>>        Send Add_Table_Value  "PREPAY"  "Pre-payment required"
77285>>>>>    End_Procedure    // Fill_List
77286>>>>>End_Object   // Terms_table
77287>>>>>
77287>>>>>Object Ship_Table  is a CodeValidationTable
77289>>>>>    Set Type_Value        To "SHIPPING"
77290>>>>>    Set Allow_Blank_State To True
77291>>>>>End_Object   // Ship_Table
77292>>>>>
77292>>>>>Register_Object OrderHea_sl
77292>>>>>
77292>>>>>Class OrderHea_DataDictionary Is A DataDictionary
77293>>>>>
77293>>>>>    Procedure Construct_Object
77295>>>>>        Forward Send Construct_Object
77297>>>>>
77297>>>>>        Set Main_File To OrderHea.File_Number
77298>>>>>
77298>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_FINDREQ to True
77299>>>>>        Set Foreign_Field_Option DD_INDEXFIELD DD_NOPUT to True
77300>>>>>        Set Foreign_Field_Option DD_DEFAULT DD_DISPLAYONLY to True
77301>>>>>
77301>>>>>        Set Add_Client_File to OrderDtl.File_Number
77302>>>>>
77302>>>>>        Set Add_Server_File to Customer.File_Number
77303>>>>>        Set Add_Server_File to SalesP.File_Number
77304>>>>>
77304>>>>>        Set ParentNullAllowed SalesP.File_Number to True
77305>>>>>        Set ParentNoSwitchIfCommitted Customer.File_Number to True
77306>>>>>
77306>>>>>        Set Add_System_File to OrdSys.File_Number DD_LOCK_ON_NEW_SAVE_DELETE
77307>>>>>
77307>>>>>        Set Field_Auto_Increment Field OrderHea.Order_Number to File_Field OrdSys.Order_Number
77308>>>>>
77308>>>>>
77308>>>>>        Set Field_Option Field OrderHea.Order_Number DD_AUTOFIND to True
77309>>>>>        Set Field_Prompt_Object Field OrderHea.Order_Number to OrderHea_SL
77310>>>>>        Set Key_Field_State Field OrderHea.Order_Number To True
77311>>>>>        Set Status_Help Field OrderHea.Order_Number To "Order Number - New orders are assigned numbers automatically"
77312>>>>>
77312>>>>>
77312>>>>>        Set Field_Class_Name Field OrderHea.Order_Date To "dbSpinForm"
77313>>>>>        Set Field_Entry_msg Field OrderHea.Order_Date To Entry_Order_Date
77314>>>>>        Set Field_Mask_Type Field OrderHea.Order_Date To MASK_DATE_WINDOW
77315>>>>>        Set Field_Prompt_Object Field OrderHea.Order_Date to OrderHea_SL
77316>>>>>        Set Status_Help Field OrderHea.Order_Date To "Date on which the order was placed"
77317>>>>>        Set Field_Option Field OrderHea.Order_Date DD_COMMIT to True
77318>>>>>
77318>>>>>        Set Field_Class_Name Field OrderHea.Terms To "dbComboForm"
77319>>>>>        Set Field_Value_Table Field OrderHea.Terms to Terms_table
77320>>>>>        Set Status_Help Field OrderHea.Terms To "Payment terms"
77321>>>>>
77321>>>>>        Set Field_Class_Name Field OrderHea.Ship_Via To "dbComboForm"
77322>>>>>        Set Field_Value_Table Field OrderHea.Ship_Via to Ship_Table
77323>>>>>        Set Status_Help Field OrderHea.Ship_Via To "Shipping method"
77324>>>>>
77324>>>>>        Set Status_Help Field OrderHea.Ordered_By To "Order placed by"
77325>>>>>        Set Field_Option Field OrderHea.Ordered_By DD_COMMIT to True
77326>>>>>
77326>>>>>        Set Field_Label_Long Field OrderHea.Salesperson_ID To "Sales Person ID"
77327>>>>>        Set Field_Label_Short Field OrderHea.Salesperson_ID To "Sales ID"
77328>>>>>        Set Status_Help Field OrderHea.Salesperson_ID To "Sales Person who initiated the order"
77329>>>>>
77329>>>>>        Set Field_Mask_Type Field OrderHea.Order_Total To MASK_CURRENCY_WINDOW
77330>>>>>        Set Field_Option Field OrderHea.Order_Total DD_DISPLAYONLY to True
77331>>>>>
77331>>>>>
77331>>>>>    End_Procedure  // Construct_Object
77332>>>>>
77332>>>>>    Procedure Field_Defaults
77334>>>>>        Forward Send Field_Defaults
77336>>>>>    End_Procedure
77337>>>>>
77337>>>>>    // Add a default date if the field is blank
77337>>>>>    Procedure Entry_Order_Date Integer iField Date dDate
77339>>>>>         Integer iChanged
77339>>>>>         
77339>>>>>         Get Field_Changed_State iField To iChanged
77340>>>>>         If (iChanged=0 And dDate=0) Begin
77342>>>>>            SysDate dDate
77343>>>>>            Set Field_Default_Value iField To dDate
77344>>>>>         End
77344>>>>>>
77344>>>>>    End_Procedure
77345>>>>>
77345>>>>>    Procedure Update
77347>>>>>        Forward Send Update
77349>>>>>        Send Adjust_Balances OrderHea.Order_Total
77350>>>>>    End_Procedure
77351>>>>>
77351>>>>>    Procedure Backout
77353>>>>>        Forward Send Backout
77355>>>>>        Send Adjust_Balances (-OrderHea.Order_Total)
77356>>>>>    End_Procedure
77357>>>>>
77357>>>>>    Procedure Adjust_Balances Number Amt
77359>>>>>        Add Amt To Customer.Purchases
77360>>>>>        Add Amt To Customer.Balance
77361>>>>>    End_Procedure
77362>>>>>
77362>>>>>    Procedure Deleting
77364>>>>>        Forward Send Deleting
77366>>>>>        // see if we can decrement the order number in sys file...can only do
77366>>>>>        // this if this is the newest order.
77366>>>>>        If (OrderHea.Order_Number=OrdSys.Order_Number) Begin // if this is
77368>>>>>           Decrement OrdSys.Order_Number          // the last number,
77369>>>>>           Saverecord OrdSys                      // decrement and save.
77370>>>>>        End
77370>>>>>>
77370>>>>>    End_Procedure
77371>>>>>
77371>>>>>End_Class    //  OrderHea_DataDictionary
77372>>>>>
77372>>>>>Use OrderHea.sl      // OrderHea_sl
Including file: Orderhea.sl    (C:\Test\Order Entry git\AppSrc\Orderhea.sl)
77372>>>>>>>Use DFClient.pkg
77372>>>>>>>Use DFSelLst.pkg
77372>>>>>>>Use Windows.pkg
77372>>>>>>>Use cDbCJGridPromptList.pkg
77372>>>>>>>
77372>>>>>>>Use Customer.DD
77372>>>>>>>Use OrderHea.DD
77372>>>>>>>
77372>>>>>>>
77372>>>>>>>CD_Popup_Object OrderHea_sl is a dbModalPanel
77390>>>>>>>>
77390>>>>>>>
77390>>>>>>>    Set Minimize_Icon to False
77391>>>>>>>    Set Label to "Order List"
77392>>>>>>>    Set Size to 134 392
77393>>>>>>>    Set Location to 4 5
77394>>>>>>>    Set piMinSize to 134 392
77395>>>>>>>
77395>>>>>>>    Object Customer_DD is a Customer_DataDictionary
77397>>>>>>>    End_Object    // Customer_DD
77398>>>>>>>
77398>>>>>>>    Object OrderHea_DD is a OrderHea_DataDictionary
77400>>>>>>>        Set DDO_Server to Customer_DD
77401>>>>>>>    End_Object    // OrderHea_DD
77402>>>>>>>
77402>>>>>>>    Set Main_DD to OrderHea_DD
77403>>>>>>>    Set Server to OrderHea_DD
77404>>>>>>>
77404>>>>>>>    Object oSelList is a cDbCJGridPromptList
77406>>>>>>>        Set Size to 100 377
77407>>>>>>>        Set Location to 9 7
77408>>>>>>>        Set pbAllowColumnRemove to False
77409>>>>>>>        Set peAnchors to anAll
77410>>>>>>>
77410>>>>>>>        Object oOrderHea_Order_Number is a cDbCJGridColumn
77412>>>>>>>            Entry_Item OrderHea.Order_Number
77413>>>>>>>            Set piWidth to 87
77414>>>>>>>            Set psCaption to "Order Number"
77415>>>>>>>        End_Object
77416>>>>>>>
77416>>>>>>>        Object oCustomer_Customer_Number is a cDbCJGridColumn
77418>>>>>>>            Entry_Item Customer.Customer_Number
77419>>>>>>>            Set piWidth to 84
77420>>>>>>>            Set psCaption to "Cust. Number"
77421>>>>>>>        End_Object
77422>>>>>>>
77422>>>>>>>        Object oCustomer_Name is a cDbCJGridColumn
77424>>>>>>>            Entry_Item Customer.Name
77425>>>>>>>            Set piWidth to 231
77426>>>>>>>            Set psCaption to "Customer Name"
77427>>>>>>>        End_Object
77428>>>>>>>
77428>>>>>>>        Object oOrderHea_Order_Date is a cDbCJGridColumn
77430>>>>>>>            Entry_Item OrderHea.Order_Date
77431>>>>>>>            Set piWidth to 75
77432>>>>>>>            Set psCaption to "Order Date"
77433>>>>>>>            Set peTextAlignment to xtpAlignmentRight
77434>>>>>>>        End_Object
77435>>>>>>>
77435>>>>>>>        Object oOrderHea_Order_Total is a cDbCJGridColumn
77437>>>>>>>            Entry_Item OrderHea.Order_Total
77438>>>>>>>            Set piWidth to 88
77439>>>>>>>            Set psCaption to "Order Total"
77440>>>>>>>        End_Object
77441>>>>>>>    End_Object
77442>>>>>>>
77442>>>>>>>    Object oOK_bn is a Button
77444>>>>>>>        Set Label to "&Ok"
77445>>>>>>>        Set Location to 116 231
77446>>>>>>>        Set peAnchors to anBottomRight
77447>>>>>>>
77447>>>>>>>        Procedure OnClick
77450>>>>>>>            Send OK of oSelList
77451>>>>>>>        End_Procedure
77452>>>>>>>
77452>>>>>>>    End_Object    // oOK_bn
77453>>>>>>>
77453>>>>>>>    Object oCancel_bn is a Button
77455>>>>>>>        Set Label to "&Cancel"
77456>>>>>>>        Set Location to 116 284
77457>>>>>>>        Set peAnchors to anBottomRight
77458>>>>>>>
77458>>>>>>>        Procedure OnClick
77461>>>>>>>            Send Cancel of oSelList
77462>>>>>>>        End_Procedure
77463>>>>>>>
77463>>>>>>>    End_Object    // oCancel_bn
77464>>>>>>>
77464>>>>>>>    Object oSearch_bn is a Button
77466>>>>>>>        Set Label to "&Search..."
77467>>>>>>>        Set Location to 116 337
77468>>>>>>>        Set peAnchors to anBottomRight
77469>>>>>>>
77469>>>>>>>        Procedure OnClick
77472>>>>>>>            Send Search of oSelList
77473>>>>>>>        End_Procedure
77474>>>>>>>
77474>>>>>>>    End_Object    // oSearch_bn
77475>>>>>>>
77475>>>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOk_bn
77476>>>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_bn
77477>>>>>>>    On_Key Key_Alt+Key_S Send KeyAction of oSearch_bn
77478>>>>>>>
77478>>>>>>>CD_End_Object    // OrderHea_sl
77480>>>>>>>>
77480>>>>>
77480>>>>>
77480>>>Use OrderDtl.DD
Including file: OrderDtl.dd    (C:\Test\Order Entry git\DDSrc\OrderDtl.dd)
77480>>>>>Use  Windows.pkg           // Basic Definitions
77480>>>>>Use  DataDict.pkg          // DataDictionary Class Definition
77480>>>>>Use  DDvalTbl.pkg          // Validation Table Class Definitions
77480>>>>>
77480>>>>>Open OrderDtl
77482>>>>>Open OrderHea
77484>>>>>Open Invt
77486>>>>>
77486>>>>>
77486>>>>>Class OrderDtl_DataDictionary Is A DataDictionary
77487>>>>>
77487>>>>>    Procedure Construct_Object
77489>>>>>        Forward Send Construct_Object
77491>>>>>
77491>>>>>        Set Main_File To OrderDtl.File_Number
77492>>>>>        Set Cascade_Delete_State To False
77493>>>>>
77493>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_FINDREQ to True
77494>>>>>        Set Foreign_Field_Option DD_INDEXFIELD DD_NOPUT to True
77495>>>>>        Set Foreign_Field_Option DD_DEFAULT DD_DISPLAYONLY to True
77496>>>>>
77496>>>>>        Set Add_Server_File to OrderHea.File_Number
77497>>>>>        Set Add_Server_File to Invt.File_Number
77498>>>>>
77498>>>>>        Set Field_Auto_Increment Field OrderDtl.Detail_Number to File_Field OrderHea.Last_Detail_Num
77499>>>>>
77499>>>>>
77499>>>>>        Set Field_Option Field OrderDtl.Order_Number DD_NOPUT to True
77500>>>>>
77500>>>>>        Set Field_Option Field OrderDtl.Detail_Number DD_NOPUT to True
77501>>>>>
77501>>>>>
77501>>>>>        Set Field_Exit_msg Field OrderDtl.Qty_Ordered To Adjust_Display_Total
77502>>>>>        Set Field_Label_Long Field OrderDtl.Qty_Ordered To "Quantity Ordered"
77503>>>>>        Set Field_Label_Short Field OrderDtl.Qty_Ordered To "Quantity"
77504>>>>>        Set Field_Mask_Type Field OrderDtl.Qty_Ordered To MASK_NUMERIC_WINDOW
77505>>>>>        Set Status_Help Field OrderDtl.Qty_Ordered To "Number of items ordered"
77506>>>>>
77506>>>>>        Set Field_Entry_msg Field OrderDtl.Price To Entering_Price
77507>>>>>        Set Field_Exit_msg Field OrderDtl.Price To Adjust_Display_Total
77508>>>>>        Set Field_Label_Long Field OrderDtl.Price To "Price per Unit"
77509>>>>>        Set Field_Label_Short Field OrderDtl.Price To "Price"
77510>>>>>        Set Field_Mask_Type Field OrderDtl.Price To MASK_CURRENCY_WINDOW
77511>>>>>        Set Status_Help Field OrderDtl.Price To "Price per Unit"
77512>>>>>
77512>>>>>        Set Field_Label_Long Field OrderDtl.Extended_Price To "Extended Price"
77513>>>>>        Set Field_Label_Short Field OrderDtl.Extended_Price To "Total"
77514>>>>>        Set Field_Mask_Type Field OrderDtl.Extended_Price To MASK_CURRENCY_WINDOW
77515>>>>>        Set Field_Option Field OrderDtl.Extended_Price DD_DISPLAYONLY to True
77516>>>>>        Set Status_Help Field OrderDtl.Extended_Price To "Total extended price"
77517>>>>>
77517>>>>>    End_Procedure  //  Construct_Object
77518>>>>>
77518>>>>>    // Update and Backout need to adjust the Invt.On_Hand quantity,
77518>>>>>    // the dtl line's extended price and the OrderHea total. We will call
77518>>>>>    // the same procedure (Adjust_Balances) to insure that backout and
77518>>>>>    // update are inverses of each other.
77518>>>>>    // Note that Backout does not need to change the extended_price. This
77518>>>>>    // only gets changed as part of update.
77518>>>>>    Procedure Update
77520>>>>>        Forward Send Update
77522>>>>>        Move (OrderDtl.Price * OrderDtl.Qty_Ordered) To OrderDtl.Extended_Price
77523>>>>>        Send Adjust_Balances OrderDtl.Qty_Ordered OrderDtl.Extended_Price
77524>>>>>    End_Procedure
77525>>>>>    
77525>>>>>    Procedure Backout
77527>>>>>        Forward Send Backout
77529>>>>>        Send Adjust_Balances (-OrderDtl.Qty_Ordered) (-OrderDtl.Extended_Price)
77530>>>>>    End_Procedure
77531>>>>>
77531>>>>>    // Called by Backout and Update passing the quantity
77531>>>>>    // and the extended price. 
77531>>>>>    // Subtract quantity from Invt on-hand and
77531>>>>>    // add extended amnt to order total.
77531>>>>>    Procedure Adjust_Balances Number Qty Number Amt
77533>>>>>        Subtract Qty From Invt.On_Hand
77534>>>>>        Add      Amt To   OrderHea.Order_Total
77535>>>>>    End_Procedure
77536>>>>>
77536>>>>>    // when entering the price field we may wish to update the
77536>>>>>    // current field value with the standard unit price from the
77536>>>>>    // Invt file. Only do this if the current amount is zero and an item was actually picked. If non-
77536>>>>>    // zero or no item picked, we assume the field is being edited (and we make no assumptions). 
77536>>>>>    Procedure Entering_Price Integer Field# Number nAmnt
77538>>>>>        Handle hoInvtDD
77538>>>>>        Boolean bHasRecord
77538>>>>>
77538>>>>>        Get Data_Set Invt.File_Number to hoInvtDD
77539>>>>>
77539>>>>>        If (hoInvtDD) Begin
77541>>>>>            Get HasRecord of hoInvtDD to bHasRecord
77542>>>>>        
77542>>>>>            If (nAmnt=0 and bHasRecord) Begin
77544>>>>>               Get File_Field_Current_Value File_Field Invt.Unit_Price to nAmnt
77545>>>>>               Set Field_Changed_Value Field# to nAmnt
77546>>>>>               Send Adjust_Display_Total
77547>>>>>            End
77547>>>>>>
77547>>>>>        End
77547>>>>>>
77547>>>>>        
77547>>>>>    End_Procedure
77548>>>>>
77548>>>>>    // This updates the extended price field, which will update any 
77548>>>>>    // display balances. This is only done for display purposes. The actual
77548>>>>>    // amount is updated to the field during the save.
77548>>>>>    Procedure Adjust_Display_total Integer iField String sValue
77550>>>>>        Integer iQty
77550>>>>>        Number  nAmnt
77550>>>>>        
77550>>>>>        Get Field_Current_Value Field OrderDtl.Qty_Ordered    To iQty
77551>>>>>        Get Field_Current_Value Field OrderDtl.Price          To nAmnt
77552>>>>>        Set Field_Current_Value Field OrderDtl.Extended_Price To (nAmnt * iQty)
77553>>>>>        // note we set value, but not changed state!
77553>>>>>    End_Procedure
77554>>>>>
77554>>>>>
77554>>>>>    Procedure Field_Defaults
77556>>>>>        Forward Send Field_Defaults
77558>>>>>    End_Procedure    // Field_Defaults
77559>>>>>    
77559>>>>>End_Class    //  OrderDtl_DataDictionary
77560>>>>>
77560>>>Use cDbCJGrid.pkg
77560>>>Use cCJGridColumnRowIndicator.pkg
Including file: cCJGridColumnRowIndicator.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cCJGridColumnRowIndicator.pkg)
77560>>>>>Use cCJGridColumn.pkg
77560>>>>>
77560>>>>>Class cCJGridColumnRowIndicator is a cCJGridColumn
77561>>>>>    
77561>>>>>    Procedure Construct_Object
77563>>>>>        Forward Send Construct_Object
77565>>>>>    
77565>>>>>        Property Integer piImage 0
77566>>>>>        
77566>>>>>        Set psCaption to ""
77567>>>>>        Set piWidth to 20
77568>>>>>        Set pbResizable to False
77569>>>>>        Set pbEditable to False
77570>>>>>        Set pbFocusable to False
77571>>>>>        Set pbAllowDrag to False
77572>>>>>        Set psToolTip to "Row Indicator"
77573>>>>>//        Set Color to (RGB(217,222,243))   //JVH
77573>>>>>    End_Procedure
77574>>>>>    
77574>>>>>    Procedure OnCreateColumn
77576>>>>>        Integer iImage
77576>>>>>        Delegate Get AddImage "GridColumnRowIndicator.bmp" 0 to iImage
77578>>>>>        Set piImage to iImage
77579>>>>>    End_Procedure
77580>>>>>            
77580>>>>>    Procedure OnSetDisplayMetrics Handle hoGridItemMetrics Integer iRow String ByRef sValue
77582>>>>>        Integer iImage iFocusedRow
77582>>>>>        Handle hoDataSource
77582>>>>>        
77582>>>>>        Get phoDataSource to hoDataSource
77583>>>>>        Get SelectedRow of hoDataSource to iFocusedRow
77584>>>>>        Move -1 to iImage
77585>>>>>        If (iRow = iFocusedRow) Begin
77587>>>>>            Get piImage to iImage
77588>>>>>            Set ComItemIcon of hoGridItemMetrics to iImage
77589>>>>>        End
77589>>>>>>
77589>>>>>    End_Procedure
77590>>>>>
77590>>>>>End_Class
77591>>>
77591>>>Use MonthCalendarPrompt.dg
Including file: MonthCalendarPrompt.dg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\MonthCalendarPrompt.dg)
77591>>>>>// Month Calendar Prompt dialog
77591>>>>>
77591>>>>>
77591>>>>>Use cMonthCalendarPrompt.pkg
Including file: cMonthCalendarPrompt.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cMonthCalendarPrompt.pkg)
77591>>>>>>>Use cMonthCalendar.pkg
Including file: cMonthCalendar.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cMonthCalendar.pkg)
77591>>>>>>>>>Use Windows.pkg
77591>>>>>>>>>Use Commctrl.pkg
77591>>>>>>>>>Use tWinStructs.pkg
77591>>>>>>>>>Use cWinControlEx.pkg
Including file: cWinControlEx.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cWinControlEx.pkg)
77591>>>>>>>>>>>Use cWinControl.pkg
77591>>>>>>>>>>>// This adds proper navigation and default button support for
77591>>>>>>>>>>>// external classes
77591>>>>>>>>>>>
77591>>>>>>>>>>>Class cWinControlEx is a cWinControl
77592>>>>>>>>>>>    Import_Class_Protocol Standard_Form_Mixin
77593>>>>>>>>>>>    Procedure Construct_Object
77595>>>>>>>>>>>        Forward Send Construct_Object
77597>>>>>>>>>>>        Send define_standard_Form_Mixin
77598>>>>>>>>>>>    End_Procedure
77599>>>>>>>>>>>    
77599>>>>>>>>>>>    Function item_count Integer iItem Returns Integer
77601>>>>>>>>>>>        Function_Return 1
77602>>>>>>>>>>>    End_Function
77603>>>>>>>>>>>    
77603>>>>>>>>>>>    Procedure External_SetFocus
77605>>>>>>>>>>>        Send notify_focus_change 1
77606>>>>>>>>>>>    End_Procedure
77607>>>>>>>>>>>
77607>>>>>>>>>>>    Procedure External_KillFocus
77609>>>>>>>>>>>        Send notify_focus_change 0
77610>>>>>>>>>>>    End_Procedure
77611>>>>>>>>>>>
77611>>>>>>>>>>>    Procedure End_Construct_Object
77613>>>>>>>>>>>        Forward Send End_Construct_Object
77615>>>>>>>>>>>        Set External_Message WM_SETFOCUS  to External_SetFocus
77616>>>>>>>>>>>        Set External_Message WM_KILLFOCUS to External_KillFocus
77617>>>>>>>>>>>    End_Procedure
77618>>>>>>>>>>>        
77618>>>>>>>>>>>End_Class
77619>>>>>>>>>>>
77619>>>>>>>>>
77619>>>>>>>>>Class cMonthCalendar is a cWinControlEx
77620>>>>>>>>>    Procedure Construct_Object
77622>>>>>>>>>        Integer iResult
77622>>>>>>>>>        tWinInitCommonControlsEX InitCC
77622>>>>>>>>>        tWinInitCommonControlsEX InitCC
77622>>>>>>>>>
77622>>>>>>>>>        Forward Send Construct_Object
77624>>>>>>>>>
77624>>>>>>>>>        Move (SizeOfType (tWinInitCommonControlsEX)) to InitCC.dwSize
77625>>>>>>>>>        Move ICC_DATE_CLASSES to InitCC.dwICC
77626>>>>>>>>>        Move (InitCommonControlsEx(AddressOf(InitCC))) to iResult
77627>>>>>>>>>        
77627>>>>>>>>>        Set External_Class_Name 'cMonthCalendar' to 'SysMonthCal32'
77628>>>>>>>>>        Set External_Message WM_LBUTTONDBLCLK to msg_OnLButtonDblClick
77629>>>>>>>>>        
77629>>>>>>>>>        Set Border_Style to Border_Normal
77630>>>>>>>>>        
77630>>>>>>>>>        Property Boolean pbNoToday False
77631>>>>>>>>>        Property Boolean pbNoTodayCircle False
77632>>>>>>>>>        Property Boolean pbMultiSelect False
77633>>>>>>>>>        Property Boolean pbWeekNumbers False
77634>>>>>>>>>        Property Integer piMaxSelectedCount 90
77635>>>>>>>>>        
77635>>>>>>>>>        // this is minimum Dialog units required for a single picker rectangle
77635>>>>>>>>>        Property Integer piMinWidth 0
77636>>>>>>>>>        Property Integer piMinHeight 0
77637>>>>>>>>>
77637>>>>>>>>>        // stores initial date before control is activated
77637>>>>>>>>>        Property Date pdPrivateDate 
77638>>>>>>>>>        // if multi-select, this is the end range
77638>>>>>>>>>        Property Date pdPrivateDate2 
77639>>>>>>>>>        
77639>>>>>>>>>    End_Procedure
77640>>>>>>>>>    
77640>>>>>>>>>    // returns control's value when single select
77640>>>>>>>>>    Function SelectedDate Returns Date
77642>>>>>>>>>        tWinSystemTime CurrentSystemTime
77642>>>>>>>>>        tWinSystemTime CurrentSystemTime
77642>>>>>>>>>        Integer iRetval
77642>>>>>>>>>        DateTime dtSel
77642>>>>>>>>>        Handle hWnd
77642>>>>>>>>>        Get Window_Handle to hWnd
77643>>>>>>>>>        If (hWnd) Begin
77645>>>>>>>>>            Move (Windows_Message (MCM_GETCURSEL, 0, AddressOf (CurrentSystemTime))) to iRetval
77646>>>>>>>>>            Move (DateSetDay(dtSel,CurrentSystemTime.wDay)) to dtSel
77647>>>>>>>>>            Move (DateSetMonth(dtSel,CurrentSystemTime.wMonth)) to dtSel
77648>>>>>>>>>            Move (DateSetYear(dtSel,CurrentSystemTime.wYear)) to dtSel
77649>>>>>>>>>        End
77649>>>>>>>>>>
77649>>>>>>>>>        Else Begin
77650>>>>>>>>>            Get pdPrivateDate to dtSel
77651>>>>>>>>>        End
77651>>>>>>>>>>
77651>>>>>>>>>        Function_Return (Date(dtSel))
77652>>>>>>>>>    End_Function
77653>>>>>>>>>
77653>>>>>>>>>    // returns control's values when multi select
77653>>>>>>>>>    Function SelectedDateRange Returns Date[]
77655>>>>>>>>>        tWinSystemTime[2] CurrentSystemTime
77655>>>>>>>>>        tWinSystemTime[2] CurrentSystemTime
77656>>>>>>>>>        Integer iRetval
77656>>>>>>>>>        DateTime dtSel1 dtsel2
77656>>>>>>>>>        Date[] dtSel
77657>>>>>>>>>        Handle hWnd
77657>>>>>>>>>        Get Window_Handle to hWnd
77658>>>>>>>>>        If (hWnd) Begin
77660>>>>>>>>>            Move (Windows_Message (MCM_GETSELRANGE, 0, AddressOf (CurrentSystemTime))) to iRetval
77661>>>>>>>>>            
77661>>>>>>>>>            Move (DateSetDay(dtSel1,CurrentSystemTime[0].wDay)) to dtSel1
77662>>>>>>>>>            Move (DateSetMonth(dtSel1,CurrentSystemTime[0].wMonth)) to dtSel1
77663>>>>>>>>>            Move (DateSetYear(dtSel1,CurrentSystemTime[0].wYear)) to dtSel1
77664>>>>>>>>>            
77664>>>>>>>>>            Move (DateSetDay(dtSel2,CurrentSystemTime[1].wDay)) to dtSel2
77665>>>>>>>>>            Move (DateSetMonth(dtSel2,CurrentSystemTime[1].wMonth)) to dtSel2
77666>>>>>>>>>            Move (DateSetYear(dtSel2,CurrentSystemTime[1].wYear)) to dtSel2
77667>>>>>>>>>            
77667>>>>>>>>>            Move dtSel1 to dtSel[0]
77668>>>>>>>>>            Move dtsel2 to dtSel[1]
77669>>>>>>>>>        End
77669>>>>>>>>>>
77669>>>>>>>>>        Else Begin
77670>>>>>>>>>            Get pdPrivateDate to dtSel[0]
77671>>>>>>>>>            Get pdPrivateDate2 to dtSel[1]
77672>>>>>>>>>        End
77672>>>>>>>>>>
77672>>>>>>>>>        Function_Return dtSel
77673>>>>>>>>>    End_Function
77674>>>>>>>>>
77674>>>>>>>>>    // Set control's value when single select
77674>>>>>>>>>    Procedure SetSelectedDate Date dDate
77676>>>>>>>>>        tWinSystemTime CurrentSystemTime
77676>>>>>>>>>        tWinSystemTime CurrentSystemTime
77676>>>>>>>>>        Integer iRetval
77676>>>>>>>>>        Handle hWnd
77676>>>>>>>>>        
77676>>>>>>>>>        Get Window_Handle to hWnd
77677>>>>>>>>>        Set pdPrivateDate to dDate
77678>>>>>>>>>        If (hWnd) Begin
77680>>>>>>>>>            Move (DateGetDay(dDate)) to CurrentSystemTime.wDay
77681>>>>>>>>>            Move (DateGetMonth(dDate)) to CurrentSystemTime.wMonth
77682>>>>>>>>>            Move (DateGetYear(dDate)) to CurrentSystemTime.wYear
77683>>>>>>>>>    
77683>>>>>>>>>           Move (Windows_Message (MCM_SETCURSEL, 0, AddressOf (CurrentSystemTime))) to iRetval        
77684>>>>>>>>>        End
77684>>>>>>>>>>
77684>>>>>>>>>    End_Procedure
77685>>>>>>>>>
77685>>>>>>>>>    // Set control's values when multi select
77685>>>>>>>>>    Procedure SetSelectedDateRange Date dDate Date dDate2
77687>>>>>>>>>        tWinSystemTime[] CurrentSystemTime
77687>>>>>>>>>        tWinSystemTime[] CurrentSystemTime
77688>>>>>>>>>        Integer iRetval
77688>>>>>>>>>        Handle hWnd
77688>>>>>>>>>
77688>>>>>>>>>        Get Window_Handle to hWnd
77689>>>>>>>>>        Set pdPrivateDate to dDate
77690>>>>>>>>>        Set pdPrivateDate2 to dDate2
77691>>>>>>>>>        If (hWnd) Begin
77693>>>>>>>>>            Move (DateGetDay(dDate)) to CurrentSystemTime[0].wDay
77694>>>>>>>>>            Move (DateGetMonth(dDate)) to CurrentSystemTime[0].wMonth
77695>>>>>>>>>            Move (DateGetYear(dDate)) to CurrentSystemTime[0].wYear
77696>>>>>>>>>
77696>>>>>>>>>            Move (DateGetDay(dDate2)) to CurrentSystemTime[1].wDay
77697>>>>>>>>>            Move (DateGetMonth(dDate2)) to CurrentSystemTime[1].wMonth
77698>>>>>>>>>            Move (DateGetYear(dDate2)) to CurrentSystemTime[1].wYear
77699>>>>>>>>>    
77699>>>>>>>>>            Move (Windows_Message (MCM_SETSELRANGE, 0, AddressOf (CurrentSystemTime))) to iRetval        
77700>>>>>>>>>        End
77700>>>>>>>>>>
77700>>>>>>>>>    End_Procedure
77701>>>>>>>>>    
77701>>>>>>>>>    // augment to set dates from control, so they can be accessed after the control is closed
77701>>>>>>>>>    Procedure Remove_Object
77703>>>>>>>>>        Date[] SelDate 
77704>>>>>>>>>        If (pbMultiSelect(Self)) Begin
77706>>>>>>>>>            Get SelectedDateRange to SelDate
77707>>>>>>>>>            Set pdPrivateDate2 to SelDate[1]
77708>>>>>>>>>        End
77708>>>>>>>>>>
77708>>>>>>>>>        Else Begin
77709>>>>>>>>>            Get SelectedDate to SelDate[0]
77710>>>>>>>>>        End
77710>>>>>>>>>>
77710>>>>>>>>>        Set pdPrivateDate to SelDate[0]
77711>>>>>>>>>        Forward Send Remove_Object
77713>>>>>>>>>    End_Procedure
77714>>>>>>>>>
77714>>>>>>>>>    Procedure Page Integer iState
77716>>>>>>>>>        Integer iRetval iSize iHeight iWidth
77716>>>>>>>>>        tWinRect WindowRect
77716>>>>>>>>>        tWinRect WindowRect
77716>>>>>>>>>        Date dDate dDate2
77716>>>>>>>>>        Handle hWnd
77716>>>>>>>>>        Integer  iMaxSelectedCount
77716>>>>>>>>>        Boolean bNoToday bWeekNumbers bMultiSelect bNoTodayCircle
77716>>>>>>>>>        
77716>>>>>>>>>        If (iState<>1) Begin
77718>>>>>>>>>            Forward Send Page iState
77720>>>>>>>>>            Procedure_Return
77721>>>>>>>>>        End
77721>>>>>>>>>>
77721>>>>>>>>>        
77721>>>>>>>>>        Set Icon to 'ActionCalendar.ico'
77722>>>>>>>>>
77722>>>>>>>>>        Get pbNoToday to bNoToday
77723>>>>>>>>>        Get pbNoTodayCircle to bNoTodayCircle
77724>>>>>>>>>        Get pbMultiSelect to bMultiSelect
77725>>>>>>>>>        Get pbWeekNumbers to bWeekNumbers
77726>>>>>>>>>        Get piMaxSelectedCount to iMaxSelectedCount
77727>>>>>>>>>
77727>>>>>>>>>        Set Window_Style MCS_MULTISELECT to bMultiSelect
77728>>>>>>>>>        Set Window_Style MCS_NOTODAY to bNoToday
77729>>>>>>>>>        Set Window_Style MCS_NOTODAYCIRCLE to bNoTodayCircle
77730>>>>>>>>>        Set Window_Style MCS_WEEKNUMBERS to bWeekNumbers
77731>>>>>>>>>        Forward Send Page iState
77733>>>>>>>>>
77733>>>>>>>>>        Get Window_Handle to hWnd
77734>>>>>>>>>        // support double click
77734>>>>>>>>>        Move (SetClassLong(hWnd,GCL_STYLE,CS_DBLCLKS ior CS_GLOBALCLASS)) to iRetval
77735>>>>>>>>>        // set range when multi select
77735>>>>>>>>>        Move (Windows_Message(MCM_SETMAXSELCOUNT,iMaxSelectedCount,0)) to iRetval
77736>>>>>>>>>        
77736>>>>>>>>>        // store minimum size for calendar control and set the size to this by default
77736>>>>>>>>>        Move (Windows_Message (MCM_GETMINREQRECT, 0, AddressOf(WindowRect))) to iRetval
77737>>>>>>>>>        Get GuiToDialog WindowRect.bottom WindowRect.right to iSize
77738>>>>>>>>>        Move (Hi(iSize)) to iHeight
77739>>>>>>>>>        Move (Low(iSize)) to iWidth
77740>>>>>>>>>        Set piMinWidth to iWidth
77741>>>>>>>>>        Set piMinHeight to iHeight
77742>>>>>>>>>        Set Size to iHeight iWidth
77743>>>>>>>>>        
77743>>>>>>>>>        // now that we are activated set starting date or date range
77743>>>>>>>>>        Get pdPrivateDate to dDate
77744>>>>>>>>>        If (pbMultiSelect(Self)) Begin
77746>>>>>>>>>            Get pdPrivateDate2 to dDate2
77747>>>>>>>>>            Send SetSelectedDateRange dDate dDate2
77748>>>>>>>>>        End
77748>>>>>>>>>>
77748>>>>>>>>>        Else Begin
77749>>>>>>>>>            Send SetSelectedDate dDate
77750>>>>>>>>>        End
77750>>>>>>>>>>
77750>>>>>>>>>    End_Procedure
77751>>>>>>>>>
77751>>>>>>>>>    Procedure Notify Integer wParam Integer lParam
77753>>>>>>>>>        Integer iRetval
77753>>>>>>>>>        DateTime dtSel dtSel2
77753>>>>>>>>>        tWintagNMSelChange CalenderInfo
77753>>>>>>>>>        tWintagNMSelChange CalenderInfo
77753>>>>>>>>>        Boolean bMulti
77753>>>>>>>>>        
77753>>>>>>>>>        Move (MemCopy (AddressOf (CalenderInfo), lParam, SizeOfType (tWintagNMSelChange))) to iRetval
77754>>>>>>>>>        If (CalenderInfo.nmHdr.code = MCN_SELCHANGE) Begin
77756>>>>>>>>>            Get pbMultiSelect to bMulti
77757>>>>>>>>>            Move (DateSetDay(dtSel,CalenderInfo.stSelStart.wDay)) to dtSel
77758>>>>>>>>>            Move (DateSetMonth(dtSel,CalenderInfo.stSelStart.wMonth)) to dtSel
77759>>>>>>>>>            Move (DateSetYear(dtSel,CalenderInfo.stSelStart.wYear)) to dtSel
77760>>>>>>>>>            If bMulti Begin
77762>>>>>>>>>                Move (DateSetDay(dtSel,CalenderInfo.stSelEnd.wDay)) to dtSel2
77763>>>>>>>>>                Move (DateSetMonth(dtSel,CalenderInfo.stSelEnd.wMonth)) to dtSel2
77764>>>>>>>>>                Move (DateSetYear(dtSel,CalenderInfo.stSelEnd.wYear)) to dtSel2
77765>>>>>>>>>            End
77765>>>>>>>>>>
77765>>>>>>>>>            Send OnChange (Date(dtSel)) (Date(dtSel2))
77766>>>>>>>>>        End
77766>>>>>>>>>>
77766>>>>>>>>>    End_Procedure
77767>>>>>>>>>
77767>>>>>>>>>    // sent whenever there is a selection change within the calendar
77767>>>>>>>>>    Procedure OnChangeDate Date dDate Date dDate2
77769>>>>>>>>>    End_Procedure
77770>>>>>>>>>
77770>>>>>>>>>    // sent when a click occurs in the calendar 
77770>>>>>>>>>    Procedure OnClick
77772>>>>>>>>>    End_Procedure
77773>>>>>>>>>    
77773>>>>>>>>>    // sent when a double click occurs in the calendar 
77773>>>>>>>>>    Procedure OnDoubleClick
77775>>>>>>>>>    End_Procedure
77776>>>>>>>>>    
77776>>>>>>>>>    // sends OnClick if the double click is on a calendar day
77776>>>>>>>>>    Procedure OnLButtonDblClick Integer wParam Integer lParam
77778>>>>>>>>>        Boolean bDayHit
77778>>>>>>>>>        Get MonthDayHit to bDayHit
77779>>>>>>>>>        If bDayHit Begin
77781>>>>>>>>>            Send OnDoubleClick
77782>>>>>>>>>        End
77782>>>>>>>>>>
77782>>>>>>>>>    End_Procedure
77783>>>>>>>>>
77783>>>>>>>>>    // sends OnClick if the click is on a calendar day
77783>>>>>>>>>    Procedure OnWmLButtonUp Integer wParam Integer lParam
77785>>>>>>>>>        Boolean bDayHit
77785>>>>>>>>>        Get MonthDayHit to bDayHit
77786>>>>>>>>>        If bDayHit Begin
77788>>>>>>>>>            Send OnClick
77789>>>>>>>>>        End
77789>>>>>>>>>>
77789>>>>>>>>>    End_Procedure
77790>>>>>>>>>    
77790>>>>>>>>>    // returns true if the month calander is up and the mouse is over a day
77790>>>>>>>>>    Function MonthDayHit Returns Boolean
77792>>>>>>>>>        Integer iRet
77792>>>>>>>>>        Get Windows_Message MCM_GETCURRENTVIEW 0 0 to iRet
77793>>>>>>>>>        If (iRet=MCMV_MONTH) Begin
77795>>>>>>>>>            Get HitTest to iRet
77796>>>>>>>>>            Function_Return (iRet=MCHT_CALENDARDATE)
77797>>>>>>>>>        End
77797>>>>>>>>>>
77797>>>>>>>>>        Function_Return False
77798>>>>>>>>>    End_Function
77799>>>>>>>>>    
77799>>>>>>>>>    // return what was hit in the control
77799>>>>>>>>>    Function HitTest Returns Integer
77801>>>>>>>>>        tWinMCHitTestInfo HitInfo
77801>>>>>>>>>        tWinMCHitTestInfo HitInfo
77801>>>>>>>>>        Handle hWnd iRet
77801>>>>>>>>>        Integer iVoid
77801>>>>>>>>>        Pointer lpPt
77801>>>>>>>>>        tWinPoint Pt
77801>>>>>>>>>        tWinPoint Pt
77801>>>>>>>>>        Get Window_Handle to hWnd
77802>>>>>>>>>        Move (AddressOf(Pt)) to lpPt
77803>>>>>>>>>        Move (GetCursorPos(lpPt)) to iVoid
77804>>>>>>>>>        Move (ScreenToClient(hWnd, lpPt)) to iVoid
77805>>>>>>>>>        Move Pt to HitInfo.Pt
77806>>>>>>>>>        Move (SizeOfType(tWinMCHitTestInfo)) to HitInfo.cbSize
77807>>>>>>>>>        Get WindowsMessage MCM_HITTEST 0 (AddressOf(HitInfo)) to iRet
77808>>>>>>>>>        Function_Return HitInfo.uHit
77809>>>>>>>>>    End_Function
77810>>>>>>>>>    
77810>>>>>>>>>End_Class
77811>>>>>>>
77811>>>>>>>// peMouseSelectOk choices
77811>>>>>>>Enum_List
77811>>>>>>>    Define msoClick
77811>>>>>>>    Define msoDblClick
77811>>>>>>>    Define msoNone
77811>>>>>>>End_Enum_List
77811>>>>>>>
77811>>>>>>>// It is expected that this class will only be used inside of ModalPanel and
77811>>>>>>>// will be used as a prompt object component in a framework style application.
77811>>>>>>>// If you wish to Use a month calendar in some other non prompt situation, 
77811>>>>>>>// use cMonthCalendar
77811>>>>>>>
77811>>>>>>>Class cMonthCalendarPrompt is a cMonthCalendar
77812>>>>>>>
77812>>>>>>>    Procedure Construct_Object
77814>>>>>>>
77814>>>>>>>        Forward Send Construct_Object
77816>>>>>>>
77816>>>>>>>        Property Integer peUpdateMode umPromptValue
77817>>>>>>>
77817>>>>>>>        Property Integer peMouseSelectOk msoClick
77818>>>>>>>        
77818>>>>>>>        Property Date pdSeedValue
77819>>>>>>>
77819>>>>>>>        // if multi-select, this is the end range
77819>>>>>>>        Property Date pdSeedValue2
77820>>>>>>>
77820>>>>>>>        Property Handle phmPromptUpdateCallback 0
77821>>>>>>>
77821>>>>>>>        Property Integer phoInvokingObject
77822>>>>>>>        
77822>>>>>>>        Property Integer peStoredUpdateMode
77823>>>>>>>        Property Handle  phmStoredPromptUpdateCallback
77824>>>>>>>        Property Boolean pbStoredWeekNumbers
77825>>>>>>>        Property Boolean pbStoredNoToday
77826>>>>>>>        Property Boolean pbStoredNoTodayCircle
77827>>>>>>>        Property Boolean pbStoredMultiSelect
77828>>>>>>>        Property Integer piStoredMaxSelectedCount
77829>>>>>>>        Property Integer peStoredpeMouseSelectOk
77830>>>>>>>
77830>>>>>>>        // internally set by list
77830>>>>>>>        // these must be set upon closing the list and can be used for manual list updates
77830>>>>>>>        Property Boolean pbCanceled
77831>>>>>>>
77831>>>>>>>    End_Procedure
77832>>>>>>>        
77832>>>>>>>    Procedure OnStoreDefaults
77834>>>>>>>        Integer iVal
77834>>>>>>>        Boolean bVal
77834>>>>>>>
77834>>>>>>>        Get peUpdateMode to iVal
77835>>>>>>>        Set peStoredUpdateMode to iVal
77836>>>>>>>        
77836>>>>>>>        Get phmPromptUpdateCallback to iVal       
77837>>>>>>>        Set phmStoredPromptUpdateCallback to iVal       
77838>>>>>>>
77838>>>>>>>        Get pbMultiSelect to bVal       
77839>>>>>>>        Set pbStoredMultiSelect to bVal       
77840>>>>>>>
77840>>>>>>>        Get pbNoToday to bVal       
77841>>>>>>>        Set pbStoredNoToday to bVal       
77842>>>>>>>
77842>>>>>>>        Get pbNoTodayCircle to bVal       
77843>>>>>>>        Set pbStoredNoTodayCircle to bVal       
77844>>>>>>>
77844>>>>>>>        Get pbWeekNumbers to bVal       
77845>>>>>>>        Set pbStoredWeekNumbers to bVal       
77846>>>>>>>
77846>>>>>>>        Get piMaxSelectedCount to iVal       
77847>>>>>>>        Set piStoredMaxSelectedCount to iVal  
77848>>>>>>>        
77848>>>>>>>        Get peMouseSelectOk to iVal       
77849>>>>>>>        Set peStoredpeMouseSelectOk to iVal       
77850>>>>>>>        
77850>>>>>>>    End_Procedure
77851>>>>>>>
77851>>>>>>>    Procedure OnRestoreDefaults
77853>>>>>>>        Integer iVal
77853>>>>>>>        Boolean bVal
77853>>>>>>>
77853>>>>>>>        Get peStoredUpdateMode to iVal
77854>>>>>>>        Set peUpdateMode to iVal
77855>>>>>>>        
77855>>>>>>>        Get phmStoredPromptUpdateCallback to iVal       
77856>>>>>>>        Set phmPromptUpdateCallback to iVal       
77857>>>>>>>
77857>>>>>>>        Get pbStoredMultiSelect to bVal       
77858>>>>>>>        Set pbMultiSelect to bVal       
77859>>>>>>>
77859>>>>>>>        Get pbStoredNoToday to bVal       
77860>>>>>>>        Set pbNoToday to bVal       
77861>>>>>>>
77861>>>>>>>        Get pbStoredNoTodayCircle to bVal       
77862>>>>>>>        Set pbNoTodayCircle to bVal       
77863>>>>>>>
77863>>>>>>>        Get pbStoredWeekNumbers to bVal       
77864>>>>>>>        Set pbWeekNumbers to bVal       
77865>>>>>>>
77865>>>>>>>        Get piStoredMaxSelectedCount to iVal       
77866>>>>>>>        Set piMaxSelectedCount to iVal       
77867>>>>>>>
77867>>>>>>>        Get peStoredpeMouseSelectOk to iVal       
77868>>>>>>>        Set peMouseSelectOk to iVal       
77869>>>>>>>
77869>>>>>>>    End_Procedure
77870>>>>>>>
77870>>>>>>>    Procedure Add_Focus Handle hoParent Returns Integer
77872>>>>>>>        Integer eMode
77872>>>>>>>        Set pbCanceled to True // assume cancel unless changed
77873>>>>>>>        Get peUpdateMode to eMode
77874>>>>>>>        If (eMode<>umPromptNonInvoking) Begin
77876>>>>>>>            Send OnStoreDefaults
77877>>>>>>>        End
77877>>>>>>>>
77877>>>>>>>        Send InitializePrompt
77878>>>>>>>        Forward Send Add_Focus hoParent
77880>>>>>>>    End_Procedure
77881>>>>>>>        
77881>>>>>>>    // augment to send OnRestoreDefaults.
77881>>>>>>>    Procedure Release_Focus
77883>>>>>>>        Integer eUpdateMode
77883>>>>>>>        Get peUpdateMode to eUpdateMode
77884>>>>>>>        Forward Send Release_Focus
77886>>>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
77888>>>>>>>            Send OnRestoreDefaults
77889>>>>>>>        End
77889>>>>>>>>
77889>>>>>>>    End_Procedure
77890>>>>>>>
77890>>>>>>>    // This is only called in a successful close
77890>>>>>>>    Procedure ClosePrompt
77892>>>>>>>        Handle hoInvokingObject
77892>>>>>>>        Handle hmCallBack
77892>>>>>>>        Integer eUpdateMode
77892>>>>>>>        Date[] dDates
77893>>>>>>>        
77893>>>>>>>        Set pbCanceled to False
77894>>>>>>>        
77894>>>>>>>        Get peUpdateMode to eUpdateMode
77895>>>>>>>        // if non-invoking there is by definition, no move value out
77895>>>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
77897>>>>>>>            
77897>>>>>>>            If (eUpdateMode=umPromptValue) Begin
77899>>>>>>>                Send OnMoveValueOutByValue
77900>>>>>>>            End
77900>>>>>>>>
77900>>>>>>>            Else If (eUpdateMode=umPromptCustom) Begin
77903>>>>>>>                Send OnMoveValueOutByCustom
77904>>>>>>>            End
77904>>>>>>>>
77904>>>>>>>            Get phmPromptUpdateCallback to hmCallBack
77905>>>>>>>            If hmCallBack Begin
77907>>>>>>>                Get phoInvokingObject to hoInvokingObject
77908>>>>>>>                If (pbMultiSelect(Self)) Begin
77910>>>>>>>                    Get SelectedDateRange to dDates
77911>>>>>>>                    Send hmCallBack of hoInvokingObject Self dDates[0] dDates[1]
77912>>>>>>>                    
77912>>>>>>>                End
77912>>>>>>>>
77912>>>>>>>                Else Begin
77913>>>>>>>                    Get SelectedDate to dDates[0]
77914>>>>>>>                    Send hmCallBack of hoInvokingObject Self dDates[0]
77915>>>>>>>                End
77915>>>>>>>>
77915>>>>>>>            End
77915>>>>>>>>
77915>>>>>>>        End
77915>>>>>>>>
77915>>>>>>>
77915>>>>>>>        Send Close_Panel
77916>>>>>>>    End_Procedure
77917>>>>>>>
77917>>>>>>>    Procedure OnMoveValueOutByValue
77919>>>>>>>        Handle hoInvokingObject
77919>>>>>>>        Date dSelDate
77919>>>>>>>        Boolean bMulti
77919>>>>>>>        // we can only do an automatic move value out with
77919>>>>>>>        // single select. If multi-select you will probably want to
77919>>>>>>>        // use a callback method (hmCallBack) to update the values. 
77919>>>>>>>        Get pbMultiSelect to bMulti
77920>>>>>>>        If (not(bMulti)) Begin
77922>>>>>>>            Get SelectedDate to dSelDate
77923>>>>>>>            Get phoInvokingObject to hoInvokingObject
77924>>>>>>>            Set Value of hoInvokingObject to dSelDate
77925>>>>>>>            Set Item_Changed_State of hoInvokingObject to True
77926>>>>>>>        End
77926>>>>>>>>
77926>>>>>>>    End_Procedure
77927>>>>>>>
77927>>>>>>>    Procedure OnMoveValueOutByCustom
77929>>>>>>>    End_Procedure
77930>>>>>>>        
77930>>>>>>>    // called before the list is activated. 
77930>>>>>>>    Procedure InitializePrompt
77932>>>>>>>        Handle hoInvokingObject
77932>>>>>>>        Integer eUpdateMode
77932>>>>>>>        Boolean bMulti 
77932>>>>>>>        Date dValue
77932>>>>>>>
77932>>>>>>>        Get peUpdateMode to eUpdateMode
77933>>>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
77935>>>>>>>
77935>>>>>>>            Get Focus of Desktop to hoInvokingObject
77936>>>>>>>            If (hoInvokingObject<=Desktop) Begin
77938>>>>>>>                Error DFERR_PROGRAM "Calendar Prompt has no invoking object"
77939>>>>>>>>
77939>>>>>>>                Procedure_Return
77940>>>>>>>            End
77940>>>>>>>>
77940>>>>>>>
77940>>>>>>>            Set phoInvokingObject to hoInvokingObject
77941>>>>>>>            Send Prompt_Callback to hoInvokingObject Self
77942>>>>>>>            Get peUpdateMode to eUpdateMode
77943>>>>>>>        End
77943>>>>>>>>
77943>>>>>>>
77943>>>>>>>        Get pdSeedValue to dValue
77944>>>>>>>        Get pbMultiSelect to bMulti
77945>>>>>>>        If (not(bMulti) and eUpdateMode=umPromptValue and dValue=0) Begin
77947>>>>>>>            Get Value of hoInvokingObject to dValue
77948>>>>>>>            Set pdSeedValue to dValue
77949>>>>>>>        End
77949>>>>>>>>
77949>>>>>>>        Send OnSeedData
77950>>>>>>>        Set pdSeedValue to 0
77951>>>>>>>        Set pdSeedValue2 to 0
77952>>>>>>>    End_Procedure
77953>>>>>>>    
77953>>>>>>>    Procedure OnSeedData 
77955>>>>>>>        Boolean bMulti
77955>>>>>>>        Date dValue dValue2
77955>>>>>>>        Integer iMax iRange
77955>>>>>>>        DateTime dt1 dt2
77955>>>>>>>        Get pbMultiSelect to bMulti
77956>>>>>>>        Get pdSeedValue to dValue
77957>>>>>>>        If (not(bMulti)) Begin
77959>>>>>>>            // if no date, use current date
77959>>>>>>>            If (dValue=0) Begin
77961>>>>>>>                Move (CurrentDateTime()) to dValue
77962>>>>>>>            End
77962>>>>>>>>
77962>>>>>>>            Send SetSelectedDate dValue    
77963>>>>>>>        End
77963>>>>>>>>
77963>>>>>>>        Else Begin
77964>>>>>>>            Get pdSeedValue2 to dValue2 
77965>>>>>>>            // if no dates, use current date
77965>>>>>>>            If (dValue=0 and dValue2=0) Begin
77967>>>>>>>                Move (CurrentDateTime()) to dValue
77968>>>>>>>            End
77968>>>>>>>>
77968>>>>>>>            // if only one date, make that the range
77968>>>>>>>            If (dValue=0) Begin
77970>>>>>>>                Move dValue2 to dValue
77971>>>>>>>            End
77971>>>>>>>>
77971>>>>>>>            Else If (dValue2=0) Begin
77974>>>>>>>                Move dValue to dValue2
77975>>>>>>>            End
77975>>>>>>>>
77975>>>>>>>            
77975>>>>>>>            // test for valid range
77975>>>>>>>            Get piMaxSelectedCount to iMax
77976>>>>>>>            Move dValue to dt1
77977>>>>>>>            Move dValue2 to dt2
77978>>>>>>>            Move (SpanTotalDays(dt1 - dt2)) to iRange
77979>>>>>>>            If (iRange>iMax) Begin
77981>>>>>>>                Error DFERR_OPERATOR (SFormat(C_$DateRangeExceeded,iMax))
77982>>>>>>>>
77982>>>>>>>                Move dValue to dValue2
77983>>>>>>>            End
77983>>>>>>>>
77983>>>>>>>            
77983>>>>>>>            Send SetSelectedDateRange dValue dValue2
77984>>>>>>>        End
77984>>>>>>>>
77984>>>>>>>    End_Procedure
77985>>>>>>>
77985>>>>>>>    Procedure OnDoubleClick
77987>>>>>>>        Integer eSelectOn
77987>>>>>>>        Get peMouseSelectOk to eSelectOn
77988>>>>>>>        If (eSelectOn=msoDblClick) Begin
77990>>>>>>>            Send Ok
77991>>>>>>>        End
77991>>>>>>>>
77991>>>>>>>    End_Procedure
77992>>>>>>>    
77992>>>>>>>    Procedure OnClick
77994>>>>>>>        Integer eSelectOn
77994>>>>>>>        Get peMouseSelectOk to eSelectOn
77995>>>>>>>        If (eSelectOn=msoClick) Begin
77997>>>>>>>            Send Ok
77998>>>>>>>        End
77998>>>>>>>>
77998>>>>>>>    End_Procedure
77999>>>>>>>
77999>>>>>>>    Procedure Ok Returns Integer
78001>>>>>>>        Send ClosePrompt
78002>>>>>>>    End_Procedure
78003>>>>>>>
78003>>>>>>>    Procedure Cancel Returns Integer
78005>>>>>>>        Send Close_Panel
78006>>>>>>>    End_Procedure
78007>>>>>>>        
78007>>>>>>>End_Class
78008>>>>>>>
78008>>>>>>>
78008>>>>>Use Dfclient.pkg
78008>>>>>
78008>>>>>Cd_Popup_Object oMonthCalendarPrompt is a ModalPanel
78026>>>>>>
78026>>>>>    Set Location to 10 10
78027>>>>>    Set Size to 145 145
78028>>>>>    // resizable
78028>>>>>    Set Border_Style to Border_Thick
78029>>>>>
78029>>>>>    Set Label to C_$DateSelector
78030>>>>>
78030>>>>>    Set piMinSize to 0 0 // set this dynamically // 145 145
78031>>>>>    Set piMaxSize to 310 460
78032>>>>>
78032>>>>>    // tells us if this been activated and sized yet
78032>>>>>    Property Boolean pbSizeInited False
78034>>>>>        
78034>>>>>    Object oCalendar is a cMonthCalendarPrompt
78036>>>>>        Set Size to 120 135 // not real size, will be assigned
78037>>>>>        Set Location to 5 5
78038>>>>>        Set Border_Style to Border_None
78039>>>>>    End_Object
78040>>>>>
78040>>>>>    Object oOKButton is a Button
78042>>>>>        Set Label to C_$OK
78043>>>>>        Set Default_State to True
78044>>>>>        Set Location to 129 34
78045>>>>>        Set peAnchors to anBottomRight
78046>>>>>        
78046>>>>>        Procedure OnClick
78049>>>>>            Send Ok of oCalendar
78050>>>>>        End_Procedure
78051>>>>>    End_Object
78052>>>>>
78052>>>>>    Object oCancelButton is a Button
78054>>>>>        Set Label to C_$Cancel
78055>>>>>        Set Location to 129 89
78056>>>>>        Set peAnchors to anBottomRight
78057>>>>>        
78057>>>>>        Procedure OnClick
78060>>>>>            Send Cancel of oCalendar
78061>>>>>        End_Procedure
78062>>>>>    End_Object
78063>>>>>
78063>>>>>    Procedure OnResize 
78066>>>>>        Integer iSize iHeight iWidth iMinSize
78066>>>>>        Boolean bInited
78066>>>>>
78066>>>>>        Get piMinHeight of oCalendar to iHeight
78067>>>>>        // when 0, the control has not yet been created. Nothing to do.
78067>>>>>        If (iHeight=0) Begin
78069>>>>>            Procedure_Return
78070>>>>>        End
78070>>>>>>
78070>>>>>
78070>>>>>        Get pbSizeInited to bInited
78071>>>>>        
78071>>>>>        Get piMinWidth of oCalendar to iWidth
78072>>>>>        Get piMinSize to iMinSize
78073>>>>>        // Minumum size of panel - add 1 to each to each for wiggle room
78073>>>>>        Move (iHeight+25+1) to iHeight
78074>>>>>        Move (iWidth+10+1) to iWidth
78075>>>>>         
78075>>>>>        Set piMinSize to iHeight iWidth
78076>>>>>
78076>>>>>        If (not(bInited))  Begin
78078>>>>>            Set Size to iHeight iWidth
78079>>>>>            Set pbSizeInited to True
78080>>>>>        End
78080>>>>>>
78080>>>>>        Else Begin
78081>>>>>            Send Adjust_Logicals
78082>>>>>            Get Size to iSize
78083>>>>>            If (Hi(iSize)<iHeight or Low(iSize)<iWidth) Begin
78085>>>>>                Set Size to (iHeight max Hi(iSize)) (iWidth max Low(iSize))
78086>>>>>                Get Size to iSize
78087>>>>>            End
78087>>>>>>
78087>>>>>            Set Size of oCalendar to (Hi(iSize) - 25) (Low(iSize) - 10)
78088>>>>>        End
78088>>>>>>
78088>>>>>        
78088>>>>>    End_Procedure
78089>>>>>    
78089>>>>>    Procedure Add_Focus Handle hoParent Returns Integer
78092>>>>>        Forward Send Add_Focus hoParent
78094>>>>>        Send OnResize
78095>>>>>    End_Procedure
78096>>>>>
78096>>>>>    On_Key kCancel Send KeyAction to oCancelButton
78097>>>>>
78097>>>>>Cd_End_Object
78099>>>>>>
78099>>>
78099>>>Activate_View Activate_oOrderEntryView for oOrderEntryView
78109>>>>
78109>>>Object oOrderEntryView is a dbView
78111>>>    Set Border_Style to Border_Thick
78112>>>    Set Maximize_Icon to True
78113>>>    Set Label to "Order Entry"
78114>>>    Set Location to 2 3
78115>>>    Set Size to 174 383
78116>>>    Set piMinSize to 174 383
78117>>>    Set pbAutoActivate to True
78118>>>    
78118>>>
78118>>>    Object Vendor_DD is a Vendor_DataDictionary
78120>>>    End_Object    // Vendor_DD
78121>>>
78121>>>    Object Invt_DD is a Invt_DataDictionary
78123>>>        Set DDO_Server to Vendor_DD
78124>>>    End_Object    // Invt_DD
78125>>>
78125>>>    Object Customer_DD is a Customer_DataDictionary
78127>>>    End_Object    // Customer_DD
78128>>>
78128>>>    Object SalesP_DD is a Salesp_DataDictionary
78130>>>    End_Object    // SalesP_DD
78131>>>
78131>>>    Object OrderHea_DD is a OrderHea_DataDictionary
78133>>>        Set DDO_Server to Customer_DD
78134>>>        Set DDO_Server to SalesP_DD
78135>>>        
78135>>>        // this lets you save a new OrderHea from within OrderDtl.
78135>>>        Set Allow_Foreign_New_Save_State to True
78136>>>        
78136>>>    End_Object    // OrderHea_DD
78137>>>    
78137>>>    Object OrderDtl_DD is a OrderDtl_DataDictionary
78139>>>        Set DDO_Server to OrderHea_DD
78140>>>        Set DDO_Server to Invt_DD
78141>>>        Set Constrain_File to OrderHea.File_Number
78142>>>    End_Object    // OrderDtl_DD
78143>>>
78143>>>    Set Main_DD to OrderHea_DD
78144>>>    Set Server to OrderHea_DD
78145>>>    
78145>>>    Object oDbContainer3d1 is a dbContainer3d
78147>>>        Set Size to 85 377
78148>>>        Set Location to 2 3
78149>>>        Set peAnchors to anTopLeftRight
78150>>>        
78150>>>        
78150>>>        Object oOrderHea_Order_Number is a dbForm
78152>>>            Entry_Item OrderHea.Order_Number
78153>>>            Set Label to "Order Number:"
78154>>>            Set Size to 13 42
78155>>>            Set Location to 4 63
78156>>>            Set peAnchors to anTopLeft
78157>>>            Set Label_Col_Offset to 2
78158>>>            Set Label_Justification_Mode to jMode_Right
78159>>>            
78159>>>        End_Object    // oOrderHea_Order_Number
78160>>>
78160>>>        Object oOrderHea_Customer_Number is a dbForm
78162>>>            Entry_Item Customer.Customer_Number
78163>>>            Set Label to "Customer Number:"
78164>>>            Set Size to 13 42
78165>>>            Set Location to 4 201
78166>>>            Set peAnchors to anTopRight
78167>>>            Set Label_Col_Offset to 2
78168>>>            Set Label_Justification_Mode to jMode_Right
78169>>>        End_Object    // oOrderHea_Customer_Number
78170>>>
78170>>>        Object oOrderHea_Order_Date is a dbForm
78172>>>            Entry_Item OrderHea.Order_Date
78173>>>            Set Label to "Order Date:"
78174>>>            Set Size to 13 67
78175>>>            Set Location to 4 299
78176>>>            Set peAnchors to anTopRight
78177>>>            Set Label_Col_Offset to 2
78178>>>            Set Label_Justification_Mode to jMode_Right
78179>>>            
78179>>>            Set Prompt_Object to oMonthCalendarPrompt
78180>>>            Set Prompt_Button_Mode to PB_PromptOn
78181>>>        End_Object    // oOrderHea_Order_Date
78182>>>
78182>>>        Object oCustomer_Name is a dbForm
78184>>>            Entry_Item Customer.Name
78185>>>            Set Label to "Customer Name:"
78186>>>            Set Size to 13 180
78187>>>            Set Location to 18 63
78188>>>            Set peAnchors to anTopLeftRight
78189>>>            Set Label_Col_Offset to 2
78190>>>            Set Label_Justification_Mode to jMode_Right
78191>>>        End_Object    // oCustomer_Name
78192>>>
78192>>>        Object oCustomer_Address is a dbForm
78194>>>            Entry_Item Customer.Address
78195>>>            Set Label to "Street Address:"
78196>>>            Set Size to 13 180
78197>>>            Set Location to 34 63
78198>>>            Set peAnchors to anTopLeftRight
78199>>>            Set Label_Col_Offset to 2
78200>>>            Set Label_Justification_Mode to jMode_Right
78201>>>        End_Object    // oCustomer_Address
78202>>>
78202>>>        Object oCustomer_City is a dbForm
78204>>>            Entry_Item Customer.City
78205>>>            Set Label to "City/State/Zip:"
78206>>>            Set Size to 13 84
78207>>>            Set Location to 49 63
78208>>>            Set peAnchors to anTopLeftRight
78209>>>            Set Label_Col_Offset to 2
78210>>>            Set Label_Justification_Mode to jMode_Right
78211>>>        End_Object    // oCustomer_City
78212>>>
78212>>>        Object oCustomer_State is a dbForm
78214>>>            Entry_Item Customer.State
78215>>>            Set Size to 13 20
78216>>>            Set Location to 49 155
78217>>>            Set peAnchors to anTopRight
78218>>>        End_Object    // oCustomer_State
78219>>>
78219>>>        Object oCustomer_Zip is a dbForm
78221>>>            Entry_Item Customer.Zip
78222>>>            Set Size to 13 60
78223>>>            Set Location to 49 183
78224>>>            Set peAnchors to anTopRight
78225>>>        End_Object    // oCustomer_Zip
78226>>>
78226>>>        Object oOrderHea_Ordered_By is a dbForm
78228>>>            Entry_Item OrderHea.Ordered_By
78229>>>            Set Label to "Ordered By:"
78230>>>            Set Size to 13 67
78231>>>            Set Location to 34 299
78232>>>            Set peAnchors to anTopRight
78233>>>            Set Label_Col_Offset to 2
78234>>>            Set Label_Justification_Mode to jMode_Right
78235>>>        End_Object    // oOrderHea_Ordered_By
78236>>>
78236>>>        Object oOrderHea_Salesperson_ID is a dbForm
78238>>>            Entry_Item Salesp.Id
78239>>>            Set Label to "Salesperson ID:"
78240>>>            Set Size to 13 40
78241>>>            Set Location to 49 299
78242>>>            Set peAnchors to anTopRight
78243>>>            Set Label_Col_Offset to 2
78244>>>            Set Label_Justification_Mode to jMode_Right
78245>>>        End_Object    // oOrderHea_Salesperson_ID
78246>>>
78246>>>        Object oOrderHea_Terms is a dbComboForm
78248>>>            Entry_Item OrderHea.Terms
78249>>>            Set Label to "Terms:"
78250>>>            Set Size to 13 85
78251>>>            Set Location to 64 63
78252>>>            Set peAnchors to anTopLeft
78253>>>            Set Form_Border to 0
78254>>>            Set Label_Col_Offset to 2
78255>>>            Set Label_Justification_Mode to jMode_Right
78256>>>
78256>>>        End_Object    // oOrderHea_Terms
78257>>>
78257>>>        Object oOrderHea_Ship_Via is a dbComboForm
78259>>>            Entry_Item OrderHea.Ship_Via
78260>>>            Set Label to "Ship Via:"
78261>>>            Set Size to 13 103
78262>>>            Set Location to 64 183
78263>>>            Set peAnchors to anTopRight
78264>>>            Set Form_Border to 0
78265>>>            Set Label_Col_Offset to 2
78266>>>            Set Label_Justification_Mode to jMode_Right
78267>>>
78267>>>        End_Object    // oOrderHea_Ship_Via
78268>>>
78268>>>        Object oTextBox1 is a TextBox
78270>>>            Set Size to 10 31
78271>>>            Set Location to 4 4
78272>>>            Set Label to "Hallo!!"
78273>>>            Set Justification_Mode to JMode_Right
78274>>>            Set FontWeight to fw_Bold
78275>>>            Set FontPointHeight to 90
78276>>>        End_Object
78277>>>
78277>>>    End_Object    // oDbContainer3d1
78278>>>
78278>>>    Object oOrderDtl_Grid is a cDbCJGrid
78280>>>        Set Server to OrderDtl_DD
78281>>>        Set Ordering to 1
78282>>>        Set Size to 63 377
78283>>>        Set Location to 90 3
78284>>>        Set peAnchors to anAll
78285>>>        Set pbAllowInsertRow to False
78286>>>        Set pbRestoreLayout to False
78287>>>        Set psLayoutSection to "OrderView_oOrderDtl_Grid2"
78288>>>        Set piLayoutBuild to 6
78289>>>        Set pbHeaderPrompts to True
78290>>>
78290>>>        On_Key Key_F11 Send Request_InsertRow
78291>>>
78291>>>        Object oMark is a cCJGridColumnRowIndicator
78293>>>        End_Object
78294>>>        
78294>>>        Object oInvt_Item_ID is a cDbCJGridColumn
78296>>>            Entry_Item Invt.Item_ID
78297>>>            Set piWidth to 91
78298>>>            Set psCaption to "Item ID"
78299>>>            Set psImage to "ActionPrompt.ico"
78300>>>        End_Object
78301>>>
78301>>>        Object oInvt_Description is a cDbCJGridColumn
78303>>>            Entry_Item Invt.Description
78304>>>            Set piWidth to 213
78305>>>            Set psCaption to "Description"
78306>>>        End_Object
78307>>>
78307>>>        Object oInvt_Unit_Price is a cDbCJGridColumn
78309>>>            Entry_Item Invt.Unit_Price
78310>>>            Set piWidth to 53
78311>>>            Set psCaption to "Unit Price"
78312>>>        End_Object
78313>>>
78313>>>        Object oOrderDtl_Qty_Ordered is a cDbCJGridColumn
78315>>>            Entry_Item OrderDtl.Qty_Ordered
78316>>>            Set piWidth to 50
78317>>>            Set psCaption to "Quantity"
78318>>>        End_Object
78319>>>
78319>>>        Object oOrderDtl_Price is a cDbCJGridColumn
78321>>>            Entry_Item OrderDtl.Price
78322>>>            Set piWidth to 62
78323>>>            Set psCaption to "Price"
78324>>>        End_Object
78325>>>
78325>>>        Object oOrderDtl_Extended_Price is a cDbCJGridColumn
78327>>>            Entry_Item OrderDtl.Extended_Price
78328>>>            Set piWidth to 81
78329>>>            Set psCaption to "Total"
78330>>>        End_Object
78331>>>        
78331>>>    End_Object    // oOrderDtl_Grid
78332>>>
78332>>>    Object oOrderHea_Order_Total is a dbForm
78334>>>        Entry_Item OrderHea.Order_Total
78335>>>        Set Label to "Order Total:"
78336>>>        Set Size to 13 60
78337>>>        Set Location to 156 307
78338>>>        Set peAnchors to anBottomRight
78339>>>        Set Label_Col_Offset to 3
78340>>>        Set Label_Justification_Mode to jMode_Right
78341>>>    End_Object    // oOrderHea_Order_Total
78342>>>
78342>>>    Object oPrintBtn is a Button
78344>>>        Set Label to "Print Order"
78345>>>        Set Location to 156 3
78346>>>        Set peAnchors to anBottomLeft
78347>>>        Set psToolTip to "Print preview of current order"
78348>>>
78348>>>        Procedure OnClick
78351>>>            Delegate Send PrintCurrentOrder // defined in view object
78353>>>        End_Procedure  // OnClick
78354>>>        
78354>>>    End_Object    // oPrintBtn
78355>>>
78355>>>
78355>>>    // Change:   Create custom confirmation messages for save and delete
78355>>>    //           We must create the new functions and assign verify messages
78355>>>    //           to them.
78355>>>    Function Confirm_Delete_Order Returns Integer
78358>>>        Integer iRetVal
78358>>>        Get Confirm "Delete Entire Order?" to iRetVal
78359>>>        Function_Return iRetVal
78360>>>    End_Function
78361>>>    
78361>>>    // Only confirm on the saving of new records
78361>>>    Function Confirm_Save_Order Returns Integer
78364>>>        Integer iNoSave iSrvr
78364>>>        Boolean bOld
78364>>>        Get Server to iSrvr
78365>>>        Get HasRecord of iSrvr to bOld
78366>>>        If not bOld Begin
78368>>>            Get Confirm "Save this NEW order header?" to iNoSave
78369>>>        End
78369>>>>
78369>>>        Function_Return iNoSave
78370>>>    End_Function
78371>>>    
78371>>>    // Define alternate confirmation Messages
78371>>>    Set Verify_Save_MSG       to (RefFunc(Confirm_Save_Order))
78372>>>    Set Verify_Delete_MSG     to (RefFunc(Confirm_Delete_Order))
78373>>>    Set Auto_Clear_DEO_State  to False // don't clear Header on save
78374>>>    
78374>>>    
78374>>>    // print the current order. This message will be sent
78374>>>    // by the print button
78374>>>    Procedure PrintCurrentOrder
78377>>>        Integer hDD iNum
78377>>>        Get Server to hDD // this will be the OrderHea DD
78378>>>        If (HasRecord(hDD)) Begin // only do this if record exists
78380>>>            Get Field_Current_Value of hDD Field OrderHea.Order_Number to iNum
78381>>>//            Send PrintOrder of oOrder_Report iNum
78381>>>            Send Info_Box "This is just a stub and this invoice is not actually being printed" ("Print Order " + String(iNum))
78382>>>        End
78382>>>>
78382>>>    End_Procedure
78383>>>    
78383>>>    // refresh is sent to containers. We will use that to control the print button and only
78383>>>    // enable it when an order exists
78383>>>    Procedure Refresh Integer eMode
78386>>>        Boolean bRec
78386>>>        Handle hoServer
78386>>>        Get Server to hoServer
78387>>>        Get HasRecord of hoServer to bRec
78388>>>        Set Enabled_State of oPrintBtn to bRec
78389>>>    End_Procedure
78390>>>
78390>>>End_Object
78391>        Use SalesP.vw
Including file: Salesp.vw    (C:\Test\Order Entry git\AppSrc\Salesp.vw)
78391>>>Use dfClient.pkg
78391>>>Use DataDict.pkg
78391>>>Use dfEntry.pkg
78391>>>Use SalesP.DD
78391>>>
78391>>>DEFERRED_VIEW Activate_oSalesPersonView FOR ;;Object oSalesPersonView is a dbView
78416>>>    Set Border_Style to Border_None
78417>>>    Set Label to "Sales Person Entry View"
78418>>>    Set Location to 6 6
78419>>>    Set Size to 51 245
78420>>>
78420>>>    Object SalesP_DD is a Salesp_DataDictionary
78422>>>    End_Object    // Salesp_DD
78423>>>
78423>>>    Set Main_DD to SalesP_DD
78424>>>    Set Server to SalesP_DD
78425>>>
78425>>>    Object oContainer1 is a dbContainer3d
78427>>>        Set Size to 40 233
78428>>>        Set Location to 5 6
78429>>>        Object oSalesP_ID is a dbForm
78431>>>            Entry_Item SalesP.ID
78432>>>            Set Label to "Sales Person ID:"
78433>>>            Set Size to 13 46
78434>>>            Set Location to 4 70
78435>>>            Set Label_Col_Offset to 2
78436>>>            Set Label_Justification_Mode to jMode_Right
78437>>>        End_Object    // oSalesP_ID
78438>>>
78438>>>        Object oSalesP_Name is a dbForm
78440>>>            Entry_Item SalesP.Name
78441>>>            Set Label to "Sales Person Name:"
78442>>>            Set Size to 13 156
78443>>>            Set Location to 20 70
78444>>>            Set Label_Col_Offset to 2
78445>>>            Set Label_Justification_Mode to jMode_Right
78446>>>        End_Object    // oSalesP_Name
78447>>>
78447>>>    End_Object    // oContainer1
78448>>>
78448>>>CD_End_Object    // oSalesPersonView
78450>>>>
78450>        Use Vendor.vw
Including file: Vendor.vw    (C:\Test\Order Entry git\AppSrc\Vendor.vw)
78450>>>Use dfClient.pkg
78450>>>Use DataDict.pkg
78450>>>Use dfEntry.pkg
78450>>>Use dfCEntry.pkg
78450>>>Use Vendor.DD
78450>>>
78450>>>DEFERRED_VIEW Activate_oVendorView FOR ;;Object oVendorView is a dbView
78475>>>    Set Border_Style to Border_Thick
78476>>>    Set Label to "Vendor Entry View"
78477>>>    Set Location to 6 6
78478>>>    Set Size to 137 281
78479>>>    Set piMaxSize to 137 350
78480>>>    Set piMinSize to 137 215
78481>>>
78481>>>    Object Vendor_DD is a Vendor_DataDictionary
78483>>>    End_Object    // Vendor_DD
78484>>>
78484>>>    Set Main_DD to Vendor_DD
78485>>>    Set Server to Vendor_DD
78486>>>
78486>>>    Object oContainer1 is a dbContainer3d
78488>>>        Set Size to 129 273
78489>>>        Set Location to 4 4
78490>>>        Set peAnchors to anAll
78491>>>        Object oVendor_Id is a dbForm
78493>>>            Entry_Item Vendor.ID
78494>>>            Set Label to "Vendor ID:"
78495>>>            Set Size to 13 42
78496>>>            Set Location to 4 67
78497>>>            Set peAnchors to anTopLeft
78498>>>            Set Label_Col_Offset to 2
78499>>>            Set Label_Justification_Mode to jMode_Right
78500>>>        End_Object    // oVendor_ID
78501>>>
78501>>>        Object oVendor_Name is a dbForm
78503>>>            Entry_Item Vendor.Name
78504>>>            Set Label to "Vendor Name:"
78505>>>            Set Size to 13 186
78506>>>            Set Location to 18 67
78507>>>            Set peAnchors to anTopLeftRight
78508>>>            Set Label_Col_Offset to 2
78509>>>            Set Label_Justification_Mode to jMode_Right
78510>>>        End_Object    // oVendor_Name
78511>>>
78511>>>        Object oVendor_Address is a dbForm
78513>>>            Entry_Item Vendor.Address
78514>>>            Set Label to "Street Address:"
78515>>>            Set Size to 13 186
78516>>>            Set Location to 34 67
78517>>>            Set peAnchors to anTopLeftRight
78518>>>            Set Label_Col_Offset to 2
78519>>>            Set Label_Justification_Mode to jMode_Right
78520>>>        End_Object    // oVendor_Address
78521>>>
78521>>>        Object oVendor_City is a dbForm
78523>>>            Entry_Item Vendor.City
78524>>>            Set Label to "City:"
78525>>>            Set Size to 13 90
78526>>>            Set Location to 49 67
78527>>>            Set peAnchors to anTopLeft
78528>>>            Set Label_Col_Offset to 2
78529>>>            Set Label_Justification_Mode to jMode_Right
78530>>>        End_Object    // oVendor_City
78531>>>
78531>>>        Object oVendor_State is a dbComboForm
78533>>>            Entry_Item Vendor.State
78534>>>            Set Label to "State:"
78535>>>            Set Size to 13 32
78536>>>            Set Location to 64 67
78537>>>            Set peAnchors to anTopLeft
78538>>>            Set Form_Border to 0
78539>>>            Set Label_Col_Offset to 2
78540>>>            Set Label_Justification_Mode to jMode_Right
78541>>>            Set Entry_State to False
78542>>>            Set Code_Display_Mode to cb_code_display_code
78543>>>        End_Object    // oVendor_State
78544>>>
78544>>>        Object oVendor_Zip is a dbForm
78546>>>            Entry_Item Vendor.Zip
78547>>>            Set Label to "Zip/Postal Code:"
78548>>>            Set Size to 13 66
78549>>>            Set Location to 79 67
78550>>>            Set peAnchors to anTopLeft
78551>>>            Set Label_Col_Offset to 2
78552>>>            Set Label_Justification_Mode to jMode_Right
78553>>>        End_Object    // oVendor_Zip
78554>>>
78554>>>        Object oVendor_Phone_Number is a dbForm
78556>>>            Entry_Item Vendor.Phone_Number
78557>>>            Set Label to "Phone Number:"
78558>>>            Set Size to 13 126
78559>>>            Set Location to 94 67
78560>>>            Set peAnchors to anTopLeftRight
78561>>>            Set Label_Col_Offset to 2
78562>>>            Set Label_Justification_Mode to jMode_Right
78563>>>        End_Object    // oVendor_Phone_Number
78564>>>
78564>>>        Object oVendor_Fax_Number is a dbForm
78566>>>            Entry_Item Vendor.Fax_Number
78567>>>            Set Label to "Fax Number:"
78568>>>            Set Size to 13 126
78569>>>            Set Location to 108 67
78570>>>            Set peAnchors to anTopLeftRight
78571>>>            Set Label_Col_Offset to 2
78572>>>            Set Label_Justification_Mode to jMode_Right
78573>>>        End_Object    // oVendor_Fax_Number
78574>>>
78574>>>    End_Object    // oContainer1
78575>>>
78575>>>CD_End_Object    // oVendorView
78577>>>>
78577>        
78577>        Use Basic\CustomerListBR.rv
Including file: Basic\CustomerListBR.rv    (C:\Test\Order Entry git\AppSrc\Basic\CustomerListBR.rv)
78577>>>Use DFAllRpt.pkg
78577>>>Use Basic\CustBasicRptImages.inc  // contains the images for the report
Including file: Basic\CustBasicRptImages.inc    (C:\Test\Order Entry git\AppSrc\Basic\CustBasicRptImages.inc)
78577>>>>>// CustBasicRptImages.pkg - images for CustomerListBR.rv
78577>>>>>// Since report images, such as the one used here, are not fully supported by
78577>>>>>// the Studio, we have placed the images for this report in a separate package.
78577>>>>>
/CUSTHDR
Image 2, CUSTHDR
                             Customer Listing                      Page:___.
Number  Name
----------------------------------------------------------------------------
/CustBody
Image 3, CUSTBODY
_____.  ______________________________
/Footer
Image 4, FOOTER
Date printed:  __/__/____
/*
78577>>>
78577>>>Open Customer
78579>>>Use dfrptvw.pkg
78579>>>Use dfRadio.pkg
Including file: Dfradio.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\Dfradio.pkg)
78579>>>>>Use windows.pkg // this now lives here. (you don't need to ever use this). 
78579>>>>>
78579>>>Use Windows.pkg
78579>>>
78579>>>DEFERRED_VIEW Activate_oCustomerListBR FOR ;;Object oCustomerListBR is a ReportView
78604>>>
78604>>>    Property Integer piSortIndex Public 1
78606>>>
78606>>>    Set Label to "Customer List"
78607>>>    Set Location to 6 6
78608>>>    Set Size to 80 180
78609>>>
78609>>>    Object oDestination is a RadioGroup
78611>>>        Set Size to 50 80
78612>>>        Set Location to 5 5
78613>>>        Set Label to "Output Device:"
78614>>>        Object oScreen is a Radio
78616>>>            Set Label to "Screen"
78617>>>            Set Size to 10 39
78618>>>            Set Location to 15 10
78619>>>            Set Status_Help to "Preview the report to screen"
78620>>>        End_Object    // oScreen
78621>>>
78621>>>        Object oPrinter is a Radio
78623>>>            Set Label to "Printer"
78624>>>            Set Size to 10 37
78625>>>            Set Location to 30 10
78626>>>            Set Status_Help to "Send the report to the default printer"
78627>>>        End_Object    // oPrinter
78628>>>
78628>>>        // set the Output_Device_Mode each time the radio button changes
78628>>>        Procedure Notify_Select_State Integer iNewItem Integer iOldItem
78631>>>            Forward Send Notify_Select_State iNewItem iOldItem
78633>>>        
78633>>>            If (iNewItem=0) Set Output_Device_Mode To PRINT_TO_WINDOW
78636>>>            Else            Set Output_Device_Mode To PRINT_TO_PRINTER
78638>>>        End_Procedure
78639>>>
78639>>>    End_Object    // oDestination
78640>>>
78640>>>    Object oOrderRadio is a RadioGroup
78642>>>        Set Size to 50 80
78643>>>        Set Location to 5 95
78644>>>        Set Label to "Report Order:"
78645>>>        Object oNumber is a Radio
78647>>>            Set Label to "Number"
78648>>>            Set Size to 10 41
78649>>>            Set Location to 15 10
78650>>>            Set Status_Help to "Sort by customer number"
78651>>>        End_Object    // oNumber
78652>>>
78652>>>        Object oName is a Radio
78654>>>            Set Label to "Name"
78655>>>            Set Size to 10 35
78656>>>            Set Location to 30 10
78657>>>            Set Status_Help to "Sort by customer name"
78658>>>        End_Object    // oName
78659>>>
78659>>>        // set the piSortIndex each time the radio button changes
78659>>>        Procedure Notify_Select_State Integer iNewItem Integer iOldItem
78662>>>            Forward Send Notify_Select_State iNewItem iOldItem
78664>>>        
78664>>>            Set piSortIndex  To (iNewItem + 1)
78665>>>        End_Procedure
78666>>>
78666>>>    End_Object    // oOrderRadio
78667>>>
78667>>>    Object oOkButton is a Button
78669>>>        Set Label to "OK"
78670>>>        Set Size to 14 51
78671>>>        Set Location to 62 71
78672>>>        Set Default_State to True
78673>>>
78673>>>        Procedure OnClick
78676>>>            Send StartReport
78677>>>        End_Procedure
78678>>>
78678>>>    End_Object    // oOkButton
78679>>>
78679>>>    Object oCancelButton is a Button
78681>>>        Set Label to "Cancel"
78682>>>        Set Location to 62 125
78683>>>
78683>>>        Procedure OnClick
78686>>>            Send Request_Cancel
78687>>>        End_Procedure
78688>>>
78688>>>    End_Object    // oCancelButton
78689>>>
78689>>>    Procedure StartReport
78692>>>        Integer iOutputDevice
78692>>>        Handle hoThisWorkspace
78692>>>        String sCurDir sDataPath 
78692>>>        String sFileName
78692>>>                    
78692>>>        Get Output_Device_Mode to iOutputDevice
78693>>>
78693>>>        If (iOutputDevice=PRINT_TO_WINDOW) Begin
78695>>>            // save current location
78695>>>            Get_Current_Directory to sCurDir
78696>>>
78696>>>            // get workspace data path (all users must have r/w rights to it) to output the temp file there
78696>>>            Get phoWorkspace of ghoApplication to hoThisWorkspace
78697>>>            Get psDataPath of hoThisWorkspace to sDataPath
78698>>>            Get PathAtIndex of hoThisWorkspace sDataPath 1 to sDataPath
78699>>>            
78699>>>            // set current directory to DataPath
78699>>>            Set_Directory sDataPath
78700>>>        
78700>>>            Make_Temp_File "TXT" sFileName
78701>>>            Move (".\" - sFileName) to sFileName
78702>>>            Set Output_Device_Name to sFileName
78703>>>        End
78703>>>>
78703>>>        Else Begin
78704>>>           Set Output_Device_Name to "WinLST:"
78705>>>        End
78705>>>>
78705>>>    
78705>>>        Send Run_Report
78706>>>    
78706>>>        If (iOutputDevice=PRINT_TO_WINDOW) Begin
78708>>>           Runprogram background "NotePad" sFileName
78709>>>           EraseFile sFileName
78710>>>>
78710>>>        End
78710>>>>
78710>>>        
78710>>>        // restore previous location
78710>>>        Set_Directory sCurDir
78711>>>        
78711>>>    End_Procedure   // StartReport
78712>>>    
78712>>>    Object oCustomer_BasicReport is a BasicReport
78714>>>    
78714>>>        Report_Main_File Customer
78715>>>    
78715>>>        Set Report_Title to "Printing Customer Names"
78716>>>    
78716>>>        Function Starting_Main_Report Returns Integer
78719>>>            Integer iRetVal
78719>>>            Integer iIndex
78719>>>    
78719>>>            Forward Get Starting_Main_Report to iRetVal
78721>>>    
78721>>>            Get piSortIndex To iIndex
78722>>>            Report_Index BY iIndex    // set the sort order
78724>>>            Sysdate Footer.1         // set date for report
78725>>>            
78725>>>            Function_Return iRetVal
78726>>>        End_Function
78727>>>    
78727>>>        Procedure_Section Page_Top as CustHdr
78732>>>            Integer iPage
78732>>>            Get Page_Count To iPage
78733>>>            Print iPage
78734>>>            OutPut_PageCheck
78735>>>        End_Procedure
78736>>>    
78736>>>        Procedure_Section Body as CustBody
78741>>>            Send Update_Status (String(Customer.Customer_Number)- ":" * Customer.Name )
78742>>>            Print Customer.Customer_number
78743>>>            Print Customer.Name
78744>>>            OutPut_PageCheck
78745>>>        End_Procedure
78746>>>    
78746>>>        Procedure_Section Page_Bottom as Footer
78756>>>            OutPut_PageCheck
78757>>>        End_Procedure
78758>>>    
78758>>>    End_Object    // Customer_BasicReport
78759>>>
78759>>>CD_End_Object    // oCustomerListBR
78761>>>>
78761>        Use WinPrint\CustomerListWP.rv
Including file: WinPrint\CustomerListWP.rv    (C:\Test\Order Entry git\AppSrc\WinPrint\CustomerListWP.rv)
78761>>>Use dfrptvw.pkg
78761>>>Use DataDict.pkg
78761>>>Use dfRadio.pkg
78761>>>Use Windows.pkg
78761>>>Use cWinReport2.pkg
Including file: cWinReport2.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cWinReport2.pkg)
78761>>>>>// cWinReport2.pkg
78761>>>>>
78761>>>>>// defines support for new Winprint2 cWinReport2 class
78761>>>>>
78761>>>>>
78761>>>>>Use DFRpt.pkg              // BasicReport RO Class for VDF
78761>>>>>Use WinPrint2.pkg          // WinPrint2 engine
Including file: Winprint2.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\Winprint2.pkg)
78761>>>>>>>// WinPrint2.pkg
78761>>>>>>>//
78761>>>>>>>Use windows.pkg
78761>>>>>>>Use LanguageText.pkg
78761>>>>>>>Use DLL.pkg
78761>>>>>>>Use WinPrint2_Api.pkg
Including file: WinPrint2_API.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\WinPrint2_API.pkg)
78761>>>>>>>>>//WinPrint2_API.pkg
78761>>>>>>>>>
78761>>>>>>>>>Use DLL.pkg
78761>>>>>>>>>
78761>>>>>>>>>External_Function WP_IsPrinterValid "IsPrinterValid" WinPrint.dll ;Returns Boolean // True if the the current printer is a valid one. False, otherwise.
78762>>>>>>>>>
78762>>>>>>>>>External_Function WP_ArePrintersInstalled "ArePrintersInstalled" WinPrint.dll ; // determines whether at least one printer is installedReturns Boolean // True, if a printer is installed, False if it is not.
78763>>>>>>>>>
78763>>>>>>>>>External_Function WP_ExecutePrinterSetupDialog "ExecutePrinterSetupDialog" WinPrint.dll ; // displays the "printer setup" dialog   Handle hWndParent; // window handle of the parent windowReturns Boolean // True if the OK button pressed; False, otherwise.
78764>>>>>>>>>
78764>>>>>>>>>External_Function WP_ExecutePrintDialog "ExecutePrintDialog" WinPrint.dll ; // displays the "Print" dialog   Handle hWndParent; // window handle of the parent windowReturns Boolean // True if the OK button pressed; False, otherwise.
78765>>>>>>>>>
78765>>>>>>>>>External_Function WP_GetCurrentDevice "GetCurrentDevice" WinPrint.dll ; // retrieves the name of the current printer device    Address aDevice ; // address of the string (255 chars) that will hold the device name upon returnReturns Boolean // True, if success; False if error occurred
78766>>>>>>>>>
78766>>>>>>>>>External_Function WP_GetPrintDialogFlags "GetPrintDialogFlags" WinPrint.dll ; // retrieves the current print optionsReturns UInteger // array of flags representing print-related options that are currently set
78767>>>>>>>>>
78767>>>>>>>>>External_Function WP_GetUserDefinedPapersize "GetUserDefinedPapersize" WinPrint.dll ;  // gets the size of user-defined paperReturns UInteger // // hi-word=length; lo-word=width
78768>>>>>>>>>
78768>>>>>>>>>External_Function WP_IsPrintDialogFlagSet "IsPrintDialogFlagSet" WinPrint.dll ; // determines whether a specific print-flag is set    UInteger iFlag ; // the printer flagReturns Boolean // True, if the flag is set; False, if it isn't
78769>>>>>>>>>
78769>>>>>>>>>External_Function WP_SelectPrinter "SelectPrinter" WinPrint.dll ; // selects a printer programatically    String sDevice; // the name of the printerReturns Boolean // True, if success; False, if error (such as an invalid printer name)
78770>>>>>>>>>
78770>>>>>>>>>External_Function WP_SetFirstPagePaperSource "SetFirstPagePaperSource"  WinPrint.dll ;        Integer iBin ; // the bim constantReturns Boolean // True if success, false if error
78771>>>>>>>>>
78771>>>>>>>>>External_Function WP_SetNumberOfPrintCopies "SetNumberOfPrintCopies" WinPrint.dll ; // sets the number of copies to print    UInteger iNumCopies; // number of copies to makeReturns Boolean // Always True
78772>>>>>>>>>
78772>>>>>>>>>External_Function WP_SetSpecificPrintDialogFlag "SetSpecificPrintDialogFlag" WinPrint.dll; // Sets/unsets one printer flag    UInteger fFlag; // printer flagReturns Boolean // True, if success; False if error occurred
78773>>>>>>>>>
78773>>>>>>>>>External_Function WP_SetPrintDialogFlags "SetPrintDialogFlags" WinPrint.dll; // Sets/unsets all printer flags in one call    UInteger fFlags; // printer flagsReturns Boolean // True, if success; False if error occurred
78774>>>>>>>>>
78774>>>>>>>>>External_Function WP_SetUserDefinedPapersize "SetUserDefinedPapersize" WinPrint.dll ;  // sets the size of user-defined paper    UInteger iPaperSize ; // hi-word=length; lo-word=widthReturns Boolean; // True, if success; False if error occurred
78775>>>>>>>>>External_Function WP_SetFontStyle "SetFontStyle" WinPrint.dll ; // sets multiple font attributes    Integer iStyles ; // series of flagsReturns Boolean // always True
78776>>>>>>>>>
78776>>>>>>>>>External_Function WP_SetFontBold "SetFontBold" WinPrint.dll ; // toggles the bold attribute of the current font    Boolean bBold ; // True to switch bold attribute on; False to switch it offReturns Boolean // always True
78777>>>>>>>>>
78777>>>>>>>>>External_Function WP_SetFontItalic "SetFontItalic" WinPrint.dll ; // toggles the italic attribute of the current font    Boolean bItalic ; // True to switch italic attribute on; False to switch it offReturns Boolean  // always True
78778>>>>>>>>>
78778>>>>>>>>>External_Function WP_SetFontUnderline "SetFontUnderline" WinPrint.dll ; // toggles the underline attribute of the current font    Boolean bUnderline ; // True to switch underline attribute on; False to switch it offReturns Boolean  // always True
78779>>>>>>>>>
78779>>>>>>>>>External_Function WP_SetFontStrikeout "SetFontStrikeout" WinPrint.dll ; // toggles the strikeout attribute of the current font    Boolean bStrikeout ; // True to switch strikeout attribute on; False to switch it offReturns Boolean  // always True
78780>>>>>>>>>
78780>>>>>>>>>External_Function WP_SetFontColor "SetFontColor" WinPrint.dll ; // sets the color of the current font    Integer iColor ; // color of the fontReturns Boolean  // always True
78781>>>>>>>>>
78781>>>>>>>>>External_Function WP_SetFontHeight "SetFontHeight" WinPrint.dll ; // sets the height of the font    UInteger iHeight ; // height of the font in points (multiplied by 100. Eg 12.5 point should be sent as 1250)Returns Boolean  // always True
78782>>>>>>>>>
78782>>>>>>>>>External_Function WP_SetFontName "SetFontName" WinPrint.dll ; // Sets the name of the font to use    String sFontName ; // name of the font to useReturns Boolean  // always True
78783>>>>>>>>>
78783>>>>>>>>>External_Function WP_DrawBitmap "DrawBitmap" WinPrint.dll ; // Draws a bitmap (BMP, JPG)    String  sBitmap;                 // Name of the bitmap    Integer iLeft;                   // distance from left edge to draw bitmap    Integer iTop;                    // distance from top edge to draw bitmap    Integer iWidth;                  // width of the bitmap    Integer iHeight;                 // height of the bitmap    Boolean bUpdateCurrentPosition;  // after drawing, should the current position be updated?Returns Boolean // True, if OK; False, if an error occurred.
78784>>>>>>>>>
78784>>>>>>>>>External_Function WP_DrawEllipse "DrawEllipse" WinPrint.dll ; // draws an elipse within a bounding rectangle    Integer iLeft;                   // distance from left edge to draw the ellipse    Integer iTop;                    // distance from top edge to draw the ellipse    Integer iWidth;                  // width of the bounding rectangle    Integer iHeight;                 // height of the bounding rectangle    Integer iBorderColor;            // color of the ellipse's edge    Integer iFillColor;              // internal color of the ellipse    Boolean  bFill;                  // should the ellipse be filled? (False=transparent)    UInteger iThickness;             // thickness of the elipse    Boolean  bUpdateCurrentPosition; // after drawing, should the current position be updated?    Boolean  bWrap;                  // Should the ellipse be drawn on future soft-page breaks?Returns Boolean // True, if OK; False, if an error occurred.
78785>>>>>>>>>
78785>>>>>>>>>External_Function WP_DrawLine "DrawLine" WinPrint.dll ; // draws a line from the current position    Integer iLeft;                   // distance from left edge to draw the line    Integer iTop;                    // distance from top edge to draw the line    Integer iLength;                 // length of the line    Boolean  bHorizontal;            // draw horizontal? (False=vertical)    Integer iColor;                  // color of the line    UInteger iThickness;             // thickness of the line    Boolean  bUpdateCurrentPosition; // after drawing, should the current position be updated?Returns Boolean // True, if OK; False, if an error occurred.
78786>>>>>>>>>
78786>>>>>>>>>External_Function WP_DrawRectangle "DrawRectangle" WinPrint.dll ; // draws a rectangle    Integer iLeft;                   // distance from left edge to draw the rectangle    Integer iTop;                    // distance from top edge to draw the rectangle    Integer iWidth;                  // width of the rectangle    Integer iHeight;                 // height of the rectangle    Integer iBorderColor;            // color of the rectangle's border    Integer iFillColor;              // internal color of the rectangle    Boolean  bFill;                  // should the rectangle be filled? (False=transparent)    UInteger iThickness;             // thickness of the rectangle's border    Boolean  bUpdateCurrentPosition; // after drawing, should the current position be updated?    Boolean  bWrap;                  // Should the rectangle be drawn on future soft-page breaks?Returns Boolean // True, if OK; False, if an error occurred.
78787>>>>>>>>>
78787>>>>>>>>>External_Function WP_DrawXYLine "DrawXYLine" WinPrint.dll ; // draws a line between two points    Integer iLeftStart;              // distance from left edge to draw from    Integer iTopStart;               // distance from top edge to draw from    Integer iLeftEnd;                // distance from left edge to draw to    Integer iTopEnd;                 // distance from top edge to draw to    Integer iColor;                  // color of the line    UInteger iThickness;             // thickness of the line    Boolean  bUpdateCurrentPosition; // after drawing, should the current position be updated?    Boolean  bWrap;                  // Should the line be drawn on future soft-page breaks?Returns Boolean // True, if OK; False, if an error occurred.
78788>>>>>>>>>
78788>>>>>>>>>External_Function WP_SetAbsoluteMargins "SetAbsoluteMargins" WinPrint.dll ; // modifies the top/bottom non-printable margin    UInteger iTop;      // the top margin offset    UInteger iBottom;   // the bottom margin offset    Boolean  bAllPages; // should all pages be affected? True=AllPages; False=first page onlyReturns Boolean // always True
78789>>>>>>>>>
78789>>>>>>>>>External_Function WP_SetMargins "SetMargins" WinPrint.dll ; // Sets the user-margins    UInteger iLeft;   // the left margin    UInteger iTop;    // the top margin    UInteger iRight;  // the right margin    UInteger iBottom; // the bottom marginReturns Boolean // always True
78790>>>>>>>>>
78790>>>>>>>>>External_Function WP_CreateDiagram "CreateDiagram" WinPrint.dll ; // Creates a new diagram    UInteger eType;       // type of diagram (Bar, Line, Pie)    UInteger eEffect;     // how it is drawn (2d or 3d, etc)    UInteger iWidth;      // width of the diagram    UInteger iHeight;     // height of the diagram    Boolean  bDrawXyAxis; // draw the xy-axis (for bar charts only)?Returns Handle // unique id for the diagram used in other diagram funtions
78791>>>>>>>>>
78791>>>>>>>>>External_Function WP_AddDiagramEntry "AddDiagramEntry" WinPrint.dll ; // Adds an item into a diagram    Handle   hDiagram;          // diagram handle returned by CreateDiagram()    String   sValueDescription; // description of the item    String   sValue;            // value of the item    Integer iBorderColor;       // color of the item's border    Integer iFillColor;         // color of the item's interior    Boolean  bFilled;           // should the item be drawn filled (with iFillColor), or transparent?    UInteger iNumDecimals;      // Number of decimals in the sValue argument    UInteger eValueOrPercent;   // How the value should be displayed (as value or percentage, etc)    Boolean  bExploded;         // should the value be "pulled out" (pie charts only)Returns Boolean // True, if success; False, if error
78792>>>>>>>>>
78792>>>>>>>>>External_Function WP_DrawDiagram "DrawDiagram" WinPrint.dll ; // draws a diagram    Handle   hDiagram;               // diagram handle returned by CreateDiagram()    UInteger iLeft;                  // x-coordinate to draw the diagram    UInteger iTop;                   // y-coordinate to draw the diagram    Boolean  bUpdateCurrentPosition; // after drawing, should the current position be updated?Returns Boolean // True, if success; False, if error
78793>>>>>>>>>
78793>>>>>>>>>External_Function WP_LockDiagram "LockDiagram" WinPrint.dll ; // Locks a diagram so that no more entries can be added    Handle hDiagram; // diagram handle returned by CreateDiagram()Returns Boolean // True, if success; False, if error
78794>>>>>>>>>
78794>>>>>>>>>External_Function WP_SetDiagramCaption "SetDiagramCaption" WinPrint.dll ; // Sets the caption of a diagram    Handle hDiagram; // diagram handle returned by CreateDiagram()    String sCaption; // the diagram's captionReturns Boolean // True, if success; False, if error
78795>>>>>>>>>
78795>>>>>>>>>External_Function WP_SetDiagramXText "SetDiagramXText" WinPrint.dll ; // Sets the horizontal label of a diagram    Handle hDiagram; // diagram handle returned by CreateDiagram()    String sText;    // the diagram's horizonal labelReturns Boolean // True, if success; False, if error
78796>>>>>>>>>
78796>>>>>>>>>External_Function WP_SetDiagramYText "SetDiagramYText" WinPrint.dll ; // Sets the vertical label of a diagram    Handle  hDiagram;      // diagram handle returned by CreateDiagram()    String  sText;         // the diagram's vertical label    Boolean bVerticalText; // should the text be drawn vertically (False=horizontally)Returns Boolean // True, if success; False, if error
78797>>>>>>>>>
78797>>>>>>>>>External_Function WP_BeginHeader "BeginHeader" WinPrint.dll ; // creates a new header    UInteger iHeaderType; // the type of header    UInteger iSubHeaderNum; // for subheaders, then number (1-0)Returns Boolean // always True
78798>>>>>>>>>
78798>>>>>>>>>External_Function WP_EndHeader "EndHeader" WinPrint.dll ; // declares the end of the current headerReturns Boolean // always True
78799>>>>>>>>>
78799>>>>>>>>>External_Function WP_SetExtraLineCheck "SetExtraLineCheck" WinPrint.dll ; // forces a soft page break if header plus number of lines don't fit on page    UInteger iNumLines; // number of lines in addition to header required before forcing a soft page-breakReturns Boolean; // always True
78800>>>>>>>>>External_Function WP_SetHeaderFrame "SetHeaderFrame" WinPrint.dll ; // sets the style, color and frame of a header    UInteger eFrame;     // style of frame (margin-to-margin, etc)    Integer iColor;      // color of the frame's edge    UInteger iThickness; // thickness of the frame    Integer iFillCol;    // the internal color of the frame (only used if bBilled=True)    Boolean  bFilled;    // True, if the frame should be filled with the iFillColor (False=Transparent)Returns Boolean // Always True
78801>>>>>>>>>
78801>>>>>>>>>External_Function WP_SetHeaderMargin "SetHeaderMargin" WinPrint.dll ; // Sets a margin of space on the inside and outside of the current header    UInteger eType;      // Specifies which margin areas is being set.    Integer  iSize;      // Size of the margin setting in the current report metricsReturns Boolean  // False if document is not started
78802>>>>>>>>>
78802>>>>>>>>>External_Function WP_SetHeaderPlacement "SetHeaderPlacement" WinPrint.dll ; // placement (left, center or right) of the header    UInteger ePlacement; // placed left, center or rightReturns Boolean //always True
78803>>>>>>>>>
78803>>>>>>>>>External_Function WP_SetHeaderWrap "SetHeaderWrap" WinPrint.dll ; // determines whether the current header is drawn on soft page-breaks    Boolean bWrap; // True, to wrap onto following pages; False, for current page onlyReturns Boolean // always True
78804>>>>>>>>>
78804>>>>>>>>>External_Function WP_WriteHeader "WriteHeader" WinPrint.dll ; // writes a header to the current page    UInteger eHeaderType;   // type of header    UInteger iSubHeaderNum; // for subheaders, the number (1-9)Returns Boolean // True, if success; False, if error
78805>>>>>>>>>
78805>>>>>>>>>External_Function WP_RGBToDFPrintColor "RGBToDFPrintColor" WinPrint.dll ; // converts R, G, and B values into a composite color that WinPrint expects    UInteger iRed;   // red component (1-255)    UInteger iGreen; // green component (1-255)    UInteger iBlue;  // blue component (1-255)Returns Integer // composite color
78806>>>>>>>>>
78806>>>>>>>>>External_Function WP_GetMetrics "GetMetrics" WinPrint.dll ; // gets the current unit of measurementReturns UInteger // unit of measurement (Inch or CM)
78807>>>>>>>>>
78807>>>>>>>>>External_Function WP_SetMetrics "SetMetrics" WinPrint.dll ; // sets the unit of measurement   UInteger eMetrics; // Inch or CMReturns Boolean // always True
78808>>>>>>>>>
78808>>>>>>>>>External_Function WP_ClearDocument "ClearDocument" WinPrint.dll ; // clears the resources of the document from memoryReturns Boolean // always True
78809>>>>>>>>>
78809>>>>>>>>>External_Function WP_NewDocument "NewDocument" WinPrint.dll ; // starts a new document, but preserves the printer settings   Boolean bAutoPreview ; // Should the Previewer be displayed immediatelyReturns Boolean // True, if success; False, if an error occurred
78810>>>>>>>>>
78810>>>>>>>>>External_Function WP_EndDocument "EndDocument" WinPrint.dll ; // Indicates that the document is finishedReturns Boolean // always True
78811>>>>>>>>>
78811>>>>>>>>>External_Function WP_ClearPrinter "ClearPrinter" WinPrint.dll ; // clears all printer and document resourcesReturns Boolean // True, if success; False, if an error occurred
78812>>>>>>>>>
78812>>>>>>>>>External_Function WP_ConfirmLines "ConfirmLines" WinPrint.dll ; // ensures that a specified number of lines will fit on the page; if not, a soft page-break is performed automatically    UInteger iNumLines; // number of lines that must fit on the pageReturns Boolean // True, if success; False, if an error occurred
78813>>>>>>>>>
78813>>>>>>>>>External_Function WP_CreatePage "CreatePage" WinPrint.dll ; // creates a new page of specified columns   UInteger iNumColumns; // number of columns (zero= no columns)Returns UInteger; // page number that was created
78814>>>>>>>>>External_Function WP_PreviewDocument "PreviewDocument" WinPrint.dll ; // previews the current document    Boolean bPrintDialog; // Determines whether the Print Dialog (range, etc) is displayed when the "print" button is clicked in the preview window.    Boolean bPrintSetup;  // Determines whether the Print Setup button is enabled (allows to change orientation, etc)    Boolean bPrint;       // Determines whether the Print button is enabledReturns Handle // non-zero = hViewerProcess; zero= error
78815>>>>>>>>>
78815>>>>>>>>>External_Function WP_ClosePreview "ClosePreview" WinPrint.dll ; // closes the preview windowReturns Boolean // True, if closed; False, if an error occurred (such as it not being already open)
78816>>>>>>>>>
78816>>>>>>>>>External_Function WP_PrintDocument "PrintDocument" WinPrint.dll ; // prints the current document    Handle hWndParent; // window handle of object to use for any modal outputReturns Boolean // True, if success; False, if an error occurred
78817>>>>>>>>>
78817>>>>>>>>>External_Function WP_SetAlign "SetAlign" WinPrint.dll ; // align future text    UInteger eAlign; // left, center or rightReturns Boolean // always True
78818>>>>>>>>>
78818>>>>>>>>>External_Function WP_WriteText "WriteText" WinPrint.dll ; // write text to the current position or column    String sText;               // the text to write    Boolean bNewLineAfterPrint; // should a "CR" be written after the text    UInteger iColumnNum;        // number of the column to write to (zero=no column, use current position)    Integer iNumDecimals;       // number of decimals in the text (-1 means sText is a string)    UInteger iWidth;            // width of text before truncatingReturns Boolean // True, if success; False, if an error occurred
78819>>>>>>>>>
78819>>>>>>>>>External_Function WP_WriteTextAtPosition "WriteTextAtPosition" WinPrint.dll ; // writes text to a specific position    String sText;               // the text to write    Boolean bNewLineAfterPrint; // should a "CR" be written after the text    UInteger iPosition;         // horizontal position to write the text    Integer iNumDecimals;       // number of decimals in the text (-1 means sText is a string)    UInteger iWidth;            // width of text before truncatingReturns Boolean // True, if success; False, if an error occurred
78820>>>>>>>>>
78820>>>>>>>>>External_Function WP_SetProgressCaption "SetProgressCaption" WinPrint.dll ;    String sProgressCaption ;Returns Boolean
78821>>>>>>>>>
78821>>>>>>>>>External_Function WP_SetReportTitle     "SetReportTitle"     WinPrint.dll ;    String sCaption ;Returns Boolean
78822>>>>>>>>>
78822>>>>>>>>>External_Function WP_ViewerWantsToClose "ViewerWantsToClose" WinPrint.dll ;Returns Integer
78823>>>>>>>>>
78823>>>>>>>>>External_Function WP_DisplayMessageBox  "DisplayMessageBox"  WinPrint.dll ;    String sCaption String sText ;Returns Integer
78824>>>>>>>>>
78824>>>>>>>>>External_Function WP_GetViewerWindow "GetViewerWindow" Winprint.dll ;Returns Handle
78825>>>>>>>>>
78825>>>>>>>>>External_Function WP_GetDocumentStatus "GetDocumentStatus" Winprint.dll ;Returns Integer // returns dsNotStarted, dsStarted, or dsFinished
78826>>>>>>>>>
78826>>>>>>>Use WinPrint_Constants.pkg
78826>>>>>>>Use Rgb.pkg
78826>>>>>>>Use GlobalFunctionsProcedures.pkg
78826>>>>>>>
78826>>>>>>>DEFINE INFINITE for -1
78826>>>>>>>DEFINE WAIT_TIMEOUT for |CI$00000102
78826>>>>>>>
78826>>>>>>>
78826>>>>>>>DEFINE QS_KEY            for |CI$0001
78826>>>>>>>DEFINE QS_MOUSEMOVE      for |CI$0002
78826>>>>>>>DEFINE QS_MOUSEBUTTON    for |CI$0004
78826>>>>>>>DEFINE QS_POSTMESSAGE    for |CI$0008
78826>>>>>>>DEFINE QS_TIMER          for |CI$0010
78826>>>>>>>DEFINE QS_PAINT          for |CI$0020
78826>>>>>>>DEFINE QS_SENDMESSAGE    for |CI$0040
78826>>>>>>>DEFINE QS_HOTKEY         for |CI$0080
78826>>>>>>>DEFINE QS_ALLPOSTMESSAGE for |CI$0100
78826>>>>>>>DEFINE QS_MOUSE          for (QS_MOUSEMOVE ior QS_MOUSEBUTTON)
78826>>>>>>>DEFINE QS_INPUT          for (QS_MOUSE ior QS_KEY)
78826>>>>>>>DEFINE QS_ALLEVENTS      for (QS_INPUT ior QS_POSTMESSAGE ior QS_TIMER ior QS_PAINT ior QS_HOTKEY)
78826>>>>>>>DEFINE QS_ALLINPUT       for (QS_INPUT ior QS_POSTMESSAGE ior QS_TIMER ior QS_PAINT ior QS_HOTKEY ior QS_SENDMESSAGE)
78826>>>>>>>
78826>>>>>>>External_Function WaitForSingleObject "WaitForSingleObject" Kernel32.dll Handle hHandle Dword dwMilliseconds Returns DWord
78827>>>>>>>External_Function GetCurrentProcessId "GetCurrentProcessId" Kernel32.dll Returns DWord
78828>>>>>>>External_Function GetCurrentProcess "GetCurrentProcess" Kernel32.dll Returns DWord
78829>>>>>>>
78829>>>>>>>External_Function MsgWaitForMultipleObjects "MsgWaitForMultipleObjects" User32.dll ;    DWORD nCount;             // number of handles in the object handle array    Address pHandles;     // pointer to the object-handle array    Boolean fWaitAll;     // wait for all or wait for one    DWORD dwMilliseconds; // time-out interval in milliseconds    DWORD dwWakeMask;     // type of input events to wait forReturns Dword
78830>>>>>>>
78830>>>>>>>Use GlobalFunctionsProcedures.pkg
78830>>>>>>>
78830>>>>>>>Class cWinPrint2 is a cObject // JJT: Will we need a windows handle for this like old one
78831>>>>>>>    Procedure Construct_Object
78833>>>>>>>        forward send construct_object
78835>>>>>>>
78835>>>>>>>        //*** internal properties
78835>>>>>>>        Property Integer DFCurrent_Color       0
78836>>>>>>>        Property String  DFCurrent_OutPut      "WinPrint"
78837>>>>>>>        Property Integer DFCurrent_Diagram     0
78838>>>>>>>        Property Integer DFCurrent_HeaderType  0
78839>>>>>>>        Property Integer DFCurrent_HeaderNr    0
78840>>>>>>>        Property Number  DFCurrent_FontSize    10
78841>>>>>>>        Property String  DFCurrent_Font        "Arial"
78842>>>>>>>
78842>>>>>>>        //*** Default values for margins 2.53 CM = 1 inch
78842>>>>>>>        Property Number  DFLeft_Margin    2.53
78843>>>>>>>        Property Number  DFTop_Margin     2.53
78844>>>>>>>        Property Number  DFright_Margin   2.53
78845>>>>>>>        Property Number  DFBottom_Margin  2.53
78846>>>>>>>
78846>>>>>>>        // If WP1 this defaults to false. In 2, it is true which means that the print job
78846>>>>>>>        // dialog appears when you hitprint in previewer.
78846>>>>>>>        Property Integer PrintDlgInPreview   1
78847>>>>>>>         // This does nothing in Wp2 (because you can't to this anyway)
78847>>>>>>>        Property Integer EnablePrintSetupFromPreview  True
78848>>>>>>>        Property Integer EnablePrintFromPreview  1
78849>>>>>>>
78849>>>>>>>        // is the GUI Suspended. This is privately maintained and is used
78849>>>>>>>        // to figure out if a preview panel is up or not
78849>>>>>>>        Property Integer pbIsSuspended False
78850>>>>>>>
78850>>>>>>>        Object oDFColorArray is an Array
78852>>>>>>>           //Moved into array
78852>>>>>>>           Set Value  0  To RGB_WHITE
78853>>>>>>>           Set Value  1  To RGB_RED
78854>>>>>>>           Set Value  2  To RGB_BLUE
78855>>>>>>>           Set Value  3  To RGB_GREEN
78856>>>>>>>           Set Value  4  To RGB_YELLOW
78857>>>>>>>           Set Value  5  To RGB_GREY
78858>>>>>>>           Set Value  6  To RGB_CYAN
78859>>>>>>>           Set Value  7  To RGB_MAGENTA
78860>>>>>>>           Set Value  8  To RGB_DRED
78861>>>>>>>           Set Value  9  To RGB_DBLUE
78862>>>>>>>           Set Value  10 To RGB_DGREEN
78863>>>>>>>           Set Value  11 To RGB_DYELLOW
78864>>>>>>>           Set Value  12 To RGB_DGREY
78865>>>>>>>           Set Value  13 To RGB_DCYAN
78866>>>>>>>           Set Value  14 To RGB_DMAGENTA
78867>>>>>>>           Set Value  15 To RGB_BLACK
78868>>>>>>>        End_Object
78869>>>>>>>
78869>>>>>>>        Object oDiagramArray is an Array
78871>>>>>>>        End_Object
78872>>>>>>>
78872>>>>>>>    End_Procedure
78873>>>>>>>
78873>>>>>>>    Function ViewerWantsToClose returns Boolean
78875>>>>>>>        Function_return (WP_ViewerWantsToClose())
78876>>>>>>>    end_Function
78877>>>>>>>
78877>>>>>>>    Function IsViewerActive returns boolean
78879>>>>>>>        Function_Return (WP_GetViewerWindow()<>0)
78880>>>>>>>    end_function
78881>>>>>>>
78881>>>>>>>    Function IsPrinterValid Returns Boolean
78883>>>>>>>        Function_Return (WP_IsPrinterValid()<>0)
78884>>>>>>>    End_Function
78885>>>>>>>
78885>>>>>>>    Function ArePrintersInstalled returns boolean
78887>>>>>>>        Function_Return (WP_ArePrintersInstalled()<>0)
78888>>>>>>>    End_Function
78889>>>>>>>
78889>>>>>>>
78889>>>>>>>    // returns docucument state: dsNotStarted, dsStarted, dsFinished
78889>>>>>>>    Function DocumentStatus returns Integer
78891>>>>>>>        Function_Return (WP_GetDocumentStatus())
78892>>>>>>>    end_function
78893>>>>>>>
78893>>>>>>>    // Might still be called from report class. Leave dummy stub
78893>>>>>>>    Procedure DFZeroCounters
78895>>>>>>>    End_Procedure
78896>>>>>>>
78896>>>>>>>    //***
78896>>>>>>>    Function DFNewPage Integer Columns Returns Integer
78898>>>>>>>        Integer iPageNum
78898>>>>>>>        // This returns a page number used in report object....(this may change)
78898>>>>>>>        Move (WP_CreatePage(Columns)) To iPageNum
78899>>>>>>>        If (iPageNum=0) Begin
78901>>>>>>>            Error DFERR_WINPRINT DFPrintError900
78902>>>>>>>>
78902>>>>>>>        End
78902>>>>>>>>
78902>>>>>>>        Function_Return iPageNum
78903>>>>>>>    End_Function
78904>>>>>>>
78904>>>>>>>    //***Return handle to use for winprint dialog. If main_window
78904>>>>>>>    //   exists, use it. Else, get object's handle
78904>>>>>>>    Function Report_Window_Handle returns handle
78906>>>>>>>        Handle hWnd
78906>>>>>>>        Handle hoObj
78906>>>>>>>        Get Focus of desktop to hoObj // start with the focus
78907>>>>>>>        Move (gOwnerWindowHandle(hoObj)) to hWnd // global function finds the right handle for us
78908>>>>>>>        function_return hWnd
78909>>>>>>>    End_Function
78910>>>>>>>
78910>>>>>>>
78910>>>>>>>    //***
78910>>>>>>>    Function DFPrintDialog Returns Boolean
78912>>>>>>>        Handle hwnd
78912>>>>>>>        Boolean bOk
78912>>>>>>>
78912>>>>>>>        Get Report_Window_Handle to hWnd
78913>>>>>>>        Move (WP_ExecutePrintDialog(hwnd)) To bOk
78914>>>>>>>
78914>>>>>>>        Function_Return bOk
78915>>>>>>>    End_Function
78916>>>>>>>
78916>>>>>>>
78916>>>>>>>    //*** You can only invoke the print setup if the report is cleared. If you try to to do this in
78916>>>>>>>    //    the wrong state you will get an error.
78916>>>>>>>    Function DFPrintSetupDialog Returns Boolean
78918>>>>>>>        Handle hwnd
78918>>>>>>>        Boolean bOk
78918>>>>>>>        Integer iStatus
78918>>>>>>>        Get ArePrintersInstalled to bOk
78919>>>>>>>        If not bOk Begin
78921>>>>>>>            Error DFERR_WINPRINT C_$NoInstalledPrinters
78922>>>>>>>>
78922>>>>>>>        End
78922>>>>>>>>
78922>>>>>>>        Else Begin
78923>>>>>>>            Get DocumentStatus to iStatus
78924>>>>>>>            
78924>>>>>>>            If (iStatus=dsNotStarted) Begin
78926>>>>>>>                Get Report_Window_Handle to hWnd
78927>>>>>>>                Move (WP_ExecutePrinterSetupDialog(hwnd)) to bOk
78928>>>>>>>                
78928>>>>>>>                // test that the selected printer is valid....
78928>>>>>>>                If bOK Begin
78930>>>>>>>                    Get IsPrinterValid to bOk // if printer not valid, it's not ok
78931>>>>>>>                    If not bOk Begin
78933>>>>>>>                        Error DFERR_WINPRINT DFPrintError936  // could not select a valid printer
78934>>>>>>>>
78934>>>>>>>                    End
78934>>>>>>>>
78934>>>>>>>                End
78934>>>>>>>>
78934>>>>>>>            End
78934>>>>>>>>
78934>>>>>>>            Else Begin
78935>>>>>>>               Error DFERR_WINPRINT DFPrintError966      // cannot change printer when report is active
78936>>>>>>>>
78936>>>>>>>            End
78936>>>>>>>>
78936>>>>>>>        End
78936>>>>>>>>
78936>>>>>>>        Function_Return bOk
78937>>>>>>>    End_Function
78938>>>>>>>
78938>>>>>>>
78938>>>>>>>    //*** Provided for backwards compatibility. DFPrintSetupDialog is more flexible because it returns a
78938>>>>>>>    //    false if cancel was selected.
78938>>>>>>>    Procedure DFPrintSetup
78940>>>>>>>        Boolean bOk
78940>>>>>>>        Get DFPrintSetupDialog to bOk
78941>>>>>>>    End_Procedure
78942>>>>>>>
78942>>>>>>>    //*** This invokes the print job dialog, prints the report, then clears the report document.
78942>>>>>>>    //    This should be called after the report is complete.
78942>>>>>>>    Procedure DFPrint
78944>>>>>>>        Integer bOk
78944>>>>>>>        Get DFPrintDialog To bOk
78945>>>>>>>        If bOk Begin
78947>>>>>>>            Send DFPrintDoc
78948>>>>>>>            Send DFClearDoc
78949>>>>>>>        End
78949>>>>>>>>
78949>>>>>>>    End_Procedure
78950>>>>>>>
78950>>>>>>>    Procedure DFSuspendGui boolean bSuspend
78952>>>>>>>        If (bSuspend<>pbIsSuspended(self)) begin
78954>>>>>>>            Send SuspendGui of Desktop bSuspend
78955>>>>>>>            Set pbIsSuspended to bSuspend
78956>>>>>>>        end
78956>>>>>>>>
78956>>>>>>>    end_procedure
78957>>>>>>>
78957>>>>>>>    // this is protected so that the queue is only pumped if the
78957>>>>>>>    // gui is suspended.
78957>>>>>>>    Procedure PumpMsgQueue
78959>>>>>>>        If (pbIsSuspended(self)) begin
78961>>>>>>>            Send PumpMsgQueue of desktop // permit painting
78962>>>>>>>        end
78962>>>>>>>>
78962>>>>>>>    end_procedure
78963>>>>>>>
78963>>>>>>>
78963>>>>>>>    //*** This does a modeless preview. This is what you'd want during
78963>>>>>>>    //    report generation and it may be what you want for report viewing.
78963>>>>>>>    Procedure DFPreviewNoWait
78965>>>>>>>        Boolean bOk
78965>>>>>>>        Boolean bPrntDlg bPrintSetup bPrint
78965>>>>>>>        integer iStatus
78965>>>>>>>        Get PrintDlgInPreview to bPrntDlg
78966>>>>>>>        Get EnablePrintSetupFromPreview to bPrintSetup
78967>>>>>>>        Get EnablePrintFromPreview to bPrint
78968>>>>>>>        Get DocumentStatus to iStatus
78969>>>>>>>        If (iStatus=dsStarted) begin
78971>>>>>>>            Send DfSuspendGui True
78972>>>>>>>        end
78972>>>>>>>>
78972>>>>>>>        Move (WP_PreviewDocument(bPrntDlg,bPrintSetup,bPrint)) To bOk
78973>>>>>>>        If not bOk Begin
78975>>>>>>>            Error DFERR_WINPRINT DFPrintError901
78976>>>>>>>>
78976>>>>>>>            Send DfSuspendGui False
78977>>>>>>>        End
78977>>>>>>>>
78977>>>>>>>    End_Procedure
78978>>>>>>>
78978>>>>>>>
78978>>>>>>>    //*** This does a modal preview. You might want this for report
78978>>>>>>>    //    viewing as the program knows when the viewer is closed
78978>>>>>>>    // Note that this is a private message and it was never intended that this
78978>>>>>>>    // should be used. We expect winprint reports to use modeless viewers.
78978>>>>>>>    Procedure DFPreviewWait
78980>>>>>>>        Handle hViewerProcess
78980>>>>>>>        Boolean bPrntDlg bPrintSetup bPrint
78980>>>>>>>        Integer iRetVal
78980>>>>>>>        Integer hwMain hMain
78980>>>>>>>
78980>>>>>>>        Get PrintDlgInPreview to bPrntDlg
78981>>>>>>>        Get EnablePrintSetupFromPreview to bPrintSetup
78982>>>>>>>        Get EnablePrintFromPreview to bPrint
78983>>>>>>>
78983>>>>>>>        Send DfSuspendGui True
78984>>>>>>>        Move (WP_PreviewDocument(bPrntDlg,bPrintSetup,bPrint)) To hViewerProcess
78985>>>>>>>
78985>>>>>>>        If (hViewerProcess = 0) Begin
78987>>>>>>>            Error DFERR_WINPRINT DFPrintError901
78988>>>>>>>>
78988>>>>>>>        End
78988>>>>>>>>
78988>>>>>>>        Else Begin
78989>>>>>>>            // We need to wait for either the Viewer to close, or a WM_PAINT message in the thread's queue...
78989>>>>>>>            Repeat
78989>>>>>>>>
78989>>>>>>>               Move (MsgWaitForMultipleObjects(1, AddressOf(hViewerProcess), False, INFINITE, QS_PAINT)) To iRetVal
78990>>>>>>>               Send PumpMsgQueue // permit painting
78991>>>>>>>            Until (iRetVal = 0) // 0 means that the viewer process terminated
78993>>>>>>>        end
78993>>>>>>>>
78993>>>>>>>        Send DfSuspendGui False
78994>>>>>>>
78994>>>>>>>       // Do what we can to force VDF application to the top.
78994>>>>>>>       // As 12.0 dfSuspendGUI actually properly disables the underlying windows. When the viewer
78994>>>>>>>       // is closed it cannot give the focus back to this so it goes elsewhere. This will force it
78994>>>>>>>       // back. 
78994>>>>>>>
78994>>>>>>>       Get main_window of desktop to hMain
78995>>>>>>>       If hMain Begin
78997>>>>>>>          Get window_handle of hMain to hwMain
78998>>>>>>>          If hwMain Begin
79000>>>>>>>              If (GetForegroundWindow()<>hwMain) Begin
79002>>>>>>>                  Move (SetForegroundWindow(hwMain)) to hwMain
79003>>>>>>>              End
79003>>>>>>>>
79003>>>>>>>          End
79003>>>>>>>>
79003>>>>>>>       End
79003>>>>>>>>
79003>>>>>>>
79003>>>>>>>    End_Procedure
79004>>>>>>>
79004>>>>>>>    Procedure DfPreview
79006>>>>>>>        send DfPreviewNoWait
79007>>>>>>>    end_procedure
79008>>>>>>>
79008>>>>>>>
79008>>>>>>>    //***
79008>>>>>>>    Procedure DFPrintDoc
79010>>>>>>>        Handle hwnd
79010>>>>>>>        Boolean bOk
79010>>>>>>>        Get Report_Window_Handle to hWnd
79011>>>>>>>        Move (WP_PrintDocument(hwnd)) To bOk
79012>>>>>>>
79012>>>>>>>        If not bOk Begin
79014>>>>>>>            Error DFERR_WINPRINT DFPrintError902
79015>>>>>>>>
79015>>>>>>>        End
79015>>>>>>>>
79015>>>>>>>    End_Procedure
79016>>>>>>>
79016>>>>>>>
79016>>>>>>>    //***
79016>>>>>>>    Procedure DFClearDoc
79018>>>>>>>        Boolean bOk
79018>>>>>>>        Get ArePrintersInstalled to bOk
79019>>>>>>>        If bOk begin
79021>>>>>>>            Move (WP_ClearDocument()) To bOk
79022>>>>>>>            Send DFSuspendGUI False
79023>>>>>>>            If not bOk Begin
79025>>>>>>>               Error DFERR_WINPRINT DFPrintError903 // error number right?
79026>>>>>>>>
79026>>>>>>>            End
79026>>>>>>>>
79026>>>>>>>        End
79026>>>>>>>>
79026>>>>>>>    End_Procedure
79027>>>>>>>
79027>>>>>>>    Procedure DFNewDoc Boolean bAutoPreview
79029>>>>>>>        Boolean bOk
79029>>>>>>>        // this is the most likely place we will encounter when we start a report. Check for
79029>>>>>>>        // printers and return an explicit error to make it easy to identify the error
79029>>>>>>>        Get ArePrintersInstalled to bOk
79030>>>>>>>        If not bOk begin
79032>>>>>>>            Error DFERR_WINPRINT C_$NoInstalledPrinters
79033>>>>>>>>
79033>>>>>>>        end
79033>>>>>>>>
79033>>>>>>>        else begin
79034>>>>>>>            Send DfClearDoc //JJT - a new doc should always start with a clear
79035>>>>>>>            If bAutoPreview Send DFSuspendGUI True
79038>>>>>>>            Move (WP_NewDocument(bAutoPreview)) To bOk
79039>>>>>>>
79039>>>>>>>            If not bOk Begin
79041>>>>>>>               Error DFERR_WINPRINT DFPrintError902  // could not print document
79042>>>>>>>>
79042>>>>>>>               Send DFSuspendGUI False
79043>>>>>>>            End
79043>>>>>>>>
79043>>>>>>>        end
79043>>>>>>>>
79043>>>>>>>    End_Procedure
79044>>>>>>>
79044>>>>>>>    //***
79044>>>>>>>    Procedure DFSetFont String sFontName
79046>>>>>>>        boolean bOk
79046>>>>>>>        Move (WP_SetFontName(sFontName)) To bOk
79047>>>>>>>
79047>>>>>>>        If not bOK Begin
79049>>>>>>>            Error DFERR_WINPRINT DFPrintError904
79050>>>>>>>>
79050>>>>>>>        End
79050>>>>>>>>
79050>>>>>>>    End_Procedure
79051>>>>>>>
79051>>>>>>>
79051>>>>>>>    //***
79051>>>>>>>    Procedure DFSetFontSize Integer iHeight Integer iWidth
79053>>>>>>>        boolean bOk
79053>>>>>>>        // note that width is ignored in new implementation
79053>>>>>>>        Move (WP_SetFontHeight(iHeight)) To bOk
79054>>>>>>>
79054>>>>>>>        If not bOK Begin
79056>>>>>>>            Error DFERR_WINPRINT  DFPrintError905
79057>>>>>>>>
79057>>>>>>>        End
79057>>>>>>>>
79057>>>>>>>    End_Procedure
79058>>>>>>>
79058>>>>>>>
79058>>>>>>>    //***
79058>>>>>>>    Procedure DFSetFontStyle DWORD dwStyle
79060>>>>>>>        boolean bOk
79060>>>>>>>        Move (WP_SetFontStyle(dwStyle)) To bOk
79061>>>>>>>
79061>>>>>>>        If not bOK Begin
79063>>>>>>>            Error DFERR_WINPRINT DFPrintError906
79064>>>>>>>>
79064>>>>>>>        End
79064>>>>>>>>
79064>>>>>>>    End_Procedure
79065>>>>>>>
79065>>>>>>>
79065>>>>>>>    //***
79065>>>>>>>    Procedure DFSetUnderline boolean bUnderline
79067>>>>>>>        boolean bOk
79067>>>>>>>
79067>>>>>>>        Move (WP_SetFontUnderline(bUnderline)) To bOk
79068>>>>>>>
79068>>>>>>>        If not bOK Begin
79070>>>>>>>            Error DFERR_WINPRINT DFPrintError907
79071>>>>>>>>
79071>>>>>>>        End
79071>>>>>>>>
79071>>>>>>>    End_Procedure
79072>>>>>>>
79072>>>>>>>
79072>>>>>>>    //***
79072>>>>>>>    Procedure DFSetBold Boolean bBold
79074>>>>>>>        Boolean bOk
79074>>>>>>>
79074>>>>>>>        Move (WP_SetFontBold(bBold)) To bOk
79075>>>>>>>
79075>>>>>>>        If not bOK Begin
79077>>>>>>>            Error DFERR_WINPRINT DFPrintError908
79078>>>>>>>>
79078>>>>>>>        End
79078>>>>>>>>
79078>>>>>>>    End_Procedure
79079>>>>>>>
79079>>>>>>>
79079>>>>>>>    //***
79079>>>>>>>    Procedure DFSetItalic Boolean bItalic
79081>>>>>>>        Boolean bOk
79081>>>>>>>
79081>>>>>>>        Move (WP_SetFontItalic(bItalic)) To bOk
79082>>>>>>>
79082>>>>>>>        If not bOK Begin
79084>>>>>>>            Error DFERR_WINPRINT DFPrintError909
79085>>>>>>>>
79085>>>>>>>        End
79085>>>>>>>>
79085>>>>>>>    End_Procedure
79086>>>>>>>
79086>>>>>>>
79086>>>>>>>    //***
79086>>>>>>>    Procedure DFSetStrikeout Boolean bStrikeout
79088>>>>>>>        Boolean bOk
79088>>>>>>>
79088>>>>>>>        Move (WP_SetFontStrikeout(bStrikeout)) To bOk
79089>>>>>>>
79089>>>>>>>        If not bOK Begin
79091>>>>>>>            Error DFERR_WINPRINT DFPrintError910
79092>>>>>>>>
79092>>>>>>>        End
79092>>>>>>>>
79092>>>>>>>    End_Procedure
79093>>>>>>>
79093>>>>>>>
79093>>>>>>>    //***
79093>>>>>>>    Procedure DFSetMargins Number nLeft Number nTop Number nRight Number nBottom
79095>>>>>>>        Boolean bOk
79095>>>>>>>        integer iLeft iRight iTop iBottom
79095>>>>>>>
79095>>>>>>>        Move (nLeft   * 100) to iLeft
79096>>>>>>>        Move (nRight  * 100) to iRight
79097>>>>>>>        Move (nTop    * 100) to iTop
79098>>>>>>>        Move (nBottom * 100) to iBottom
79099>>>>>>>
79099>>>>>>>        Move (WP_SetMargins(iLeft,iTop,iRight,iBottom)) To bOk
79100>>>>>>>
79100>>>>>>>        If bOk Begin
79102>>>>>>>            Set DFLeft_Margin   To nLeft
79103>>>>>>>            Set DFTop_Margin    To nTop
79104>>>>>>>            Set DFRight_Margin  To nRight
79105>>>>>>>            Set DFBottom_Margin To nBottom
79106>>>>>>>        End
79106>>>>>>>>
79106>>>>>>>        Else Begin
79107>>>>>>>            Error DFERR_WINPRINT DFPrintError911
79108>>>>>>>>
79108>>>>>>>        End
79108>>>>>>>>
79108>>>>>>>    End_Procedure
79109>>>>>>>
79109>>>>>>>
79109>>>>>>>    //***
79109>>>>>>>    Procedure DFSetLeftMargin Number nLeft
79111>>>>>>>        number  nTop nRight nBottom
79111>>>>>>>        Get DFTop_Margin    To nTop
79112>>>>>>>        Get DFRight_Margin  To nRight
79113>>>>>>>        Get DFBottom_Margin To nBottom
79114>>>>>>>        Send DFSetMargins nLeft nTop nRight nBottom
79115>>>>>>>    End_Procedure
79116>>>>>>>
79116>>>>>>>
79116>>>>>>>    //***
79116>>>>>>>    Procedure DFSetRightMargin Number nRight
79118>>>>>>>        number  nLeft nTop nBottom
79118>>>>>>>        Get DFLeft_Margin   To nLeft
79119>>>>>>>        Get DFTop_Margin    To nTop
79120>>>>>>>        Get DFBottom_Margin To nBottom
79121>>>>>>>        Send DFSetMargins nLeft nTop nRight nBottom
79122>>>>>>>    End_Procedure
79123>>>>>>>
79123>>>>>>>
79123>>>>>>>    //***
79123>>>>>>>    Procedure DFSetTopMargin Number nTop
79125>>>>>>>        number  nLeft nRight nBottom
79125>>>>>>>        Get DFLeft_Margin   To nLeft
79126>>>>>>>        Get DFRight_Margin  To nRight
79127>>>>>>>        Get DFBottom_Margin To nBottom
79128>>>>>>>        Send DFSetMargins nLeft nTop nRight nBottom
79129>>>>>>>    End_Procedure
79130>>>>>>>
79130>>>>>>>
79130>>>>>>>    //***
79130>>>>>>>    Procedure DFSetBottomMargin Number nBottom
79132>>>>>>>        number  nLeft nTop nRight
79132>>>>>>>        Get DFLeft_Margin   To nLeft
79133>>>>>>>        Get DFTop_Margin    To nTop
79134>>>>>>>        Get DFRight_Margin  To nRight
79135>>>>>>>        Send DFSetMargins nLeft nTop nRight nBottom
79136>>>>>>>    End_Procedure
79137>>>>>>>
79137>>>>>>>
79137>>>>>>>    //***
79137>>>>>>>    Procedure DFWriteText String sText Integer iStyle Integer iColumn Integer iDecimal Boolean bNewLineAfterPrint
79139>>>>>>>        Boolean bOk
79139>>>>>>>
79139>>>>>>>        Send DFSetFontStyle iStyle
79140>>>>>>>        Get ToAnsi sText To sText
79141>>>>>>>        Move (WP_WriteText(sText,bNewLineAfterPrint,iColumn,iDecimal,0)) To bOk
79142>>>>>>>        If not bOk Begin
79144>>>>>>>            Error DFERR_WINPRINT DFPrintError918
79145>>>>>>>>
79145>>>>>>>        End
79145>>>>>>>>
79145>>>>>>>        Send PumpMsgQueue // permit painting //JJT!!!!!!!!!!!
79146>>>>>>>    End_Procedure
79147>>>>>>>
79147>>>>>>>    //***
79147>>>>>>>    Procedure DFWrite String sText DWORD iStyle Integer iColumn Integer iDecimal Boolean bTrim
79149>>>>>>>        If (Num_Arguments>=5 and bTrim) Begin
79151>>>>>>>            Move (Rtrim(sText)) to sText
79152>>>>>>>        end
79152>>>>>>>>
79152>>>>>>>        Send DFWriteText sText iStyle iColumn iDecimal False
79153>>>>>>>    End_Procedure
79154>>>>>>>
79154>>>>>>>    //***
79154>>>>>>>    Procedure DFWriteLn String sText DWORD iStyle Integer iColumn Integer iDecimal Boolean bTrim
79156>>>>>>>        If (Num_Arguments>=5 and bTrim) Begin
79158>>>>>>>            Move (Rtrim(sText)) to sText
79159>>>>>>>        end
79159>>>>>>>>
79159>>>>>>>        Send DFWriteText sText iStyle iColumn iDecimal True
79160>>>>>>>    End_Procedure
79161>>>>>>>
79161>>>>>>>
79161>>>>>>>    //***
79161>>>>>>>    Procedure DFWriteTextAtPosition String sText integer iStyle Number nPosition Integer iDecimal ;                                    Number nMaxLength Boolean bNewLineAfterPrint
79163>>>>>>>        Boolean bOk
79163>>>>>>>        Integer iPosition iMaxLength
79163>>>>>>>        Send DFSetFontStyle iStyle
79164>>>>>>>        Get ToAnsi sText To sText
79165>>>>>>>        Move (nPosition * 100) to iPosition
79166>>>>>>>        Move (nMaxLength * 100) to iMaxLength
79167>>>>>>>        Move (WP_WriteTextAtPosition(sText,bNewLineAfterPrint,iPosition,iDecimal,iMaxLength)) To bOk
79168>>>>>>>        If not bOk Begin
79170>>>>>>>            Error DFERR_WINPRINT DFPrintError922
79171>>>>>>>>
79171>>>>>>>        End
79171>>>>>>>>
79171>>>>>>>         Send PumpMsgQueue // permit painting //JJT!!!!!!!!!!!
79172>>>>>>>    End_Procedure
79173>>>>>>>
79173>>>>>>>    //***
79173>>>>>>>    Procedure DFWritePos String sText integer iStyle Number nPosition Integer iDecimal Number nMaxLength boolean bTrim
79175>>>>>>>        Number nMax
79175>>>>>>>        If (Num_Arguments>=6 and bTrim) Begin
79177>>>>>>>            Move (Rtrim(sText)) to sText
79178>>>>>>>        end
79178>>>>>>>>
79178>>>>>>>
79178>>>>>>>        If (Num_Arguments<5) ;            Move 0 to nMax
79181>>>>>>>        Else ;            Move nMaxLength to nMax
79183>>>>>>>        Send DFWriteTextAtPosition sText iStyle nPosition iDecimal nMax False
79184>>>>>>>    End_Procedure
79185>>>>>>>
79185>>>>>>>    //***
79185>>>>>>>    Procedure DFWriteLnPos String sText integer iStyle Number nPosition Integer iDecimal Number nMaxLength boolean bTrim
79187>>>>>>>        Number nMax
79187>>>>>>>        If (Num_Arguments>=6 and bTrim) Begin
79189>>>>>>>            Move (Rtrim(sText)) to sText
79190>>>>>>>        end
79190>>>>>>>>
79190>>>>>>>
79190>>>>>>>        If (Num_Arguments<5) ;            Move 0 to nMax
79193>>>>>>>        Else ;            Move nMaxLength to nMax
79195>>>>>>>        Send DFWriteTextAtPosition sText iStyle nPosition iDecimal nMax True
79196>>>>>>>    End_Procedure
79197>>>>>>>
79197>>>>>>>    Procedure DFSetMetrics String sMetrics
79199>>>>>>>        integer eMetrics
79199>>>>>>>        // for backwards compatibility support both string names and integer enumerations
79199>>>>>>>        // it is better to use the enumeration value
79199>>>>>>>        If (sMetrics="INCH" or sMetrics="CM") Begin
79201>>>>>>>            Set DFCurrent_Metrics to sMetrics
79202>>>>>>>        end
79202>>>>>>>>
79202>>>>>>>        else Begin
79203>>>>>>>            Move sMetrics to eMetrics
79204>>>>>>>            Move (WP_SetMetrics(eMetrics)) To eMetrics
79205>>>>>>>        End
79205>>>>>>>>
79205>>>>>>>    End_Procedure
79206>>>>>>>
79206>>>>>>>    Function DFGetMetrics Returns Integer
79208>>>>>>>        Integer eMetrics
79208>>>>>>>        Move (WP_GetMetrics()) To eMetrics
79209>>>>>>>        Function_return eMetrics
79210>>>>>>>    End_Function
79211>>>>>>>
79211>>>>>>>
79211>>>>>>>    //**** Properties Maintained for compatibility with old Winprint (obsolete)
79211>>>>>>>    Function DFCurrent_Metrics returns string
79213>>>>>>>        Integer eMetrics
79213>>>>>>>        Get DFGetMetrics to eMetrics
79214>>>>>>>        Function_return (if(eMetrics=WPM_INCH,"INCH","CM"))
79215>>>>>>>    end_function
79216>>>>>>>
79216>>>>>>>    Procedure Set DFCurrent_Metrics string sCMorINCH
79218>>>>>>>        Send DFSetMetrics (if(sCMorINCH="INCH", WPM_INCH, WPM_CM))
79219>>>>>>>    End_Procedure
79220>>>>>>>
79220>>>>>>>
79220>>>>>>>
79220>>>>>>>
79220>>>>>>>
79220>>>>>>>    //***
79220>>>>>>>    Procedure DFBeginHeaderType Integer iHeaderNr Integer eHeaderType
79222>>>>>>>        Boolean bOk
79222>>>>>>>
79222>>>>>>>        If (eHeaderType=DFSubHeader or eHeaderType=DFSubTotal) Begin
79224>>>>>>>            //*** Do nothing for the moment
79224>>>>>>>        End
79224>>>>>>>>
79224>>>>>>>        Else ;            Move 0 to iHeaderNr // If the user made a mistake
79226>>>>>>>
79226>>>>>>>        Set DFCurrent_HeaderType To eHeaderType
79227>>>>>>>        Set DFCurrent_HeaderNr   To iHeaderNr
79228>>>>>>>
79228>>>>>>>        Move (WP_BeginHeader(eHeaderType, iHeaderNr)) To bOk
79229>>>>>>>
79229>>>>>>>        If not bOk Begin
79231>>>>>>>            Error DFERR_WINPRINT DFPrintError925
79232>>>>>>>>
79232>>>>>>>        End
79232>>>>>>>>
79232>>>>>>>    End_Procedure
79233>>>>>>>
79233>>>>>>>
79233>>>>>>>    //***
79233>>>>>>>    Procedure DFEndHeaderType
79235>>>>>>>        Boolean bOk
79235>>>>>>>
79235>>>>>>>        Move (WP_EndHeader()) To bOk
79236>>>>>>>
79236>>>>>>>        if not bOk begin
79238>>>>>>>            Error DFERR_WINPRINT DFPrintError926
79239>>>>>>>>
79239>>>>>>>        End
79239>>>>>>>>
79239>>>>>>>    End_Procedure
79240>>>>>>>
79240>>>>>>>
79240>>>>>>>    //***
79240>>>>>>>    Procedure DFWriteHeaderType Integer iHeaderNr Integer eHeaderType
79242>>>>>>>        Boolean bOk
79242>>>>>>>        Move (WP_WriteHeader(eHeaderType, iHeaderNr)) To bOk
79243>>>>>>>        if not bOk begin
79245>>>>>>>            Error DFERR_WINPRINT DFPrintError927
79246>>>>>>>>
79246>>>>>>>        End
79246>>>>>>>>
79246>>>>>>>    End_Procedure
79247>>>>>>>
79247>>>>>>>
79247>>>>>>>    //***
79247>>>>>>>    Procedure DFHeaderPosition Integer ePlace
79249>>>>>>>        Boolean bOk
79249>>>>>>>
79249>>>>>>>         Move (WP_SetHeaderPlacement(ePlace)) To bOk
79250>>>>>>>
79250>>>>>>>         if not bOk begin
79252>>>>>>>            Error DFERR_WINPRINT DFPrintError929
79253>>>>>>>>
79253>>>>>>>        End
79253>>>>>>>>
79253>>>>>>>    End_Procedure
79254>>>>>>>
79254>>>>>>>
79254>>>>>>>    //***
79254>>>>>>>    Procedure DFHeaderFrameType Integer eFrame integer iColor Number nWeight;                                Integer iFillColor Boolean bFillFrame
79256>>>>>>>        Integer iWeight
79256>>>>>>>        Boolean bOk
79256>>>>>>>
79256>>>>>>>        move (nWeight*100) To iWeight
79257>>>>>>>
79257>>>>>>>        Move (WP_SetHeaderFrame(eFrame,iColor,iWeight,iFillColor,bFillFrame)) To bOk
79258>>>>>>>
79258>>>>>>>         if not bOk begin
79260>>>>>>>            Error DFERR_WINPRINT DFPrintError930
79261>>>>>>>>
79261>>>>>>>        End
79261>>>>>>>>
79261>>>>>>>    End_Procedure
79262>>>>>>>
79262>>>>>>>  Procedure DFHeaderMargin Integer eType Number nSize
79264>>>>>>>        Boolean bOk
79264>>>>>>>        Integer iSize
79264>>>>>>>
79264>>>>>>>        move (nSize * 100) to iSize
79265>>>>>>>
79265>>>>>>>        move (WP_SetHeaderMargin(eType, iSize)) To bOk
79266>>>>>>>
79266>>>>>>>        if not bOk begin
79268>>>>>>>            Error DFERR_WINPRINT DFPrintError930
79269>>>>>>>>
79269>>>>>>>        end
79269>>>>>>>>
79269>>>>>>>    End_Procedure
79270>>>>>>>
79270>>>>>>>
79270>>>>>>>    //***
79270>>>>>>>    Procedure DFHeaderWrap Integer eOnOff
79272>>>>>>>         Boolean bOk
79272>>>>>>>
79272>>>>>>>         Move (WP_SetHeaderWrap(eOnOff)) To bOk
79273>>>>>>>
79273>>>>>>>         if not bOk begin
79275>>>>>>>            Error DFERR_WINPRINT DFPrintError931
79276>>>>>>>>
79276>>>>>>>        End
79276>>>>>>>>
79276>>>>>>>    End_Procedure
79277>>>>>>>
79277>>>>>>>    //***
79277>>>>>>>    Procedure DFWriteBMP String sFileName Number nStartX Number nStartY Number nHeight Number nWidth Boolean bUCp
79279>>>>>>>        Boolean bOk
79279>>>>>>>        Integer iStartX iStartY iHeight iWidth
79279>>>>>>>
79279>>>>>>>        If ((nStartX = -998) or (nStartX = -999));            move nStartX to iStartX
79282>>>>>>>        else ;            move (nStartX*100) To iStartX
79284>>>>>>>
79284>>>>>>>        If ((nStartY = -998) or (nStartY = -999));            move nStartY to iStartY
79287>>>>>>>        else ;            move (nStartY*100) To iStartY
79289>>>>>>>
79289>>>>>>>        If ((nWidth = -998) or (nWidth = -999));            move nWidth To iWidth
79292>>>>>>>        else ;            move (nWidth*100) To iWidth
79294>>>>>>>
79294>>>>>>>        If ((nHeight = -998) or (nHeight = -999));            move nHeight To iHeight
79297>>>>>>>        else ;            move (nHeight*100) To iHeight
79299>>>>>>>
79299>>>>>>>        Get_File_Path sFileName To sFileName
79300>>>>>>>        Move (WP_DrawBitmap(sFileName,iStartX,iStartY,iWidth,iHeight,bUCp)) to bOk
79301>>>>>>>
79301>>>>>>>        If not bOk Begin
79303>>>>>>>            Error DFERR_WINPRINT DFPrintError932
79304>>>>>>>>
79304>>>>>>>        End
79304>>>>>>>>
79304>>>>>>>    End_Procedure
79305>>>>>>>
79305>>>>>>>
79305>>>>>>>    //***
79305>>>>>>>    Procedure DFHeaderLineCheck Integer iLines
79307>>>>>>>        Boolean bOk
79307>>>>>>>
79307>>>>>>>         Move (WP_SetExtraLineCheck(iLines)) To bOk
79308>>>>>>>
79308>>>>>>>        If not bOk begin
79310>>>>>>>            Error DFERR_WINPRINT DFPrintError934
79311>>>>>>>>
79311>>>>>>>        End
79311>>>>>>>>
79311>>>>>>>    End_Procedure
79312>>>>>>>
79312>>>>>>>
79312>>>>>>>    //***
79312>>>>>>>    Procedure DFPrintFlags Integer Flags
79314>>>>>>>        Boolean bOk
79314>>>>>>>
79314>>>>>>>         Move (WP_SetPrintDialogFlags(Flags)) To bOk
79315>>>>>>>
79315>>>>>>>        If not bOk begin
79317>>>>>>>            Error DFERR_WINPRINT DFPrintError935
79318>>>>>>>>
79318>>>>>>>        End
79318>>>>>>>>
79318>>>>>>>    End_Procedure
79319>>>>>>>
79319>>>>>>>
79319>>>>>>>    //*** obsolete and maintained for winprint-I backwards compatibility (maybe should be removed)
79319>>>>>>>    //
79319>>>>>>>    Procedure DFSelectPrinter String sDriver String sDevice String sPort Boolean bUpdate
79321>>>>>>>        Send DFSetDevice sDevice
79322>>>>>>>    End_Procedure
79323>>>>>>>
79323>>>>>>>    //*** Preferred usage for WinprintII
79323>>>>>>>    Procedure DFSetDevice String sDevice
79325>>>>>>>        Boolean bOk
79325>>>>>>>
79325>>>>>>>        Move (WP_SelectPrinter(sDevice)) To bOk
79326>>>>>>>
79326>>>>>>>        If not bOk Begin
79328>>>>>>>            Error DFERR_WINPRINT DFPrintError936
79329>>>>>>>>
79329>>>>>>>        End
79329>>>>>>>>
79329>>>>>>>    End_Procedure
79330>>>>>>>
79330>>>>>>>    Procedure DFPrinterBinFirstPage Integer eBin
79332>>>>>>>        Boolean bOk
79332>>>>>>>
79332>>>>>>>         Move (WP_SetFirstPagePaperSource(eBin)) To bOk
79333>>>>>>>
79333>>>>>>>        If not bOk Begin
79335>>>>>>>            Error DFERR_WINPRINT DFPrintError937
79336>>>>>>>>
79336>>>>>>>        End
79336>>>>>>>>
79336>>>>>>>    End_Procedure
79337>>>>>>>
79337>>>>>>>
79337>>>>>>>    //***
79337>>>>>>>    Function DFGetDFColor Integer iRed Integer iGreen Integer iBlue Returns Integer
79339>>>>>>>        Integer iColor
79339>>>>>>>
79339>>>>>>>         Move (WP_RGBToDFPrintColor(iRed,iGreen,iBlue)) To iColor
79340>>>>>>>
79340>>>>>>>        If (iColor=0) Begin
79342>>>>>>>            Error DFERR_WINPRINT DFPrintError938
79343>>>>>>>>
79343>>>>>>>        End
79343>>>>>>>>
79343>>>>>>>        Function_Return iColor
79344>>>>>>>    End_Function
79345>>>>>>>
79345>>>>>>>
79345>>>>>>>    //***
79345>>>>>>>    Procedure DFSetDFColor Dword dwColor
79347>>>>>>>        Integer bOk
79347>>>>>>>
79347>>>>>>>         Move (WP_SetFontColor(dwColor)) To bOk
79348>>>>>>>
79348>>>>>>>        If not bOk Begin
79350>>>>>>>            Error DFERR_WINPRINT DFPrintError939
79351>>>>>>>>
79351>>>>>>>        End
79351>>>>>>>>
79351>>>>>>>    End_Procedure
79352>>>>>>>
79352>>>>>>>
79352>>>>>>>    //***
79352>>>>>>>    Procedure DFSetTopBottom Number nTop Number nBottom Boolean bAllPages
79354>>>>>>>        Boolean bOk
79354>>>>>>>        Integer iTop iBottom
79354>>>>>>>
79354>>>>>>>        move (nTop*100)    To iTop
79355>>>>>>>        move (nBottom*100) To iBottom
79356>>>>>>>
79356>>>>>>>        Move (WP_SetAbsoluteMargins(iTop,iBottom,bAllPages)) To bOk
79357>>>>>>>
79357>>>>>>>        If Not bOk Begin
79359>>>>>>>            Error DFERR_WINPRINT DFPrintError940
79360>>>>>>>>
79360>>>>>>>        End
79360>>>>>>>>
79360>>>>>>>    End_Procedure
79361>>>>>>>
79361>>>>>>>
79361>>>>>>>    //***
79361>>>>>>>    Procedure DFSetJMode Integer eAlign
79363>>>>>>>        Boolean bOk
79363>>>>>>>
79363>>>>>>>        Move (WP_SetAlign(eAlign)) To bOk
79364>>>>>>>
79364>>>>>>>        If Not bOk Begin
79366>>>>>>>            Error DFERR_WINPRINT DFPrintError941
79367>>>>>>>>
79367>>>>>>>        End
79367>>>>>>>>
79367>>>>>>>    End_Procedure
79368>>>>>>>
79368>>>>>>>
79368>>>>>>>    //***
79368>>>>>>>    Procedure DFWriteEllip Number nStartX Number nStartY Number nHeight Number nWidth ;              Dword dwBColor Dword dwFColor Boolean bFill Number nWeight Boolean bWrap Boolean bUCp
79370>>>>>>>
79370>>>>>>>        Boolean bOk
79370>>>>>>>        Integer iWeight
79370>>>>>>>        Integer iStartX iStartY iHeight iWidth
79370>>>>>>>
79370>>>>>>>        If ((nStartX = -998) or (nStartX = -999));            move nStartX To iStartX
79373>>>>>>>        else ;            move (nStartX*100) To iStartX
79375>>>>>>>
79375>>>>>>>        If ((nStartY = -998) or (nStartY = -999));            move nStartY To iStartY
79378>>>>>>>        else ;            move (nStartY*100) To iStartY
79380>>>>>>>
79380>>>>>>>        If ((nWidth = -998) or (nWidth = -999));            move nWidth To iWidth
79383>>>>>>>        else ;            move (nWidth*100) To iWidth
79385>>>>>>>
79385>>>>>>>        If ((nHeight = -998) or (nHeight = -999));            move nHeight To iHeight
79388>>>>>>>        else ;            move (nHeight*100) To iHeight
79390>>>>>>>
79390>>>>>>>        move (nWeight*100) To iWeight
79391>>>>>>>
79391>>>>>>>
79391>>>>>>>        Move (WP_DrawEllipse(iStartX,iStartY,iWidth,iHeight,;                        dwBColor,dwFColor,bFill,iWeight,bUCp,bWrap)) To bOk
79392>>>>>>>
79392>>>>>>>        If Not bOk Begin
79394>>>>>>>            Error DFERR_WINPRINT DFPrintError942
79395>>>>>>>>
79395>>>>>>>        End
79395>>>>>>>>
79395>>>>>>>    End_Procedure
79396>>>>>>>
79396>>>>>>>
79396>>>>>>>
79396>>>>>>>
79396>>>>>>>    //***
79396>>>>>>>    Procedure DFWriteRect Number nStartX Number nStartY Number nHeight Number nWidth;              Dword dwBColor Dword dwFColor Boolean bFill Number nWeight Boolean bWrap Boolean bUCp
79398>>>>>>>
79398>>>>>>>        Boolean bOk
79398>>>>>>>        Integer iWeight
79398>>>>>>>        Integer iStartX iStartY iHeight iWidth
79398>>>>>>>
79398>>>>>>>        If ((nStartX = -998) or (nStartX = -999));            move nStartX To iStartX
79401>>>>>>>        else ;            move (nStartX*100) To iStartX
79403>>>>>>>
79403>>>>>>>        If ((nStartY = -998) or (nStartY = -999));            move nStartY To iStartY
79406>>>>>>>        else ;            move (nStartY*100) To iStartY
79408>>>>>>>
79408>>>>>>>        If ((nWidth = -998) or (nWidth = -999));            move nWidth To iWidth
79411>>>>>>>        else ;            move (nWidth*100) To iWidth
79413>>>>>>>
79413>>>>>>>        If ((nHeight = -998) or (nHeight = -999));            move nHeight To iHeight
79416>>>>>>>        else ;            move (nHeight*100) To iHeight
79418>>>>>>>
79418>>>>>>>        move (nWeight*100) To iWeight
79419>>>>>>>
79419>>>>>>>        Move (WP_DrawRectangle(iStartX,iStartY,iWidth,iHeight,;                            dwBColor,dwFColor,bFill,iWeight,bUCp,bWrap)) To bOk
79420>>>>>>>
79420>>>>>>>        If Not bOk Begin
79422>>>>>>>            Error DFERR_WINPRINT DFPrintError944
79423>>>>>>>>
79423>>>>>>>        End
79423>>>>>>>>
79423>>>>>>>    End_Procedure
79424>>>>>>>
79424>>>>>>>
79424>>>>>>>
79424>>>>>>>
79424>>>>>>>    //***
79424>>>>>>>    Procedure DFLineCheck Integer iLines
79426>>>>>>>        Boolean bOk
79426>>>>>>>
79426>>>>>>>        Move (WP_ConfirmLines(iLines)) To bOk
79427>>>>>>>
79427>>>>>>>        If Not bOk Begin
79429>>>>>>>            Error DFERR_WINPRINT DFPrintError946
79430>>>>>>>>
79430>>>>>>>        End
79430>>>>>>>>
79430>>>>>>>    End_Procedure
79431>>>>>>>
79431>>>>>>>
79431>>>>>>>    //***
79431>>>>>>>    Procedure DFCreateDiagram Integer eType Integer eFx Number nHeight Number nWidth Integer bXyAxis
79433>>>>>>>        Handle hDiagram
79433>>>>>>>        Integer iWidth iHeight
79433>>>>>>>
79433>>>>>>>        move (nHeight*100) To iHeight
79434>>>>>>>        move (nWidth*100)  To iWidth
79435>>>>>>>
79435>>>>>>>        Set DFCurrent_Color To 0
79436>>>>>>>
79436>>>>>>>        Move (WP_CreateDiagram(eType,eFx,iWidth,iHeight,bXyAxis)) To hDiagram
79437>>>>>>>
79437>>>>>>>        If (hDiagram) Begin
79439>>>>>>>            Error DFERR_WINPRINT DFPrintError947
79440>>>>>>>>
79440>>>>>>>        End
79440>>>>>>>>
79440>>>>>>>        Else Begin
79441>>>>>>>            Set DFCurrent_Diagram To hDiagram
79442>>>>>>>        end
79442>>>>>>>>
79442>>>>>>>    End_Procedure
79443>>>>>>>
79443>>>>>>>
79443>>>>>>>    //***
79443>>>>>>>    Procedure DFDiagram_Item handle hDiagram String sLabel Number nValue;                             Dword dwBColor Dword dwFColor Integer eFill;                             Integer iDec Integer eValueOrPercent Integer eExt
79445>>>>>>>
79445>>>>>>>        Boolean bOk
79445>>>>>>>        Integer iCurrColor iValue
79445>>>>>>>
79445>>>>>>>        If (dwFColor = -1) Begin
79447>>>>>>>            Get DFCurrent_Color To iCurrColor
79448>>>>>>>            Increment iCurrColor
79449>>>>>>>            If (iCurrColor>15) Move 1 To iCurrColor
79452>>>>>>>            Set DFCurrent_Color To iCurrColor
79453>>>>>>>            Get DFGetColor iCurrColor To dwFColor
79454>>>>>>>        End
79454>>>>>>>>
79454>>>>>>>
79454>>>>>>>        Move (nValue *100) to iValue
79455>>>>>>>
79455>>>>>>>        Get ToAnsi sLabel To sLabel
79456>>>>>>>
79456>>>>>>>        Move (WP_AddDiagramEntry(hDiagram,sLabel,iValue,dwBColor,dwFColor,eFill,iDec,eValueorPercent,eExt)) To bOk
79457>>>>>>>
79457>>>>>>>        If not bOk Begin
79459>>>>>>>            Error DFERR_WINPRINT DFPrintError948
79460>>>>>>>>
79460>>>>>>>        End
79460>>>>>>>>
79460>>>>>>>    End_Procedure
79461>>>>>>>
79461>>>>>>>
79461>>>>>>>    //***
79461>>>>>>>    Procedure DFLockDiagram Handle hDiagram
79463>>>>>>>        Boolean bOk
79463>>>>>>>
79463>>>>>>>        Move (WP_LockDiagram(hDiagram)) To bOk
79464>>>>>>>
79464>>>>>>>        If not bOk Begin
79466>>>>>>>            Error DFERR_WINPRINT DFPrintError949
79467>>>>>>>>
79467>>>>>>>        End
79467>>>>>>>>
79467>>>>>>>    End_Procedure
79468>>>>>>>
79468>>>>>>>
79468>>>>>>>
79468>>>>>>>    //***
79468>>>>>>>    Procedure DFDrawDiagram Handle hDiagram Number nYPos Number nXPos Boolean bUCp
79470>>>>>>>        Boolean bOk
79470>>>>>>>        Integer iXPos
79470>>>>>>>        Integer iYPos
79470>>>>>>>
79470>>>>>>>        move (nXPos*100) To iXPos
79471>>>>>>>        move (nYPos*100) To iYPos
79472>>>>>>>
79472>>>>>>>        If nYPos Eq -999 Move -999 To iYPos
79475>>>>>>>
79475>>>>>>>        Move (WP_DrawDiagram(hDiagram,iXPos,iYPos,bUCp)) To bOk
79476>>>>>>>
79476>>>>>>>        If not bOk Begin
79478>>>>>>>            Error DFERR_WINPRINT DFPrintError950
79479>>>>>>>>
79479>>>>>>>        End
79479>>>>>>>>
79479>>>>>>>    End_Procedure
79480>>>>>>>
79480>>>>>>>
79480>>>>>>>
79480>>>>>>>    //***
79480>>>>>>>    Procedure DFDiagramLabel handle hDiagram String sLabel
79482>>>>>>>        Boolean bOk
79482>>>>>>>        Integer iLabelLen
79482>>>>>>>
79482>>>>>>>        Get ToAnsi sLabel To sLabel
79483>>>>>>>
79483>>>>>>>        Move (WP_SetDiagramCaption(hDiagram,sLabel)) To bOk
79484>>>>>>>
79484>>>>>>>        if not bOk Begin
79486>>>>>>>            Error DFERR_WINPRINT DFPrintError952
79487>>>>>>>>
79487>>>>>>>        End
79487>>>>>>>>
79487>>>>>>>    End_Procedure
79488>>>>>>>
79488>>>>>>>
79488>>>>>>>    //***
79488>>>>>>>    Procedure DFDiagramXLabel handle hDiagram String sLabel
79490>>>>>>>        Boolean bOk
79490>>>>>>>        Get ToAnsi sLabel To sLabel
79491>>>>>>>
79491>>>>>>>        Move (WP_SetDiagramXText(hDiagram,sLabel)) To bOk
79492>>>>>>>
79492>>>>>>>        if not bOk Begin
79494>>>>>>>            Error DFERR_WINPRINT DFPrintError953
79495>>>>>>>>
79495>>>>>>>        End
79495>>>>>>>>
79495>>>>>>>    End_Procedure
79496>>>>>>>
79496>>>>>>>
79496>>>>>>>    //***
79496>>>>>>>    Procedure DFDiagramYLabel handle hDiagram String sLabel Boolean bVertical
79498>>>>>>>        Boolean bOk
79498>>>>>>>        Get ToAnsi sLabel To sLabel
79499>>>>>>>
79499>>>>>>>        Move (WP_SetDiagramYText(hDiagram,sLabel,bVertical)) To bOk
79500>>>>>>>
79500>>>>>>>        if not bOk Begin
79502>>>>>>>            Error DFERR_WINPRINT DFPrintError954
79503>>>>>>>>
79503>>>>>>>        End
79503>>>>>>>>
79503>>>>>>>    End_Procedure
79504>>>>>>>
79504>>>>>>>
79504>>>>>>>    //***
79504>>>>>>>    Procedure DFWriteXYLine Number nStartX Number nStartY Number nStopX Number nStopY;              Dword dwColor Number nWeight Boolean bWrap Boolean bUCp
79506>>>>>>>
79506>>>>>>>        Boolean bOk
79506>>>>>>>        Integer iStartX iStartY iStopX iStopY
79506>>>>>>>        Integer iWeight
79506>>>>>>>
79506>>>>>>>        move (nStartX*100)  To iStartX
79507>>>>>>>        move (nStartY*100)  To iStartY
79508>>>>>>>        move (nStopX*100)   To iStopX
79509>>>>>>>        move (nStopY*100)   To iStopY
79510>>>>>>>
79510>>>>>>>        move (nWeight*100) To iWeight
79511>>>>>>>
79511>>>>>>>        If (nStopY  = -998) Move -998 To iStopY
79514>>>>>>>        If (nStopX  = -998) Move -998 To iStopX
79517>>>>>>>
79517>>>>>>>        If (nStartY  = -999) Move -999 To iStartY
79520>>>>>>>        If (nStartX  = -999) Move -999 To iStartX
79523>>>>>>>
79523>>>>>>>        Move (WP_DrawXYLine(iStartX,iStartY,iStopX,iStopY,dwColor,iWeight,bUCp,bWrap)) To bOk
79524>>>>>>>
79524>>>>>>>        if not bOk Begin
79526>>>>>>>            Error DFERR_WINPRINT DFPrintError955
79527>>>>>>>>
79527>>>>>>>        End
79527>>>>>>>>
79527>>>>>>>    End_Procedure
79528>>>>>>>
79528>>>>>>>
79528>>>>>>>    //***
79528>>>>>>>    Procedure DFWriteLine Number nStartX Number nStartY Number nLength;                          Boolean bHorizontal Dword dwColor Number nWeight Boolean bUCp
79530>>>>>>>
79530>>>>>>>        Boolean bOk
79530>>>>>>>        Integer iStartX iStartY iLength
79530>>>>>>>        Integer iWeight
79530>>>>>>>
79530>>>>>>>        move (nStartX*100)  To iStartX
79531>>>>>>>        move (nStartY*100)  To iStartY
79532>>>>>>>        move (nLength*100)  To iLength
79533>>>>>>>        move (nWeight*100)  To iWeight
79534>>>>>>>
79534>>>>>>>        If (nStartY = -999) Move -999 To iStartY
79537>>>>>>>        If (nStartX = -999) Move -999 To iStartX
79540>>>>>>>        If (nLength = -998) Move -998 To iLength
79543>>>>>>>
79543>>>>>>>        Move (WP_DrawLine(iSTartX,iStartY,iLength,bHorizontal,dwColor,iWeight,bUCp)) To bOk
79544>>>>>>>
79544>>>>>>>        if not bOk Begin
79546>>>>>>>            Error DFERR_WINPRINT DFPrintError956
79547>>>>>>>>
79547>>>>>>>        End
79547>>>>>>>>
79547>>>>>>>    End_Procedure
79548>>>>>>>
79548>>>>>>>
79548>>>>>>>    //***
79548>>>>>>>    Procedure DFClearPrinter
79550>>>>>>>        Boolean bOk
79550>>>>>>>
79550>>>>>>>        Move (WP_ClearPrinter()) To bOk
79551>>>>>>>
79551>>>>>>>        If not bOk Begin
79553>>>>>>>            Error DFERR_WINPRINT DFPrintError957
79554>>>>>>>>
79554>>>>>>>        End
79554>>>>>>>>
79554>>>>>>>    End_Procedure
79555>>>>>>>
79555>>>>>>>
79555>>>>>>>
79555>>>>>>>    //***
79555>>>>>>>     Function DFGetCurrentDevice Returns String
79557>>>>>>>        Boolean bOk
79557>>>>>>>        String  sDFStr
79557>>>>>>>        Address pDFStr
79557>>>>>>>
79557>>>>>>>        Move (Repeat( Character(0), 255 )) to sDFStr
79558>>>>>>>        GetAddress of sDFStr to pDFStr
79559>>>>>>>
79559>>>>>>>        Move (WP_GetCurrentDevice(pDFStr)) To bOk
79560>>>>>>>
79560>>>>>>>        If not bOk Begin
79562>>>>>>>            Error DFERR_WINPRINT DFPrintError959
79563>>>>>>>>
79563>>>>>>>        End
79563>>>>>>>>
79563>>>>>>>
79563>>>>>>>        Move (CString(sDFStr)) To sDFStr
79564>>>>>>>        Function_Return sDFStr
79565>>>>>>>     End_Function
79566>>>>>>>
79566>>>>>>>
79566>>>>>>>    // Note: DfGetCurrentPort and DFGetCurrentDriver do not exist in winprint2. Trying to
79566>>>>>>>    //       use these will result in a runtime error (which is good - don't use them)
79566>>>>>>>
79566>>>>>>>
79566>>>>>>>    //***
79566>>>>>>>     Function DFGetPrintDialogFlags Returns Dword
79568>>>>>>>        Dword dwRetVal
79568>>>>>>>
79568>>>>>>>        Move (WP_GetPrintDialogFlags()) To dwRetVal
79569>>>>>>>
79569>>>>>>>        Function_Return dwRetVal
79570>>>>>>>     End_Function
79571>>>>>>>
79571>>>>>>>
79571>>>>>>>    //***
79571>>>>>>>    //*** Returns PRN_TRUE=  if the flag is set     (1)
79571>>>>>>>    //*** Returns PRN_FALSE= If the flag not is set (0)
79571>>>>>>>    //***
79571>>>>>>>     Function DFCheckPrintDialogFlag Dword dwPDFlag Returns Boolean
79573>>>>>>>        Boolean bIsSet
79573>>>>>>>
79573>>>>>>>        Move (WP_IsPrintDialogFlagSet(dwPDFlag)) To bIsSet
79574>>>>>>>
79574>>>>>>>        Function_Return bIsSet
79575>>>>>>>     End_Function
79576>>>>>>>
79576>>>>>>>
79576>>>>>>>    //***
79576>>>>>>>     Procedure DFSetSpecPrintFlag Dword dwPDFlag
79578>>>>>>>        Boolean bOk
79578>>>>>>>
79578>>>>>>>        Move (WP_SetSpecificPrintDialogFlag(dwPDFlag)) To bOk
79579>>>>>>>
79579>>>>>>>        If not bOk Begin
79581>>>>>>>            Error DFERR_WINPRINT DFPrintError961
79582>>>>>>>>
79582>>>>>>>        End
79582>>>>>>>>
79582>>>>>>>     End_Procedure
79583>>>>>>>
79583>>>>>>>
79583>>>>>>>    //***
79583>>>>>>>     Function DFGetUserDefinedLength Returns Number
79585>>>>>>>        Integer iRetVal
79585>>>>>>>        Number  nRetVal
79585>>>>>>>
79585>>>>>>>        Move (WP_GetUserDefinedPapersize()) To iRetVal
79586>>>>>>>
79586>>>>>>>        If (iRetVal=0) Begin
79588>>>>>>>            Error DFERR_WINPRINT DFPrintError962
79589>>>>>>>>
79589>>>>>>>            Function_Return 0
79590>>>>>>>        End
79590>>>>>>>>
79590>>>>>>>
79590>>>>>>>        Move (Hi(iRetVal)) To nRetVal
79591>>>>>>>        move (nRetVal/100) To nRetVal //Returns CM
79592>>>>>>>
79592>>>>>>>        Function_Return nRetVal
79593>>>>>>>     End_Function
79594>>>>>>>
79594>>>>>>>
79594>>>>>>>    //***
79594>>>>>>>     Function DFGetUserDefinedWidth Returns Number
79596>>>>>>>        Integer iRetVal
79596>>>>>>>        Number  nRetVal
79596>>>>>>>
79596>>>>>>>        Move (WP_GetUserDefinedPapersize()) To iRetVal
79597>>>>>>>
79597>>>>>>>        If (iRetVal=0) Begin
79599>>>>>>>            Error DFERR_WINPRINT DFPrintError963
79600>>>>>>>>
79600>>>>>>>            Function_Return 0
79601>>>>>>>        End
79601>>>>>>>>
79601>>>>>>>
79601>>>>>>>        Move (Low(iRetVal)) To nRetVal
79602>>>>>>>        Move (nRetVal/100) To nRetVal //Returns CM
79603>>>>>>>
79603>>>>>>>        Function_Return nRetVal
79604>>>>>>>     End_Function
79605>>>>>>>
79605>>>>>>>
79605>>>>>>>    //*** To be set in CM
79605>>>>>>>     Procedure DFSetUserDefinedPapersize Number nLength Number nWidth
79607>>>>>>>        Integer bOk
79607>>>>>>>        Integer iLength iWidth iSize
79607>>>>>>>
79607>>>>>>>        move (nLength*100) To iLength
79608>>>>>>>        move (nWidth*100)  To iWidth
79609>>>>>>>        move ((iLength*65536)+iWidth) To iSize
79610>>>>>>>
79610>>>>>>>        Move (WP_SetUserDefinedPapersize(iSize)) To bOk
79611>>>>>>>
79611>>>>>>>        If not bOk Begin
79613>>>>>>>            Error DFERR_WINPRINT DFPrintError964
79614>>>>>>>>
79614>>>>>>>        End
79614>>>>>>>>
79614>>>>>>>     End_Procedure
79615>>>>>>>
79615>>>>>>>     Procedure DFSetNumberOfCopies Integer iNrOfCopies
79617>>>>>>>        Boolean bOk
79617>>>>>>>
79617>>>>>>>        Move (WP_SetNumberOfPrintCopies(iNrOfCopies)) to bOk
79618>>>>>>>
79618>>>>>>>        If not bOk Begin
79620>>>>>>>            Error DFERR_WINPRINT DFPrintError965
79621>>>>>>>>
79621>>>>>>>        end
79621>>>>>>>>
79621>>>>>>>     End_Procedure
79622>>>>>>>
79622>>>>>>>
79622>>>>>>>
79622>>>>>>>
79622>>>>>>>    //*************************************************************
79622>>>>>>>    //*** This procedures and functions are used when building  ***
79622>>>>>>>    //*** complex graphics when you need to change value of the ***
79622>>>>>>>    //*** current diagram, so you can mix diagrams within each  ***
79622>>>>>>>    //*** other.                                                ***
79622>>>>>>>    //*************************************************************
79622>>>>>>>
79622>>>>>>>
79622>>>>>>>    Function DFGetCurrentDiagram Returns Integer
79624>>>>>>>        Integer iRetVal
79624>>>>>>>        Get DFCurrent_Diagram To iRetVal
79625>>>>>>>        Function_Return iRetVal
79626>>>>>>>    End_Function
79627>>>>>>>
79627>>>>>>>    Procedure DFSetCurrentDiagram Integer iDiagram
79629>>>>>>>        Set DFCurrent_Diagram To iDiagram
79630>>>>>>>    End_Procedure
79631>>>>>>>
79631>>>>>>>    Procedure DFSetDiagramList Integer iItem Integer iDiagram
79633>>>>>>>        Set Value of oDiagramArray iItem To iDiagram
79634>>>>>>>    End_Procedure
79635>>>>>>>
79635>>>>>>>    Function DFGetDiagramList Integer iItem Returns Integer
79637>>>>>>>        Integer iRetVal
79637>>>>>>>        Get Value of oDiagramArray iItem To iRetVal
79638>>>>>>>        Function_Return iRetVal
79639>>>>>>>    End_Function
79640>>>>>>>
79640>>>>>>>    Procedure DFClearDiagramList
79642>>>>>>>        Send Delete_Data To oDiagramArray
79643>>>>>>>    End_Procedure
79644>>>>>>>
79644>>>>>>>
79644>>>>>>>    Function DFGetColor Integer iColor Returns Dword
79646>>>>>>>        Dword   dwRetVal
79646>>>>>>>        Get Value of oDFColorArray iColor To dwRetVal
79647>>>>>>>        Function_Return dwRetVal
79648>>>>>>>    End_Function
79649>>>>>>>
79649>>>>>>>    Function DFGetCurrentColor Returns Dword
79651>>>>>>>        Dword   dwRetVal
79651>>>>>>>        Integer iCurrColor
79651>>>>>>>
79651>>>>>>>        Get DFCurrent_Color To iCurrColor
79652>>>>>>>        Get DFGetColor iCurrColor To dwRetVal
79653>>>>>>>
79653>>>>>>>        Function_Return dwRetVal
79654>>>>>>>    End_Function
79655>>>>>>>
79655>>>>>>>    Procedure DFEndDocument
79657>>>>>>>        integer iVoid
79657>>>>>>>        Move (WP_EndDocument()) To iVoid
79658>>>>>>>        Send DfSuspendGui False
79659>>>>>>>    End_procedure
79660>>>>>>>
79660>>>>>>>    Procedure DFClosePreview
79662>>>>>>>        integer iVoid
79662>>>>>>>        Move (WP_ClosePreview()) To iVoid
79663>>>>>>>        Send DfSuspendGui False
79664>>>>>>>    End_procedure
79665>>>>>>>
79665>>>>>>>    Procedure SetProgressCaption string sCaption
79667>>>>>>>        integer iVoid
79667>>>>>>>        Move (ToAnsi(sCaption)) to sCaption
79668>>>>>>>        Move (WP_SetProgressCaption(sCaption)) To iVoid
79669>>>>>>>    End_procedure
79670>>>>>>>
79670>>>>>>>    Procedure SetReportTitle string sTitle
79672>>>>>>>        integer iVoid
79672>>>>>>>        Move (ToAnsi(sTitle)) to sTitle
79673>>>>>>>        Move (WP_SetReportTitle(sTitle)) To iVoid
79674>>>>>>>    End_procedure
79675>>>>>>>
79675>>>>>>>    Function PreviewYesNoBox string sCaption string sText returns integer
79677>>>>>>>        integer eResult
79677>>>>>>>        Move (ToAnsi(sCaption)) to sCaption
79678>>>>>>>        Move (ToAnsi(sText))    to sText
79679>>>>>>>        Move (WP_DisplayMessageBox(sCaption, sText)) To eResult
79680>>>>>>>        Function_return eResult
79681>>>>>>>    end_function
79682>>>>>>>
79682>>>>>>>    // internal function, used to extract different printer flags ranges based on
79682>>>>>>>    // the print flag integer. These flags use a decimal style of packing information
79682>>>>>>>    // where different printer options (paper, bin, etc) use different ranges and
79682>>>>>>>    // different steps. Everything above iTopVal is removed and everything that is not
79682>>>>>>>    // within the iStep range is removed.
79682>>>>>>>    Function PrintFlagRange integer iTopVal integer iStep returns integer
79684>>>>>>>        integer iFgs iFg
79684>>>>>>>        Get DFGetPrintDialogFlags to iFg
79685>>>>>>>        Move (mod(iFg,iTopVal) / iStep * iStep ) to iFg
79686>>>>>>>        function_return iFg
79687>>>>>>>    end_Function
79688>>>>>>>
79688>>>>>>>    Procedure DFSetPrinterPaper integer ePaperType
79690>>>>>>>        Send DFSetSpecPrintFlag ePaperType
79691>>>>>>>    End_Procedure
79692>>>>>>>
79692>>>>>>>    Function DFGetPrinterPaper returns integer //ePaperType
79694>>>>>>>        integer ePaperType
79694>>>>>>>        Get PrintFlagRange 500 10 to ePaperType // 10-490 in steps of 10
79695>>>>>>>        function_return ePaperType
79696>>>>>>>    End_Function
79697>>>>>>>
79697>>>>>>>
79697>>>>>>>    Procedure DFSetPrinterBin integer eBinType
79699>>>>>>>        Send DFSetSpecPrintFlag eBinType
79700>>>>>>>    End_Procedure
79701>>>>>>>
79701>>>>>>>    Function DFGetPrinterBin returns integer //eBinType
79703>>>>>>>        integer eBinType
79703>>>>>>>        Get PrintFlagRange 10000 500 to eBinType // 1000-9000 steps 500
79704>>>>>>>        function_return eBinType
79705>>>>>>>    End_Function
79706>>>>>>>
79706>>>>>>>
79706>>>>>>>    Procedure DFSetPrinterResolution integer eResType
79708>>>>>>>        Send DFSetSpecPrintFlag eResType
79709>>>>>>>    End_Procedure
79710>>>>>>>
79710>>>>>>>    Function DFGetPrinterResolution returns integer //eResType
79712>>>>>>>        integer eResType
79712>>>>>>>        Get PrintFlagRange 50000 10000 to eResType // 10000-500000 steps 10000
79713>>>>>>>        function_return eResType
79714>>>>>>>    End_Function
79715>>>>>>>
79715>>>>>>>
79715>>>>>>>    Procedure DFSetLandscape boolean bIsLandscape
79717>>>>>>>        Send DFSetSpecPrintFlag (If(bIsLandscape,DF_Landscape,DF_Portrait))
79718>>>>>>>    End_Procedure
79719>>>>>>>
79719>>>>>>>    Function DFGetLandscape returns boolean // bIsLandscape
79721>>>>>>>        boolean bIsLandscape
79721>>>>>>>        Get DFCheckPrintDialogFlag DF_Landscape to bIsLandscape
79722>>>>>>>        function_return bIsLandscape
79723>>>>>>>    End_Function
79724>>>>>>>
79724>>>>>>>    Function RGBToWPColor integer iRgb returns integer
79726>>>>>>>        integer iRed iGreen iBlue
79726>>>>>>>        integer iWPColor
79726>>>>>>>        Move (R_from_rgb(iRGB)) to iRed
79727>>>>>>>        Move (G_from_rgb(iRGB)) to iGreen
79728>>>>>>>        Move (B_from_rgb(iRGB)) to iBlue
79729>>>>>>>        Get DfGetDfColor iRed iGreen iBlue to iWPColor
79730>>>>>>>        function_Return iWPColor
79731>>>>>>>    end_function
79732>>>>>>>
79732>>>>>>>
79732>>>>>>>
79732>>>>>>>End_Class
79733>>>>>>>
79733>>>>>>>Global_Variable Integer ghoWinPrint2
79733>>>>>>>
79733>>>>>>>Get Create of desktop U_cWinPrint2 to ghoWinPrint2
79734>>>>>>>
79734>>>>>>>
79734>>>>>Use Winprint_Commands.pkg  // commands used by this class
79734>>>>>
79734>>>>>Class cWinReport2 is a BasicReport
79735>>>>>
79735>>>>>    Procedure Construct_Object
79737>>>>>        Forward send construct_object
79739>>>>>
79739>>>>>        Date Today
79739>>>>>        Sysdate Today
79740>>>>>
79740>>>>>        // should use built in DF function CurrentDateTime()
79740>>>>>        Property Date  RptToday    Today
79741>>>>>
79741>>>>>        Object RptTotal is an Array
79743>>>>>        End_Object
79744>>>>>
79744>>>>>        // If true, report is output upon completion. Either preview
79744>>>>>        // or printer depending on output_device_mode
79744>>>>>        Property Boolean AutoOutput_State True
79745>>>>>
79745>>>>>        // When a new page is created (DFNew_Page) and the number
79745>>>>>        // of columns is not passed, this is used.
79745>>>>>        Property Integer Print_Columns 0
79746>>>>>
79746>>>>>        // This determines if a DFNew_Page should be executed when the
79746>>>>>        // report starts. In some rare cases, you would not want this to
79746>>>>>        // occur until a subheader
79746>>>>>        Property Boolean AutoNew_Page_State True
79747>>>>>
79747>>>>>        // Output device (print or preview). Normally this is delegated to
79747>>>>>        // the report view.
79747>>>>>        //
79747>>>>>
79747>>>>>        Property Integer Private.Output_Device_Mode PRINT_TO_UNDEFINED
79748>>>>>
79748>>>>>        Property Handle phoWinPrint  ghoWinPrint2 // the report engine to use.
79749>>>>>
79749>>>>>        // JJT: For now this is for testing.
79749>>>>>        Property boolean pbModalViewer False
79750>>>>>
79750>>>>>        Property boolean pbMultiReports False
79751>>>>>
79751>>>>>        Property boolean pbFirstPagePrinted false
79752>>>>>
79752>>>>>    End_Procedure
79753>>>>>
79753>>>>>    // returns the current status of Winprint Document object. dsNotStarted, dsStarted, dsFinished
79753>>>>>    // note that the status can reflect a status from a different report. The winprint object is global.
79753>>>>>    Function DocumentStatus returns Boolean
79755>>>>>        integer iStatus
79755>>>>>        Get DocumentStatus of (phoWinprint(self)) to iStatus
79756>>>>>        function_return iStatus
79757>>>>>    End_function
79758>>>>>
79758>>>>>    Function IsViewerActive Returns Boolean
79760>>>>>        Boolean bIsActive
79760>>>>>        Get IsViewerActive of (phoWinPrint(Self)) to bIsActive
79761>>>>>        Function_Return bIsActive
79762>>>>>    End_Function
79763>>>>>
79763>>>>>    Function IsPrinterValid Returns Boolean
79765>>>>>        Function_Return (WP_IsPrinterValid()<>0)
79766>>>>>    End_Function
79767>>>>>
79767>>>>>    Function ArePrintersInstalled Returns Boolean
79769>>>>>        Function_Return (WP_ArePrintersInstalled()<>0)
79770>>>>>    End_Function
79771>>>>>
79771>>>>>
79771>>>>>    // All subtotal commands use the outer main report. This makes it easier to keep
79771>>>>>    // track of these numbers
79771>>>>>
79771>>>>>    Procedure Add_SubTotal Integer iCounter Number nData
79773>>>>>        Number nValue
79773>>>>>        Integer iObj
79773>>>>>        Move (RptTotal(Main_Report_Id(Self))) to iObj
79774>>>>>        Get Number_Value of iObj iCounter To nValue
79775>>>>>        Add nData To nValue
79776>>>>>        Set Array_Value of iObj iCounter To nValue
79777>>>>>    End_Procedure
79778>>>>>
79778>>>>>    Procedure Clr_SubTotal Integer iCounter
79780>>>>>        Set Array_Value of (RptTotal(Main_Report_Id(Self))) iCounter To 0
79781>>>>>    End_Procedure
79782>>>>>
79782>>>>>    Procedure Clr_AllSubTotals
79784>>>>>        Send Delete_Data of (RptTotal(Main_Report_Id(Self)))
79785>>>>>    End_Procedure
79786>>>>>
79786>>>>>    Function Sum_SubTotal Integer iTotal Returns Number
79788>>>>>        Number nRetVal
79788>>>>>        Get Number_Value of (RptTotal(Main_Report_Id(Self))) iTotal To nRetVal
79789>>>>>        Function_Return nRetVal
79790>>>>>    End_Function
79791>>>>>
79791>>>>>    //Return sub-total and clear accumulator
79791>>>>>    //
79791>>>>>    Function SubTotal Integer iTotal Returns Number
79793>>>>>        Number nRetVal
79793>>>>>        Get Sum_SubTotal  iTotal to nRetVal
79794>>>>>        Send Clr_SubTotal iTotal
79795>>>>>        Function_Return nRetVal
79796>>>>>    End_Function
79797>>>>>
79797>>>>>
79797>>>>>    // Note: Cols is optional. If no argument is passed it will use
79797>>>>>    //       the object's property Print_Columns (0 by default)
79797>>>>>    //
79797>>>>>    Procedure DFNew_Page Integer Cols
79799>>>>>        Integer PageNumber Columns
79799>>>>>        Boolean bFirstPagePrinted
79799>>>>>        // If no args passed used default setting
79799>>>>>        If (Num_Arguments=0) ;           Move (Print_Columns(Main_Report_id(Self))) to Columns
79802>>>>>        Else ;           Move Cols to Columns
79804>>>>>        Set Page_Feed   to -2   // No FormFeed
79805>>>>>        If (Child_Rpt_State(self)) ;            Send DFNew_Page of (Main_Report_Id(Self)) Columns
79808>>>>>        Else Begin
79809>>>>>            // we only want to print report_header once. When report starts
79809>>>>>            // this is set true, after the first print it is false. You can set
79809>>>>>            // this to true before and explicit dfNew_page to force a header
79809>>>>>            Get pbFirstPagePrinted to bFirstPagePrinted
79810>>>>>            Get  DFNewPage of (phoWinPrint(self)) Columns To PageNumber
79811>>>>>            If (PageNumber<>0) begin // if 0, it failed
79813>>>>>                Set No_PageCheck_State to True
79814>>>>>
79814>>>>>                //Top section
79814>>>>>                Send Page_Top
79815>>>>>                If Not bFirstPagePrinted Send Report_Header
79818>>>>>                Send Page_Header
79819>>>>>                Send Page_Title
79820>>>>>
79820>>>>>                Set New_Page_State to False
79821>>>>>                Set Page_End_State to False
79822>>>>>                Set No_PageCheck_State to False        // No longer Paging
79823>>>>>                Set pbFirstPagePrinted to True
79824>>>>>            End
79824>>>>>>
79824>>>>>        End
79824>>>>>>
79824>>>>>
79824>>>>>        // Footer section
79824>>>>>        //
79824>>>>>        // DO NOT CHANGE THE ORDER OF BOTTOM SECTIONS !!!!!
79824>>>>>        //
79824>>>>>
79824>>>>>        Send Page_Bottom
79825>>>>>
79825>>>>>        // in WinPrint it is not possible to replace Page_Footer
79825>>>>>        // with Report_Footer. If you use Report_Footer you will
79825>>>>>        // have both Page_Footer and Report_Footer
79825>>>>>        //
79825>>>>>        //If LastTime eq 0 Send Page_Footer
79825>>>>>        //else             Send Report_Footer
79825>>>>>
79825>>>>>        Send Page_Footer
79826>>>>>        Send Page_Total
79827>>>>>    End_Procedure
79828>>>>>
79828>>>>>    Procedure Ending_Main_Report
79830>>>>>        Boolean bCancel bMultiReports
79830>>>>>
79830>>>>>        Get Cancelled_state to bCancel
79831>>>>>        Get pbMultiReports to bMultiReports
79832>>>>>
79832>>>>>        Forward Send Ending_Main_Report
79834>>>>>
79834>>>>>        If bCancel Begin
79836>>>>>            Send DFEndDocument
79837>>>>>            Send DFClearDoc // this will also close the previewer
79838>>>>>        end
79838>>>>>>
79838>>>>>        Else Begin
79839>>>>>            Send Report_Footer
79840>>>>>
79840>>>>>            // if multi-reports, we don't do an end of report yet. The programmer must
79840>>>>>            // manually end the report by sending EndMultiReport
79840>>>>>            If (not(bMultiReports)) begin
79842>>>>>                Send EndWinPrintReport
79843>>>>>            end
79843>>>>>>
79843>>>>>
79843>>>>>        end
79843>>>>>>
79843>>>>>
79843>>>>>    End_Procedure
79844>>>>>
79844>>>>>    // This must get called when you are running multiple reports (pbMultiReport).
79844>>>>>    // Send this when the last report is complete.
79844>>>>>    Procedure EndMultiReport
79846>>>>>        Send EndWinPrintReport
79847>>>>>    End_procedure
79848>>>>>
79848>>>>>
79848>>>>>    Procedure EndWinPrintReport
79850>>>>>        Boolean bAutoOutput
79850>>>>>        integer iStatus eMode
79850>>>>>        Get DocumentStatus to iStatus
79851>>>>>        If (iStatus<>dsStarted) procedure_return
79854>>>>>
79854>>>>>        // this tells winprint that the report is complete
79854>>>>>        Send DFEndDocument
79855>>>>>        // if auto-output we print or display automatically.
79855>>>>>        // for winprint2, if in preview mode you must do this so the previewer can enter
79855>>>>>        // a modal state (which it may or may not need to do).
79855>>>>>        Get AutoOutput_state to bAutoOutput
79856>>>>>        Get Output_device_mode to eMode
79857>>>>>        If (bAutoOutput or eMode=PRINT_TO_WINDOW) begin
79859>>>>>            Send PrintReport
79860>>>>>            // if auto output, we assume that you are done when it is all over
79860>>>>>            // we only can do this with the modal viewer
79860>>>>>            If (bAutoOutput and pbModalViewer(self)) begin
79862>>>>>                Send DFClearDoc
79863>>>>>            end
79863>>>>>>
79863>>>>>        end
79863>>>>>>
79863>>>>>
79863>>>>>    End_Procedure
79864>>>>>
79864>>>>>
79864>>>>>    Function Setup_Report Returns Integer
79866>>>>>        Integer iErr iStatus eMode
79866>>>>>        Boolean bActiveViewer bChildReport bMultiReports bOk
79866>>>>>
79866>>>>>        Get Child_rpt_state to bChildReport
79867>>>>>
79867>>>>>        If not bChildReport Begin
79869>>>>>
79869>>>>>            // This makes sure that we are pointing to the new winprint2 engine object.
79869>>>>>            // normally this will be the new winprint, but it can be redirected
79869>>>>>            Get phoWinPrint to WinPrintID
79870>>>>>
79870>>>>>            // winprint must have installed printer. If not installed, generate error and stop the report
79870>>>>>            Get ArePrintersInstalled to bOk
79871>>>>>            If not bOk Begin
79873>>>>>                Error DFERR_WINPRINT C_$NoInstalledPrinters
79874>>>>>>
79874>>>>>                Function_Return 1
79875>>>>>            End
79875>>>>>>
79875>>>>>
79875>>>>>            // check if selected printer is valid. If not, generate error and stop the report
79875>>>>>            Get IsPrinterValid to bOk
79876>>>>>            If not bOk Begin
79878>>>>>                Error DFERR_WINPRINT DFPrintError936    // Could not select a valid printer
79879>>>>>>
79879>>>>>                Function_Return 1
79880>>>>>            End
79880>>>>>>
79880>>>>>
79880>>>>>            // make sure it is ok to start a new report but try to be smart about it.
79880>>>>>            // if a report is active (dsstarted or dsFinished) check to see if it is
79880>>>>>            // finished w/ no viewer. If so, assume the user closed the report and is done
79880>>>>>            // so just clear the report. If a viewer is present, declare an error.
79880>>>>>            Get DocumentStatus to iStatus
79881>>>>>            Get pbMultiReports to bMultiReports
79882>>>>>            // multi-report only in-progress is multi and it is started
79882>>>>>            Move (bMultiReports and iStatus=dsStarted) to bMultiReports
79883>>>>>            If not bMultiReports Begin
79885>>>>>                If (iStatus<>dsNotStarted) Begin
79887>>>>>                    Get IsViewerActive to bActiveViewer
79888>>>>>                    If (iStatus=dsFinished and not(bActiveViewer)) Begin
79890>>>>>                        Send DfClearDoc
79891>>>>>                    End
79891>>>>>>
79891>>>>>                    Else Begin
79892>>>>>                        Error DFERR_WINPRINT DFPrintError967
79893>>>>>>
79893>>>>>                        Function_Return 1
79894>>>>>                    End
79894>>>>>>
79894>>>>>                End
79894>>>>>>
79894>>>>>
79894>>>>>                // all new reports by default allow printing from viewer and they have the print job set up when you select print
79894>>>>>                // if you need to change these defaults, you can change these inside of Starting_main_report
79894>>>>>                // We only do this with non-multi-reports.
79894>>>>>                Send DFSetPrintDlgInPreview      True
79895>>>>>                Send DFSetEnablePrintFromPreview True
79896>>>>>
79896>>>>>            End
79896>>>>>>
79896>>>>>
79896>>>>>            // In the new winprint, this message is not needed and is a stub. For
79896>>>>>            // now it is in here for compatibility purposes
79896>>>>>            //You MUST always start a new report with this procedure
79896>>>>>            Send DFZeroCounters of (phoWinPrint(Self))
79897>>>>>            Send Clr_AllSubTotals
79898>>>>>
79898>>>>>        End
79898>>>>>>
79898>>>>>
79898>>>>>        Forward Get Setup_report to iErr
79900>>>>>
79900>>>>>        If (iErr=0) Begin
79902>>>>>            If not bChildReport Begin
79904>>>>>                // if part of a multi-report we don't do a new doc
79904>>>>>                If not bMultiReports Begin
79906>>>>>                    Get Output_Device_Mode to eMode
79907>>>>>                    Send DFNewDoc of (phoWinPrint(Self))  (eMode = PRINT_TO_WINDOW) // pass True of display while printing
79908>>>>>                End
79908>>>>>>
79908>>>>>                // Do new page if not part of a multi-report and we say don't do a new page
79908>>>>>                If (not(bMultiReports) or AutoNew_Page_State(Self)) Begin
79910>>>>>                    Set pbFirstPagePrinted to False // tells new page that this is the first time for this report
79911>>>>>                    Send DFNew_page
79912>>>>>                End
79912>>>>>>
79912>>>>>            End
79912>>>>>>
79912>>>>>        End
79912>>>>>>
79912>>>>>        Function_Return iErr
79913>>>>>    End_Function
79914>>>>>
79914>>>>>
79914>>>>>
79914>>>>>    // Cancel RO behavior - there is no device to close
79914>>>>>    //
79914>>>>>    Procedure Close_Output_Device
79916>>>>>    End_Procedure
79917>>>>>
79917>>>>>    // Cancel RO Behavior
79917>>>>>    //
79917>>>>>    Procedure Initialize_Output_Device
79919>>>>>    End_procedure
79920>>>>>
79920>>>>>
79920>>>>>    Function Output_Device_Mode Returns Integer
79922>>>>>        Integer hoId
79922>>>>>        String DevMode
79922>>>>>        Get Private.Output_Device_Mode to DevMode
79923>>>>>        If (DevMode=PRINT_TO_UNDEFINED) Begin
79925>>>>>            Get Report_View_Id to hoId
79926>>>>>            If hoID ;                Get OutPut_Device_Mode of hoID to DevMode
79929>>>>>            If (DevMode=PRINT_TO_UNDEFINED) ;                Move PRINT_TO_WINDOW to DevMode
79932>>>>>        End
79932>>>>>>
79932>>>>>        Function_Return DevMode
79933>>>>>    End_Function // Output_Destination
79934>>>>>
79934>>>>>    Procedure Set Output_Device_Mode Integer DevMode
79936>>>>>        Set Private.Output_Device_Mode to DevMode
79937>>>>>    End_Procedure // Set Output_Device
79938>>>>>
79938>>>>>    // displays a metric ruler in .5 increments. This can be
79938>>>>>    // sent to make it easy to see how fields and labels should
79938>>>>>    // be moved for alignment.
79938>>>>>    //
79938>>>>>    Procedure ShowRuler
79940>>>>>        integer i
79940>>>>>        number n
79940>>>>>        for i from 0 to 30
79946>>>>>>
79946>>>>>            Send DFWritePos of (phoWinPrint(self)) (String(i)) FONT_DEFAULT i -1 0
79947>>>>>            Move (i+.5) to n
79948>>>>>            Send DFWritePos of (phoWinPrint(self)) "." FONT_DEFAULT n -1 0
79949>>>>>        Loop
79950>>>>>>
79950>>>>>        Send DFWriteln of (phoWinPrint(self)) ''  FONT_DEFAULT FONT_DEFAULT -1
79951>>>>>    End_procedure
79952>>>>>
79952>>>>>      // status panel related agumentations to handle the auto-previewer
79952>>>>>
79952>>>>>      Procedure Update_Status string sVal
79954>>>>>         Integer eMode
79954>>>>>         Get Output_device_mode to eMode
79955>>>>>         If (eMode=PRINT_TO_WINDOW) Begin
79957>>>>>            Send SetProgressCaption  of (phoWinPrint(self)) sVal
79958>>>>>         End
79958>>>>>>
79958>>>>>         Else Begin
79959>>>>>            forward Send Update_Status sVal
79961>>>>>         end
79961>>>>>>
79961>>>>>      End_Procedure
79962>>>>>
79962>>>>>      Procedure Start_Status
79964>>>>>         Integer eMode
79964>>>>>         string sTitle sCaption
79964>>>>>         Get Output_device_mode to eMode
79965>>>>>         If (eMode=PRINT_TO_WINDOW) Begin
79967>>>>>            Get Report_Caption to sCaption
79968>>>>>            Get Report_Title to sTitle
79969>>>>>            If (sTitle<>"" and sCaption<>"") begin
79971>>>>>                Move ( sCaption- ":" * sTitle) to sTitle
79972>>>>>            end
79972>>>>>>
79972>>>>>            else begin
79973>>>>>                Move (sCaption - sTitle) to sTitle
79974>>>>>            end
79974>>>>>>
79974>>>>>            Send SetReportTitle of (phoWinPrint(self)) sTitle
79975>>>>>         End
79975>>>>>>
79975>>>>>         Else Begin
79976>>>>>            forward Send Start_status
79978>>>>>         end
79978>>>>>>
79978>>>>>      End_Procedure
79979>>>>>
79979>>>>>      Procedure Resume_Status
79981>>>>>         Integer eMode
79981>>>>>         Get Output_device_mode to eMode
79982>>>>>         If (eMode=PRINT_TO_WINDOW) Begin
79984>>>>>            Send DfPreviewNoWait of (phoWinPrint(self))
79985>>>>>         End
79985>>>>>>
79985>>>>>         Else Begin
79986>>>>>            forward Send Resume_Status
79988>>>>>         end
79988>>>>>>
79988>>>>>      End_Procedure
79989>>>>>
79989>>>>>      Procedure End_Status
79991>>>>>         Integer eMode
79991>>>>>         Get Output_device_mode to eMode
79992>>>>>         If (error_processing_state(self)) Begin
79994>>>>>            Send DFClosePreview
79995>>>>>         end
79995>>>>>>
79995>>>>>         If (eMode=PRINT_TO_WINDOW) Begin
79997>>>>>         End
79997>>>>>>
79997>>>>>         Else Begin
79998>>>>>            forward Send End_Status
80000>>>>>         end
80000>>>>>>
80000>>>>>      End_Procedure
80001>>>>>
80001>>>>>    Function Report_Interrupt Returns Integer
80003>>>>>         integer eStat
80003>>>>>         String sMess
80003>>>>>         Boolean bActiveViewer
80003>>>>>         Get IsViewerActive to bActiveViewer
80004>>>>>         If (Error_Check_State(self)) begin
80006>>>>>            Move C_$AnErrorWishToCancel to sMess
80007>>>>>         end
80007>>>>>>
80007>>>>>         Else begin
80008>>>>>            Move  C_$CancelThisReport to sMess
80009>>>>>         end
80009>>>>>>
80009>>>>>         If bActiveViewer Begin
80011>>>>>            Get PreviewYesNoBox of (phoWinPrint(self)) C_$ReportInterrupt sMess to eStat
80012>>>>>         end
80012>>>>>>
80012>>>>>         Else Begin
80013>>>>>            Get YesNo_Box sMess C_$ReportInterrupt to eStat
80014>>>>>         End
80014>>>>>>
80014>>>>>
80014>>>>>         Function_Return (eStat=MBR_YES)
80015>>>>>
80015>>>>>  End_Function
80016>>>>>
80016>>>>>  Function Test_KeyPressed Returns Integer
80018>>>>>     Boolean bStop bError bActiveViewer
80018>>>>>     integer eMode
80018>>>>>     // winreport will do this also, but this makes sure that this gets called
80018>>>>>     // for each body loop -- even if the body loop prints nothing
80018>>>>>     Send PumpMsgQueue of (phoWinPrint(self)) // permit painting
80019>>>>>     Get IsViewerActive to bActiveViewer
80020>>>>>     Get Output_device_mode to eMode
80021>>>>>     If bActiveViewer Begin
80023>>>>>        Get ViewerWantsToClose of (phoWinPrint(self)) to bStop
80024>>>>>        Get Error_Check_State to bError
80025>>>>>        if (bStop or bError) begin
80027>>>>>            Get Report_Interrupt to bStop
80028>>>>>        end
80028>>>>>>
80028>>>>>     end
80028>>>>>>
80028>>>>>     Else Begin
80029>>>>>        Forward Get Test_KeyPressed to bStop
80031>>>>>        If (eMode=PRINT_TO_WINDOW and not(bStop)) Begin
80033>>>>>            Send DfPreviewNoWait
80034>>>>>        end
80034>>>>>>
80034>>>>>     End
80034>>>>>>
80034>>>>>
80034>>>>>     Function_Return bStop
80035>>>>>  End_Function
80036>>>>>
80036>>>>>    Procedure OnClosingView
80038>>>>>        Send DFClearDoc
80039>>>>>    end_procedure
80040>>>>>
80040>>>>>
80040>>>>>    // Attempt to make this as intuitive as possible. You cannot invoke this when a
80040>>>>>    // report is active. If a report is not finished, you cannot do this.
80040>>>>>    // If a report is finsihed it may or may not have a viewer present.
80040>>>>>    // If a viewer is not present, we will clear the exising report (making the assumption
80040>>>>>    // that a modeless viewer was closed and the report will not be invoked again). If a viewer
80040>>>>>    // is active, we will pass this through to the winprint object which will show an error
80040>>>>>
80040>>>>>    Function DFPrintSetupDialog Returns Boolean// invoke printer setup dialog
80042>>>>>        Integer iStatus
80042>>>>>        Boolean bActiveViewer bOk
80042>>>>>        // we must have printers installed for this to work
80042>>>>>        Get ArePrintersInstalled to bOk
80043>>>>>        If not bOk Begin
80045>>>>>            Error DFERR_WINPRINT C_$NoInstalledPrinters
80046>>>>>>
80046>>>>>        End
80046>>>>>>
80046>>>>>        Else Begin
80047>>>>>            Get DocumentStatus to iStatus
80048>>>>>            If (iStatus=dsFinished) Begin
80050>>>>>                Get IsViewerActive to bActiveViewer
80051>>>>>                If not bActiveViewer Begin
80053>>>>>                    Send DfClearDoc
80054>>>>>                End
80054>>>>>>
80054>>>>>            End
80054>>>>>>
80054>>>>>            // the winprint object will generate an error if the status is not dsNotStarted.
80054>>>>>            // we want those errors
80054>>>>>            Get DFPrintSetupDialog of (phoWinPrint(Self)) to bOk
80055>>>>>        End
80055>>>>>>
80055>>>>>        Function_Return bOk
80056>>>>>    End_Procedure
80057>>>>>
80057>>>>>    // It is better to use DFPrintSetupDialog which tells you if the dialog was canceled
80057>>>>>    Procedure DFPrintSetup // invoke printer setup dialog
80059>>>>>        Boolean bOk
80059>>>>>        Get DFPrintSetupDialog to bOk
80060>>>>>    End_Procedure
80061>>>>>
80061>>>>>    Procedure DFClearDoc // clear document, remove viewer
80063>>>>>        Send DFClearDoc of (phoWinPrint(self))
80064>>>>>    end_procedure
80065>>>>>
80065>>>>>    Procedure DFEndDocument // tell winprint that the report is complete
80067>>>>>        Send DfEndDocument of (phoWinPrint(self))
80068>>>>>    end_procedure
80069>>>>>
80069>>>>>    Procedure DFClosePreview //close the previewer, does not clear the document
80071>>>>>        Send DfClosePreview of (phoWinPrint(self))
80072>>>>>    end_procedure
80073>>>>>
80073>>>>>    Procedure DFPrintDialog // popup print job dialog
80075>>>>>        Send DFPrintDialog of (phoWinPrint(self))
80076>>>>>    End_procedure
80077>>>>>
80077>>>>>    Procedure DFPrint // print with printer dialog
80079>>>>>        Send DFPrint of (phoWinPrint(self))
80080>>>>>    End_procedure
80081>>>>>
80081>>>>>    Procedure DFPrintDoc // print without printer dialog
80083>>>>>        Send DFPrintDoc of (phoWinPrint(self))
80084>>>>>    End_Procedure
80085>>>>>
80085>>>>>    Procedure DFPreviewWait // invoke previewer in modal mode
80087>>>>>       Send DFPreviewWait of (phoWinPrint(self))
80088>>>>>    End_Procedure
80089>>>>>
80089>>>>>    Procedure DFPreviewNoWait // invoke previwer in modeless mode
80091>>>>>       Send DFPreviewNoWait of (phoWinPrint(self))
80092>>>>>    End_Procedure
80093>>>>>
80093>>>>>    Procedure DFPreview // invokde previewer based on pbModalViewer property
80095>>>>>       Boolean bModalViewer
80095>>>>>       Get pbModalViewer to bModalViewer
80096>>>>>       If bModalViewer Begin
80098>>>>>           Send DFPreviewWait
80099>>>>>       end
80099>>>>>>
80099>>>>>       else Begin
80100>>>>>           Send DFPreviewNoWait
80101>>>>>       end
80101>>>>>>
80101>>>>>   End_Procedure
80102>>>>>
80102>>>>>    // Print report to appropriate device (printer, preview) based
80102>>>>>    // on output_device_mode
80102>>>>>    //
80102>>>>>    Procedure PrintReport
80104>>>>>        Integer eMode
80104>>>>>        Get OutPut_Device_Mode to eMode
80105>>>>>        If ((eMode=PRINT_TO_WINDOW) or (eMode=DEFERRED_PRINT_TO_WINDOW)) Begin
80107>>>>>           Send DFPreview
80108>>>>>        end
80108>>>>>>
80108>>>>>        Else If (eMode=PRINT_TO_PRINTER_NO_DIALOG) Begin
80111>>>>>           Send DFPrintDoc // print, no print job dialog
80112>>>>>        end
80112>>>>>>
80112>>>>>        Else Begin // (eMode=PRINT_TO_PRINTER)
80113>>>>>           Send DFPrint // print with print job dialog
80114>>>>>        end
80114>>>>>>
80114>>>>>    End_Procedure
80115>>>>>
80115>>>>>
80115>>>>>    Procedure DFSetPrinterPaper integer ePaperType
80117>>>>>        Send DFSetPrinterPaper of (phoWinPrint(self)) ePaperType
80118>>>>>    End_Procedure
80119>>>>>
80119>>>>>    Function DFGetPrinterPaper returns integer //ePaperType
80121>>>>>        integer ePaperType
80121>>>>>        Get DFGetPrinterPaper of (phoWinPrint(self)) to ePaperType
80122>>>>>        Function_return ePaperType
80123>>>>>    end_function
80124>>>>>
80124>>>>>
80124>>>>>    Procedure DFSetPrinterBin integer eBinType
80126>>>>>        Send DFSetPrinterBin of (phoWinPrint(self)) eBinType
80127>>>>>    End_Procedure
80128>>>>>
80128>>>>>    Function DFGetPrinterBin returns integer //eBinType
80130>>>>>        integer eBinType
80130>>>>>        Get DFGetPrinterBin of (phoWinPrint(self)) to eBinType
80131>>>>>        Function_return eBinType
80132>>>>>    end_function
80133>>>>>
80133>>>>>
80133>>>>>    Procedure DFSetPrinterResolution integer eResType
80135>>>>>        Send DFSetPrinterResolution of (phoWinPrint(self)) eResType
80136>>>>>    End_Procedure
80137>>>>>
80137>>>>>    Function DFGetPrinterResolution returns integer //eResType
80139>>>>>        Boolean eResType
80139>>>>>        Get DFGetPrinterResolution of (phoWinPrint(self)) to eResType
80140>>>>>        Function_return eResType
80141>>>>>    end_function
80142>>>>>
80142>>>>>
80142>>>>>    Procedure DFSetLandscape boolean bIsLandscape
80144>>>>>        Send DFSetLandscape of (phoWinPrint(self)) bIsLandscape
80145>>>>>    End_Procedure
80146>>>>>
80146>>>>>    Function DFGetLandscape returns boolean // bIsLandscape
80148>>>>>        Boolean bIsLandscape
80148>>>>>        Get DFGetLandscape of (phoWinPrint(self)) to bIsLandscape
80149>>>>>        Function_return bIsLandscape
80150>>>>>    end_function
80151>>>>>
80151>>>>>    Procedure DFSetMetrics integer eType
80153>>>>>        Send DFSetMetrics of (phoWinPrint(self)) eType
80154>>>>>    End_Procedure
80155>>>>>
80155>>>>>    Function DFGetMetrics returns integer
80157>>>>>        integer eType
80157>>>>>        Get DFGetMetrics of (phoWinPrint(self)) to eType
80158>>>>>        Function_return eType
80159>>>>>    end_function
80160>>>>>
80160>>>>>
80160>>>>>    Procedure DFSetPrintDlgInPreview boolean bShowDialog
80162>>>>>        Set PrintDlgInPreview of (phoWinPrint(self)) to bShowDialog
80163>>>>>    End_Procedure
80164>>>>>
80164>>>>>    Function DFGetPrintDlgInPreview returns boolean
80166>>>>>        boolean bShowDialog
80166>>>>>        Get PrintDlgInPreview of (phoWinPrint(self)) to bShowDialog
80167>>>>>        Function_return bShowDialog
80168>>>>>    end_function
80169>>>>>
80169>>>>>
80169>>>>>    Procedure DFSetEnablePrintFromPreview boolean bEnablePrint
80171>>>>>        Set EnablePrintFromPreview of (phoWinPrint(self)) to bEnablePrint
80172>>>>>    End_Procedure
80173>>>>>
80173>>>>>    Function DFGetEnablePrintFromPreview returns boolean
80175>>>>>        boolean bEnablePrint
80175>>>>>        Get EnablePrintFromPreview of (phoWinPrint(self)) to bEnablePrint
80176>>>>>        Function_return bEnablePrint
80177>>>>>    end_function
80178>>>>>
80178>>>>>
80178>>>>>
80178>>>>>    Procedure DFSetMargins number nLeft number nTop number nRight number nBottom
80180>>>>>        Send DFSetMargins of (phoWinPrint(self)) nLeft nTop nRight nBottom
80181>>>>>    End_Procedure
80182>>>>>
80182>>>>>    Procedure DFSetTopBottom number nTop number nBottom Boolean bAllPages
80184>>>>>        Send DFSetTopBottom of (phoWinPrint(self)) nTop nBottom bAllPages
80185>>>>>    End_Procedure
80186>>>>>
80186>>>>>
80186>>>>>    Procedure DFSetDevice string sPrinterName
80188>>>>>        Send DFSetDevice of (phoWinPrint(self)) sPrinterName
80189>>>>>    End_Procedure
80190>>>>>
80190>>>>>    Function DFGetCurrentDevice returns string // sPrinterName
80192>>>>>        String sPrinterName
80192>>>>>        Get DFGetCurrentDevice of (phoWinPrint(self)) to sPrinterName
80193>>>>>        Function_return sPrinterName
80194>>>>>    end_function
80195>>>>>
80195>>>>>
80195>>>>>    Procedure DFSetUserDefinedPapersize number nLength number nWidth
80197>>>>>        Send DFSetUserDefinedPapersize of (phoWinPrint(self)) nLength nWidth
80198>>>>>    End_Procedure
80199>>>>>
80199>>>>>    Function DFGetUserDefinedLength returns number
80201>>>>>        number nSize
80201>>>>>        Get DFGetUserDefinedLength of (phoWinPrint(self)) to nSize
80202>>>>>        Function_return nSize
80203>>>>>    end_function
80204>>>>>
80204>>>>>    Function DFGetUserDefinedWidth returns number
80206>>>>>        number nSize
80206>>>>>        Get DFGetUserDefinedWidth of (phoWinPrint(self)) to nSize
80207>>>>>        Function_return nSize
80208>>>>>    end_function
80209>>>>>
80209>>>>>
80209>>>>>    Procedure DFSetNumberOfCopies integer iCopies
80211>>>>>        Send DFSetNumberOfCopies of (phoWinPrint(self)) iCopies
80212>>>>>    End_Procedure
80213>>>>>
80213>>>>>    Procedure DFPrinterBinFirstPage integer eBinType
80215>>>>>        Send DFPrinterBinFirstPage of (phoWinPrint(self)) eBinType
80216>>>>>    End_Procedure
80217>>>>>
80217>>>>>    Procedure DFClearPrinter
80219>>>>>        Send DFClearPrinter of (phoWinPrint(self))
80220>>>>>    End_Procedure
80221>>>>>
80221>>>>>    Function DFGetDFColor integer iRed integer iGreen integer iBlue returns integer
80223>>>>>        integer iWPColor
80223>>>>>        Get DFGetDFColor of (phoWinPrint(self)) iRed iGreen iBlue to iWPColor
80224>>>>>        Function_return iWPColor
80225>>>>>    end_function
80226>>>>>
80226>>>>>    Function RGBToWPColor integer iRgb returns integer
80228>>>>>        integer iWPColor
80228>>>>>        Get RGBToWPColor of (phoWinPrint(self)) iRGB to iWPColor
80229>>>>>        Function_return iWPColor
80230>>>>>    end_function
80231>>>>>
80231>>>>>
80231>>>>>End_Class
80232>>>Use CUSTOMER.DD
80232>>>
80232>>>ACTIVATE_VIEW Activate_oCustomerListWP FOR oCustomerListWP
80242>>>>
80242>>>
80242>>>Object oCustomerListWP is a ReportView
80244>>>
80244>>>    Property Boolean pbComments False
80246>>>    
80246>>>    Set Label to "Customer List"
80247>>>    Set Location to 6 6
80248>>>    Set Size to 95 180
80249>>>
80249>>>    Object Customer_DD is a Customer_DataDictionary
80251>>>    End_Object    // Customer_DD
80252>>>
80252>>>    Set Main_DD to Customer_DD
80253>>>    Set Server to Customer_DD
80254>>>
80254>>>    Object oPrintTo is a RadioGroup
80256>>>        Set Size to 50 80
80257>>>        Set Location to 5 5
80258>>>        Set Label to "Send Report to"
80259>>>        Object oScreenRadio is a Radio
80261>>>            Set Label to "Report Viewer"
80262>>>            Set Size to 10 61
80263>>>            Set Location to 15 10
80264>>>            Set Status_Help to "Preview the report to screen"
80265>>>        End_Object    // oScreenRadio
80266>>>
80266>>>        Object oPrinterRadio is a Radio
80268>>>            Set Label to "Printer"
80269>>>            Set Size to 10 37
80270>>>            Set Location to 30 10
80271>>>            Set Status_Help to "Send the report to the default printer"
80272>>>        End_Object    // oPrinterRadio
80273>>>
80273>>>        Function IsToPrinter Returns boolean
80276>>>            integer iRadio
80276>>>            Get Current_radio to iRadio
80277>>>            Function_return (iRadio=1)
80278>>>        End_Function // IsToPrinter
80279>>>
80279>>>    End_Object    // oPrintTo
80280>>>
80280>>>    Object oOrder is a RadioGroup
80282>>>        Set Size to 50 80
80283>>>        Set Location to 5 95
80284>>>        Set Label to "Report Order"
80285>>>        Object oNumberRadio is a Radio
80287>>>            Set Label to "Number"
80288>>>            Set Size to 10 41
80289>>>            Set Location to 15 10
80290>>>            Set Status_Help to "Sort by customer number"
80291>>>        End_Object    // oNumberRadio
80292>>>
80292>>>        Object oNameRadio is a Radio
80294>>>            Set Label to "Name"
80295>>>            Set Size to 10 35
80296>>>            Set Location to 30 10
80297>>>            Set Status_Help to "Sort by customer name"
80298>>>        End_Object    // oNameRadio
80299>>>
80299>>>        Function IsSortedByNumber Returns boolean
80302>>>            integer iRadio
80302>>>            Get Current_radio to iRadio
80303>>>            Function_return (iRadio=1)
80304>>>        End_Function // IsSortedByNumber
80305>>>
80305>>>    End_Object    // oOrder
80306>>>
80306>>>    Object oCommentsCkBx is a CheckBox
80308>>>        Set Label to "Print Comments"
80309>>>        Set Size to 10 65
80310>>>        Set Location to 59 95
80311>>>
80311>>>    End_Object    // oCommentsCkBx
80312>>>
80312>>>    Object oBtnPrint is a Button
80314>>>        Set Label to "Print"
80315>>>        Set Location to 76 7
80316>>>
80316>>>        Procedure OnClick
80319>>>            Send StartReport
80320>>>        End_Procedure
80321>>>
80321>>>    End_Object    // oBtnPrint
80322>>>
80322>>>    Object oBtnCancel is a Button
80324>>>        Set Label to "Cancel"
80325>>>        Set Location to 76 65
80326>>>
80326>>>        Procedure OnClick
80329>>>            Send Close_Panel
80330>>>        End_Procedure
80331>>>
80331>>>    End_Object    // oBtnCancel
80332>>>
80332>>>    Object oBtnPrinterSetup is a Button
80334>>>        Set Label to "Printer Setup"
80335>>>        Set Location to 76 123
80336>>>
80336>>>        Procedure OnClick
80339>>>            Boolean bSetupOk
80339>>>            Get DFPrintSetupDialog of oReport to bSetupOk
80340>>>        End_Procedure
80341>>>
80341>>>    End_Object    // oBtnPrinterSetup
80342>>>
80342>>>    Object oReport is a cWinReport2
80344>>>        Set Report_Title to "Customer List"
80345>>>
80345>>>        // Set DDO, Index and breaks for the report
80345>>>        Set Server to Customer_DD
80346>>>        Set Ordering to 1
80347>>>
80347>>>        // Report_Breaks file.field // no breaks in this report
80347>>>        
80347>>>        Property Boolean pbLandscape false
80349>>>        
80349>>>        Function Starting_Main_Report Returns Integer
80352>>>            Integer iIndex
80352>>>            Boolean bOn bErr
80352>>>        
80352>>>            Send DFSetMetrics wpm_cm
80353>>>            Send DFSetmargins 1 1 1 1
80354>>>        
80354>>>            Get pbComments to bOn
80355>>>            Send DFSetLandscape (if(bOn,True,false))  // This can be used to force a page orientation
80356>>>            Get DFGetLandscape to bOn
80357>>>            Set pbLandscape to bOn
80358>>>        
80358>>>            Forward Get Starting_Main_Report To bErr
80360>>>        
80360>>>            Function_return bErr
80361>>>        End_Function
80362>>>        
80362>>>        // Page_Top is printed first at the top margin of each page
80362>>>        Procedure Page_Top
80365>>>            string sFont
80365>>>            integer iFontSize iStyle
80365>>>        
80365>>>            Move "arial" to sFont
80366>>>            Move 8 to iFontSize
80367>>>            Move (Font_Default) to iStyle
80368>>>        
80368>>>            DFFont sFont
80369>>>            DFFontSize iFontSize
80370>>>            DFBeginHeader DFPageTop
80371>>>                DFHeaderFrame Hdr_NoFrame
80372>>>                DFHeaderPos   Hdr_Left
80373>>>                DFWriteLn ("Page:" * "#pagecount#") iStyle
80374>>>            DFEndHeader
80376>>>        
80376>>>        End_Procedure
80377>>>        
80377>>>        Procedure Page_Header
80380>>>            integer iFill iBorder iStyle
80380>>>            string  sFont sReportTitle
80380>>>            integer iFontSize
80380>>>        
80380>>>            Move "arial" to sFont
80381>>>            Move 16 to iFontSize
80382>>>            Move (Font_bold + rgb_White) to iStyle
80383>>>            Move (rgb_dGrey) to iFill
80384>>>            Move (rgb_dGrey) to iBorder
80385>>>            Get Report_Title to sReportTitle
80386>>>        
80386>>>            DFFont sFont
80387>>>            DFFontSize iFontSize
80388>>>            DFBeginHeader DFPageHeader
80389>>>                DFHeaderPos   Hdr_Left
80390>>>                DFHeaderFrame Hdr_Margins 0.01 iBorder iFill
80391>>>                DFWritelnPos sReportTitle 0.1 iStyle
80392>>>                DFHeaderMargin HM_BottomOuter 0.08
80393>>>            DFEndHeader
80395>>>        
80395>>>        End_Procedure // Page_Header
80396>>>        
80396>>>        Procedure Page_Title
80399>>>            string  sFont
80399>>>            integer iFontSize iHeaderStyle iFill iBorder
80399>>>            Boolean bOn
80399>>>        
80399>>>            Get pbLandscape to bOn
80400>>>        
80400>>>            Move "arial" to sFont
80401>>>            Move 8 to iFontSize
80402>>>            Move (Font_Bold + rgb_dBlue) to iHeaderStyle
80403>>>            Move (rgb_Grey) to iFill
80404>>>            Move (rgb_Grey) to iBorder
80405>>>        
80405>>>            DFFont sFont
80406>>>            DFFontSize iFontSize
80407>>>            DFBeginHeader DFPageTitle
80408>>>                DFHeaderPos   Hdr_Left
80409>>>                DFHeaderFrame Hdr_Margins 0 iBorder iFill
80410>>>                DfHeaderMargin HM_TopInner    0.01
80411>>>                DfHeaderMargin HM_BottomInner 0.01
80412>>>                DFHeaderMargin HM_BottomOuter 0.16
80413>>>        
80413>>>                DfWritePos "Number"                        0.1 (iHeaderStyle)
80414>>>                DfWritePos "Customer Name"                   2 (iHeaderStyle)
80415>>>                DfWritePos "Address"                         7 (iHeaderStyle)
80416>>>                DfWritePos "City"                           12 (iHeaderStyle)
80417>>>                DfWritePos "St."                            15 (iHeaderStyle)
80418>>>                DfWritePos "Zip"                            17 (iHeaderStyle)
80419>>>        
80419>>>                If bOn begin
80421>>>                   DfWritePos "Comments"                    19 (iHeaderStyle)
80422>>>                end
80422>>>>
80422>>>                DfWriteln
80423>>>            DFEndHeader
80425>>>        
80425>>>        End_Procedure // Page_Title
80426>>>        
80426>>>        Procedure Body
80429>>>            string  sFont
80429>>>            integer iFontSize iStyle
80429>>>            Boolean bOn
80429>>>        
80429>>>            Send Update_Status (String(Customer.Customer_number))
80430>>>        
80430>>>            Get pbLandscape to bOn
80431>>>        
80431>>>            Move "arial" to sFont
80432>>>            Move 8 to iFontSize
80433>>>            Move (font_default) to iStyle
80434>>>        
80434>>>            DFFont sFont
80435>>>            DFFontSize iFontSize
80436>>>            DFLineCheck 5
80437>>>        
80437>>>            DfWritePos Customer.Customer_Number       0.8 (iStyle + Font_Right) 0
80438>>>            DfWritePos Customer.Name                    2 iStyle -1 4.98
80439>>>            DfWritePos Customer.Address                 7 iStyle -1 4.98
80440>>>            DfWritePos Customer.City                   12 iStyle -1 3.98
80441>>>            DfWritePos Customer.State                  15 iStyle -1 0.98
80442>>>            DfWritePos Customer.Zip                    17 iStyle -1 1.98
80443>>>        
80443>>>            If bOn begin
80445>>>                DfWritePos Customer.Comments           19 iStyle -1 0
80446>>>                dfWriteln
80447>>>            end
80447>>>>
80447>>>            dfWriteln
80448>>>        End_Procedure  // Body
80449>>>        
80449>>>        // Page_Bottom is printed last at the bottom margin of each page
80449>>>        Procedure Page_Bottom
80452>>>            string sFont
80452>>>            integer iFontSize iBorder iStyle iFill
80452>>>            DateTime dtDT
80452>>>        
80452>>>            Move (CurrentDateTime()) to dtDT
80453>>>        
80453>>>            Move "arial" to sFont
80454>>>            Move 8 to iFontSize
80455>>>            Move (font_default) to iStyle
80456>>>            Move (rgb_dGrey) to iBorder
80457>>>            Move (rgb_White) to iFill
80458>>>        
80458>>>            DFFont sFont
80459>>>            DFFontSize iFontSize
80460>>>            DFBeginHeader DFPageBottom
80461>>>                DFHeaderFrame Hdr_Margins 0 iBorder iFill
80462>>>                DFHeaderPos Hdr_Center  // Write data in center
80463>>>                DFWriteln ("Report Printed on" * string(dtDT)) (iStyle)
80464>>>            DFEndHeader
80466>>>        
80466>>>        End_Procedure // Page_Bottom
80467>>>        
80467>>>    End_Object    // oReport
80468>>>
80468>>>    Procedure StartReport
80471>>>        Boolean bToPrinter bComments bSortByNumber
80471>>>    
80471>>>        // determine if direct print
80471>>>        Get IsToPrinter of oPrintTo to bToPrinter
80472>>>        Set OutPut_Device_Mode of oReport to (If(bToPrinter, PRINT_TO_PRINTER, PRINT_TO_WINDOW))
80473>>>    
80473>>>        // determine if sort order is by number or name
80473>>>        Get IsSortedByNumber of oOrder to bSortByNumber
80474>>>        Set Ordering of oReport to (if(bSortByNumber, 2, 1))
80475>>>    
80475>>>        Get Checked_State of oCommentsCkBx to bComments
80476>>>        Set pbComments to bComments
80477>>>    
80477>>>        // run the report
80477>>>        Send Run_Report of oReport
80478>>>    
80478>>>    End_Procedure // StartReport
80479>>>
80479>>>End_Object    // oCustomerListWP
80480>        Use WinPrint\ItemsPerOrderWP.rv
Including file: WinPrint\ItemsPerOrderWP.rv    (C:\Test\Order Entry git\AppSrc\WinPrint\ItemsPerOrderWP.rv)
80480>>>Use dfrptvw.pkg
80480>>>Use DataDict.pkg
80480>>>Use dfRadio.pkg
80480>>>Use Windows.pkg
80480>>>Use cWinReport2.pkg
80480>>>Use VENDOR.DD
80480>>>Use INVT.DD
80480>>>Use CUSTOMER.DD
80480>>>Use SALESP.DD
80480>>>Use ORDERHEA.DD
80480>>>Use ORDERDTL.DD
80480>>>
80480>>>ACTIVATE_VIEW Activate_oItemsPerOrderWP FOR oItemsPerOrderWP
80490>>>>
80490>>>
80490>>>Object oItemsPerOrderWP is a ReportView
80492>>>    Set Label to "Items per Order"
80493>>>    Set Location to 6 6
80494>>>    Set Size to 84 140
80495>>>
80495>>>    Object Vendor_DD is a Vendor_DataDictionary
80497>>>    End_Object    // Vendor_DD
80498>>>
80498>>>    Object Invt_DD is a Invt_DataDictionary
80500>>>        Set DDO_Server to Vendor_DD
80501>>>    End_Object    // Invt_DD
80502>>>
80502>>>    Object Customer_DD is a Customer_DataDictionary
80504>>>    End_Object    // Customer_DD
80505>>>
80505>>>    Object SalesP_DD is a Salesp_DataDictionary
80507>>>    End_Object    // SalesP_DD
80508>>>
80508>>>    Object Orderhea_DD is a Orderhea_DataDictionary
80510>>>        Set DDO_Server to Customer_DD
80511>>>        Set DDO_Server to SalesP_DD
80512>>>    End_Object    // Orderhea_DD
80513>>>
80513>>>    Object Orderdtl_DD is a Orderdtl_DataDictionary
80515>>>        Set DDO_Server to Orderhea_DD
80516>>>        Set DDO_Server to Invt_DD
80517>>>    End_Object    // Orderdtl_DD
80518>>>
80518>>>    Object oPrintTo is a RadioGroup
80520>>>        Set Size to 38 131
80521>>>        Set Location to 5 5
80522>>>        Set Label to "Print to"
80523>>>        Object oRadio1 is a Radio
80525>>>            Set Label to "Preview"
80526>>>            Set Size to 10 42
80527>>>            Set Location to 12 6
80528>>>            Set Status_Help to "Prints the report to screen"
80529>>>        End_Object    // oRadio1
80530>>>
80530>>>        Object oRadio2 is a Radio
80532>>>            Set Label to "Printer"
80533>>>            Set Size to 10 42
80534>>>            Set Location to 24 6
80535>>>            Set Status_Help to "Prints the report to printer"
80536>>>        End_Object    // oRadio2
80537>>>
80537>>>    End_Object    // oPrintTo
80538>>>
80538>>>    Object oBtnPrint is a Button
80540>>>        Set Label to "Print"
80541>>>        Set Location to 48 85
80542>>>        Set Status_Help to "Print the Selected report"
80543>>>        Set Default_State to True
80544>>>
80544>>>        Procedure OnClick
80547>>>            Send StartReport
80548>>>        End_Procedure
80549>>>
80549>>>    End_Object    // oBtnPrint
80550>>>
80550>>>    Object oBtnCancel is a Button
80552>>>        Set Label to "Cancel"
80553>>>        Set Location to 66 85
80554>>>        Set Status_Help to "Close this Panel"
80555>>>
80555>>>        Procedure OnClick
80558>>>            Send Close_Panel
80559>>>        End_Procedure
80560>>>
80560>>>    End_Object    // oBtnCancel
80561>>>
80561>>>    Object oOrders is a cWinReport2
80563>>>        Set Report_Title to "Customer Report"
80564>>>
80564>>>        //Main File for the report
80564>>>        Set Server to Orderdtl_DD
80565>>>
80565>>>        //Breaks and Index for the report
80565>>>        Report_Breaks ORDERHEA.ORDER_NUMBER
80579>>>        Set Ordering to 1
80580>>>
80580>>>        Function Starting_Main_Report Returns Integer
80583>>>            Integer iRetVal
80583>>>            Send DFSetMetrics WPM_CM
80584>>>            Send DFSetmargins 1 1 1 1
80585>>>            Forward Get Starting_Main_Report To iRetVal
80587>>>            If iRetVal Function_return iRetVal
80590>>>        End_Function
80591>>>
80591>>>        Procedure Page_Top
80594>>>            DFFont "Arial" //  Use Arial
80595>>>            DFFontSize 8
80596>>>            DFBeginHeader DFPageTop
80597>>>                DFHeaderPos   HDR_RIGHT
80598>>>                DFHeaderFrame HDR_NOFRAME
80599>>>                DFWriteLn ("Page:" * "#pagecount#")
80600>>>            DFEndHeader
80602>>>        End_Procedure
80603>>>
80603>>>        Procedure Page_Header
80606>>>            DFFont "Arial"
80607>>>            DFFontSize 14
80608>>>            DFBeginHeader DFPageHeader
80609>>>                DFHeaderFrame HDR_MARGINs 0 RGB_DGREY RGB_DGREY
80610>>>                DFHEADERPOS HDR_LEFT
80611>>>                DFHeaderMargin HM_BottomOuter 0.08
80612>>>                DFWritelnPos "Orders by Order Number Report" 0.10 (FONT_BOLD+RGB_WHITE)
80613>>>            DFEndHeader
80615>>>        End_Procedure
80616>>>
80616>>>        Procedure Page_Title
80619>>>            DFFont "Arial"
80620>>>            DFFontSize 8
80621>>>            DFBeginHeader DFPageTitle
80622>>>                DFHeaderFrame HDR_MARGINs 0 RGB_GREY RGB_GREY
80623>>>                DFHEADERPOS HDR_LEFT
80624>>>                DFWritePos    "Item Id"                 0.1     (FONT_BOLD+RGB_DBLUE)            -1 1.36
80625>>>                DFWritePos    "Description"             4.00    (FONT_BOLD+RGB_DBLUE)            -1 4.77
80626>>>                DFWritePos    "Qty Ordered"             11.5     (FONT_BOLD+FONT_RIGHT+RGB_DBLUE) -1 1.87
80627>>>                DFWritePos    "Price"                   13.22   (FONT_BOLD+FONT_RIGHT+RGB_DBLUE) -1 1.22
80628>>>                DFWritePos    "Extended Price"          16.0    (FONT_BOLD+FONT_RIGHT+RGB_DBLUE) -1 2.38
80629>>>                DFWriteln
80630>>>            DFEndHeader
80632>>>        End_Procedure
80633>>>
80633>>>        Procedure SubHeader1
80636>>>
80636>>>            DFFont "Arial" //  Use Arial
80637>>>            DFFontSize 10
80638>>>
80638>>>            DFBeginHeader DFSubHeader 1    //Header of type DFSubHeader
80639>>>
80639>>>                Send Update_Status ("Order:" * String(OrderHea.Order_number))
80640>>>
80640>>>                DFHeaderWrap HDR_WRAP
80641>>>                DFHeaderLineCheck 5            //Check that the header + 5 lines fits on the page, if not wrap
80642>>>
80642>>>                DFHeaderPos   HDR_LEFT         //Write data from left margin in the header
80643>>>                DFHeaderFrame HDR_NoFrame      //Set the box from margin to margin using size 0.05
80644>>>
80644>>>                DFWriteLnPos    ("Order: "+string(Orderhea.ORDER_NUMBER)) 0.1 (FONT_BOLD)
80645>>>
80645>>>              DFEndHeader                     //End and print header
80647>>>
80647>>>        End_Procedure
80648>>>
80648>>>        Procedure Body
80651>>>
80651>>>            DFFont "Arial" //  Use Arial
80652>>>            DFFontSize 8
80653>>>
80653>>>            DFLineCheck 5
80654>>>
80654>>>            DFWritePos    Invt.ITEM_ID                0.1     (FONT_DEFAULT)            -1 2.28
80655>>>            DFWritePos    Invt.DESCRIPTION            4.00    (FONT_DEFAULT)            -1 4.77
80656>>>            DFWritePos    Orderdtl.QTY_ORDERED        11.5     (FONT_DEFAULT+FONT_RIGHT)  0 1.87
80657>>>            DFWritePos    Orderdtl.PRICE              13.22   (FONT_DEFAULT+FONT_RIGHT)  2 1.22
80658>>>            DFWritePos    Orderdtl.EXTENDED_PRICE     16.0    (FONT_DEFAULT+FONT_RIGHT)  2 2.38
80659>>>            DFWriteln ""
80660>>>
80660>>>            // Using SubTotal in WinPrint.
80660>>>            Send Add_SubTotal 1 (Orderdtl.EXTENDED_PRICE)
80661>>>
80661>>>        End_Procedure
80662>>>
80662>>>        Procedure SubTotal1
80665>>>            Number nAmount
80665>>>            Get SubTotal 1 to nAmount
80666>>>            Send Add_SubTotal 2 nAmount // subtotal 2 is total
80667>>>
80667>>>            DFFont "Arial" //  Use Arial
80668>>>            DFFontSize 8
80669>>>            DFBeginHeader DFSubTotal 1
80670>>>
80670>>>                DFHEADERPOS HDR_LEFT
80671>>>                DFHEADERFRAME HDR_NOFRAME
80672>>>
80672>>>                DFWritelnPos  nAmount         16.0      (FONT_BOLD+FONT_RIGHT) 2 0
80673>>>                DFWriteLine DFGR_CURRLINE DFGR_CURRLINE DFGR_RB_MARGIN DFGR_HORI Rgb_dGrey
80674>>>
80674>>>            DFEndHeader
80676>>>
80676>>>        End_Procedure
80677>>>
80677>>>        Procedure Total
80680>>>            Number nTotal
80680>>>            Get SubTotal 2 to nTotal
80681>>>
80681>>>            DFFont "Arial" //  Use Arial
80682>>>            DFFontSize 8
80683>>>            DFBeginHeader DFTotal           //Header of type DFTotal
80684>>>
80684>>>              DFHeaderPos   HDR_LEFT         //Write data from left margin in the header
80685>>>              DFHeaderFrame HDR_MARGINs 0 RGB_DGREY RGB_GREY //rgb_Cyan rgb_Cyan
80686>>>
80686>>>              DFWritelnPos   nTotal         16.0      (FONT_BOLD+FONT_RIGHT) 2
80687>>>
80687>>>            DFEndHeader                     //End and print header
80689>>>
80689>>>        End_Procedure
80690>>>
80690>>>        Procedure Page_Bottom
80693>>>            DateTime dtDT
80693>>>            Move (CurrentDateTime()) to dtDT
80694>>>
80694>>>            DFFont "Arial" //  Use Arial
80695>>>            DFFontSize 8
80696>>>            DFBeginHeader DFPageBottom
80697>>>                DFHeaderPos   HDR_CENTER       //Write data in center
80698>>>                DFHeaderFrame HDR_MARGINS 0.01 rgb_dGrey
80699>>>                DFWriteLn   ("Report Printed on: " +string(dtDT)) (rgb_dBlue)
80700>>>            DFEndHeader
80702>>>
80702>>>        End_Procedure
80703>>>
80703>>>    End_Object    // oOrders
80704>>>
80704>>>    // Procedures and functions used by the user interface
80704>>>
80704>>>    //This function is called by the procedure StartReport
80704>>>    Function Print_to_Screen_State Returns Integer
80707>>>        Integer iRad
80707>>>        Get Current_Radio of oPrintTo To iRad
80708>>>        Function_Return (iRad=1)
80709>>>    End_Function
80710>>>
80710>>>    // Use this procedure to do print setup
80710>>>    Procedure SetupReport
80713>>>        Boolean bSetupOk
80713>>>        Get DFPrintSetupDialog of (Report_Object_Id(Self)) to bSetupOk
80714>>>    End_Procedure
80715>>>
80715>>>    // Use this procedure to start the report
80715>>>    Procedure StartReport
80718>>>        Integer iToPrinter iRepObj
80718>>>        String sVal
80718>>>        Get Report_Object_Id To iRepObj
80719>>>
80719>>>        Get Print_to_Screen_State to iToPrinter
80720>>>        If iToPrinter Set OutPut_Device_Mode to PRINT_TO_PRINTER
80723>>>        Else Set OutPut_Device_Mode to PRINT_TO_WINDOW
80725>>>
80725>>>        Send Run_Report to iRepObj
80726>>>
80726>>>    End_Procedure
80727>>>
80727>>>End_Object    // oItemsPerOrderWP
80728>        Use WinPrint\OrdersWP.rv
Including file: WinPrint\OrdersWP.rv    (C:\Test\Order Entry git\AppSrc\WinPrint\OrdersWP.rv)
80728>>>Use dfrptvw.pkg
80728>>>Use DataDict.pkg
80728>>>Use dfRadio.pkg
80728>>>Use Windows.pkg
80728>>>Use cWinReport2.pkg
80728>>>Use VENDOR.DD
80728>>>Use INVT.DD
80728>>>Use CUSTOMER.DD
80728>>>Use SALESP.DD
80728>>>Use ORDERHEA.DD
80728>>>Use ORDERDTL.DD
80728>>>
80728>>>ACTIVATE_VIEW Activate_oOrdersWP FOR oOrdersWP
80738>>>>
80738>>>
80738>>>Object oOrdersWP is a ReportView
80740>>>    Set Label to "Orders by Order Number"
80741>>>    Set Location to 6 6
80742>>>    Set Size to 46 175
80743>>>
80743>>>    Object Vendor_DD is a Vendor_DataDictionary
80745>>>    End_Object    // Vendor_DD
80746>>>
80746>>>    Object Invt_DD is a Invt_DataDictionary
80748>>>        Set DDO_Server to Vendor_DD
80749>>>    End_Object    // Invt_DD
80750>>>
80750>>>    Object Customer_DD is a Customer_DataDictionary
80752>>>    End_Object    // Customer_DD
80753>>>
80753>>>    Object SalesP_DD is a Salesp_DataDictionary
80755>>>    End_Object    // SalesP_DD
80756>>>
80756>>>    Object Orderhea_DD is a Orderhea_DataDictionary
80758>>>        Set DDO_Server to Customer_DD
80759>>>        Set DDO_Server to SalesP_DD
80760>>>    End_Object    // Orderhea_DD
80761>>>
80761>>>    Object Orderdtl_DD is a Orderdtl_DataDictionary
80763>>>        Set DDO_Server to Orderhea_DD
80764>>>        Set DDO_Server to Invt_DD
80765>>>    End_Object    // Orderdtl_DD
80766>>>
80766>>>    Object oPrintTo is a RadioGroup
80768>>>        Set Size to 38 105
80769>>>        Set Location to 4 5
80770>>>        Set Label to "Print to"
80771>>>        Object oRadio1 is a Radio
80773>>>            Set Label to "Preview"
80774>>>            Set Size to 10 42
80775>>>            Set Location to 12 6
80776>>>            Set Status_Help to "Prints the report to screen"
80777>>>        End_Object    // oRadio1
80778>>>
80778>>>        Object oRadio2 is a Radio
80780>>>            Set Label to "Printer"
80781>>>            Set Size to 10 42
80782>>>            Set Location to 24 6
80783>>>            Set Status_Help to "Prints the report to printer"
80784>>>        End_Object    // oRadio2
80785>>>
80785>>>    End_Object    // oPrintTo
80786>>>
80786>>>    Object oBtnPrint is a Button
80788>>>        Set Label to "Print"
80789>>>        Set Location to 10 120
80790>>>        Set Status_Help to "Print the Selected report"
80791>>>        Set Default_State to True
80792>>>
80792>>>        Procedure OnClick
80795>>>            Send StartReport
80796>>>        End_Procedure
80797>>>
80797>>>    End_Object    // oBtnPrint
80798>>>
80798>>>    Object oBtnCancel is a Button
80800>>>        Set Label to "Cancel"
80801>>>        Set Location to 28 120
80802>>>        Set Status_Help to "Close this Panel"
80803>>>
80803>>>        Procedure OnClick
80806>>>            Send Close_Panel
80807>>>        End_Procedure
80808>>>
80808>>>    End_Object    // oBtnCancel
80809>>>
80809>>>    Object oOrders is a cWinReport2
80811>>>        Set Report_Title to "Customer Report"
80812>>>
80812>>>        //Main File for the report
80812>>>        Set Server to Orderdtl_DD
80813>>>
80813>>>        //Breaks and Index for the report
80813>>>        Report_Breaks ORDERHEA.ORDER_NUMBER
80827>>>        Report_Index By 1
80829>>>
80829>>>        Function Starting_Main_Report Returns Integer
80832>>>            Integer iRetVal
80832>>>            Set PrintDlgInPreview of WinprintId to True
80833>>>            Send DFSetMetrics To WinPrintId "CM"
80834>>>            Send DFSetmargins To WinPrintId 1 1 1 1
80835>>>            Forward Get Starting_Main_Report To iRetVal
80837>>>            If iRetVal Function_return iRetVal
80840>>>        End_Function
80841>>>
80841>>>        Procedure Page_Top
80844>>>            DFFont "Arial" //  Use Arial
80845>>>            DFFontSize 8
80846>>>            DFBeginHeader DFPageTop
80847>>>                DFHeaderPos   HDR_RIGHT
80848>>>                DFHeaderFrame HDR_NOFRAME
80849>>>                DFWriteLn ("Page:" * "#pagecount#")
80850>>>            DFEndHeader
80852>>>        End_Procedure
80853>>>
80853>>>        Procedure Page_Title
80856>>>            DFFont "Arial"
80857>>>            DFFontSize 14
80858>>>            DFBeginHeader DFPageTitle
80859>>>                DFHeaderFrame HDR_MARGINs 0 RGB_DGREY RGB_DGREY
80860>>>                DFHEADERPOS HDR_LEFT
80861>>>                DFWritelnPos "Orders by Order Number Report" 0.10 (FONT_BOLD+RGB_WHITE)
80862>>>            DFEndHeader
80864>>>        End_Procedure
80865>>>
80865>>>        Procedure SubHeader1
80868>>>
80868>>>            DFFont "Arial" //  Use Arial
80869>>>            DFFontSize 8
80870>>>
80870>>>            DFBeginHeader DFSubHeader 1    //Header of type DFSubHeader
80871>>>
80871>>>                Send Update_Status ("Order:" * String(OrderHea.Order_number))
80872>>>
80872>>>
80872>>>                DFHeaderWrap HDR_WRAP
80873>>>                DFHeaderLineCheck 5            //Check that the header + 5 lines fits on the page, if not wrap
80874>>>
80874>>>                DFHeaderPos   HDR_LEFT         //Write data from left margin in the header
80875>>>                DFHeaderFrame HDR_NoFrame      //Set the box from margin to margin using size 0.05
80876>>>                DFHeaderMargin hm_BottomOuter 0.04
80877>>>
80877>>>                DFWritePos    "Order Number"            0.10  (FONT_BOLD+RGB_DBLUE)
80878>>>                DFWritelnPos  Orderhea.ORDER_NUMBER       4.0   (FONT_DEFAULT)
80879>>>                DFWritePos    "Order Date"              0.10  (FONT_BOLD+RGB_DBLUE)
80880>>>                DFWritelnPos  Orderhea.ORDER_DATE         4.0   (FONT_DEFAULT)
80881>>>                DFWritePos    "Customer Number"         0.10  (FONT_BOLD+RGB_DBLUE)
80882>>>                DFWritelnPos  Customer.CUSTOMER_NUMBER    4.0
80883>>>                DFWritePos    "Name"                    0.10  (FONT_BOLD+RGB_DBLUE)
80884>>>                DFWritelnPos  Customer.NAME               4.0   (FONT_DEFAULT)
80885>>>                DFWritePos    "Address"                 0.10  (FONT_BOLD+RGB_DBLUE)
80886>>>                DFWritelnPos  Customer.ADDRESS            4.0   (FONT_DEFAULT)
80887>>>                DFWritePos    "City"                    0.10  (FONT_BOLD+RGB_DBLUE)
80888>>>                DFWritelnPos  Customer.CITY               4.0   (FONT_DEFAULT)
80889>>>                DFWritePos    "State"                   0.10  (FONT_BOLD+RGB_DBLUE)
80890>>>                DFWritelnPos  Customer.STATE              4.0   (FONT_DEFAULT)
80891>>>                DFWritePos    "Zip"                     0.10  (FONT_BOLD+RGB_DBLUE)
80892>>>                DFWritelnPos  Customer.ZIP                4.0   (FONT_DEFAULT)
80893>>>                DFWritePos    "Terms"                   0.10  (FONT_BOLD+RGB_DBLUE)
80894>>>                DFWritelnPos  Orderhea.TERMS              4.0   (FONT_DEFAULT)
80895>>>                DFWritePos    "Ship Via"                0.10  (FONT_BOLD+RGB_DBLUE)
80896>>>                DFWritelnPos  Orderhea.SHIP_VIA           4.0   (FONT_DEFAULT)
80897>>>                DFFontSize 2
80898>>>                DFWriteLn
80899>>>
80899>>>                DFFontSize 8
80900>>>                DfWriteRect DFGR_CURRLINE 0 0.34 DFGR_RB_MARGIN RGB_GREY 0.0 dfgr_noWrap RGB_GREY
80901>>>                DFWritePos    "Item Id"                 0.1     (FONT_BOLD+RGB_DBLUE)            -1 1.36
80902>>>                DFWritePos    "Description"             4.00    (FONT_BOLD+RGB_DBLUE)            -1 4.77
80903>>>                DFWritePos    "Qty Ordered"             11.5     (FONT_BOLD+FONT_RIGHT+RGB_DBLUE) -1 1.87
80904>>>                DFWritePos    "Price"                   13.22   (FONT_BOLD+FONT_RIGHT+RGB_DBLUE) -1 1.22
80905>>>                DFWritePos    "Extended Price"          16.0    (FONT_BOLD+FONT_RIGHT+RGB_DBLUE) -1 2.40
80906>>>                DFWriteln
80907>>>
80907>>>              DFEndHeader                     //End and print header
80909>>>
80909>>>        End_Procedure
80910>>>
80910>>>        Procedure Body
80913>>>
80913>>>            DFFont "Arial" //  Use Arial
80914>>>            DFFontSize 8
80915>>>
80915>>>            DFLineCheck 5
80916>>>
80916>>>            DFWritePos    Invt.ITEM_ID                0.1     (FONT_DEFAULT)            -1 2.28
80917>>>            DFWritePos    Invt.DESCRIPTION            4.00    (FONT_DEFAULT)            -1 4.77
80918>>>            DFWritePos    Orderdtl.QTY_ORDERED        11.5     (FONT_DEFAULT+FONT_RIGHT)  0 1.87
80919>>>            DFWritePos    Orderdtl.PRICE              13.22   (FONT_DEFAULT+FONT_RIGHT)  2 1.22
80920>>>            DFWritePos    Orderdtl.EXTENDED_PRICE     16.0    (FONT_DEFAULT+FONT_RIGHT)  2 2.40
80921>>>            DFWriteln
80922>>>
80922>>>            // Using SubTotal in WinPrint.
80922>>>            Send Add_SubTotal 1 (Orderdtl.EXTENDED_PRICE)
80923>>>
80923>>>        End_Procedure
80924>>>
80924>>>        Procedure SubTotal1
80927>>>            Number nAmount
80927>>>            Get SubTotal 1 to nAmount
80928>>>            Send Add_SubTotal 2 nAmount // subtotal 2 is total
80929>>>
80929>>>            DFFont "Arial" //  Use Arial
80930>>>            DFFontSize 8
80931>>>            DFBeginHeader DFSubTotal 1
80932>>>
80932>>>                DFHEADERPOS HDR_LEFT
80933>>>                  DFHeaderFrame hdr_margins 0.01 rgb_grey rgb_Grey
80934>>>                  dfHeaderMargin hm_bottomOuter 0.10
80935>>>                  dfHeaderMargin hm_bottomInner 0.01
80936>>>                  dfHeaderMargin hm_TopInner    0.01
80937>>>
80937>>>                DFWritelnPos  nAmount         16.0      (Font_BOLD+FONT_RIGHT) 2 0
80938>>>            DFEndHeader
80940>>>
80940>>>        End_Procedure
80941>>>
80941>>>        Procedure Total
80944>>>            Number nTotal
80944>>>            Get SubTotal 2 to nTotal
80945>>>
80945>>>            DFFont "Arial" //  Use Arial
80946>>>            DFFontSize 8
80947>>>            DFBeginHeader DFTotal           //Header of type DFTotal
80948>>>
80948>>>              DFHeaderPos   HDR_LEFT         //Write data from left margin in the header
80949>>>              DFHeaderFrame HDR_MARGINs 0 RGB_DGREY RGB_GREY //rgb_Cyan rgb_Cyan
80950>>>
80950>>>              DFWritelnPos   nTotal         16.0      (FONT_BOLD+FONT_RIGHT) 2
80951>>>
80951>>>            DFEndHeader                     //End and print header
80953>>>
80953>>>        End_Procedure
80954>>>
80954>>>        Procedure Page_Bottom
80957>>>            DateTime dtDT
80957>>>            Move (CurrentDateTime()) to dtDT
80958>>>
80958>>>            DFFont "Arial" //  Use Arial
80959>>>            DFFontSize 8
80960>>>            DFBeginHeader DFPageBottom
80961>>>                DFHeaderPos   HDR_CENTER       //Write data in center
80962>>>                DFHeaderFrame HDR_MARGINS 0.01 rgb_dGrey
80963>>>                DFWriteLn   ("Report Printed on: " +string(dtDT)) (rgb_dBlue)
80964>>>            DFEndHeader
80966>>>
80966>>>        End_Procedure
80967>>>
80967>>>    End_Object    // oOrders
80968>>>
80968>>>    // Procedures and functions used by the user interface
80968>>>
80968>>>    //This function is called by the procedure StartReport
80968>>>    Function Print_to_Screen_State Returns Integer
80971>>>        Integer iRad
80971>>>        Get Current_Radio of oPrintTo To iRad
80972>>>        Function_Return (iRad=1)
80973>>>    End_Function
80974>>>
80974>>>    // Use this procedure to do print setup
80974>>>    Procedure SetupReport
80977>>>        Boolean bSetupOk
80977>>>        Get DFPrintSetupDialog of (Report_Object_Id(Self)) to bSetupOk
80978>>>    End_Procedure
80979>>>
80979>>>    // Use this procedure to start the report
80979>>>    Procedure StartReport
80982>>>        Integer iToPrinter iRepObj
80982>>>        String sVal
80982>>>        Get Report_Object_Id To iRepObj
80983>>>
80983>>>        Get Print_to_Screen_State to iToPrinter
80984>>>        If iToPrinter Set OutPut_Device_Mode to PRINT_TO_PRINTER
80987>>>        Else Set OutPut_Device_Mode to PRINT_TO_WINDOW
80989>>>
80989>>>        Send Run_Report to iRepObj
80990>>>
80990>>>    End_Procedure
80991>>>
80991>>>End_Object    // oOrdersWP
80992>        Use WinPrint\OrdersByCustomerWP.rv
Including file: WinPrint\OrdersByCustomerWP.rv    (C:\Test\Order Entry git\AppSrc\WinPrint\OrdersByCustomerWP.rv)
80992>>>Use dfrptvw.pkg
80992>>>Use DataDict.pkg
80992>>>Use dfRadio.pkg
80992>>>Use Windows.pkg
80992>>>Use cWinReport2.pkg
80992>>>Use VENDOR.DD
80992>>>Use INVT.DD
80992>>>Use CUSTOMER.DD
80992>>>Use SALESP.DD
80992>>>Use ORDERHEA.DD
80992>>>Use ORDERDTL.DD
80992>>>
80992>>>ACTIVATE_VIEW Activate_oOrdersByCustomerWP FOR oOrdersByCustomerWP
81002>>>>
81002>>>
81002>>>Object oOrdersByCustomerWP is a ReportView
81004>>>
81004>>>    property integer main_dd
81006>>>    Property integer server
81008>>>
81008>>>    Set Label to "Orders by Customer"
81009>>>    Set Location to 6 6
81010>>>    Set Size to 110 174
81011>>>
81011>>>    Object Vendor_DD is a Vendor_DataDictionary
81013>>>    End_Object    // Vendor_DD
81014>>>
81014>>>    Object Invt_DD is a Invt_DataDictionary
81016>>>        Set DDO_Server to Vendor_DD
81017>>>    End_Object    // Invt_DD
81018>>>
81018>>>    Object Customer_DD is a Customer_DataDictionary
81020>>>    End_Object    // Customer_DD
81021>>>
81021>>>    Object SalesP_DD is a Salesp_DataDictionary
81023>>>    End_Object    // SalesP_DD
81024>>>
81024>>>    Object Orderhea_DD is a Orderhea_DataDictionary
81026>>>        Set DDO_Server to Customer_DD
81027>>>        Set DDO_Server to SalesP_DD
81028>>>        Set Constrain_File to Customer.File_Number
81029>>>    End_Object    // Orderhea_DD
81030>>>
81030>>>    Object Orderdtl_DD is a Orderdtl_DataDictionary
81032>>>        Set DDO_Server to Orderhea_DD
81033>>>        Set DDO_Server to Invt_DD
81034>>>        Set Constrain_File to Orderhea.File_Number
81035>>>    End_Object    // Orderdtl_DD
81036>>>
81036>>>    Set Main_DD to Customer_DD
81037>>>    Set Server to Customer_DD
81038>>>
81038>>>    Object oPrintTo is a RadioGroup
81040>>>        Set Size to 38 105
81041>>>        Set Location to 5 5
81042>>>        Set Label to "Print to"
81043>>>        Object oRadio1 is a Radio
81045>>>            Set Label to "Preview"
81046>>>            Set Size to 10 42
81047>>>            Set Location to 12 6
81048>>>            Set Status_Help to "Prints the report to screen"
81049>>>        End_Object    // oRadio1
81050>>>
81050>>>        Object oRadio2 is a Radio
81052>>>            Set Label to "Printer"
81053>>>            Set Size to 10 42
81054>>>            Set Location to 24 6
81055>>>            Set Status_Help to "Prints the report to printer"
81056>>>        End_Object    // oRadio2
81057>>>
81057>>>    End_Object    // oPrintTo
81058>>>
81058>>>    Object oReportOrder is a RadioGroup
81060>>>        Set Size to 38 105
81061>>>        Set Location to 45 5
81062>>>        Set Label to "Report Order"
81063>>>        Object oRadio3 is a Radio
81065>>>            Set Label to "Customer Number"
81066>>>            Set Size to 10 73
81067>>>            Set Location to 12 6
81068>>>            Set Status_Help to "Prints the report to screen"
81069>>>        End_Object    // oRadio3
81070>>>
81070>>>        Object oRadio4 is a Radio
81072>>>            Set Label to "Customer Name"
81073>>>            Set Size to 10 67
81074>>>            Set Location to 24 6
81075>>>            Set Status_Help to "Prints the report to printer"
81076>>>        End_Object    // oRadio4
81077>>>
81077>>>        Function OrderByNumber returns boolean
81080>>>            function_return (current_radio(self)=0)
81081>>>        end_function
81082>>>        
81082>>>    End_Object    // oReportOrder
81083>>>
81083>>>    Object oSetupButton is a Button
81085>>>        Set Label to "Printer Setup"
81086>>>        Set Location to 7 120
81087>>>
81087>>>        Procedure OnClick
81090>>>            Boolean bSetupOk
81090>>>            Get DFPrintSetupDialog of oOrders to bSetupOk
81091>>>        End_Procedure
81092>>>
81092>>>    End_Object    // oSetupButton
81093>>>
81093>>>    Object oBtnPrint is a Button
81095>>>        Set Label to "Print"
81096>>>        Set Location to 49 120
81097>>>        Set Status_Help to "Print the Selected report"
81098>>>        Set Default_State to True
81099>>>
81099>>>        Procedure OnClick
81102>>>            boolean bByNumber
81102>>>            Get OrderByNumber of oReportOrder  to bByNumber
81103>>>            Set Ordering of oOrders to (if(bByNumber,1,2))
81104>>>            Send StartReport
81105>>>        End_Procedure
81106>>>
81106>>>    End_Object    // oBtnPrint
81107>>>
81107>>>    Object oBtnCancel is a Button
81109>>>        Set Label to "Cancel"
81110>>>        Set Location to 67 120
81111>>>        Set Status_Help to "Close this Panel"
81112>>>
81112>>>        Procedure OnClick
81115>>>            Send Close_Panel
81116>>>        End_Procedure
81117>>>
81117>>>    End_Object    // oBtnCancel
81118>>>
81118>>>    Object oOnePageCkBx is a CheckBox
81120>>>        Set Label to "New Page for Each Customer"
81121>>>        Set Size to 10 110
81122>>>        Set Location to 92 6
81123>>>
81123>>>        Procedure OnChange
81126>>>            Boolean bChecked
81126>>>        
81126>>>            Get Checked_State To bChecked
81127>>>        End_Procedure // OnChange
81128>>>
81128>>>    End_Object    // oOnePageCkBx
81129>>>
81129>>>    Object oOrders is a cWinReport2
81131>>>
81131>>>        Property Boolean pbOnePagePerCust False
81133>>>        
81133>>>        Set Report_Title to "Printing all Orders by Customer"
81134>>>        
81134>>>        //Main File for the report
81134>>>        Set Server to Customer_DD
81135>>>        //Breaks and Index for the report
81135>>>        Report_Breaks Customer.Customer_number
81149>>>        
81149>>>        Set Ordering to 2
81150>>>        
81150>>>        Object oOrderHea is a cWinReport2
81152>>>
81152>>>            Set Server to Orderhea_DD
81153>>>            Report_Breaks ORDERHEA.Order_number
81167>>>            set Ordering to 2
81168>>>
81168>>>            Object oOrderDtl is a cWinReport2
81170>>>
81170>>>                Set Server to Orderdtl_DD
81171>>>                Report_Breaks Orderhea.Order_Number
81185>>>                Set Ordering to 1
81186>>>                
81186>>>                Procedure SubHeader1
81189>>>                      Send Update_Status (Customer.Name - '/' - string(Orderhea.Order_number))
81190>>>                
81190>>>                      DFFont "Arial"
81191>>>                      DFFontSize 8
81192>>>                
81192>>>                      DFBeginHeader DFSubHeader 2
81193>>>                        DFHeaderFrame hdr_NoFrame
81194>>>                        DFHeaderPos   hdr_Left
81195>>>                        DFHeaderWrap hdr_Wrap
81196>>>                        DfHeaderMargin hm_BottomOuter 0.04
81197>>>                        DFHeaderLineCheck 5            //Check that the header + 5 lines fits on the page, if not wrap
81198>>>                
81198>>>                        DFWritePos    "Order Number"            0.10  (FONT_BOLD+RGB_DBLUE)
81199>>>                        DFWritelnPos  Orderhea.Order_number       4.0   (FONT_DEFAULT)
81200>>>                        DFWritePos    "Order Date"              0.10  (FONT_BOLD+RGB_DBLUE)
81201>>>                        DFWritelnPos  Orderhea.Order_date         4.0   (FONT_DEFAULT)
81202>>>                        DFWritePos    "Terms"                   0.10  (FONT_BOLD+RGB_DBLUE)
81203>>>                        DFWritelnPos  Orderhea.Terms              4.0   (FONT_DEFAULT)
81204>>>                        DFWritePos    "Ship Via"                0.10  (FONT_BOLD+RGB_DBLUE)
81205>>>                        DFWritelnPos  Orderhea.Ship_via           4.0   (FONT_DEFAULT)
81206>>>                
81206>>>                        DfWriteRect dfgr_CurrLine 0 0.34 dfgr_rb_Margin rgb_Grey 0.0 dfgr_NoWrap rgb_Grey
81207>>>                        DFWritePos    "Item Id"                 0.1     (FONT_BOLD+RGB_DBLUE)            -1 1.36
81208>>>                        DFWritePos    "Description"             4.00    (FONT_BOLD+RGB_DBLUE)            -1 4.77
81209>>>                        DFWritePos    "Qty Ordered"             11.5     (FONT_BOLD+FONT_RIGHT+RGB_DBLUE) -1 1.87
81210>>>                        DFWritePos    "Price"                   13.22   (FONT_BOLD+FONT_RIGHT+RGB_DBLUE) -1 1.22
81211>>>                        DFWritePos    "Extended Price"          16.0    (FONT_BOLD+FONT_RIGHT+RGB_DBLUE) -1 2.50
81212>>>                        DFWriteln
81213>>>                
81213>>>                      DFEndHeader
81215>>>                
81215>>>                End_Procedure
81216>>>                
81216>>>                Procedure Body // order detail body
81219>>>                
81219>>>                    DFFont "Arial"
81220>>>                    DFFontSize 8
81221>>>                
81221>>>                    DFLineCheck 5
81222>>>                
81222>>>                    DFWritePos    Invt.Item_id                0.1     (FONT_DEFAULT)            -1 2.28
81223>>>                    DFWritePos    Invt.Description            4.00    (FONT_DEFAULT)            -1 4.77
81224>>>                    DFWritePos    Orderdtl.Qty_ordered        11.5     (FONT_DEFAULT+FONT_RIGHT)  0 1.87
81225>>>                    DFWritePos    Orderdtl.Price              13.22   (FONT_DEFAULT+FONT_RIGHT)  2 1.22
81226>>>                    DFWritePos    Orderdtl.Extended_price     16.0    (FONT_DEFAULT+FONT_RIGHT)  2 2.50
81227>>>                    DFWriteln
81228>>>                
81228>>>                    // Using rectotal in WinPrint.
81228>>>                    Send Add_SubTotal 1 (Orderdtl.Extended_price)
81229>>>                
81229>>>                End_Procedure
81230>>>                
81230>>>                Procedure SubTotal1 // order total
81233>>>                    Number nAmount
81233>>>                
81233>>>                    Get SubTotal 1 to nAmount
81234>>>                    Send Add_SubTotal 2 nAmount // subtotal 2 is customer total
81235>>>                
81235>>>                    DFFont "Arial"
81236>>>                    DFFontSize 8
81237>>>                    DFBeginHeader DFSubTotal 2
81238>>>                        DFHeaderPos hdr_Left
81239>>>                        DFHeaderFrame hdr_Margins 0.01 rgb_dGrey rgb_Grey
81240>>>                        DfHeaderMargin hm_TopInner 0.02
81241>>>                        DfHeaderMargin hm_BottomInner 0.02
81242>>>                        DfHeaderMargin hm_BottomOuter 0.08
81243>>>                        DfHeaderMargin hm_TopOuter 0.04
81244>>>                
81244>>>                        DFWritePos   "Order Total:"  14.0  (FONT_BOLD+RGB_DBLUE+FONT_RIGHT)
81245>>>                        DFWritelnPos nAmount         16.0   (FONT_RIGHT) 2
81246>>>                    DFEndHeader
81248>>>                
81248>>>                End_Procedure
81249>>>                
81249>>>            End_Object    // oOrderDtl
81250>>>
81250>>>        End_Object    // oOrderHea
81251>>>        
81251>>>        Function Starting_Main_Report Returns Integer
81254>>>            Integer iRetVal bBreak
81254>>>            Get OnePagePerCust to bBreak
81255>>>            Set pbOnePagePerCust to bBreak
81256>>>            Send DFSetMetrics to WinPrintId "CM"
81257>>>            Send DFSetmargins to WinPrintId 1 1 1 1
81258>>>            Forward Get Starting_Main_Report to iRetVal
81260>>>            If iRetVal Function_Return iRetVal
81263>>>        End_Function
81264>>>        
81264>>>        Procedure Page_Top
81267>>>            DFFont "Arial"
81268>>>            DFFontSize 8
81269>>>            DFBeginHeader DFPageTop
81270>>>                DFHeaderFrame hdr_NoFrame
81271>>>                DFHeaderPos   hdr_Right
81272>>>        
81272>>>                DFWriteLn ("Page:" * "#pagecount#")
81273>>>            DFEndHeader
81275>>>        End_Procedure
81276>>>        
81276>>>        Procedure Page_Title
81279>>>            DFFont "Arial"
81280>>>            DFFontSize 14
81281>>>            DFBeginHeader DFPageTitle
81282>>>                DFHeaderFrame hdr_Margins 0.01 rgb_dGrey rgb_dGrey
81283>>>                DFHeaderPos hdr_Left
81284>>>                DFHeaderMargin hm_BottomOuter 0.08
81285>>>        
81285>>>                DFWriteLnPos "Orders by Customer Report" 0.10 (FONT_BOLD+RGB_WHITE)
81286>>>            DFEndHeader
81288>>>        End_Procedure
81289>>>        
81289>>>        Procedure SubHeader1
81292>>>            Integer iClr
81292>>>            DFFont "Arial" //  Use Arial
81293>>>            DFFontSize 8
81294>>>            Get DFGetDFColor of winprintId  242 242 242 to iClr // Move -218959360 to iClr  can be used instead
81295>>>        
81295>>>            DFBeginHeader DFSubHeader 1 // customer sub-header
81296>>>                DFHeaderFrame hdr_Margins 0.01 rgb_dGrey iClr
81297>>>                DFHeaderPos   hdr_Left
81298>>>                DFHeaderWrap hdr_Wrap
81299>>>                DFHeaderLineCheck 10 //Check that the header + 10 lines fits on the page, if not wrap
81300>>>        
81300>>>                DFWritePos    "Customer Number"         0.10  (FONT_BOLD+RGB_DBLUE)
81301>>>                DFWriteLnPos  Customer.Customer_number    4.0
81302>>>                DFWritePos    "Name"                    0.10  (FONT_BOLD+RGB_DBLUE)
81303>>>                DFWriteLnPos  Customer.Name               4.0   (FONT_DEFAULT)
81304>>>                DFWritePos    "Address"                 0.10  (FONT_BOLD+RGB_DBLUE)
81305>>>                DFWriteLnPos  Customer.Address            4.0   (FONT_DEFAULT)
81306>>>                DFWritePos    "City"                    0.10  (FONT_BOLD+RGB_DBLUE)
81307>>>                DFWriteLnPos  Customer.City               4.0   (FONT_DEFAULT)
81308>>>                DFWritePos    "State"                   0.10  (FONT_BOLD+RGB_DBLUE)
81309>>>                DFWriteLnPos  Customer.State              4.0   (FONT_DEFAULT)
81310>>>                DFWritePos    "Zip"                     0.10  (FONT_BOLD+RGB_DBLUE)
81311>>>                DFWriteLnPos  Customer.Zip                4.0   (FONT_DEFAULT)
81312>>>            DFEndHeader
81314>>>        End_Procedure
81315>>>        
81315>>>        Procedure SubTotal1 // customer total
81318>>>            Number nAmount
81318>>>            Integer iClr
81318>>>            Boolean bBreak
81318>>>        
81318>>>            Get SubTotal 2 to nAmount
81319>>>            Send Add_SubTotal 3 nAmount // subtotal 3 is total of all
81320>>>        
81320>>>            Get DFGetDFColor of winprintId  242 242 242 to iClr // Move -218959360 to iClr   can be used instead
81321>>>        
81321>>>            DFFont "Arial" //  Use Arial
81322>>>            DFFontSize 8
81323>>>            DFBeginHeader DFSubTotal 1
81324>>>                DFHeaderPos hdr_Left
81325>>>                DFHeaderFrame hdr_Margins 0.01 rgb_dGrey iClr
81326>>>                DFHeaderMargin hm_BottomOuter 0.16
81327>>>        
81327>>>                DFWritePos   "Customer Total:"  14.0 (FONT_BOLD+RGB_DBLUE+FONT_RIGHT)
81328>>>                DFWriteLnPos nAmount 16.0              (FONT_RIGHT+FONT_Bold) 2 0
81329>>>            DFEndHeader
81331>>>            Get pbOnePagePerCust to bBreak
81332>>>            If bBreak Begin
81334>>>                Send DFNew_Page
81335>>>            End
81335>>>>
81335>>>        End_Procedure
81336>>>        
81336>>>        Procedure Total // total of all customers
81339>>>            Number nTotal
81339>>>            Get SubTotal 3 to nTotal
81340>>>        
81340>>>            DFFont "Arial" //  Use Arial
81341>>>            DFFontSize 10
81342>>>        
81342>>>            DFBeginHeader DFTotal
81343>>>        
81343>>>                DFHeaderPos   hdr_Left
81344>>>                DFHeaderFrame hdr_Margins 0.01 rgb_dGrey rgb_Grey
81345>>>        
81345>>>                DFWritePos    "Grand Total:"  14.0        (FONT_BOLD+RGB_DBLUE+FONT_RIGHT)
81346>>>                DFWriteLnPos   nTotal         16.0      (FONT_BOLD+FONT_RIGHT) 2
81347>>>        
81347>>>            DFEndHeader                     //End and print header
81349>>>        
81349>>>        End_Procedure
81350>>>        
81350>>>        Procedure Page_Bottom
81353>>>            DateTime dtDT
81353>>>            Move (CurrentDateTime()) to dtDT
81354>>>        
81354>>>            DFFont "Arial"
81355>>>            DFFontSize 8
81356>>>            DFBeginHeader DFPageBottom
81357>>>                DFHeaderPos   hdr_Center
81358>>>                DFHeaderFrame hdr_Margins 0.01 rgb_dGrey
81359>>>                DFWriteLn   ("Report Printed on: " +String(dtDT)) (rgb_dBlue)
81360>>>            DFEndHeader
81362>>>        
81362>>>        End_Procedure
81363>>>
81363>>>    End_Object    // oOrders
81364>>>
81364>>>    // Procedures and functions used by the user interface
81364>>>    
81364>>>    //This function is called by the procedure StartReport
81364>>>    Function Print_to_Screen_State Returns Integer
81367>>>        Integer iRad
81367>>>        Get Current_Radio of oPrintTo To iRad
81368>>>        Function_Return (iRad=1)
81369>>>    End_Function
81370>>>    
81370>>>    // Use this procedure to do print setup
81370>>>    Procedure SetupReport
81373>>>        Boolean bSetupOk
81373>>>        Get DFPrintSetupDialog of oOrders to bSetupOk
81374>>>    End_Procedure
81375>>>    
81375>>>    // Use this procedure to start the report
81375>>>    Procedure StartReport
81378>>>        Boolean bToPrinter
81378>>>        String sVal
81378>>>        Get Print_to_Screen_State to bToPrinter
81379>>>        If bToPrinter Set OutPut_Device_Mode to PRINT_TO_PRINTER
81382>>>        Else          Set OutPut_Device_Mode to PRINT_TO_WINDOW
81384>>>    
81384>>>        Send Run_Report of oOrders
81385>>>    
81385>>>    End_Procedure
81386>>>    
81386>>>    Function OnePagePerCust returns boolean
81389>>>        boolean bBreak
81389>>>        Get checked_state of oOnePageCkBx to bBreak
81390>>>        Function_return bBreak
81391>>>    end_function
81392>>>    
81392>>>    // The Report
81392>>>    //    Object oOrders is a cWinReport2
81392>>>    //    //Object oOrders is a WinReport
81392>>>    
81392>>>    //        Property Boolean pbOnePagePerCust False
81392>>>    //        Set Report_Title to "Printing all Orders by Customer"
81392>>>    
81392>>>    //        //Main File for the report
81392>>>    //        Set Server to Customer_DD
81392>>>    //        //Breaks and Index for the report
81392>>>    //        Report_Breaks ORDERHEA.CUSTOMER_NUMBER
81392>>>    //        Set Ordering to 2
81392>>>    
81392>>>    //        Function Starting_Main_Report Returns Integer
81392>>>    //            Integer iRetVal bBreak
81392>>>    //            Get OnePagePerCust to bBreak
81392>>>    //            Set pbOnePagePerCust to bBreak
81392>>>    //            Send DFSetMetrics To WinPrintId "CM"
81392>>>    //            Send DFSetmargins To WinPrintId 1 1 1 1
81392>>>    //            Forward Get Starting_Main_Report To iRetVal
81392>>>    //            If iRetVal Function_return iRetVal
81392>>>    //        End_Function
81392>>>    
81392>>>    //        Procedure Page_Top
81392>>>    //            DFFont "Arial"
81392>>>    //            DFFontSize 8
81392>>>    //            DFBeginHeader DFPageTop
81392>>>    //                DFHeaderFrame HDR_NOFRAME
81392>>>    //                DFHeaderPos   HDR_RIGHT
81392>>>    
81392>>>    //                DFWriteLn ("Page:" * "#pagecount#")
81392>>>    //            DFEndHeader
81392>>>    //        End_Procedure
81392>>>    
81392>>>    //        Procedure Page_Title
81392>>>    //            DFFont "Arial"
81392>>>    //            DFFontSize 14
81392>>>    //            DFBeginHeader DFPageTitle
81392>>>    //                DFHeaderFrame HDR_MARGINs 0.01 RGB_DGREY RGB_DGREY
81392>>>    //                DFHEADERPOS HDR_LEFT
81392>>>    //                DfHeaderMargin hm_BottomOuter 0.08
81392>>>    
81392>>>    //                DFWritelnPos "Orders by Customer Report" 0.10 (FONT_BOLD+RGB_WHITE)
81392>>>    //            DFEndHeader
81392>>>    //        End_Procedure
81392>>>    
81392>>>    //        Procedure SubHeader1
81392>>>    //            integer iClr
81392>>>    //            DFFont "Arial" //  Use Arial
81392>>>    //            DFFontSize 8
81392>>>    //            //Get DFGetDFColor of winprintId  242 242 242 to iClr // doesn't work YET
81392>>>    //            Move -218959360 to iClr
81392>>>    
81392>>>    //            DFBeginHeader DFSubHeader 1 // customer sub-header
81392>>>    //                DFHeaderFrame hdr_Margins 0.01 rgb_dGrey iClr
81392>>>    //                DFHeaderPos   HDR_LEFT
81392>>>    //                DFHeaderWrap HDR_WRAP
81392>>>    //                DFHeaderLineCheck 10 //Check that the header + 10 lines fits on the page, if not wrap
81392>>>    
81392>>>    //                DFWritePos    "Customer Number"         0.10  (FONT_BOLD+RGB_DBLUE)
81392>>>    //                DFWritelnPos  Customer.CUSTOMER_NUMBER    4.0
81392>>>    //                DFWritePos    "Name"                    0.10  (FONT_BOLD+RGB_DBLUE)
81392>>>    //                DFWritelnPos  Customer.NAME               4.0   (FONT_DEFAULT)
81392>>>    //                DFWritePos    "Address"                 0.10  (FONT_BOLD+RGB_DBLUE)
81392>>>    //                DFWritelnPos  Customer.ADDRESS            4.0   (FONT_DEFAULT)
81392>>>    //                DFWritePos    "City"                    0.10  (FONT_BOLD+RGB_DBLUE)
81392>>>    //                DFWritelnPos  Customer.CITY               4.0   (FONT_DEFAULT)
81392>>>    //                DFWritePos    "State"                   0.10  (FONT_BOLD+RGB_DBLUE)
81392>>>    //                DFWritelnPos  Customer.STATE              4.0   (FONT_DEFAULT)
81392>>>    //                DFWritePos    "Zip"                     0.10  (FONT_BOLD+RGB_DBLUE)
81392>>>    //                DFWritelnPos  Customer.ZIP                4.0   (FONT_DEFAULT)
81392>>>    //            DFEndHeader
81392>>>    //        End_Procedure
81392>>>    
81392>>>    //        Object oOrderHea is a cWinReport2
81392>>>    //    //        Object oOrders is a WinReport
81392>>>    
81392>>>    //            Set Server to Orderhea_DD
81392>>>    //            Report_Breaks ORDERHEA.Order_number
81392>>>    //            set Ordering to 2
81392>>>    
81392>>>    //            Object oOrderDtl is a cWinReport2
81392>>>    //    //            Object oOrders is a WinReport
81392>>>    
81392>>>    //                Set Server to Orderdtl_DD
81392>>>    //                Report_Breaks ORDERHEA.Order_Number
81392>>>    //                Set Ordering to 1
81392>>>    
81392>>>    //                Procedure SubHeader1 // order sub-header
81392>>>    //                      Send Update_Status (Customer.Name - '/' - string(Orderhea.order_number))
81392>>>    
81392>>>    //                      DFFont "Arial"
81392>>>    //                      DFFontSize 8
81392>>>    
81392>>>    //                      DFBeginHeader DFSubHeader 2
81392>>>    //                        DFHeaderFrame hdr_NoFrame
81392>>>    //                        DFHeaderPos   HDR_LEFT
81392>>>    //                        DFHeaderWrap HDR_WRAP
81392>>>    //                        DfHeaderMargin hm_BottomOuter 0.04
81392>>>    //                        DFHeaderLineCheck 5            //Check that the header + 5 lines fits on the page, if not wrap
81392>>>    
81392>>>    //                        DFWritePos    "Order Number"            0.10  (FONT_BOLD+RGB_DBLUE)
81392>>>    //                        DFWritelnPos  Orderhea.ORDER_NUMBER       4.0   (FONT_DEFAULT)
81392>>>    //                        DFWritePos    "Order Date"              0.10  (FONT_BOLD+RGB_DBLUE)
81392>>>    //                        DFWritelnPos  Orderhea.ORDER_DATE         4.0   (FONT_DEFAULT)
81392>>>    //                        DFWritePos    "Terms"                   0.10  (FONT_BOLD+RGB_DBLUE)
81392>>>    //                        DFWritelnPos  Orderhea.TERMS              4.0   (FONT_DEFAULT)
81392>>>    //                        DFWritePos    "Ship Via"                0.10  (FONT_BOLD+RGB_DBLUE)
81392>>>    //                        DFWritelnPos  Orderhea.SHIP_VIA           4.0   (FONT_DEFAULT)
81392>>>    
81392>>>    //                        DfWriteRect DFGR_CURRLINE 0 0.34 DFGR_RB_MARGIN RGB_GREY 0.0 dfgr_noWrap RGB_GREY
81392>>>    //                        DFWritePos    "Item Id"                 0.1     (FONT_BOLD+RGB_DBLUE)            -1 1.36
81392>>>    //                        DFWritePos    "Description"             2.36    (FONT_BOLD+RGB_DBLUE)            -1 4.77
81392>>>    //                        DFWritePos    "Qty Ordered"             9.5     (FONT_BOLD+FONT_RIGHT+RGB_DBLUE) -1 1.87
81392>>>    //                        DFWritePos    "Price"                   11.22   (FONT_BOLD+FONT_RIGHT+RGB_DBLUE) -1 1.22
81392>>>    //                        DFWritePos    "Extended Price"          14.1    (FONT_BOLD+FONT_RIGHT+RGB_DBLUE) -1 2.38
81392>>>    //                        DFWriteln
81392>>>    
81392>>>    //                      DFEndHeader
81392>>>    
81392>>>    //                End_Procedure
81392>>>    
81392>>>    //                Procedure Body // order detail body
81392>>>    
81392>>>    //                    DFFont "Arial"
81392>>>    //                    DFFontSize 8
81392>>>    
81392>>>    //                    DFLineCheck 5
81392>>>    
81392>>>    //                    DFWritePos    Invt.ITEM_ID                0.1     (FONT_DEFAULT)            -1 2.24
81392>>>    //                    DFWritePos    Invt.DESCRIPTION            2.36    (FONT_DEFAULT)            -1 4.77
81392>>>    //                    DFWritePos    Orderdtl.QTY_ORDERED        9.5     (FONT_DEFAULT+FONT_RIGHT)  0 1.87
81392>>>    //                    DFWritePos    Orderdtl.PRICE              11.22   (FONT_DEFAULT+FONT_RIGHT)  2 1.22
81392>>>    //                    DFWritePos    Orderdtl.EXTENDED_PRICE     14.1    (FONT_DEFAULT+FONT_RIGHT)  2 2.38
81392>>>    //                    DFWriteln
81392>>>    
81392>>>    //                    // Using rectotal in WinPrint.
81392>>>    //                    Send Add_SubTotal 1 (Orderdtl.EXTENDED_PRICE)
81392>>>    
81392>>>    //                End_Procedure
81392>>>    
81392>>>    //                Procedure SubTotal1 // order total
81392>>>    //                    Number nAmount
81392>>>    
81392>>>    //                    Get SubTotal 1 to nAmount
81392>>>    //                    Send Add_SubTotal 2 nAmount // subtotal 2 is customer total
81392>>>    
81392>>>    //                    DFFont "Arial"
81392>>>    //                    DFFontSize 8
81392>>>    //                    DFBeginHeader DFSubTotal 2
81392>>>    //                        DFHEADERPOS HDR_LEFT
81392>>>    //                        DFHEADERFRAME HDR_Margins 0.01 rgb_dGrey rgb_Grey
81392>>>    //                        DfHeaderMargin hm_TopInner 0.02
81392>>>    //                        DfHeaderMargin hm_BottomInner 0.02
81392>>>    //                        DfHeaderMargin hm_BottomOuter 0.08
81392>>>    //                        DfHeaderMargin hm_TopOuter 0.04
81392>>>    
81392>>>    //                        DFWritePos   "Order Total:"  12.00  (FONT_BOLD+RGB_DBLUE+FONT_RIGHT)
81392>>>    //                        DFWritelnPos nAmount         14.1   (FONT_RIGHT) 2
81392>>>    //                    DFEndHeader
81392>>>    
81392>>>    //                End_Procedure
81392>>>    
81392>>>    //            end_object // orderdtl nested report
81392>>>    
81392>>>    //        end_object // orderhea nested report
81392>>>    
81392>>>    //        Procedure SubTotal1 // customer total
81392>>>    //            Number nAmount
81392>>>    //            integer iClr
81392>>>    //            Boolean bBreak
81392>>>    
81392>>>    //            Get SubTotal 2 to nAmount
81392>>>    //            Send Add_SubTotal 3 nAmount // subtotal 3 is total of all
81392>>>    
81392>>>    //            //Get DFGetDFColor of winprintId  242 242 242 to iClr // doesn't work YET
81392>>>    //            Move -218959360 to iClr
81392>>>    
81392>>>    //            DFFont "Arial" //  Use Arial
81392>>>    //            DFFontSize 8
81392>>>    //            DFBeginHeader DFSubTotal 1
81392>>>    //                DFHEADERPOS HDR_LEFT
81392>>>    //                DFHeaderFrame HDR_Margins 0.01 RGB_DGREY iClr
81392>>>    //                DfHeaderMargin hm_BottomOuter 0.16
81392>>>    
81392>>>    //                DFWritePos   "Customer Total:"  12.00 (FONT_BOLD+RGB_DBLUE+FONT_RIGHT)
81392>>>    //                DFWritelnPos nAmount 14.1              (FONT_RIGHT+FONT_Bold) 2 0
81392>>>    //            DFEndHeader
81392>>>    //            Get pbOnePagePerCust to bBreak
81392>>>    //            If bBreak Begin
81392>>>    //                send DFNew_Page
81392>>>    //            end
81392>>>    //        end_procedure
81392>>>    
81392>>>    //        Procedure Total // total of all customers
81392>>>    //            Number nTotal
81392>>>    //            Get SubTotal 3 to nTotal
81392>>>    
81392>>>    //            DFFont "Arial" //  Use Arial
81392>>>    //            DFFontSize 10
81392>>>    
81392>>>    //            DFBeginHeader DFTotal
81392>>>    
81392>>>    //                DFHeaderPos   HDR_LEFT
81392>>>    //                DFHeaderFrame HDR_MARGINs 0.01 RGB_DGREY RGB_GREY
81392>>>    
81392>>>    //                DFWritePos    "Grand Total:"  12        (FONT_BOLD+RGB_DBLUE+FONT_RIGHT)
81392>>>    //                DFWritelnPos   nTotal         14.1      (FONT_BOLD+FONT_RIGHT) 2
81392>>>    
81392>>>    //            DFEndHeader                     //End and print header
81392>>>    
81392>>>    //        End_Procedure
81392>>>    
81392>>>    //        Procedure Page_Bottom
81392>>>    //            DateTime dtDT
81392>>>    //            Move (CurrentDateTime()) to dtDT
81392>>>    
81392>>>    //            DFFont "Arial"
81392>>>    //            DFFontSize 8
81392>>>    //            DFBeginHeader DFPageBottom
81392>>>    //                DFHeaderPos   HDR_CENTER
81392>>>    //                DFHeaderFrame HDR_MARGINS 0.01 rgb_dGrey
81392>>>    //                DFWriteLn   ("Report Printed on: " +string(dtDT)) (rgb_dBlue)
81392>>>    //            DFEndHeader
81392>>>    
81392>>>    //        End_Procedure
81392>>>    
81392>>>    //    End_Object // customer main report
81392>>>    
81392>>>End_Object    // oOrdersByCustomerWP
81393>
81393>        On_Key Key_Ctrl+Key_1 Send Activate_oCustomerView
81394>        On_Key Key_Ctrl+Key_2 Send Activate_oInventoryView
81395>        On_Key Key_Ctrl+Key_3 Send Activate_oOrderEntryView
81396>        On_Key Key_Ctrl+Key_4 Send Activate_oSalesPersonView
81397>        On_Key Key_Ctrl+Key_5 Send Activate_oVendorView
81398>        On_Key Key_Ctrl+Key_6 Send Activate_oCustomerListWP
81399>        On_Key Key_Ctrl+Key_7 Send Activate_oItemsPerOrderWP
81400>        On_Key Key_Ctrl+Key_8 Send Activate_oOrdersByCustomerWP
81401>        On_Key Key_Ctrl+Key_9 Send Activate_oOrdersWP
81402>
81402>        Use StdAbout.pkg
Including file: StdAbout.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\StdAbout.pkg)
81402>>>//************************************************************************
81402>>>// Confidential Trade Secret.
81402>>>// Copyright (c) 1997 Data Access Corporation, Miami Florida
81402>>>// as an unpublished work.  All rights reserved.
81402>>>// DataFlex is a registered trademark of Data Access Corporation.
81402>>>//
81402>>>//************************************************************************
81402>>>//************************************************************************
81402>>>//
81402>>>// $File name  : StdAbout.pkg
81402>>>// $File title : Standard about object package for VDF
81402>>>// Notice      :
81402>>>// $Author(s)  : John Tuohy
81402>>>//
81402>>>// $Rev History
81402>>>//
81402>>>// JT 06/27/97   File created
81402>>>//************************************************************************
81402>>>
81402>>>// This provides a quick and simple way to create an about package for a program.
81402>>>// You need to create a message inside you client area called Activate_About.
81402>>>// Within this message you should send the message DoAbout passing needed
81402>>>// string information.
81402>>>//
81402>>>//       Procedure Activate_About
81402>>>//           Send DoAbout sTitle sVersion sCopyright sAuthor sBitmap
81402>>>//       End_Procedure
81402>>>//    where: sTitle =     Name of application. If none provided, uses caption
81402>>>//                        bar title
81402>>>//           sVersion   = Version Line. If none provided, will be blank
81402>>>//           sCopyRight = Copyright Line. If none provided, will be blank
81402>>>//           sAuthor    = Author name, blank if none provided
81402>>>//           sBitMap    = Bitmap logo. If none provided, standard VDF bitmap
81402>>>//                        is used.
81402>>>// It is expected that you will place this in your own object package. For
81402>>>// example an order about package may look like this:
81402>>>//
81402>>>//   // OrderAbout.pkg
81402>>>//   Use StdAbout.pkg
81402>>>//   Procedure Activate_About
81402>>>//      String sTitle sCopyright sVersion sAuthor
81402>>>//      Move "My Order Entry System" to sTitle
81402>>>//      Move "Version 2.1" to sVersion
81402>>>//      Move "Copyright 1997, Super Software Inc." to sCopyright
81402>>>//      Move "John Smith"  to sAuthor
81402>>>//      Send DoAbout sTitle sVersion sCopyright sAuthor ""
81402>>>//   end_procedure
81402>>>//   // end of file.
81402>>>
81402>>>Use DfAbout.pkg
Including file: Dfabout.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\Dfabout.pkg)
81402>>>>>//************************************************************************
81402>>>>>// Confidential Trade Secret.
81402>>>>>// Copyright (c) 1997 Data Access Corporation, Miami Florida
81402>>>>>// as an unpublished work.  All rights reserved.
81402>>>>>// DataFlex Is A registered trademark Of Data Access Corporation.
81402>>>>>//
81402>>>>>//************************************************************************
81402>>>>>//************************************************************************
81402>>>>>//
81402>>>>>// $File name  : DfAbout.pkg
81402>>>>>// $File title : About class support
81402>>>>>// Notice      :
81402>>>>>// $Author(s)  : Vincent Oorsprong, Ken Ross
81402>>>>>//
81402>>>>>// $Rev History
81402>>>>>//
81402>>>>>// VOO 02/22/2012 Replaced obsolete code, improved Network_User_Name by asking
81402>>>>>//                Windows for the size first. 
81402>>>>>// VOO 07/25/2003 Removed OnResize procedure for sysinfo dialog. Replaced logic
81402>>>>>//                with anchor technique. Removed unnessary property in the
81402>>>>>//                sysinfo dialog. Changed the size Of the about & sysinfo dialog
81402>>>>>//                object To better look in Windows XP. Repositioned the close
81402>>>>>//                button in the sysinfo dialog To line up with the display area
81402>>>>>//                Replaced obsolete code and techniques. Removed dead code.
81402>>>>>// JJT 10/23/2001 removed all ghoworkspace support. Uses app object or nothing
81402>>>>>// SWB 07/19/01   Added support Of the Application object in preference to
81402>>>>>//                the global Workspace object, if it is present
81402>>>>>// JJT 11/05/98   Added version information
81402>>>>>// VOO 29/10/98   Replaced the GetFreeSystemResources for the Win32 variant
81402>>>>>// JJT 7/31/97    Registered Enumerate Workspace so dfabout can exist without
81402>>>>>//                workspace package.
81402>>>>>// JJT 6/27/97    Turned the sysinfo objects into classes so the AboutDialog
81402>>>>>//                class can create this object.
81402>>>>>//                Cleaned up the interface (used correct classes and messages)
81402>>>>>//                Added workspace reporting support To sys-info.
81402>>>>>//                Turned off wrapping in the sys-info editor.
81402>>>>>// KR  ??/??/96   File created
81402>>>>>//************************************************************************
81402>>>>>Use LanguageText.pkg
81402>>>>>Use Windows.pkg
81402>>>>>Use DFbitmap.pkg
81402>>>>>Use GlobalFunctionsProcedures.pkg
81402>>>>>Use cTextEdit.pkg
81402>>>>>
81402>>>>>Use cli.pkg
Including file: cli.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cli.pkg)
81402>>>>>>>//*****************************************************************************
81402>>>>>>>//*** CLI.PKG                                                               ***
81402>>>>>>>//***                                                                       ***
81402>>>>>>>//*** Author: Ben Weijers                                                   ***
81402>>>>>>>//***         Data Access Nederland                                         ***
81402>>>>>>>//***         10 September 1998                                             ***
81402>>>>>>>//***                                                                       ***
81402>>>>>>>//*** Purpose:                                                              ***
81402>>>>>>>//***   CLI specific functionality. There are several connectivity kits     ***
81402>>>>>>>//***   based on  SQL/92 CLI. Those are:                                    ***
81402>>>>>>>//***    - ODBC_DRV  The Data Access CK for ODBC                            ***
81402>>>>>>>//***    - DB2_DRV   The Data Access CK for DB2                             ***
81402>>>>>>>//***    - MSSQLDRV  The Data Access CK for Microsoft SQL Server            ***
81402>>>>>>>//***                                                                       ***
81402>>>>>>>//***   This package defines the common functionality for all CLI based     ***
81402>>>>>>>//***   drivers.                                                            ***
81402>>>>>>>//***                                                                       ***
81402>>>>>>>//***   Updated:  May 23rd 2008 (Current CK build: 5.0.0.53 )               ***
81402>>>>>>>//***             Added NULLABLE and DEFAULT attributes for DATETIME type   ***
81402>>>>>>>//***   Updated:  Apr  6th 2009 (Current CK build: 5.0.0.61 )               ***
81402>>>>>>>//***             Added DF_DRIVER_MATCH_CLIENT_SERVER_VERSION attribute     ***
81402>>>>>>>//***                   DF_DRIVER_SQLSERVER_CLIENT_VERSION    attribute     ***
81402>>>>>>>//***   Updated:  Mar 30th 2012 (Current CK build: 5.1.0.93 )               ***
81402>>>>>>>//***             Added SQLSERVER2012CLIENT return value for                ***
81402>>>>>>>//***             DF_DRIVER_SQLSERVER_CLIENT_VERSION attribute              ***
81402>>>>>>>//***   Updated:  June 4th 2012 (Current CK build: 5.1.0.96)                ***
81402>>>>>>>//***             Moved SQL Server client constants from cli.pkg to         ***
81402>>>>>>>//***             mssqldrv.pkg                                              ***
81402>>>>>>>//***   Updated:  april 23, 2013 (Current CK build: 6.0.0.4)                ***
81402>>>>>>>//***             Added type mappings attributes                            ***
81402>>>>>>>//***   Updated:  october 11, 2013 (Current CK build: 6.0.0.18)             ***
81402>>>>>>>//***             Added DF_FILE_SQL_FILTER_EQ attribute                     ***
81402>>>>>>>//*****************************************************************************
81402>>>>>>>
81402>>>>>>>//*** We are not using ifndef below because that is not supported in Character Mode
81402>>>>>>>//*** Driver attributes
81402>>>>>>>
81402>>>>>>>
81402>>>>>>>
81402>>>>>>>
81402>>>>>>>
81402>>>>>>>
81402>>>>>>>
81402>>>>>>>
81402>>>>>>>
81402>>>>>>>//------------------------------------------------------------
81402>>>>>>>
81402>>>>>>>
81402>>>>>>>//-------------------------------------
81402>>>>>>>
81402>>>>>>>
81402>>>>>>>
81402>>>>>>>//*** Replacement for logical column number that indicates all columns
81402>>>>>>>
81402>>>>>>>//*** Possible DF_FILE_GENERATE_RECORD_ID_METHOD values
81402>>>>>>>
81402>>>>>>>//*** Possible DF_FIELD_READ_ONLY values
81402>>>>>>>
81402>>>>>>>
81402>>>>>>>//*** Possible DF_DRIVER_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA values
81402>>>>>>>// #Replace MAP_DF_TO_SQL_TYPE_CK5        1       
81402>>>>>>>// #Replace MAP_DF_TO_SQL_TYPE_CK6        2   
81402>>>>>>>
81402>>>>>>>
81402>>>>>>>// Moved to Mssqldrv.pkg
81402>>>>>>>//*** Possible DF_DRIVER_SQLSERVER_CLIENT_VERSION values
81402>>>>>>>//#REPLACE SQLSERVERUNKNOWNCLIENT  0
81402>>>>>>>//#REPLACE SQLSERVER2000CLIENT     8          //   "SQL Server"
81402>>>>>>>//#REPLACE SQLSERVER2005CLIENT     9          //   "SQL Native Client"
81402>>>>>>>//#REPLACE SQLSERVER2008CLIENT    10          //   "SQL Server Native Client 10.0"
81402>>>>>>>//#Replace SQLSERVER2012CLIENT    11          //   "SQL Server Native Client 11.0"
81402>>>>>>>
81402>>>>>>>//*** Possible SQL Column type values
81402>>>>>>>Define SQL_UNKNOWN_TYPE   For    0
81402>>>>>>>Define SQL_CHAR           For    1
81402>>>>>>>Define SQL_NUMERIC        For    2
81402>>>>>>>Define SQL_DECIMAL        For    3
81402>>>>>>>Define SQL_INTEGER        For    4
81402>>>>>>>Define SQL_SMALLINT       For    5
81402>>>>>>>Define SQL_FLOAT          For    6
81402>>>>>>>Define SQL_REAL           For    7
81402>>>>>>>Define SQL_DOUBLE         For    8
81402>>>>>>>Define SQL_DATETIME       For    9
81402>>>>>>>Define SQL_VARCHAR        For   12
81402>>>>>>>Define SQL_TYPE_DATE      For   91
81402>>>>>>>Define SQL_TYPE_TIME      For   92
81402>>>>>>>Define SQL_TYPE_TIMESTAMP for   93
81402>>>>>>>// Moved to mssqldrv.pkg
81402>>>>>>>//Define SQL_TYPE_TIMESTAMP2 for   (-200) //SQL server datetime2 type */
81402>>>>>>>
81402>>>>>>>
81402>>>>>>>Define SQL_DATE           For    9
81402>>>>>>>Define SQL_INTERVAL       For   10
81402>>>>>>>Define SQL_TIME           For   10
81402>>>>>>>Define SQL_TIMESTAMP      For   11
81402>>>>>>>Define SQL_LONGVARCHAR    For  (-1)
81402>>>>>>>Define SQL_BINARY         For  (-2)
81402>>>>>>>Define SQL_VARBINARY      For  (-3)
81402>>>>>>>Define SQL_LONGVARBINARY  For  (-4)
81402>>>>>>>Define SQL_BIGINT         For  (-5)
81402>>>>>>>Define SQL_TINYINT        For  (-6)
81402>>>>>>>Define SQL_BIT            For  (-7)
81402>>>>>>>Define SQL_WCHAR          For  (-8)
81402>>>>>>>Define SQL_WVARCHAR       For  (-9)
81402>>>>>>>Define SQL_WLONGVARCHAR   For (-10)
81402>>>>>>>Define SQL_GUID           For (-11)
81402>>>>>>>
81402>>>>>>>//*** Driver level attributes
81402>>>>>>>
81402>>>>>>>
81402>>>>>>>//*** Error number constants
81402>>>>>>>
81402>>>>>>>
81402>>>>>>>//*** Call driver function identifiers
81402>>>>>>>
81402>>>>>>>
81402>>>>>>>//*** Init data source types
81402>>>>>>>
81402>>>>>>>
81402>>>>>>>//*** Dummy strings used in the commands
81402>>>>>>>    String  CLI$StrDummy 255
81402>>>>>>>    Integer CLI$IntDummy
81402>>>>>>>
81402>>>>>>>
81402>>>>>>>//*****************************************************************************
81402>>>>>>>//*** CLI_SetConstraint <FileNum> <NewState>                                ***
81402>>>>>>>//***                                                                       ***
81402>>>>>>>//***   Setup a constraint for a file.                                      ***
81402>>>>>>>//*****************************************************************************
81402>>>>>>>
81402>>>>>>>
81402>>>>>>>
81402>>>>>>>
81402>>>>>>>//*****************************************************************************
81402>>>>>>>//*** CLI_Set_Driver_Atrtribute / CLI_Get_Driver_Attribute                  ***
81402>>>>>>>//***                                                                       ***
81402>>>>>>>//*** Set or get an attribute at driver level. These attributes, when set,  ***
81402>>>>>>>//*** will be set for the remainder of the session or until set again. To   ***
81402>>>>>>>//*** permanently set driver level attributes change the driver             ***
81402>>>>>>>//*** configuration file.                                                   ***
81402>>>>>>>//*****************************************************************************
81402>>>>>>>
81402>>>>>>>
81402>>>>>>>
81402>>>>>>>
81402>>>>>>>
81402>>>>>>>
81402>>>>>>>
81402>>>>>>>//*****************************************************************************
81402>>>>>>>//*** Class  : cCLIHandler                                                  ***
81402>>>>>>>//*** Purpose: An instance of this class can be used as a broker object to  ***
81402>>>>>>>//***          call several CLI releated methods.                           ***
81402>>>>>>>//*****************************************************************************
81402>>>>>>>
81402>>>>>>>Class cCLIHandler Is An Array
81403>>>>>>>
81403>>>>>>>    Procedure Construct_Object Integer iImage
81405>>>>>>>        Forward Send Construct_object iImage
81407>>>>>>>
81407>>>>>>>        Property String  psDriverID       Public ""
81408>>>>>>>    End_Procedure // Construct_Object
81409>>>>>>>
81409>>>>>>>
81409>>>>>>>
81409>>>>>>>    //***
81409>>>>>>>    //*** Fucntion: CKRevsion
81409>>>>>>>    //*** Purpose : The revsion of a CLI Connectivity Kit
81409>>>>>>>    //***
81409>>>>>>>
81409>>>>>>>    Function CKRevision Returns String
81411>>>>>>>        Local String  sDriverID
81411>>>>>>>        Local String  sRevision
81411>>>>>>>        Local String  sVoid
81411>>>>>>>        Local Integer iRetval
81411>>>>>>>
81411>>>>>>>        Get psDriverID To sDriverID
81412>>>>>>>        If (sDRiverID <> "") Begin
81414>>>>>>>            Move (Repeat(" ", 255)) To sRevision
81415>>>>>>>            Call_Driver 0 sDRiverID Function CLI_CKREVISION Callback 0 Passing sRevision sVoid 0 Result iRetval
81420>>>>>>>        End
81420>>>>>>>>
81420>>>>>>>
81420>>>>>>>        Function_Return sRevision
81421>>>>>>>    End_Function // CKRevision
81422>>>>>>>
81422>>>>>>>
81422>>>>>>>
81422>>>>>>>    //***
81422>>>>>>>    //*** Function: ExtractPartFromRevision
81422>>>>>>>    //*** Purpose : Extarct the Nth part of a a.b.c.d revsion string.
81422>>>>>>>    //***
81422>>>>>>>    //*** Returns : The part version number or -1 if there is no such part number.
81422>>>>>>>    //***
81422>>>>>>>
81422>>>>>>>    Function ExtractPartFromRevision Integer iPartNum String sRevision Returns Integer
81424>>>>>>>        Local Integer iPartRev
81424>>>>>>>        Local Integer iCurrentPart
81424>>>>>>>        Local Integer iSeparatorPos
81424>>>>>>>
81424>>>>>>>        If (iPartNum > 4) ;            Function_Return -1
81427>>>>>>>
81427>>>>>>>        Move 0 To iCurrentPart
81428>>>>>>>        Repeat
81428>>>>>>>>
81428>>>>>>>            Move (Pos(".", sRevision)) To iSeparatorPos
81429>>>>>>>            If (iSeparatorPos > 0) Begin
81431>>>>>>>                Move (Left(sRevision, iSeparatorPos - 1)) To iPartRev
81432>>>>>>>                Move (Right(sRevision, Length(sRevision) - iSeparatorPos)) To sRevision
81433>>>>>>>                Increment iCurrentPart
81434>>>>>>>            End
81434>>>>>>>>
81434>>>>>>>            Else If (sRevision <> "") Begin
81437>>>>>>>                Move sRevision To iPartRev
81438>>>>>>>                Move "" To sRevision
81439>>>>>>>                Increment iCurrentPart
81440>>>>>>>            End
81440>>>>>>>>
81440>>>>>>>            Else ;                Move -1 To iPartRev
81442>>>>>>>        Until (iCurrentPart >= iPartNum Or iPartRev = -1)
81444>>>>>>>
81444>>>>>>>        Function_Return iPartRev
81445>>>>>>>    End_Function // EcxtractPartFromRevision
81446>>>>>>>
81446>>>>>>>
81446>>>>>>>
81446>>>>>>>    //***
81446>>>>>>>    //*** Function: CKMajorRevision
81446>>>>>>>    //*** Purpose : Returns the major revision of the CK
81446>>>>>>>    //***
81446>>>>>>>
81446>>>>>>>    Function CKMajorRevision Returns Integer
81448>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 1, CKRevision(Current_Object)))
81449>>>>>>>    End_Function // CKMajorRevision
81450>>>>>>>
81450>>>>>>>
81450>>>>>>>
81450>>>>>>>    //***
81450>>>>>>>    //*** Function: CKMinorRevision
81450>>>>>>>    //*** Purpose : Returns the minor revision of the CK
81450>>>>>>>    //***
81450>>>>>>>
81450>>>>>>>    Function CKMinorRevision Returns Integer
81452>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 2, CKRevision(Current_Object)))
81453>>>>>>>    End_Function // CKMinorRevision
81454>>>>>>>
81454>>>>>>>
81454>>>>>>>
81454>>>>>>>    //***
81454>>>>>>>    //*** Function: CKReleaseRevision
81454>>>>>>>    //*** Purpose : Returns the release revision of the CK
81454>>>>>>>    //***
81454>>>>>>>
81454>>>>>>>    Function CKReleaseRevision Returns Integer
81456>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 3, CKRevision(Current_Object)))
81457>>>>>>>    End_Function // CKReleaseRevision
81458>>>>>>>
81458>>>>>>>
81458>>>>>>>
81458>>>>>>>    //***
81458>>>>>>>    //*** Function: CKBuildRevision
81458>>>>>>>    //*** Purpose : Returns the major revision of the CK
81458>>>>>>>    //***
81458>>>>>>>
81458>>>>>>>    Function CKBuildRevision Returns Integer
81460>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 4, CKRevision(Current_Object)))
81461>>>>>>>    End_Function // CKBuildRevision
81462>>>>>>>
81462>>>>>>>
81462>>>>>>>
81462>>>>>>>    //***
81462>>>>>>>    //*** Function: IsMinimalRevision
81462>>>>>>>    //*** Purpose : Determines if the CK conforms to a passed minimal revsion.
81462>>>>>>>    //***
81462>>>>>>>
81462>>>>>>>    Function IsMinimalRevision Integer iMajor Integer iMinor Integer iRelease Integer iBuild Returns Integer
81464>>>>>>>        If (iMajor < CKMajorRevision(Current_object)) ;            Function_return (TRUE)
81467>>>>>>>        Else If (iMajor = CKMajorRevision(Current_object)) Begin
81470>>>>>>>            If (iMinor < CKMinorRevision(Current_object)) ;                Function_return (TRUE)
81473>>>>>>>            Else If (iMinor = CKMinorRevision(Current_object)) Begin
81476>>>>>>>                If (iRelease < CKReleaseRevision(Current_object)) ;                    Function_return (TRUE)
81479>>>>>>>                Else If (iRelease = CKReleaseRevision(Current_object) And iBuild <= CKBuildRevision(Current_object)) ;                    Function_return (TRUE)
81483>>>>>>>            End
81483>>>>>>>>
81483>>>>>>>        End
81483>>>>>>>>
81483>>>>>>>
81483>>>>>>>        Function_Return (FALSE)
81484>>>>>>>    End_Function // IsMinimalRevision
81485>>>>>>>
81485>>>>>>>
81485>>>>>>>
81485>>>>>>>    //***
81485>>>>>>>    //*** Function: RegistrationName
81485>>>>>>>    //*** Purpose : Returns the Connectiivty Kit registration name.
81485>>>>>>>    //***
81485>>>>>>>
81485>>>>>>>    Function RegistrationName Returns String
81487>>>>>>>        Local String  sRegistration
81487>>>>>>>        Local String  sDRiverId
81487>>>>>>>        Local String  sVoid
81487>>>>>>>        Local Integer iRetval
81487>>>>>>>
81487>>>>>>>        Get psDriverID To sDriverID
81488>>>>>>>        If (sDRiverID <> "") Begin
81490>>>>>>>            Move (Repeat(" ", 255)) To sRegistration
81491>>>>>>>            Call_Driver 0 sDRiverID Function CLI_GETREGNAME Callback 0 Passing sRegistration sVoid 0 Result iRetval
81496>>>>>>>        End
81496>>>>>>>>
81496>>>>>>>
81496>>>>>>>        Function_Return sRegistration
81497>>>>>>>    End_Function // RegistrationName
81498>>>>>>>
81498>>>>>>>
81498>>>>>>>
81498>>>>>>>    //***
81498>>>>>>>    //*** Function: SerialNumber
81498>>>>>>>    //*** Purpose : Returns the Connectiivty Kit serial number.
81498>>>>>>>    //***
81498>>>>>>>
81498>>>>>>>    Function SerialNumber Returns Integer
81500>>>>>>>        Local String  sDRiverId
81500>>>>>>>        Local String  sVoid
81500>>>>>>>        Local Integer iRetval
81500>>>>>>>
81500>>>>>>>        Get psDriverID To sDriverID
81501>>>>>>>        If (sDRiverID <> "") Begin
81503>>>>>>>            Call_Driver 0 sDRiverID Function CLI_GETSERIALNUM Callback 0 Passing sVoid sVoid 0 Result iRetval
81508>>>>>>>        End
81508>>>>>>>>
81508>>>>>>>
81508>>>>>>>        Function_Return iRetval
81509>>>>>>>    End_Function // SerialNumber
81510>>>>>>>
81510>>>>>>>
81510>>>>>>>
81510>>>>>>>    //***
81510>>>>>>>    //*** Function: MaxUsers
81510>>>>>>>    //*** Purpose : Returns the Connectiivty Kit maximum number of users.
81510>>>>>>>    //***
81510>>>>>>>
81510>>>>>>>    Function MaxUsers Returns Integer
81512>>>>>>>        Local String  sDRiverId
81512>>>>>>>        Local String  sVoid
81512>>>>>>>        Local Integer iRetval
81512>>>>>>>
81512>>>>>>>        Get psDriverID To sDriverID
81513>>>>>>>        If (sDRiverID <> "") Begin
81515>>>>>>>            Call_Driver 0 sDRiverID Function CLI_GETMAXUSERS Callback 0 Passing sVoid sVoid 0 Result iRetval
81520>>>>>>>        End
81520>>>>>>>>
81520>>>>>>>
81520>>>>>>>        Function_Return iRetval
81521>>>>>>>    End_Function // MaxUsers
81522>>>>>>>
81522>>>>>>>
81522>>>>>>>
81522>>>>>>>    //***
81522>>>>>>>    //*** Procedure: DumpStatus
81522>>>>>>>    //*** Purpose  : Dump the current status of the drver in the passed disk file.
81522>>>>>>>    //***
81522>>>>>>>
81522>>>>>>>    Procedure DumpStatus String sFileName
81524>>>>>>>        Local String  sVoid
81524>>>>>>>        Local String  sDriverID
81524>>>>>>>        Local Integer iVoid
81524>>>>>>>
81524>>>>>>>        Get psDriverID To sDriverID
81525>>>>>>>        If (sDriverID <> "") ;            Call_driver 0 sDriverID Function CLI_DUMPSTATUS Callback 0 Passing sFileName sVoid iVoid Result iVoid
81532>>>>>>>    End_Procedure // DumpStatus
81533>>>>>>>
81533>>>>>>>
81533>>>>>>>
81533>>>>>>>    //***
81533>>>>>>>    //*** Procedure: ReadConfiguration
81533>>>>>>>    //*** Purpose  : Reset all driver level configurable attributes to the
81533>>>>>>>    //***            default value and then reread the configuration.
81533>>>>>>>    //***
81533>>>>>>>
81533>>>>>>>    Procedure ReadConfiguration
81535>>>>>>>        Local String  sVoid
81535>>>>>>>        Local String  sDriverID
81535>>>>>>>        Local Integer iVoid
81535>>>>>>>
81535>>>>>>>        Get psDriverID To sDriverID
81536>>>>>>>        If (sDriverID <> "") ;            Call_driver 0 sDriverID Function CLI_READCONFIGURATION Callback 0 Passing sVoid sVoid iVoid Result iVoid
81543>>>>>>>    End_Procedure // ReadConfiguration
81544>>>>>>>
81544>>>>>>>
81544>>>>>>>
81544>>>>>>>    //***
81544>>>>>>>    //*** Function: TextToRIMValue
81544>>>>>>>    //*** Purpose : Convert a text to the corresponding
81544>>>>>>>    //***           Generate_Record_ID_Method attribute value
81544>>>>>>>    //***
81544>>>>>>>
81544>>>>>>>    Function TextToRIMValue String sText Returns Integer
81546>>>>>>>        If (sText = "None") ;            Function_return RIM_NONE
81549>>>>>>>        Else If (sText = "Identity Column") ;            Function_return RIM_IDENTITY_COLUMN
81553>>>>>>>        Else If (sText = "Dispenser Table") ;            Function_return RIM_DISPENSER_TABLE
81557>>>>>>>        Else If (sText = "External") ;            Function_return RIM_EXTERNAL
81561>>>>>>>    End_Function // TextToRIMValue
81562>>>>>>>
81562>>>>>>>
81562>>>>>>>
81562>>>>>>>    //***
81562>>>>>>>    //*** Function: RIMValueTotext
81562>>>>>>>    //*** Purpose : Convert a Generate_Record_ID_Method attribute value to the
81562>>>>>>>    //***           corresponding text.
81562>>>>>>>    //***
81562>>>>>>>
81562>>>>>>>    Function RIMValueToText Integer iAttrValue Returns String
81564>>>>>>>        If (iAttrValue = RIM_NONE) ;            Function_return "None"
81567>>>>>>>        Else If (iAttrValue = RIM_IDENTITY_COLUMN) ;            Function_return "Identity Column"
81571>>>>>>>        Else If (iAttrValue = RIM_DISPENSER_TABLE) ;            Function_return "Dispenser Table"
81575>>>>>>>        Else If (iAttrValue = RIM_EXTERNAL) ;            Function_return "External"
81579>>>>>>>    End_Function // RIMValueToText
81580>>>>>>>
81580>>>>>>>
81580>>>>>>>
81580>>>>>>>    //***
81580>>>>>>>    //*** Function: TextToROValue
81580>>>>>>>    //*** Purpose : Convert a text to the corresponding
81580>>>>>>>    //***           Generate_Record_ID_Method attribute value
81580>>>>>>>    //***
81580>>>>>>>
81580>>>>>>>    Function TextToROValue String sText Returns Integer
81582>>>>>>>        If (sText = "No") ;            Function_return RO_NO
81585>>>>>>>        Else If (sText = "Ignore Change") ;            Function_return RO_IGNORECHANGE
81589>>>>>>>        Else If (sText = "Accept Change") ;            Function_return RO_ACCEPTCHANGE
81593>>>>>>>        Else If (sText = "Error On Change") ;            Function_return RO_ERRORONCHANGE
81597>>>>>>>    End_Function // TextToRIMValue
81598>>>>>>>
81598>>>>>>>
81598>>>>>>>
81598>>>>>>>    //***
81598>>>>>>>    //*** Function: ROValueTotext
81598>>>>>>>    //*** Purpose : Convert a Generate_Record_ID_Method attribute value to the
81598>>>>>>>    //***           corresponding text.
81598>>>>>>>    //***
81598>>>>>>>
81598>>>>>>>    Function ROValueToText Integer iAttrValue Returns String
81600>>>>>>>        If (iAttrValue = RO_NO) ;            Function_return "No"
81603>>>>>>>        Else If (iAttrValue = RO_IGNORECHANGE) ;            Function_return "Ignore Change"
81607>>>>>>>        Else If (iAttrValue = RO_ACCEPTCHANGE) ;            Function_return "Accept Change"
81611>>>>>>>        Else If (iAttrValue = RO_ERRORONCHANGE) ;            Function_return "Error On Change"
81615>>>>>>>    End_Function // RIMValueToText
81616>>>>>>>
81616>>>>>>>
81616>>>>>>>
81616>>>>>>>    //***
81616>>>>>>>    //*** Function: LastDriverError
81616>>>>>>>    //*** Purpose : Return the text f the last error geneated by the driver.
81616>>>>>>>    //***
81616>>>>>>>
81616>>>>>>>    Function LastDriverError Returns String
81618>>>>>>>        Local String  sDriverID
81618>>>>>>>        Local String  sLastError
81618>>>>>>>        Local String  sLastErrorLength
81618>>>>>>>        Local Integer iLastErrorLength
81618>>>>>>>        Local Integer iVoid
81618>>>>>>>
81618>>>>>>>        //*** Initialize
81618>>>>>>>        Move "" To sLastError
81619>>>>>>>
81619>>>>>>>        Get psDriverID To sDriverID
81620>>>>>>>        If (sDriverID <> "") Begin
81622>>>>>>>            //*** Get the text of the last error
81622>>>>>>>            Move (Repeat(Character(" "), 14)) To sLastErrorlength
81623>>>>>>>            Call_driver 0 sDriverID Function CLI_GETDRIVERATTRIBUTE Callback 0 Passing sLastErrorLength iVoid DRVR_LASTERRORTEXTLENGTH Result iVoid
81628>>>>>>>            Move (Left(sLastErrorLength, Pos(Character(0), sLastErrorLength) - 1)) To iLastErrorLength
81629>>>>>>>
81629>>>>>>>            If (iLastErrorLength > 0) Begin
81631>>>>>>>                Move (Repeat(Character(" "), iLastErrorLength + 1)) To sLastError
81632>>>>>>>                Call_driver 0 sDriverID Function CLI_GETDRIVERATTRIBUTE Callback 0 Passing sLastError iVoid DRVR_LASTERRORTEXT Result iVoid
81637>>>>>>>                Move (Left(sLastError, Pos(Character(0), sLastError) - 1)) To sLastError
81638>>>>>>>            End
81638>>>>>>>>
81638>>>>>>>        End
81638>>>>>>>>
81638>>>>>>>
81638>>>>>>>        Function_Return sLastError
81639>>>>>>>    End_Function // LastDriverError
81640>>>>>>>
81640>>>>>>>
81640>>>>>>>
81640>>>>>>>    //***
81640>>>>>>>    //*** Function: EnumerateTables
81640>>>>>>>    //*** Purpose : Enumerate the tables in a database
81640>>>>>>>    //***
81640>>>>>>>
81640>>>>>>>    Function EnumerateTables String sLogin Returns Integer
81642>>>>>>>        Local String  sDriver
81642>>>>>>>        Local String  sVoid
81642>>>>>>>        Local Integer iNumTables
81642>>>>>>>        Local Integer iVoid
81642>>>>>>>
81642>>>>>>>        Get psDriverID To sDriver
81643>>>>>>>        If (sDriver <> "") ;            Call_driver 0 sDriver Function CLI_ENUMERATE_TABLES Callback 0 Passing sLogin sVoid iVoid Result iNumTables
81650>>>>>>>
81650>>>>>>>        Function_Return iNumTables
81651>>>>>>>    End_Function // EnumerateTables
81652>>>>>>>
81652>>>>>>>
81652>>>>>>>
81652>>>>>>>    //***
81652>>>>>>>    //*** Function: TableName
81652>>>>>>>    //*** Purpose : Returns the name of the table enumerated at the given position
81652>>>>>>>    //***
81652>>>>>>>
81652>>>>>>>    Function TableName Integer iIndex Returns String
81654>>>>>>>        Local String  sDriver
81654>>>>>>>        Local String  sTableName
81654>>>>>>>        Local String  sVoid
81654>>>>>>>        Local Integer iVoid
81654>>>>>>>
81654>>>>>>>        Get psDriverID To sDriver
81655>>>>>>>        If (sDriver <> "") Begin
81657>>>>>>>            Move (Repeat(" ", 255)) To sTableName
81658>>>>>>>            Call_driver 0 sDriver Function CLI_TABLENAME Callback 0 Passing sTableName sVoid iIndex Result iVoid
81663>>>>>>>        End
81663>>>>>>>>
81663>>>>>>>
81663>>>>>>>        Function_Return sTableName
81664>>>>>>>    End_Function // TableName
81665>>>>>>>
81665>>>>>>>
81665>>>>>>>
81665>>>>>>>    //***
81665>>>>>>>    //*** Function: SchemaName
81665>>>>>>>    //*** Purpose : Returns the name of the schema of the table enumerated at the given position
81665>>>>>>>    //***
81665>>>>>>>
81665>>>>>>>    Function SchemaName Integer iIndex Returns String
81667>>>>>>>        Local String  sDriver
81667>>>>>>>        Local String  sSchemaName
81667>>>>>>>        Local String  sVoid
81667>>>>>>>        Local Integer iVoid
81667>>>>>>>
81667>>>>>>>        Get psDriverID To sDriver
81668>>>>>>>        If (sDriver <> "") Begin
81670>>>>>>>            Move (Repeat(" ", 255)) To sSchemaName
81671>>>>>>>            Call_driver 0 sDriver Function CLI_TABLESCHEMA Callback 0 Passing sSchemaName sVoid iIndex Result iVoid
81676>>>>>>>        End
81676>>>>>>>>
81676>>>>>>>
81676>>>>>>>        Function_Return sSchemaName
81677>>>>>>>    End_Function // SchemaName
81678>>>>>>>
81678>>>>>>>
81678>>>>>>>
81678>>>>>>>    //***
81678>>>>>>>    //*** Function: TableType
81678>>>>>>>    //*** Purpose : Returns the type of the table enumerated at the given position.
81678>>>>>>>    //***           Types can be "TABLE", "VIEW", "SYSTEM TABLE", "GLOBAL TEMPORARY",
81678>>>>>>>    //***           "LOCAL TEMPORARY", "ALIAS", "SYNONYM"
81678>>>>>>>    //***
81678>>>>>>>
81678>>>>>>>    Function TableType Integer iIndex Returns String
81680>>>>>>>        Local String  sDriver
81680>>>>>>>        Local String  sTableType
81680>>>>>>>        Local String  sVoid
81680>>>>>>>        Local Integer iVoid
81680>>>>>>>
81680>>>>>>>        Get psDriverID To sDriver
81681>>>>>>>        If (sDriver <> "") Begin
81683>>>>>>>            Move (Repeat(" ", 25)) To sTableType
81684>>>>>>>            Call_driver 0 sDriver Function CLI_TABLETYPE Callback 0 Passing sTableType sVoid iIndex Result iVoid
81689>>>>>>>        End
81689>>>>>>>>
81689>>>>>>>
81689>>>>>>>        Function_Return sTableType
81690>>>>>>>    End_Function // TableType
81691>>>>>>>
81691>>>>>>>
81691>>>>>>>
81691>>>>>>>    //***
81691>>>>>>>    //*** Function: TableComment
81691>>>>>>>    //*** Purpose : Returns the comment of the table enumerated at the given position
81691>>>>>>>    //***
81691>>>>>>>
81691>>>>>>>    Function TableComment Integer iIndex Returns String
81693>>>>>>>        Local String  sDriver
81693>>>>>>>        Local String  sTableComment
81693>>>>>>>        Local String  sVoid
81693>>>>>>>        Local Integer iVoid
81693>>>>>>>
81693>>>>>>>        Get psDriverID To sDriver
81694>>>>>>>        If (sDriver <> "") Begin
81696>>>>>>>            Move (Repeat(" ", 255)) To sTableComment
81697>>>>>>>            Call_driver 0 sDriver Function CLI_TABLECOMMENT Callback 0 Passing sTableComment sVoid iIndex Result iVoid
81702>>>>>>>        End
81702>>>>>>>>
81702>>>>>>>
81702>>>>>>>        Function_Return sTableComment
81703>>>>>>>    End_Function // TableComment
81704>>>>>>>
81704>>>>>>>
81704>>>>>>>
81704>>>>>>>    //***
81704>>>>>>>    //*** Function: EnumerateColumns
81704>>>>>>>    //*** Purpose : Enumerate the columns in a table
81704>>>>>>>    //***
81704>>>>>>>
81704>>>>>>>    Function EnumerateColumns String sLogin String sTableName Returns Integer
81706>>>>>>>        Local String  sDriver
81706>>>>>>>        Local Integer iNumColumns
81706>>>>>>>        Local Integer iVoid
81706>>>>>>>
81706>>>>>>>        Get psDriverID To sDriver
81707>>>>>>>        If (sDriver <> "") ;            Call_driver 0 sDriver Function CLI_ENUMERATE_COLUMNS Callback 0 Passing sLogin sTablename iVoid Result iNumColumns
81714>>>>>>>
81714>>>>>>>        Function_Return iNumColumns
81715>>>>>>>    End_Function // EnumerateColumns
81716>>>>>>>
81716>>>>>>>
81716>>>>>>>
81716>>>>>>>    //***
81716>>>>>>>    //*** Function: ColumnName
81716>>>>>>>    //*** Purpose : Returns the name of the column enumerated at the given position
81716>>>>>>>    //***
81716>>>>>>>
81716>>>>>>>    Function ColumnName Integer iIndex Returns String
81718>>>>>>>        Local String  sDriver
81718>>>>>>>        Local String  sColumnName
81718>>>>>>>        Local String  sVoid
81718>>>>>>>        Local Integer iVoid
81718>>>>>>>
81718>>>>>>>        Get psDriverID To sDriver
81719>>>>>>>        If (sDriver <> "") Begin
81721>>>>>>>            Move (Repeat(" ", 255)) To sColumnName
81722>>>>>>>            Call_driver 0 sDriver Function CLI_COLUMNNAME Callback 0 Passing sColumnName sVoid iIndex Result iVoid
81727>>>>>>>        End
81727>>>>>>>>
81727>>>>>>>
81727>>>>>>>        Function_Return sColumnName
81728>>>>>>>    End_Function // ColumnName
81729>>>>>>>
81729>>>>>>>
81729>>>>>>>
81729>>>>>>>    //***
81729>>>>>>>    //*** Function: CLIDFDateToSQLDate
81729>>>>>>>    //*** Purpose : Convert a DataFlex date to a SQL date using the dummy zero date value.
81729>>>>>>>    //***
81729>>>>>>>
81729>>>>>>>    Function CLIDFDateToSQLDate String sDRiver Date dDFDate Returns String
81731>>>>>>>        Local String sSQLDate
81731>>>>>>>        Local Integer iOrgDateFmt
81731>>>>>>>        Local Integer iOrgDateSep
81731>>>>>>>
81731>>>>>>>        //*** Change date format to military, SQL dates are military dates
81731>>>>>>>        Get_Attribute DF_DATE_FORMAT To iOrgDateFmt
81734>>>>>>>        Get_Attribute DF_DATE_SEPARATOR To iOrgDateSep
81737>>>>>>>        Set_Attribute DF_DATE_FORMAT To DF_DATE_MILITARY
81740>>>>>>>        Set_Attribute DF_DATE_SEPARATOR To (Ascii('-'))
81743>>>>>>>
81743>>>>>>>        //*** We only need to convert if the date is 0
81743>>>>>>>        If (Integer(dDFDate = 0)) ;            CLI_Get_Driver_Attribute sDRiver DRVR_DUMMY_ZERO_DATE_VALUE To sSQLDate
81752>>>>>>>        Else ;            Move dDFDate To sSQLDate
81754>>>>>>>
81754>>>>>>>        //*** Change date format back to original
81754>>>>>>>        Set_Attribute DF_DATE_FORMAT To iOrgDateFmt
81757>>>>>>>        Set_Attribute DF_DATE_SEPARATOR To iOrgDateSep
81760>>>>>>>
81760>>>>>>>        Function_Return sSQLDate
81761>>>>>>>    End_Function // CLIDFDateToSQLDate
81762>>>>>>>
81762>>>>>>>
81762>>>>>>>
81762>>>>>>>    //***
81762>>>>>>>    //*** Function: CLISQLDateToDFDate
81762>>>>>>>    //*** Purpose : Convert a SQL date to a DataFlex date using the dummy zero date value.
81762>>>>>>>    //***
81762>>>>>>>
81762>>>>>>>    Function CLISQLDateToDFDate String sDRiver String sSQLDate Returns Date
81764>>>>>>>        Local Date dDFDate
81764>>>>>>>        Local String sDummyDateValue
81764>>>>>>>        Local Integer iOrgDateFmt
81764>>>>>>>        Local Integer iOrgDateSep
81764>>>>>>>
81764>>>>>>>        //*** Change date format to military, SQL dates are military dates
81764>>>>>>>        Get_Attribute DF_DATE_FORMAT To iOrgDateFmt
81767>>>>>>>        Get_Attribute DF_DATE_SEPARATOR To iOrgDateSep
81770>>>>>>>        Set_Attribute DF_DATE_FORMAT To DF_DATE_MILITARY
81773>>>>>>>        Set_Attribute DF_DATE_SEPARATOR To (Ascii('-'))
81776>>>>>>>
81776>>>>>>>        //*** We only need to convert if the date is the dummy zero date value
81776>>>>>>>        CLI_Get_Driver_Attribute sDRiver DRVR_DUMMY_ZERO_DATE_VALUE To sDummyDateValue
81783>>>>>>>        If (sDummyDateValue = sSQLDate) ;            Move 0 To dDFDate
81786>>>>>>>        Else ;            Move sSQLDate To dDFDate
81788>>>>>>>
81788>>>>>>>        //*** Change date format back to original
81788>>>>>>>        Set_Attribute DF_DATE_FORMAT To iOrgDateFmt
81791>>>>>>>        Set_Attribute DF_DATE_SEPARATOR To iOrgDateSep
81794>>>>>>>
81794>>>>>>>        Function_Return dDFDate
81795>>>>>>>    End_Function // CLISQLDateToDFDate
81796>>>>>>>
81796>>>>>>>
81796>>>>>>>
81796>>>>>>>    //***
81796>>>>>>>    //*** Function: RedirectConnection
81796>>>>>>>    //*** Purpose : Redirect an exisitng connection. The existing connection
81796>>>>>>>    //***           will point to another database but all tables will stay
81796>>>>>>>    //***           open!
81796>>>>>>>    //***
81796>>>>>>>
81796>>>>>>>    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
81798>>>>>>>        Local String  sDriver
81798>>>>>>>        Local String  sVoid
81798>>>>>>>        Local Integer iResult
81798>>>>>>>        Local Integer iVoid
81798>>>>>>>
81798>>>>>>>        Get psDriverID To sDriver
81799>>>>>>>        If (sDriver <> "") Begin
81801>>>>>>>            Call_driver 0 sDriver Function CLI_REDIRECTCONNECTION Callback 0 Passing sOldConnection sNewConnection iVoid Result iResult
81806>>>>>>>        End
81806>>>>>>>>
81806>>>>>>>        Function_Return iResult
81807>>>>>>>    End_Function // RedirectConnect
81808>>>>>>>
81808>>>>>>>
81808>>>>>>>
81808>>>>>>>    //***
81808>>>>>>>    //*** Function: CreateConnectionID
81808>>>>>>>    //*** Purpose : Create a DataFlex side connection id that can be used later on.
81808>>>>>>>    //***
81808>>>>>>>
81808>>>>>>>    Function CreateConnectionID String sID String sConnStr Integer iOpt Returns Integer
81810>>>>>>>        Local String  sDriver
81810>>>>>>>        Local Integer iResult
81810>>>>>>>        Local Integer iOptions
81810>>>>>>>
81810>>>>>>>        Get psDriverID to sDriver
81811>>>>>>>        If (Num_Arguments = 2) ;            Move 0 to iOptions
81814>>>>>>>        Else ;            Move iOpt to iOptions
81816>>>>>>>        If (sDriver <> "") Begin
81818>>>>>>>            Call_Driver 0 sDriver Function CLI_CREATECONNECTIONID Callback 0 Passing sID sConnStr iOptions Result iResult
81823>>>>>>>        End
81823>>>>>>>>
81823>>>>>>>        Function_Return iResult
81824>>>>>>>    End_Function // CreateConnectionID
81825>>>>>>>
81825>>>>>>>
81825>>>>>>>
81825>>>>>>>    //***
81825>>>>>>>    //*** Function: DeleteConnectionID
81825>>>>>>>    //*** Purpose : Delete a DataFlex side connection id.
81825>>>>>>>    //***
81825>>>>>>>
81825>>>>>>>    Function DeleteConnectionID String sID Integer iIndex Returns Integer
81827>>>>>>>        Local String  sDriver
81827>>>>>>>        Local Integer iResult
81827>>>>>>>        Local String sVoid
81827>>>>>>>
81827>>>>>>>        Get psDriverID To sDriver
81828>>>>>>>        If (sDriver <> "") Begin
81830>>>>>>>            Call_Driver 0 sDriver Function CLI_DELETECONNECTIONID Callback 0 Passing sID sVoid iIndex Result iResult
81835>>>>>>>        End
81835>>>>>>>>
81835>>>>>>>        Function_Return iResult
81836>>>>>>>    End_Function // DeleteConnectionID
81837>>>>>>>
81837>>>>>>>End_Class // cCLIHandler
81838>>>>>Use DFBTRDRV.PKG
Including file: DFBTRDRV.PKG    (C:\Program Files (x86)\DataFlex 18.2\Pkg\DFBTRDRV.PKG)
81838>>>>>>>//****************************************************************************
81838>>>>>>>//
81838>>>>>>>// $File name  : DFBTRDRV.PKG
81838>>>>>>>// $File title : Package for the DataFlex Connectivity Kit for Pervasive.SQL
81838>>>>>>>// Notice      : This package contains constants and commands, used to call
81838>>>>>>>//               specific functions in the DFBTRDRV.
81838>>>>>>>// $Author(s)  : Eddy Kleinjan
81838>>>>>>>//
81838>>>>>>>// $System     : DataFlex Connectivity Kit for Pervasive.SQL
81838>>>>>>>// Created     : 01-07-97 @ 12:00:00
81838>>>>>>>//
81838>>>>>>>// Changed     : 04-04-2001.
81838>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 1.3.0.145
81838>>>>>>>//
81838>>>>>>>// Changed     : June 6, 2001
81838>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 1.3.0.148
81838>>>>>>>//
81838>>>>>>>//               Added DFBTR_DDF_OWNER command.
81838>>>>>>>//
81838>>>>>>>// Changed     : June 12, 2001
81838>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 1.3.0.149
81838>>>>>>>//
81838>>>>>>>//               Added DF_FIELD_IS_NULL and DF_FIELD_NULL_ALLOWED attributes
81838>>>>>>>//
81838>>>>>>>// Changed     : August 4, 2004
81838>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 3.0.0.1
81838>>>>>>>//
81838>>>>>>>//               Added cDfbtrdrvHandler class.
81838>>>>>>>//               New functions in this class:
81838>>>>>>>//                  Function CKRevision Returns String
81838>>>>>>>//                  Function CkUsesUri Returns Integer
81838>>>>>>>//                  Function PSQLRequesterVersionInfo Integer iFileNum Returns String
81838>>>>>>>//                  Function PSQLLocalEngineVersionInfo Integer iFileNum Returns String
81838>>>>>>>//                  Function PSQLServerEngineVersionInfo Integer iFileNum Returns String
81838>>>>>>>//
81838>>>>>>>// Changed     : September 30, 2005
81838>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 3.0.0.14
81838>>>>>>>//
81838>>>>>>>//               Bugfix: Prevent compiler errors when no (df)error.pkg is used
81838>>>>>>>//****************************************************************************
81838>>>>>>>Use Ui
81838>>>>>>>//
81838>>>>>>>// Driver Indentification
81838>>>>>>>//
81838>>>>>>>
81838>>>>>>>//*** Driver attributes
81838>>>>>>>//
81838>>>>>>>// Call_Driver functions ID's
81838>>>>>>>//
81838>>>>>>>//
81838>>>>>>>// DFBTRFN_CONVERT_FILE options
81838>>>>>>>//
81838>>>>>>>
81838>>>>>>>//
81838>>>>>>>// DFBTRFN_SET_OWNER options
81838>>>>>>>//
81838>>>>>>>
81838>>>>>>>//
81838>>>>>>>// DFBTRFN_SET_TRANSACTION_TYPE options
81838>>>>>>>//
81838>>>>>>>
81838>>>>>>>
81838>>>>>>>//
81838>>>>>>>// Command to create all vars which may be needed
81838>>>>>>>// in other commands.
81838>>>>>>>//
81838>>>>>>>
81838>>>>>>>
81838>>>>>>>
81838>>>>>>>//
81838>>>>>>>// Command to set the owner of a Btrieve file.
81838>>>>>>>// File must have been opened.
81838>>>>>>>// Filenumber needs to be passed.
81838>>>>>>>// To clear set the owner to "".
81838>>>>>>>// Examples:
81838>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret"
81838>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY CALLBACK MyCallBack
81838>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" ENCRYPT
81838>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY ENCRYPT CALLBACK MyCallBack
81838>>>>>>>// To clear:
81838>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to ""
81838>>>>>>>//
81838>>>>>>>
81838>>>>>>>
81838>>>>>>>
81838>>>>>>>//
81838>>>>>>>// Command to parse DFBTR_SET_OWNVER
81838>>>>>>>// options.
81838>>>>>>>//
81838>>>>>>>
81838>>>>>>>
81838>>>>>>>
81838>>>>>>>//
81838>>>>>>>// Command to parse for Callback
81838>>>>>>>//
81838>>>>>>>
81838>>>>>>>
81838>>>>>>>
81838>>>>>>>//
81838>>>>>>>// Command to clear the owner of a Btrieve file.
81838>>>>>>>// File must have been opened.
81838>>>>>>>// Filenumber needs to be passed.
81838>>>>>>>// Examples:
81838>>>>>>>//      DFBTR_CLEAR_OWNER MyFileNumber
81838>>>>>>>//
81838>>>>>>>
81838>>>>>>>
81838>>>>>>>
81838>>>>>>>//
81838>>>>>>>// Command to add a owner name to the internal list of ownernames
81838>>>>>>>// which will be tries when opening files.
81838>>>>>>>//
81838>>>>>>>
81838>>>>>>>
81838>>>>>>>
81838>>>>>>>//
81838>>>>>>>// Command to remove all owners from the internal list of ownernames
81838>>>>>>>//
81838>>>>>>>
81838>>>>>>>
81838>>>>>>>//
81838>>>>>>>// Command to set the owner name to be used when opening the DDF files.
81838>>>>>>>// The DDF owner is required when Pervasive.SQL security is turned on.
81838>>>>>>>// The DDF owner is equal to the password of the Master user in Pervasive.SQL
81838>>>>>>>// This command overwrites the DDF_OWNER setting in DFBTRDRV.INT
81838>>>>>>>//
81838>>>>>>>
81838>>>>>>>//
81838>>>>>>>// Command to change the transaction type.
81838>>>>>>>// Valid types are:
81838>>>>>>>//     DFBTRTT_NONE
81838>>>>>>>//     DFBTRTT_EXCLUSIVE
81838>>>>>>>//     DFBTRTT_CONCURRENT
81838>>>>>>>//
81838>>>>>>>//
81838>>>>>>>
81838>>>>>>>
81838>>>>>>>
81838>>>>>>>//
81838>>>>>>>// Command to get the current transaction type.
81838>>>>>>>//
81838>>>>>>>
81838>>>>>>>//
81838>>>>>>>// Command to set explicit_locking
81838>>>>>>>//
81838>>>>>>>
81838>>>>>>>//
81838>>>>>>>// Command to get explicit locking
81838>>>>>>>//
81838>>>>>>>
81838>>>>>>>//
81838>>>>>>>// Command to set detection for incompatible positive signs in numeric fields
81838>>>>>>>//
81838>>>>>>>
81838>>>>>>>//
81838>>>>>>>// Command to get detection for incompatible positive signs in numeric fields
81838>>>>>>>//
81838>>>>>>>
81838>>>>>>>//*****************************************************************************
81838>>>>>>>//*** Class  : cDfbtrdrvHandler                                                  ***
81838>>>>>>>//*** Purpose: An instance of this class can be used as a broker object to  ***
81838>>>>>>>//***          call several Dfbtrdrv releated methods.                           ***
81838>>>>>>>//*****************************************************************************
81838>>>>>>>
81838>>>>>>>Class cDFBtrDrvHandler Is An Array
81839>>>>>>>
81839>>>>>>>    Procedure Construct_Object Integer iImage
81841>>>>>>>        Forward Send Construct_object iImage
81843>>>>>>>
81843>>>>>>>        Property String  psDriverID       Public "DFBTRDRV"
81844>>>>>>>    End_Procedure // Construct_Object
81845>>>>>>>
81845>>>>>>>
81845>>>>>>>
81845>>>>>>>    //***
81845>>>>>>>    //*** Function: CKRevsion
81845>>>>>>>    //*** Purpose : The revsion of a Dfbtrdrv Connectivity Kit
81845>>>>>>>    //***
81845>>>>>>>
81845>>>>>>>    Function CKRevision Returns String
81847>>>>>>>        Local String  sDriverID
81847>>>>>>>        Local String  sRevision
81847>>>>>>>        Local String  sVoid
81847>>>>>>>        Local Integer iRetval
81847>>>>>>>
81847>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
81847>>>>>>>        // This error would otherwise be raised when we have an older
81847>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
81847>>>>>>>        Send Ignore_error To Error_object_Id 20491
81848>>>>>>>        Get psDriverID To sDriverID
81849>>>>>>>        Move (Repeat(" ", 255)) To sRevision
81850>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKREVISION Callback 0 Passing sRevision sVoid 0 Result iRetval
81855>>>>>>>        Send Trap_Error To Error_object_Id 20491
81856>>>>>>>        If (Trim(sRevision) = "") Begin
81858>>>>>>>            // Unable to get the revision. return all zeroes.
81858>>>>>>>            Move "0.0.0.0" To sRevision
81859>>>>>>>        End
81859>>>>>>>>
81859>>>>>>>        Function_Return sRevision
81860>>>>>>>    End_Function // CKRevision
81861>>>>>>>
81861>>>>>>>    Function CkUsesUri Returns Integer
81863>>>>>>>        Local String  sDriverID
81863>>>>>>>        Local String  sVoid1
81863>>>>>>>        Local String  sVoid2
81863>>>>>>>        Local Integer iRetval
81863>>>>>>>
81863>>>>>>>        Get psDriverID To sDriverID
81864>>>>>>>
81864>>>>>>>        Move 0 To iRetval
81865>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
81865>>>>>>>        // This error would otherwise be raised when we have an older
81865>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKUSESURI function
81865>>>>>>>        Send Ignore_error To Error_object_Id 20491
81866>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKUSESURI Callback 0 Passing sVoid1 sVoid2 0 Result iRetval
81871>>>>>>>        Send Trap_Error To Error_object_Id 20491
81872>>>>>>>
81872>>>>>>>        Function_Return iRetval
81873>>>>>>>    End_Function // CKUsesUri
81874>>>>>>>
81874>>>>>>>
81874>>>>>>>
81874>>>>>>>    //***
81874>>>>>>>    //*** Function: ExtractPartFromRevsion
81874>>>>>>>    //*** Purpose : Extarct the Nth part of a a.b.c.d revsion string.
81874>>>>>>>    //***
81874>>>>>>>    //*** Returns : The part version number or -1 if there is no such part number.
81874>>>>>>>    //***
81874>>>>>>>
81874>>>>>>>    Function ExtractPartFromRevision Integer iPartNum String sRevision Returns Integer
81876>>>>>>>        Local Integer iPartRev
81876>>>>>>>        Local Integer iCurrentPart
81876>>>>>>>        Local Integer iSeparatorPos
81876>>>>>>>
81876>>>>>>>        If (iPartNum > 4) ;            Function_Return -1
81879>>>>>>>
81879>>>>>>>        Move 0 To iCurrentPart
81880>>>>>>>        Repeat
81880>>>>>>>>
81880>>>>>>>            Move (Pos(".", sRevision)) To iSeparatorPos
81881>>>>>>>            If (iSeparatorPos > 0) Begin
81883>>>>>>>                Move (Left(sRevision, iSeparatorPos - 1)) To iPartRev
81884>>>>>>>                Move (Right(sRevision, Length(sRevision) - iSeparatorPos)) To sRevision
81885>>>>>>>                Increment iCurrentPart
81886>>>>>>>            End
81886>>>>>>>>
81886>>>>>>>            Else If (sRevision <> "") Begin
81889>>>>>>>                Move sRevision To iPartRev
81890>>>>>>>                Move "" To sRevision
81891>>>>>>>                Increment iCurrentPart
81892>>>>>>>            End
81892>>>>>>>>
81892>>>>>>>            Else ;                Move -1 To iPartRev
81894>>>>>>>        Until (iCurrentPart >= iPartNum Or iPartRev = -1)
81896>>>>>>>
81896>>>>>>>        Function_Return iPartRev
81897>>>>>>>    End_Function // EcxtractPartFromRevision
81898>>>>>>>
81898>>>>>>>
81898>>>>>>>
81898>>>>>>>    //***
81898>>>>>>>    //*** Function: CKMajorRevision
81898>>>>>>>    //*** Purpose : Returns the major revision of the CK
81898>>>>>>>    //***
81898>>>>>>>
81898>>>>>>>    Function CKMajorRevision Returns Integer
81900>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 1, CKRevision(Current_Object)))
81901>>>>>>>    End_Function // CKMajorRevision
81902>>>>>>>
81902>>>>>>>
81902>>>>>>>
81902>>>>>>>    //***
81902>>>>>>>    //*** Function: CKMinorRevision
81902>>>>>>>    //*** Purpose : Returns the minor revision of the CK
81902>>>>>>>    //***
81902>>>>>>>
81902>>>>>>>    Function CKMinorRevision Returns Integer
81904>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 2, CKRevision(Current_Object)))
81905>>>>>>>    End_Function // CKMinorRevision
81906>>>>>>>
81906>>>>>>>
81906>>>>>>>
81906>>>>>>>    //***
81906>>>>>>>    //*** Function: CKReleaseRevision
81906>>>>>>>    //*** Purpose : Returns the release revision of the CK
81906>>>>>>>    //***
81906>>>>>>>
81906>>>>>>>    Function CKReleaseRevision Returns Integer
81908>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 3, CKRevision(Current_Object)))
81909>>>>>>>    End_Function // CKReleaseRevision
81910>>>>>>>
81910>>>>>>>
81910>>>>>>>
81910>>>>>>>    //***
81910>>>>>>>    //*** Function: CKBuildRevision
81910>>>>>>>    //*** Purpose : Returns the major revision of the CK
81910>>>>>>>    //***
81910>>>>>>>
81910>>>>>>>    Function CKBuildRevision Returns Integer
81912>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 4, CKRevision(Current_Object)))
81913>>>>>>>    End_Function // CKBuildRevision
81914>>>>>>>
81914>>>>>>>
81914>>>>>>>
81914>>>>>>>    //***
81914>>>>>>>    //*** Function: IsMinimalRevision
81914>>>>>>>    //*** Purpose : Determines if the CK conforms to a passed minimal revsion.
81914>>>>>>>    //***
81914>>>>>>>
81914>>>>>>>    Function IsMinimalRevision Integer iMajor Integer iMinor Integer iRelease Integer iBuild Returns Integer
81916>>>>>>>        If (iMajor < CKMajorRevision(Current_object)) ;            Function_return (TRUE)
81919>>>>>>>        Else If (iMajor = CKMajorRevision(Current_object)) Begin
81922>>>>>>>            If (iMinor < CKMinorRevision(Current_object)) ;                Function_return (TRUE)
81925>>>>>>>            Else If (iMinor = CKMinorRevision(Current_object)) Begin
81928>>>>>>>                If (iRelease < CKReleaseRevision(Current_object)) ;                    Function_return (TRUE)
81931>>>>>>>                Else If (iRelease = CKReleaseRevision(Current_object) And iBuild <= CKBuildRevision(Current_object)) ;                    Function_return (TRUE)
81935>>>>>>>            End
81935>>>>>>>>
81935>>>>>>>        End
81935>>>>>>>>
81935>>>>>>>
81935>>>>>>>        Function_Return (FALSE)
81936>>>>>>>    End_Function // IsMinimalRevision
81937>>>>>>>
81937>>>>>>>    //   Functions to query the Pervasive.SQL version:
81937>>>>>>>    //       PSQLRequesterVersionInfo    Integer iFileNum Returns String
81937>>>>>>>    //       PSQLLocalEngineVersionInfo  Integer iFileNum Returns String
81937>>>>>>>    //       PSQLServerEngineVersionInfo Integer iFileNum Returns String
81937>>>>>>>    //
81937>>>>>>>    //   All 3 functions return the version of a Pervasive.SQL component
81937>>>>>>>    //   in the following format:
81937>>>>>>>    //       <version>.<revision>.<type>
81937>>>>>>>    //   possible values for <type>:
81937>>>>>>>    //       9 for 32-bit Windows workstation/workgroup engine or Linux
81937>>>>>>>    //         server using Workgroup authentication mode
81937>>>>>>>    //       C for client cache engine
81937>>>>>>>    //       D for DOS workstation
81937>>>>>>>    //       N for client Requester
81937>>>>>>>    //       S for NetWare server
81937>>>>>>>    //       T for 32-bit Windows server engine
81937>>>>>>>    //       U for Linux server using PAM or BTPASSWD authentication
81937>>>>>>>    //
81937>>>>>>>    //   example:
81937>>>>>>>    //       8.50.T
81937>>>>>>>    //   will be returned for a Pervasive.SQL 8.5 Server Engine running on
81937>>>>>>>    //   32-bits Windows server.
81937>>>>>>>    //
81937>>>>>>>    //   The FileNumber parameter must specify an opened table or 0.
81937>>>>>>>    //   For PSQLServerEngineVersionInfo the FileNumber can not be 0.
81937>>>>>>>    //
81937>>>>>>>    //   If the version information is not available or can not be obtained
81937>>>>>>>    //   the functions will return "0.0.0"
81937>>>>>>>
81937>>>>>>>
81937>>>>>>>    //***
81937>>>>>>>    //*** Function: PSQLRequesterVersionInfo
81937>>>>>>>    //*** Purpose : Returns the version information of the
81937>>>>>>>    //***           Pervasive.SQL Client requester.
81937>>>>>>>
81937>>>>>>>    Function PSQLRequesterVersionInfo Integer iFileNum Returns String
81939>>>>>>>
81939>>>>>>>        Local String  sDriverID
81939>>>>>>>        Local String  sVersion
81939>>>>>>>        Local String  sVoid
81939>>>>>>>        Local Integer iRetval
81939>>>>>>>
81939>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
81939>>>>>>>        // This error would otherwise be raised when we have an older
81939>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
81939>>>>>>>        Send Ignore_error To Error_object_Id 20491
81940>>>>>>>        Get psDriverID To sDriverID
81941>>>>>>>        Move (Repeat(" ", 255)) To sVersion
81942>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLREQUESTERVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
81947>>>>>>>        Send Trap_Error To Error_object_Id 20491
81948>>>>>>>        If (Trim(sVersion) = "") Begin
81950>>>>>>>            // Unable to get the revision. return all zeroes.
81950>>>>>>>            Move "0.0.0" To sVersion
81951>>>>>>>        End
81951>>>>>>>>
81951>>>>>>>        Function_Return sVersion
81952>>>>>>>    End_Function //  PSQLRequesterVersion
81953>>>>>>>
81953>>>>>>>    //***
81953>>>>>>>    //*** Function: PSQLLocalEngineVersionInfo
81953>>>>>>>    //*** Purpose : Returns the version information of the
81953>>>>>>>    //***           Pervasive.SQL Local Engine
81953>>>>>>>
81953>>>>>>>    Function PSQLLocalEngineVersionInfo Integer iFileNum Returns String
81955>>>>>>>
81955>>>>>>>        Local String  sDriverID
81955>>>>>>>        Local String  sVersion
81955>>>>>>>        Local String  sVoid
81955>>>>>>>        Local Integer iRetval
81955>>>>>>>
81955>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
81955>>>>>>>        // This error would otherwise be raised when we have an older
81955>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
81955>>>>>>>        Send Ignore_error To Error_object_Id 20491
81956>>>>>>>        Get psDriverID To sDriverID
81957>>>>>>>        Move (Repeat(" ", 255)) To sVersion
81958>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLLOCALENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
81963>>>>>>>        Send Trap_Error To Error_object_Id 20491
81964>>>>>>>        If (Trim(sVersion) = "") Begin
81966>>>>>>>            // Unable to get the revision. return all zeroes.
81966>>>>>>>            Move "0.0.0" To sVersion
81967>>>>>>>        End
81967>>>>>>>>
81967>>>>>>>        Function_Return sVersion
81968>>>>>>>    End_Function //  PSQLLocalEngineVersion
81969>>>>>>>
81969>>>>>>>    //***
81969>>>>>>>    //*** Function: PSQLServerEngineVersionInfo
81969>>>>>>>    //*** Purpose : Returns the version information of the
81969>>>>>>>    //***           Pervasive.SQL Server Engine
81969>>>>>>>
81969>>>>>>>    Function PSQLServerEngineVersionInfo Integer iFileNum Returns String
81971>>>>>>>
81971>>>>>>>        Local String  sDriverID
81971>>>>>>>        Local String  sVersion
81971>>>>>>>        Local String  sVoid
81971>>>>>>>        Local Integer iRetval
81971>>>>>>>
81971>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
81971>>>>>>>        // This error would otherwise be raised when we have an older
81971>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
81971>>>>>>>        Send Ignore_error To Error_object_Id 20491
81972>>>>>>>        Get psDriverID To sDriverID
81973>>>>>>>        Move (Repeat(" ", 255)) To sVersion
81974>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLSERVERENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
81979>>>>>>>        Send Trap_Error To Error_object_Id 20491
81980>>>>>>>        If (Trim(sVersion) = "") Begin
81982>>>>>>>            // Unable to get the revision. return all zeroes.
81982>>>>>>>            Move "0.0.0" To sVersion
81983>>>>>>>        End
81983>>>>>>>>
81983>>>>>>>        Function_Return sVersion
81984>>>>>>>    End_Function //  PSQLServerEngineVersion
81985>>>>>>>
81985>>>>>>>End_Class // cDfbtrdrvHandler
81986>>>>>>>
81986>>>>>
81986>>>>>
81986>>>>>External_Function WNetGetUser "WNetGetUserA" MPR.DLL Pointer lpName Pointer lpUser_Name Pointer lpLength Returns DWord
81987>>>>>
81987>>>>>Register_Function phoWorkspace Returns Handle
81987>>>>>Register_Function Help_filename Returns String
81987>>>>>Register_Function GetHelpFile Returns String
81987>>>>>Register_Function pbEnterKeyAsTabKey Returns Boolean
81987>>>>>
81987>>>>>//****************************************************************************
81987>>>>>// $Module type: FUNCTION
81987>>>>>// $Module name: Network_User_Name
81987>>>>>// $Author     : AK/VOO/KCR
81987>>>>>// Created     : 09-24-96 @ 19:17
81987>>>>>//
81987>>>>>// Description
81987>>>>>//    This function reads the current username Of windows and returns that
81987>>>>>//    name or an text unknown user
81987>>>>>//
81987>>>>>// $Rev History
81987>>>>>//  02/22/2012  Ask Windows how long the size of the name should be
81987>>>>>//  07/25/2003  Replaced obsolete code
81987>>>>>//  09/24/1996  Module header created
81987>>>>>//****************************************************************************
81987>>>>>Function Network_User_Name for cDesktop Returns String
81989>>>>>    String sName
81989>>>>>    Integer iRetval iLength
81989>>>>>
81989>>>>>    Move 0 to iLength
81990>>>>>    Move (WNetGetUser (0, 0, AddressOf (iLength))) to iRetval
81991>>>>>    ZeroString iLength to sName
81992>>>>>    Move (WNetGetUser (0, AddressOf (sName), AddressOf (iLength))) to iRetval
81993>>>>>
81993>>>>>    If (iRetval = NO_ERROR) Begin
81995>>>>>        Function_Return (CString (sName))
81996>>>>>    End
81996>>>>>>
81996>>>>>    
81996>>>>>    Function_Return "User Unknown"
81997>>>>>End_Function
81998>>>>>
81998>>>>>// OBSOLETE STRUCTURE AND WINDOWS API CALL. KEPT FOR BACKWARDS COMPATIBILITY
81998>>>>>Type MEMORYSTATUS
81998>>>>>   Field MEMORYSTATUS.dwLength         as DWord // sizeof(MEMORYSTATUS)
81998>>>>>   Field MEMORYSTATUS.dwMemoryLoad     as DWord // percent Of memory in use
81998>>>>>   Field MEMORYSTATUS.dwTotalPhys      as DWord // bytes Of physical memory
81998>>>>>   Field MEMORYSTATUS.dwAvailPhys      as DWord // free physical memory bytes
81998>>>>>   Field MEMORYSTATUS.dwTotalPageFile  as DWord // bytes Of paging file
81998>>>>>   Field MEMORYSTATUS.dwAvailPageFile  as DWord // free bytes Of paging file
81998>>>>>   Field MEMORYSTATUS.dwTotalVirtual   as DWord // user bytes Of address space
81998>>>>>   Field MEMORYSTATUS.dwAvailVirtual   as DWord // free user bytes
81998>>>>>End_Type // MEMORYSTATUS
81998>>>>>
81998>>>>>External_Function GlobalMemoryStatus "GlobalMemoryStatus" Kernel32.Dll Pointer lpsMemoryStatus Returns Integer
81999>>>>>
81999>>>>>Struct tWinMemoryStatusEx
81999>>>>>    UInteger dwLength                
81999>>>>>    UInteger dwMemoryLoad          
81999>>>>>    UBigInt ullTotalPhys           
81999>>>>>    UBigInt ullAvailPhys           
81999>>>>>    UBigInt ullTotalPageFile       
81999>>>>>    UBigInt ullAvailPageFile       
81999>>>>>    UBigInt ullTotalVirtual        
81999>>>>>    UBigInt ullAvailVirtual        
81999>>>>>    UBigInt ullAvailExtendedVirtual
81999>>>>>End_Struct
81999>>>>>
81999>>>>>External_Function GlobalMemoryStatusEx "GlobalMemoryStatusEx" Kernel32.Dll Pointer lpMemoryStatus Returns Integer
82000>>>>>
82000>>>>>Class SysinfoDisplay is a cTextEdit
82001>>>>>    Procedure Construct_Object
82003>>>>>        Forward Send Construct_Object
82005>>>>>
82005>>>>>        Set Location To 6 6
82006>>>>>        Set Size To 110 255
82007>>>>>        Set Read_Only_State To True
82008>>>>>        Set pbWrap to False
82009>>>>>    End_Procedure
82010>>>>>
82010>>>>>    //****************************************************************************
82010>>>>>    // $Module type: PROCEDURE
82010>>>>>    // $Module name: Show_Current_Directory
82010>>>>>    // $Author     : VOO
82010>>>>>    // Created     : 06-10-96 @ 15:24
82010>>>>>    //
82010>>>>>    // Description
82010>>>>>    //    This method will show the name Of the current directory in the system
82010>>>>>    //    information box
82010>>>>>    //
82010>>>>>    // $Rev History
82010>>>>>    //    06-10-96  Module header created
82010>>>>>    //****************************************************************************
82010>>>>>    Procedure Show_Current_Directory
82012>>>>>        String sDir
82012>>>>>
82012>>>>>        Get_Current_Directory To sDir
82013>>>>>
82013>>>>>        Send AppendTextLn (SFormat (C_$CurrentDirectory, sDir))
82014>>>>>    End_Procedure
82015>>>>>
82015>>>>>    Procedure Show_Windows_Directory
82017>>>>>        String sWindir
82017>>>>>
82017>>>>>        Get_Windows_Directory To sWindir
82018>>>>>
82018>>>>>        Send AppendTextLn (SFormat (C_$WindowsDirectory, sWindir))
82019>>>>>    End_Procedure
82020>>>>>
82020>>>>>    Procedure Show_Current_User
82022>>>>>        Send AppendTextLn (SFormat (C_$NetworkUserName, Network_User_Name (Self)))
82023>>>>>    End_Procedure
82024>>>>>
82024>>>>>    Procedure Show_Number_Format
82026>>>>>        Integer iFormat
82026>>>>>        String sFormatText
82026>>>>>
82026>>>>>        Get_Attribute DF_THOUSANDS_SEPARATOR to iFormat
82029>>>>>        Move (Character (iFormat)) To sFormatText
82030>>>>>        Send AppendTextLn (SFormat (C_$ThousandsSeparator, sFormatText, iFormat))
82031>>>>>
82031>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iFormat
82034>>>>>        Move (Character (iFormat)) to sFormatText
82035>>>>>        Send AppendTextLn (SFormat (C_$DecimalSeparator, sFormatText))
82036>>>>>    End_Procedure
82037>>>>>
82037>>>>>    Procedure Show_Filelist_Name
82039>>>>>        String sFilename
82039>>>>>
82039>>>>>        Get_Attribute DF_FILELIST_NAME to sFilename
82042>>>>>
82042>>>>>        Send AppendTextLn (SFormat (C_$CurrentFilelist, sFilename))
82043>>>>>        Send AppendTextLn ""
82044>>>>>    End_Procedure
82045>>>>>
82045>>>>>    Procedure Show_Lock_Delay
82047>>>>>        Integer iLockdelay
82047>>>>>
82047>>>>>        Get_Attribute DF_LOCK_DELAY to iLockdelay
82050>>>>>
82050>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingDelay, iLockDelay))
82051>>>>>    End_Procedure
82052>>>>>
82052>>>>>    Procedure Show_Lock_Timeout
82054>>>>>        Integer iLockTimeout
82054>>>>>
82054>>>>>        Get_Attribute DF_LOCK_TIMEOUT to iLockTimeout
82057>>>>>
82057>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingTimeout, iLockTimeOut))
82058>>>>>    End_Procedure
82059>>>>>
82059>>>>>    Procedure Show_Screen_Size
82061>>>>>        Integer iYscreensize iXscreensize
82061>>>>>
82061>>>>>        Move (GetSystemMetrics (SM_CXSCREEN)) To iXscreensize
82062>>>>>        Move (GetSystemMetrics (SM_CYSCREEN)) To iYscreensize
82063>>>>>
82063>>>>>        Send AppendTextLn (SFormat (C_$VideoResolution, iXscreensize, iYscreensize))
82064>>>>>    End_Procedure
82065>>>>>
82065>>>>>    Procedure Show_Page_Size
82067>>>>>        Send AppendTextLn (SFormat (C_$PageEndFormFeed, Pageend, Pagefeed))
82068>>>>>    End_procedure
82069>>>>>
82069>>>>>    Procedure Show_Date
82071>>>>>        Date dToday
82071>>>>>
82071>>>>>        Sysdate dToday
82072>>>>>
82072>>>>>        Send AppendTextLn (SFormat (C_$CurrentSystemDate, String (dToday)))
82073>>>>>    End_procedure
82074>>>>>
82074>>>>>    Procedure Show_Date_Format
82076>>>>>        Integer iDateFormat
82076>>>>>        String sDateFormat
82076>>>>>
82076>>>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
82079>>>>>        Case Begin
82079>>>>>            Case (iDateFormat = DF_DATE_USA)
82081>>>>>                Move C_$USA To sDateFormat
82082>>>>>                Case Break
82083>>>>>            Case (iDateFormat = DF_DATE_EUROPEAN)
82086>>>>>                Move C_$European To sDateFormat
82087>>>>>                Case Break
82088>>>>>            Case (iDateFormat = DF_DATE_MILITARY)
82091>>>>>                Move C_$Military To sDateFormat
82092>>>>>                Case Break
82093>>>>>            Case Else
82093>>>>>                Move C_$UnknownDateType To sDateFormat
82094>>>>>                Case Break
82095>>>>>        Case End
82095>>>>>
82095>>>>>        Send AppendTextLn (SFormat (C_$DateFormat, sDateformat))
82096>>>>>    End_Procedure
82097>>>>>
82097>>>>>    Procedure Show_Systemresources
82099>>>>>        tWinMemoryStatusEx MemoryStatusInfo
82099>>>>>        tWinMemoryStatusEx MemoryStatusInfo
82099>>>>>        Integer iRetval
82099>>>>>
82099>>>>>        Move (SizeOfType (tWinMemoryStatusEx)) to MemoryStatusInfo.dwLength
82100>>>>>        Move (GlobalMemoryStatusEx (AddressOf (MemoryStatusInfo))) to iRetval
82101>>>>>        If (iRetval = 0) Begin
82103>>>>>            Move (ShowLastError ()) to iRetval
82104>>>>>        End
82104>>>>>>
82104>>>>>
82104>>>>>        Send AppendTextLn (SFormat (C_$AvailableMemory, MemoryStatusInfo.ullTotalPhys))
82105>>>>>        Send AppendTextLn (SFormat (C_$MemoryUtilization, MemoryStatusInfo.dwMemoryLoad))
82106>>>>>        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, Real (MemoryStatusInfo.ullAvailPhys) / Real (MemoryStatusInfo.ullTotalPhys) * 100.0))
82107>>>>>        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, Real (MemoryStatusInfo.ullAvailPageFile) / Real (MemoryStatusInfo.ullTotalPageFile) * 100.0))
82108>>>>>        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, Real (MemoryStatusInfo.ullAvailVirtual) / Real (MemoryStatusInfo.ullTotalVirtual) * 100.0))
82109>>>>>    End_Procedure
82110>>>>>
82110>>>>>    Procedure Show_Registration
82112>>>>>        String sRegName
82112>>>>>        Integer iSN iMaxUsers
82112>>>>>
82112>>>>>        Registration sRegName iSN
82113>>>>>>
82113>>>>>        
82113>>>>>        Get_Licensed_Max_Users to iMaxUsers
82114>>>>>
82114>>>>>        Send AppendTextLn ""
82115>>>>>        Send AppendTextLn (SFormat (C_$Serial, iSN))
82116>>>>>        Send AppendTextLn (SFormat (C_$RegName, sRegName))
82117>>>>>        Send AppendTextLn (SFormat (C_$MaxNumUsers, iMaxUsers))
82118>>>>>    End_Procedure
82119>>>>>
82119>>>>>    //****************************************************************************
82119>>>>>    // If workspaces are used, we will send the message EnumerateWorkspaceData
82119>>>>>    // To the workspace object passing the an object and message To send back
82119>>>>>    // To this object. It is expected that the workspace object will send this
82119>>>>>    // message for every line Of information it wants displayed (passing the
82119>>>>>    // information To be displayed
82119>>>>>    //****************************************************************************
82119>>>>>    Register_Procedure EnumerateWorkspaceData Integer hObjId Integer hmMessId
82119>>>>>
82119>>>>>    Procedure Show_ServicePack
82121>>>>>        String sKey sVersionDescription sVersion 
82121>>>>>        Handle hoRegistry
82121>>>>>        Boolean bExists bOpened
82121>>>>>        
82121>>>>>        Get Create (RefClass (cRegistry)) to hoRegistry
82122>>>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
82123>>>>>        Set pfAccessRights of hoRegistry to KEY_READ
82124>>>>>
82124>>>>>        Move C_DFVersionRegistryRoot to sKey
82125>>>>>        Get KeyExists of hoRegistry sKey to bExists
82126>>>>>        If (bExists) Begin
82128>>>>>            Get OpenKey of hoRegistry sKey to bOpened
82129>>>>>            If (bOpened) Begin
82131>>>>>                Get ValueExists of hoRegistry "CurrentVersionDescription" to bExists
82132>>>>>                If (bExists) Begin
82134>>>>>                    Get ReadString of hoRegistry "CurrentVersionDescription" to sVersionDescription
82135>>>>>                End
82135>>>>>>
82135>>>>>                
82135>>>>>                Get ValueExists of hoRegistry "CurrentVersion" to bExists
82136>>>>>                If (bExists) Begin
82138>>>>>                    Get ReadString of hoRegistry "CurrentVersion" to sVersion
82139>>>>>                End                
82139>>>>>>
82139>>>>>                Send CloseKey of hoRegistry
82140>>>>>            End
82140>>>>>>
82140>>>>>        End
82140>>>>>>
82140>>>>>        Send Destroy of hoRegistry
82141>>>>>
82141>>>>>        If (sVersionDescription <> "") Begin
82143>>>>>           Send AppendTextLn (sVersionDescription * "-" * sVersion)
82144>>>>>           Send AppendTextLn ""
82145>>>>>        End
82145>>>>>>
82145>>>>>    End_Procedure
82146>>>>>    
82146>>>>>
82146>>>>>    Procedure Show_WorkspaceInformation
82148>>>>>        Integer hoWorkspace
82148>>>>>
82148>>>>>        If (ghoApplication <> 0) Begin
82150>>>>>            Get phoWorkspace of ghoApplication to hoWorkspace
82151>>>>>            If (hoWorkspace <> 0) Begin
82153>>>>>                Send EnumerateWorkspaceData of hoWorkspace Self (Refproc (AppendTextLn))
82154>>>>>                Send AppendTextLn ""
82155>>>>>            End
82155>>>>>>
82155>>>>>        End
82155>>>>>>
82155>>>>>    End_Procedure
82156>>>>>
82156>>>>>    Function VersionStr Integer iVer Integer iRev Integer iBld Returns String
82158>>>>>        Function_Return (String (iVer) - "." - String (iRev) - "." - String (iBld))
82159>>>>>    End_Function
82160>>>>>
82160>>>>>    Procedure Show_Versions
82162>>>>>        Integer iVersion iRevision iBuild
82162>>>>>
82162>>>>>        Version_Information iVersion iRevision iBuild
82164>>>>>
82164>>>>>        Send AppendTextLn (SFormat (C_$RuntimeVersion, VersionStr(Self,iVersion,iRevision,iBuild) ))
82165>>>>>        Send AppendTextLn (SFormat (C_$PackageVersion, VersionStr(Self,PKG_VERSION, PKG_REVISION, PKG_BUILD) ))
82166>>>>>        Send AppendTextLn (SFormat (C_$FMACVersion, VersionStr(Self,FMAC_VERSION, FMAC_REVISION, FMAC_BUILD) ))
82167>>>>>    End_Procedure
82168>>>>>    
82168>>>>>    Function CKRevisionNumber String sDriverID Returns String
82170>>>>>        Handle hoCLIHandler
82170>>>>>        Handle hoDFBtrDrvHandler
82170>>>>>        String sCKRevision
82170>>>>>
82170>>>>>
82170>>>>>        If (sDriverID = "MSSQLDRV" or sDriverID = "ODBC_DRV" or sDriverID = "DB2_DRV") Begin
82172>>>>>            Get Create (RefClass(cCLIHandler)) to hoCLIHandler
82173>>>>>            Set psDriverID of hoCLIHandler to sDriverID
82174>>>>>            Move (CKRevision(hoCLIHandler)) to sCKRevision
82175>>>>>            Send Destroy of hoCLIHandler
82176>>>>>        End
82176>>>>>>
82176>>>>>        Else Begin
82177>>>>>            If (sDriverID = "DFBTRDRV") Begin
82179>>>>>                Get Create (RefClass(cDFBtrDrvHandler)) to hoDFBtrDrvHandler
82180>>>>>                Set psDriverID of hoDFBtrDrvHandler to sDriverID
82181>>>>>                Move (CKRevision(hoDFBtrDrvHandler)) to sCKRevision
82182>>>>>                Send Destroy of hoDFBtrDrvHandler
82183>>>>>            End
82183>>>>>>
82183>>>>>        End
82183>>>>>>
82183>>>>>        
82183>>>>>        Function_Return sCKRevision
82184>>>>>    End_Function
82185>>>>>    
82185>>>>>    
82185>>>>>    Function IsDataAccessCK String sDriverID Returns Boolean
82187>>>>>        
82187>>>>>        If (sDriverID = "DATAFLEX") Begin
82189>>>>>            Function_Return False
82190>>>>>        End
82190>>>>>>
82190>>>>>    
82190>>>>>        Function_Return (sDriverID = "MSSQLDRV" or sDriverID = "ODBC_DRV" or sDriverID = "DB2_DRV" or sDriverID = "DFBTRDRV")
82191>>>>>    End_Function    
82192>>>>>
82192>>>>>
82192>>>>>    //***
82192>>>>>    //*** BW
82192>>>>>    //*** Procedure: Show_Drivers
82192>>>>>    //*** Purpose  : Show loaded database drivers
82192>>>>>    //***
82192>>>>>
82192>>>>>    Procedure Show_Drivers
82194>>>>>        String sCurrentDriver sRevNumber
82194>>>>>        String sLoadedDrivers
82194>>>>>        Integer iNumberOfDrivers iCount
82194>>>>>        Boolean bOK
82194>>>>>
82194>>>>>        Move "" To sLoadedDrivers
82195>>>>>        Get_Attribute DF_NUMBER_DRIVERS To iNumberOfDrivers
82198>>>>>        For iCount From 1 To iNumberOfDrivers
82204>>>>>>
82204>>>>>            Get_Attribute DF_DRIVER_NAME Of iCount To sCurrentDriver
82207>>>>>            If (sLoadedDrivers <> "") Begin
82209>>>>>                Move (Append (sLoadedDrivers, ", ")) To sLoadedDrivers
82210>>>>>            End
82210>>>>>>
82210>>>>>            Get IsDataAccessCK sCurrentDriver to bOK
82211>>>>>            If (bOK) Begin
82213>>>>>                Get CKRevisionNumber sCurrentDriver to sRevNumber
82214>>>>>                Move (sCurrentDriver * "(" + sRevNumber + ")") to sCurrentDriver
82215>>>>>            End
82215>>>>>>
82215>>>>>            Move (Append (sLoadedDrivers, sCurrentDriver)) To sLoadedDrivers
82216>>>>>        Loop
82217>>>>>>
82217>>>>>        Send AppendTextLn (SFormat (C_$DatabaseDriver, sLoadedDrivers))
82218>>>>>    End_Procedure
82219>>>>>
82219>>>>>    Procedure Show_HelpFile
82221>>>>>        String sHelpFile
82221>>>>>        Integer eHelpType
82221>>>>>
82221>>>>>        If (ghoApplication <> 0) Begin
82223>>>>>            Get peHelpType Of ghoApplication To eHelpType
82224>>>>>            If (eHelpType = htHtmlHelp and ghoHtmlHelp) Begin
82226>>>>>                Get GetHelpFile Of ghoHtmlHelp To sHelpFile
82227>>>>>            End
82227>>>>>>
82227>>>>>            Else If (eHelpType = htWinHelp and Help_object_id) Begin
82230>>>>>                Get Help_filename Of Help_object_id To sHelpFile
82231>>>>>            End
82231>>>>>>
82231>>>>>            Else Begin
82232>>>>>                Move C_$ThereIsNoHelpfileDefined To sHelpFile
82233>>>>>            End
82233>>>>>>
82233>>>>>
82233>>>>>            Send AppendTextLn ""
82234>>>>>            Send AppendTextLn (SFormat (C_$HelpFile, sHelpFile))
82235>>>>>        End
82235>>>>>>
82235>>>>>    End_Procedure
82236>>>>>
82236>>>>>    Procedure Show_EnterAsTab
82238>>>>>        Boolean bEnterKeyAsTabKey
82238>>>>>        String sText
82238>>>>>
82238>>>>>        If (ghoApplication <> 0) Begin
82240>>>>>            Get pbEnterKeyAsTabKey Of ghoApplication To bEnterKeyAsTabKey
82241>>>>>            If (bEnterKeyAsTabKey) Begin
82243>>>>>                Move "True" To sText
82244>>>>>            End
82244>>>>>>
82244>>>>>            Else Begin
82245>>>>>                Move "False" To sText
82246>>>>>            End
82246>>>>>>
82246>>>>>            Send AppendTextLn (SFormat (C_$EnterKeyNavForward, sText))
82247>>>>>        End
82247>>>>>>
82247>>>>>    End_Procedure
82248>>>>>
82248>>>>>    //****************************************************************************
82248>>>>>    // $Module type: PROCEDURE
82248>>>>>    // $Module name: Add_Focus
82248>>>>>    // $Author     : VOO
82248>>>>>    // Created     : 24-09-96 @ 19:43
82248>>>>>    //
82248>>>>>    // Description
82248>>>>>    //    During activation we will remove the old information and add the newly
82248>>>>>    //    found systeminformation
82248>>>>>    //
82248>>>>>    // $Rev History
82248>>>>>    //    24-09-96  Module header created
82248>>>>>    //****************************************************************************
82248>>>>>    Procedure Add_Focus Integer hoRoot
82250>>>>>        Forward Send Add_Focus hoRoot
82252>>>>>
82252>>>>>        Send Delete_Data
82253>>>>>
82253>>>>>        Set Changed_State To False
82254>>>>>        Set Read_Only_State To True
82255>>>>>
82255>>>>>        Send Show_ServicePack
82256>>>>>        Send Show_Versions   
82257>>>>>        Send Show_Drivers         
82258>>>>>        Send Show_HelpFile
82259>>>>>        Send Show_Current_Directory
82260>>>>>        Send Show_Filelist_Name          
82261>>>>>        If (ghoApplication <> 0) Begin
82263>>>>>            Send Show_WorkSpaceInformation // added To show WS info
82264>>>>>        End
82264>>>>>>
82264>>>>>        Send Show_Current_User 
82265>>>>>        Send Show_Windows_Directory 
82266>>>>>        Send Show_Screen_Size
82267>>>>>        Send Show_Page_Size
82268>>>>>        Send Show_EnterAsTab        
82269>>>>>        Send Show_Number_Format
82270>>>>>        Send Show_Date_Format
82271>>>>>        Send Show_Lock_Delay
82272>>>>>        Send Show_Lock_Timeout
82273>>>>>        Send Show_Date
82274>>>>>        Send Show_Systemresources
82275>>>>>        Send Show_Registration
82276>>>>>        Send Beginning_of_Data
82277>>>>>
82277>>>>>        Set Icon to 'default.ico'
82278>>>>>    End_Procedure
82279>>>>>End_Class
82280>>>>>
82280>>>>>//****************************************************************************
82280>>>>>// $Module type: OBJECT
82280>>>>>// $Module name: Sysinfo_Dialog
82280>>>>>// $Author     : VOO
82280>>>>>// Created     : 24-09-96 @ 18:47
82280>>>>>//
82280>>>>>// Description
82280>>>>>//    This object shows the systeminformation on the screen
82280>>>>>//
82280>>>>>// $Rev History
82280>>>>>//    24-09-96  Module header created
82280>>>>>//****************************************************************************
82280>>>>>Class SysInfoDialog Is A ModalPanel
82281>>>>>    Procedure Construct_Object
82283>>>>>        Forward Send Construct_Object
82285>>>>>
82285>>>>>        Set Label to C_$SystemInformation
82286>>>>>        Set Size to 140 267
82287>>>>>        Set piMinSize to 140 267
82288>>>>>        Set Locate_Mode To CENTER_ON_SCREEN
82289>>>>>        Set Border_Style to Border_Thick
82290>>>>>
82290>>>>>        Object oSysinfoDisplay Is A SysInfoDisplay
82292>>>>>            Set peAnchors to anAll
82293>>>>>        End_Object
82294>>>>>
82294>>>>>        Object oCloseButton Is A Button
82296>>>>>            Set Label To C_$Close
82297>>>>>            Set Location To 120 210
82298>>>>>            Set Message Item 0 To (Refproc (Close_Panel))
82299>>>>>            Set Default_State To True
82300>>>>>            Set peAnchors to anBottomRight
82301>>>>>        End_Object
82302>>>>>
82302>>>>>        On_Key kCancel Send Close_Panel
82303>>>>>    End_Procedure
82304>>>>>End_Class
82305>>>>>
82305>>>>>// Purpose:
82305>>>>>//
82305>>>>>// Ken Ross 12/17/96 5:16PM
82305>>>>>//
82305>>>>>Class AboutDialog Is A ModalPanel
82306>>>>>    Procedure Construct_Object
82308>>>>>        String sVdfRootDir
82308>>>>>
82308>>>>>        Forward Send Construct_Object
82310>>>>>
82310>>>>>        Set Label To C_$About
82311>>>>>        Set Size to 89 212
82312>>>>>        Set Locate_Mode To CENTER_ON_SCREEN
82313>>>>>
82313>>>>>        Object oSysInfoDialog Is A SysInfoDialog
82315>>>>>        End_Object
82316>>>>>
82316>>>>>        Object oBox Is A Container3d
82318>>>>>            Set Border_Style To Border_StaticEdge
82319>>>>>            Set Size to 63 202
82320>>>>>            Set Location To 4 5
82321>>>>>
82321>>>>>            Object oAboutGraphic Is A BitmapContainer
82323>>>>>                Set Border_Style To Border_None
82324>>>>>                Set Bitmap_Style To Bitmap_Center
82325>>>>>                Set Size To 48 48
82326>>>>>                Set Location To 7 2
82327>>>>>            End_Object
82328>>>>>
82328>>>>>            Object oProductName Is A TextBox
82330>>>>>                Set Label To C_$ProductName
82331>>>>>                Set Size To 10 45
82332>>>>>                Set Location To 8 53
82333>>>>>            End_Object
82334>>>>>
82334>>>>>            Object oVersion Is A TextBox
82336>>>>>                Set Label To C_$Version
82337>>>>>                Set Size To 10 25
82338>>>>>                Set Location To 21 53
82339>>>>>            End_Object
82340>>>>>
82340>>>>>            Object oCopyright Is A TextBox
82342>>>>>                Set Label To C_$Copyright
82343>>>>>                Set Size To 10 31
82344>>>>>                Set Location To 34 53
82345>>>>>            End_Object
82346>>>>>
82346>>>>>            Object oAuthor Is A TextBox
82348>>>>>                Set Label To C_$Author
82349>>>>>                Set Size To 10 22
82350>>>>>                Set Location To 46 53
82351>>>>>            End_Object
82352>>>>>        End_Object
82353>>>>>
82353>>>>>        Object oOKButton Is A Button
82355>>>>>            On_Item C_$OK Send Close_Panel
82356>>>>>            Set Size To 14 50
82357>>>>>            Set Location To 71 157
82358>>>>>        End_Object
82359>>>>>
82359>>>>>        Object oSysInfoButton Is A Button
82361>>>>>            On_Item C_$SystemInfo Send Show_Sysinfo
82362>>>>>            Set Size To 14 50
82363>>>>>            Set Location To 71 101
82364>>>>>        End_Object
82365>>>>>
82365>>>>>        On_Key Kcancel Send KeyAction Of oOKButton
82366>>>>>
82366>>>>>        Set Logo To "DacAbout.bmp"  // square bitmaps Of 42x42 work best
82367>>>>>    End_Procedure
82368>>>>>
82368>>>>>    Procedure Set ProductName String sProductName
82370>>>>>        Set Label Of oProductName To sProductName
82371>>>>>    End_Procedure
82372>>>>>
82372>>>>>    Procedure Set Version String sVersion
82374>>>>>        Set Label Of oVersion To sVersion
82375>>>>>    End_Procedure
82376>>>>>
82376>>>>>    Procedure Set Copyright string sCopyright
82378>>>>>        Set Label Of oCopyright To sCopyright
82379>>>>>    End_Procedure
82380>>>>>
82380>>>>>    Procedure Set Author String sAuthor
82382>>>>>        Set Label Of oAuthor To sAuthor
82383>>>>>    End_Procedure
82384>>>>>
82384>>>>>    Procedure Set Logo string sLogo
82386>>>>>        // square bitmaps Of 42x42 work best
82386>>>>>        Set Bitmap Of oAboutGraphic To sLogo
82387>>>>>    End_Procedure
82388>>>>>
82388>>>>>    Procedure Show_Sysinfo
82390>>>>>        Send Popup_Modal Of oSysinfoDialog
82391>>>>>    End_Procedure
82392>>>>>
82392>>>>>    Procedure End_Construct_Object
82394>>>>>        Handle hoVersionInfo
82394>>>>>        Boolean bIncluded
82394>>>>>        Integer iMajor iMinor iRelease iBuild
82394>>>>>        String sLabel
82394>>>>>
82394>>>>>        Get Label Of oVersion To sLabel
82395>>>>>        If (sLabel = C_$VERSION) Begin
82397>>>>>            // set it To the version info Of the program, if available
82397>>>>>            If (ghoApplication <> 0) Begin
82399>>>>>                Get phoVersionInfo of ghoApplication to hoVersionInfo
82400>>>>>                If (hoVersionInfo <> 0) Begin
82402>>>>>                    Get pbIncluded of hoVersionInfo to bIncluded
82403>>>>>                    If (bIncluded) Begin
82405>>>>>                        Get piVersionMajor of hoVersionInfo to iMajor
82406>>>>>                        Get piVersionMinor of hoVersionInfo to iMinor
82407>>>>>                        Get piVersionRelease of hoVersionInfo to iRelease
82408>>>>>                        Get piVersionBuild of hoVersionInfo to iBuild
82409>>>>>                        Move (SFormat (C_$VERSION + ": %1.%2.%3.%4", iMajor, iMinor, iRelease, iBuild)) to sLabel
82410>>>>>                        Set Version to sLabel
82411>>>>>                    End
82411>>>>>>
82411>>>>>                End
82411>>>>>>
82411>>>>>            End
82411>>>>>>
82411>>>>>        End
82411>>>>>>
82411>>>>>
82411>>>>>        Forward Send End_Construct_Object
82413>>>>>    End_Procedure
82414>>>>>End_Class
82415>>>
82415>>>// *************************************************************************
82415>>>//  Public message. This is the default message. It is expected that you will
82415>>>//   create your own message to override this
82415>>>// *************************************************************************
82415>>>
82415>>>Procedure Activate_About
82418>>>   Send DoAbout "" "" "" "" ""
82419>>>End_Procedure
82420>>>
82420>>>// *************************************************************************
82420>>>//  Public message. It is expected that you will send this message (most
82420>>>//  likely from Activate_About. This creates an about object, activates it
82420>>>//  and destroys it when done. It is not exepected that you will augment this.
82420>>>// *************************************************************************
82420>>>
82420>>>Procedure DoAbout string sTitle string sVersion string sCopyRight string sAuthor string sBitmap
82423>>>        integer hoObj hoMain
82423>>>
82423>>>        // create object
82423>>>        Object About is an AboutDialog
82425>>>            // if no title passed use the label of the main panel
82425>>>            // (if a main panel exists).
82425>>>            if sTitle     eq '' Begin
82427>>>                Get Main_Window of desktop to hoMain
82428>>>                if hoMain Get Label of hoMain to sTitle
82431>>>            end
82431>>>>
82431>>>            set productname to sTitle
82432>>>            set version     to sVersion
82433>>>            set copyright   to sCopyRight
82434>>>            set author      to sAuthor
82435>>>            If sBitmap    ne '' ;               set logo to sBitMap // square bitmaps of 42x42 work best
82438>>>            Move self to hoObj // object Id
82439>>>        End_Object
82440>>>        Send Popup   of hoObj    // popup the about object
82441>>>        Send Destroy of hoObj // when done, it will be destroyed
82442>>>End_procedure
82443>        Use DemoSuggestionForm.vw
Including file: DemoSuggestionForm.vw    (C:\Test\Order Entry git\AppSrc\DemoSuggestionForm.vw)
82443>>>Use Windows.pkg
82443>>>Use DFClient.pkg
82443>>>Use dbSuggestionForm.pkg
Including file: dbSuggestionForm.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\dbSuggestionForm.pkg)
82443>>>>>Use Dfentry.pkg
82443>>>>>Use WinSuggestion.pkg
Including file: WinSuggestion.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\WinSuggestion.pkg)
82443>>>>>>>// 
82443>>>>>>>
82443>>>>>>>Use Windows.pkg
82443>>>>>>>Use tWinStructs.pkg
82443>>>>>>>Use tSuggestion.pkg
Including file: tSuggestion.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\tSuggestion.pkg)
82443>>>>>>>>>// struct used for suggestion forms, representing an item of data
82443>>>>>>>>>Enum_List 
82443>>>>>>>>>    Define smFind
82443>>>>>>>>>    Define smValidationTable
82443>>>>>>>>>    Define smCustom
82443>>>>>>>>>End_Enum_List
82443>>>>>>>>>
82443>>>>>>>>>Struct tSuggestion
82443>>>>>>>>>    String sRowId
82443>>>>>>>>>    String[] aValues
82443>>>>>>>>>End_Struct
82443>>>>>>>>>
82443>>>>>>>Use cTimer.pkg
Including file: cTimer.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cTimer.pkg)
82443>>>>>>>>>// cTimer class
82443>>>>>>>>>//
82443>>>>>>>>>// This supercedes the DFTimer class. 
82443>>>>>>>>>// It is simpler and more flexible
82443>>>>>>>>>
82443>>>>>>>>>Use Dftimer.pkg // we still use the Timer Manager classes and global objects
Including file: Dftimer.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\Dftimer.pkg)
82443>>>>>>>>>>>//************************************************************************
82443>>>>>>>>>>>//--- DFTimer   Timer package for DataFlex programs
82443>>>>>>>>>>>//
82443>>>>>>>>>>>// Copyright (c) 1983-2002 Data Access Corporation, Miami Florida,
82443>>>>>>>>>>>// All rights reserved.
82443>>>>>>>>>>>// DataFlex is a registered trademark of Data Access Corporation.
82443>>>>>>>>>>>//
82443>>>>>>>>>>>//************************************************************************
82443>>>>>>>>>>>//  Description:
82443>>>>>>>>>>>//      This package contains all components needed to implement timers
82443>>>>>>>>>>>//      in a DataFlex 4 program.
82443>>>>>>>>>>>//
82443>>>>>>>>>>>//
82443>>>>>>>>>>>//  Author: Eddy Kleinjan, Data Access Nederland
82443>>>>>>>>>>>//************************************************************************
82443>>>>>>>>>>>// 03/03/2001 EK  Fixed Timer_Active_State to check for valid windows
82443>>>>>>>>>>>//                handle before trying to set or kill a timer.
82443>>>>>>>>>>>//                Fixed Kill_All_Timers to check for valid windows
82443>>>>>>>>>>>//                handle before trying to kill a timer.
82443>>>>>>>>>>>//                The windows handle might not exist anymore when the
82443>>>>>>>>>>>//                program is being exited using Exit_Application.
82443>>>>>>>>>>>// 12/13/2001 JJT fixed Timer_Active_State to check for -1 (not 0). Fixed a
82443>>>>>>>>>>>//                a bug where set Timeout started inactive timers.
82443>>>>>>>>>>>//                Added code to force timer object to desktop
82443>>>>>>>>>>>//************************************************************************
82443>>>>>>>>>>>// CLASS DFTimer
82443>>>>>>>>>>>//
82443>>>>>>>>>>>// Usage:
82443>>>>>>>>>>>//    Object MyTimer is a DFTimer
82443>>>>>>>>>>>//
82443>>>>>>>>>>>//        Set Timeout to 2000                             // Default 1000
82443>>>>>>>>>>>//        Set Auto_Start_State to TRUE|FALSE              // Default TRUE
82443>>>>>>>>>>>//        Set Auto_Stop_State to TRUE|FALSE               // Default TRUE
82443>>>>>>>>>>>//        Set Timer_Message to MyMessage                  // Default 0
82443>>>>>>>>>>>//        Set Timer_Object to (MyObject(self))            // Default 0
82443>>>>>>>>>>>//        Set Timer_Active_State to TRUE|FALSE            // Default FALSE
82443>>>>>>>>>>>//
82443>>>>>>>>>>>//        // Augment when no Timer_Message
82443>>>>>>>>>>>//        Procedure OnTimer
82443>>>>>>>>>>>//            Send Info_Box "HEY, WAKE UP!"
82443>>>>>>>>>>>//        End_Procedure
82443>>>>>>>>>>>//
82443>>>>>>>>>>>//    End_Object
82443>>>>>>>>>>>//
82443>>>>>>>>>>>// DESCRIPTION
82443>>>>>>>>>>>//      Objects of this class can be used to trigger an event after a
82443>>>>>>>>>>>//      certain amount of time has passed. You can specify this time
82443>>>>>>>>>>>//      by setting the Timeout property of the object. This timeout
82443>>>>>>>>>>>//      is in miliseconds.
82443>>>>>>>>>>>//
82443>>>>>>>>>>>//      Whenever a timer event happens, it will notify the object by
82443>>>>>>>>>>>//      sending an OnTimer event. You can trap this event to do whatever
82443>>>>>>>>>>>//      you want the timer to do. By default this OnTimer event
82443>>>>>>>>>>>//      will send the Timer_Message to Timer_Object, when these have
82443>>>>>>>>>>>//      been specified.
82443>>>>>>>>>>>//
82443>>>>>>>>>>>//      By default, you have to activate a timer by setting its
82443>>>>>>>>>>>//      Timer_Active_State to TRUE. When the timer has been placed
82443>>>>>>>>>>>//      inside a user-interface object, it can also be activated
82443>>>>>>>>>>>//      automatically when this user-interface object is being
82443>>>>>>>>>>>//      activated. This only happes when it Auto_Start_State is TRUE,
82443>>>>>>>>>>>//      which is the default setting. In such a case, the timer will
82443>>>>>>>>>>>//      also automatically being stopped when the user-interface
82443>>>>>>>>>>>//      object is taken of the screen. This depends on the
82443>>>>>>>>>>>//      Auto_Stop_Timer state to happen.
82443>>>>>>>>>>>//
82443>>>>>>>>>>>//      When you need to set a new timeout value, you can do so
82443>>>>>>>>>>>//      even when the timer is active. It will adjust the timeout
82443>>>>>>>>>>>//      immediately.
82443>>>>>>>>>>>//
82443>>>>>>>>>>>//      Note that timer events depend on Windows for the delivery of
82443>>>>>>>>>>>//      the event. Since timer events get a low priority in Windows,
82443>>>>>>>>>>>//      it might put your program on hold when other programs are very
82443>>>>>>>>>>>//      busy. In such a case, you will only receive one timer event
82443>>>>>>>>>>>//      after the process stopped. There is no way, other than
82443>>>>>>>>>>>//      calculating it yourself, to determine how many time has passed
82443>>>>>>>>>>>//      or how many timer event should have happened since the last
82443>>>>>>>>>>>//      timer event or timer activation.
82443>>>>>>>>>>>//
82443>>>>>>>>>>>// PUBLIC INTERFACE
82443>>>>>>>>>>>//
82443>>>>>>>>>>>//    PROPERTIES
82443>>>>>>>>>>>//
82443>>>>>>>>>>>//    Auto_Start_State When TRUE (default) the timer will be activated
82443>>>>>>>>>>>//                     automatically when the object will be (virtually)
82443>>>>>>>>>>>//                     paged on the screen.
82443>>>>>>>>>>>//                     Example: When a timer object has been placed
82443>>>>>>>>>>>//                     inside a view, then the timer will be activated
82443>>>>>>>>>>>//                     when the view is activated.
82443>>>>>>>>>>>//
82443>>>>>>>>>>>//    Auto_Stop_State  When TRUE (default) the timer will be deactivated
82443>>>>>>>>>>>//                     automatically when the object will be (virtually)
82443>>>>>>>>>>>//                     taken off the screen.
82443>>>>>>>>>>>//
82443>>>>>>>>>>>//    Timeout          The timeout value for the timer to fire. The
82443>>>>>>>>>>>//                     timeout value must be set in miliseconds.
82443>>>>>>>>>>>//                     This property may be set even when the timer is
82443>>>>>>>>>>>//                     active. The new timeout value will be applied
82443>>>>>>>>>>>//                     immediately.
82443>>>>>>>>>>>//                     NOTE: The timeout set here is never precise. It
82443>>>>>>>>>>>//                     depends on Windows to deliver the message to our
82443>>>>>>>>>>>//                     application.
82443>>>>>>>>>>>//                     Default 1000.
82443>>>>>>>>>>>//
82443>>>>>>>>>>>//    Timer_Active_State
82443>>>>>>>>>>>//                     Set to TRUE to activate the timer, to FALSE to
82443>>>>>>>>>>>//                     deactivate the timer.
82443>>>>>>>>>>>//
82443>>>>>>>>>>>//
82443>>>>>>>>>>>//    Timer_Message    This property can be set to a messageID which has
82443>>>>>>>>>>>//                     to be sent whenever a timer event occurs. Default
82443>>>>>>>>>>>//                     this message will be send to the object itself
82443>>>>>>>>>>>//                     unless a Timer_Object as been specified.
82443>>>>>>>>>>>//
82443>>>>>>>>>>>//    Timer_Object     This property can be set to an objectID which has
82443>>>>>>>>>>>//                     to receive the Timer_Message whenever a timer
82443>>>>>>>>>>>//                     event occurs. This value has no meaning when
82443>>>>>>>>>>>//                     no Timer_Message has been set.
82443>>>>>>>>>>>//
82443>>>>>>>>>>>//    METHODS
82443>>>>>>>>>>>//
82443>>>>>>>>>>>//    OnTimer          This event will happen whenever the specified
82443>>>>>>>>>>>//                     amount of time has passed and the timer is
82443>>>>>>>>>>>//                     active. By default it sends the message in
82443>>>>>>>>>>>//                     the Timer_Message property to the object in
82443>>>>>>>>>>>//                     the Timer_Object when these have been specified.
82443>>>>>>>>>>>//                     When you don't need this, you can just override
82443>>>>>>>>>>>//                     the OnTimer event.
82443>>>>>>>>>>>//
82443>>>>>>>>>>>// PUBLIC INTERFACE
82443>>>>>>>>>>>//
82443>>>>>>>>>>>//    Page_Object      Has been augmented to auto_start the timer when
82443>>>>>>>>>>>//                     it becomes active as part or a user-interface
82443>>>>>>>>>>>//                     object.
82443>>>>>>>>>>>//
82443>>>>>>>>>>>//    Page_Delete      Has been augmented to auto_stop the timer when
82443>>>>>>>>>>>//                     it is deactivated as part or a user-interface
82443>>>>>>>>>>>//                     object.
82443>>>>>>>>>>>//
82443>>>>>>>>>>>//    Destroy_Object   Has been augmented to deactivate the timer.
82443>>>>>>>>>>>//
82443>>>>>>>>>>>Use LanguageText.pkg
82443>>>>>>>>>>>Use Windows.pkg
82443>>>>>>>>>>>Use WinUser.pkg
82443>>>>>>>>>>>
82443>>>>>>>>>>>External_Function SetTimer "SetTimer" User32.DLL ;    Integer hWnd ;    Integer idTimer ;    Integer idTimeout ;    Pointer tmprc ;    Returns Integer
82444>>>>>>>>>>>
82444>>>>>>>>>>>External_Function KillTimer "KillTimer" User32.DLL ;    Integer hWnd ;    Integer idTimer ;    Returns Integer
82445>>>>>>>>>>>
82445>>>>>>>>>>>// This global integer holds the ID of the object
82445>>>>>>>>>>>// that manages all timers.
82445>>>>>>>>>>>Integer giTimerManager
82445>>>>>>>>>>>
82445>>>>>>>>>>>// This class is used to store the object IDs
82445>>>>>>>>>>>// of the active timer objects. It augments
82445>>>>>>>>>>>// the Destroy_Object procedure to notify
82445>>>>>>>>>>>// the DFTimerManager to kill all its active
82445>>>>>>>>>>>// timers.
82445>>>>>>>>>>>// NOTE: This class looks very much like the
82445>>>>>>>>>>>// Set class. I didn't want to use Set because
82445>>>>>>>>>>>// Remove_Element shifts items which I don't
82445>>>>>>>>>>>// want to happen because item numbers are used
82445>>>>>>>>>>>// as timerIDs.
82445>>>>>>>>>>>
82445>>>>>>>>>>>Class TimersArray is an Array
82446>>>>>>>>>>>
82446>>>>>>>>>>>    Function Find_Object Integer iObj Returns Integer
82448>>>>>>>>>>>        Integer iMax
82448>>>>>>>>>>>        Integer iItem
82448>>>>>>>>>>>        Integer iValue
82448>>>>>>>>>>>        Get Item_count to iMax
82449>>>>>>>>>>>        Decrement iMax
82450>>>>>>>>>>>        For iItem from 1 to iMax
82456>>>>>>>>>>>>
82456>>>>>>>>>>>            Get Integer_Value item iItem to iValue
82457>>>>>>>>>>>            If iValue EQ iObj;                Function_Return iItem
82460>>>>>>>>>>>        Loop
82461>>>>>>>>>>>>
82461>>>>>>>>>>>        Function_Return -1
82462>>>>>>>>>>>    End_Function
82463>>>>>>>>>>>
82463>>>>>>>>>>>    Procedure Add_Object Integer iObj Returns Integer
82465>>>>>>>>>>>        Integer iItem
82465>>>>>>>>>>>        Get Find_Object iObj to iItem
82466>>>>>>>>>>>        If iItem LT 0 Begin
82468>>>>>>>>>>>            Get Find_Object 0 to iItem
82469>>>>>>>>>>>            If iItem LT 0 ;                Get Item_Count to iItem
82472>>>>>>>>>>>        End
82472>>>>>>>>>>>>
82472>>>>>>>>>>>        Set Array_Value item iItem to iObj
82473>>>>>>>>>>>        Procedure_Return iItem
82474>>>>>>>>>>>    End_Procedure
82475>>>>>>>>>>>
82475>>>>>>>>>>>    Procedure Remove_Object Integer iObj
82477>>>>>>>>>>>        Integer iItem
82477>>>>>>>>>>>        Get Find_Object iObj to iItem
82478>>>>>>>>>>>        If iItem GT 0 ;            Set Array_Value item iItem to 0
82481>>>>>>>>>>>    End_Procedure
82482>>>>>>>>>>>
82482>>>>>>>>>>>    Procedure Destroy_Object
82484>>>>>>>>>>>        Delegate Send Kill_All_Timers
82486>>>>>>>>>>>        Forward Send Destroy_Object
82488>>>>>>>>>>>    End_Procedure
82489>>>>>>>>>>>
82489>>>>>>>>>>>End_Class // TimersArray
82490>>>>>>>>>>>
82490>>>>>>>>>>>// This class is the actual timer manager
82490>>>>>>>>>>>// A timer will be created when Message Set_Timer_Active_State
82490>>>>>>>>>>>// has been send. This message needs two arguments. The first
82490>>>>>>>>>>>// is the objectID of the object to receive the timer event,
82490>>>>>>>>>>>// and the second is state. The object which ID has been passed,
82490>>>>>>>>>>>// needs to have a Timeout property to return the timeout for the
82490>>>>>>>>>>>// timer and it also needs to handle the MSG_OnTimer whenever a
82490>>>>>>>>>>>// timer event occurs.
82490>>>>>>>>>>>// The objectID of the Object will be placed in an array which contains
82490>>>>>>>>>>>// the objectIDs of all active timers. The Windows timer ID of a timer
82490>>>>>>>>>>>// is the itemnumber of the object in the array.
82490>>>>>>>>>>>//
82490>>>>>>>>>>>Class DFTimerManager is a DfBaseControl
82491>>>>>>>>>>>
82491>>>>>>>>>>>    Procedure Construct_Object
82493>>>>>>>>>>>
82493>>>>>>>>>>>        Forward Send Construct_Object
82495>>>>>>>>>>>
82495>>>>>>>>>>>        Set Visible_State to FALSE
82496>>>>>>>>>>>
82496>>>>>>>>>>>        Set External_Class_Name "cVdfTimer" to "static"
82497>>>>>>>>>>>        Set External_Message WM_TIMER to OnTimer
82498>>>>>>>>>>>
82498>>>>>>>>>>>        Object TimersArray is a TimersArray
82500>>>>>>>>>>>            Set Array_Value item 0 to -9999 // So we don't use item 0
82501>>>>>>>>>>>        End_Object
82502>>>>>>>>>>>
82502>>>>>>>>>>>        Move self to giTimerManager
82503>>>>>>>>>>>
82503>>>>>>>>>>>    End_Procedure
82504>>>>>>>>>>>
82504>>>>>>>>>>>    Procedure Set Timer_Active_State Integer iObj Integer iState
82506>>>>>>>>>>>        Integer iTimerID
82506>>>>>>>>>>>        Integer iTimeout
82506>>>>>>>>>>>        Integer iResult
82506>>>>>>>>>>>        Integer iSet
82506>>>>>>>>>>>        Dword   nResult
82506>>>>>>>>>>>        Handle  hWnd
82506>>>>>>>>>>>
82506>>>>>>>>>>>        // Get the handle of this object
82506>>>>>>>>>>>        Get Window_Handle to hWnd
82507>>>>>>>>>>>        If (Not(hWnd)) Begin
82509>>>>>>>>>>>            Error DFERR_DFTIMER C_$TimerNoHandle
82510>>>>>>>>>>>>
82510>>>>>>>>>>>            Procedure_Return
82511>>>>>>>>>>>        End
82511>>>>>>>>>>>>
82511>>>>>>>>>>>
82511>>>>>>>>>>>        // Test if handle is valid. If not, we leave.
82511>>>>>>>>>>>        If (Not(IsWindow(hWnd))) ;            Procedure_Return
82514>>>>>>>>>>>
82514>>>>>>>>>>>        Move (TimersArray(self)) to iSet
82515>>>>>>>>>>>
82515>>>>>>>>>>>        If (iSet) Begin
82517>>>>>>>>>>>
82517>>>>>>>>>>>            // Let's create or modify a timer
82517>>>>>>>>>>>            If iState Begin
82519>>>>>>>>>>>
82519>>>>>>>>>>>                // Get the exising to new TimerID
82519>>>>>>>>>>>                Get MSG_Add_Object of iSet iObj to iTimerID
82520>>>>>>>>>>>
82520>>>>>>>>>>>                // Set/Modify the timer
82520>>>>>>>>>>>                Get Timeout of iObj to iTimeout
82521>>>>>>>>>>>                Move (SetTimer(hWnd, iTimerID, iTimeout, 0)) to iResult
82522>>>>>>>>>>>                If Not iResult Begin
82524>>>>>>>>>>>                    Error DFERR_DFTIMER C_$TooManyTimers
82525>>>>>>>>>>>>
82525>>>>>>>>>>>                    Procedure_Return
82526>>>>>>>>>>>                End
82526>>>>>>>>>>>>
82526>>>>>>>>>>>
82526>>>>>>>>>>>            End
82526>>>>>>>>>>>>
82526>>>>>>>>>>>
82526>>>>>>>>>>>            // Let's kill an existing timer
82526>>>>>>>>>>>            Else Begin
82527>>>>>>>>>>>
82527>>>>>>>>>>>                // Look up the object in the set
82527>>>>>>>>>>>                Get Find_Object of iSet iObj to iTimerID
82528>>>>>>>>>>>
82528>>>>>>>>>>>                If iTimerID EQ -1 ;                    Procedure_Return
82531>>>>>>>>>>>
82531>>>>>>>>>>>                // Kill the timer
82531>>>>>>>>>>>                Move (KillTimer(hWnd, iTimerID)) to iResult
82532>>>>>>>>>>>                If Not iResult Begin
82534>>>>>>>>>>>                    Move (GetLastError()) to nResult
82535>>>>>>>>>>>                    Error DFERR_DFTIMER (C_$CantKillTimer * string(nResult) - "!")
82536>>>>>>>>>>>>
82536>>>>>>>>>>>                    Procedure_Return
82537>>>>>>>>>>>                End
82537>>>>>>>>>>>>
82537>>>>>>>>>>>
82537>>>>>>>>>>>                // Remove the objectID
82537>>>>>>>>>>>                Send Remove_Object to iSet iObj
82538>>>>>>>>>>>            End
82538>>>>>>>>>>>>
82538>>>>>>>>>>>        End
82538>>>>>>>>>>>>
82538>>>>>>>>>>>    End_Procedure
82539>>>>>>>>>>>
82539>>>>>>>>>>>    Function Timer_Active_State Integer iObj Returns Integer
82541>>>>>>>>>>>        Integer iResult
82541>>>>>>>>>>>        Get Find_Object of (TimersArray(self)) iObj to iResult
82542>>>>>>>>>>>        Function_Return (iResult<>-1) // note: -1= not found
82543>>>>>>>>>>>    End_Function
82544>>>>>>>>>>>
82544>>>>>>>>>>>    // Will be called by the Set when it is being destroyed.
82544>>>>>>>>>>>    Procedure Kill_All_Timers
82546>>>>>>>>>>>        Integer iMax
82546>>>>>>>>>>>        Integer iSet
82546>>>>>>>>>>>        Integer iItem
82546>>>>>>>>>>>        Integer iObj
82546>>>>>>>>>>>        Integer iResult
82546>>>>>>>>>>>        Handle  hWnd
82546>>>>>>>>>>>
82546>>>>>>>>>>>        // Get the handle of this object
82546>>>>>>>>>>>        Get Window_Handle to hWnd
82547>>>>>>>>>>>        If (Not(hWnd)) Begin
82549>>>>>>>>>>>            Error DFERR_DFTIMER C_$TimerNoHandle
82550>>>>>>>>>>>>
82550>>>>>>>>>>>            Procedure_Return
82551>>>>>>>>>>>        End
82551>>>>>>>>>>>>
82551>>>>>>>>>>>
82551>>>>>>>>>>>        // If the window handle is no longer valid, we
82551>>>>>>>>>>>        // leave this procedure. This can happen when the
82551>>>>>>>>>>>        // program is begin aborted using Exit_Application
82551>>>>>>>>>>>        If (Not(IsWindow(hWnd))) ;            Procedure_Return
82554>>>>>>>>>>>
82554>>>>>>>>>>>        // Scan the set and kill all known timers
82554>>>>>>>>>>>        Move (TimersArray(self)) to iSet
82555>>>>>>>>>>>        If (iSet) Begin
82557>>>>>>>>>>>            Get Item_Count of iSet to iMax
82558>>>>>>>>>>>            Decrement iMax
82559>>>>>>>>>>>            For iItem From 1 to iMax
82565>>>>>>>>>>>>
82565>>>>>>>>>>>                Get Integer_Value of iSet item iItem to iObj
82566>>>>>>>>>>>                If iObj Begin
82568>>>>>>>>>>>                    Move (KillTimer(hWnd, iItem)) to iResult
82569>>>>>>>>>>>                    Set Array_Value of iSet item iItem to 0
82570>>>>>>>>>>>                End
82570>>>>>>>>>>>>
82570>>>>>>>>>>>            Loop
82571>>>>>>>>>>>>
82571>>>>>>>>>>>        End
82571>>>>>>>>>>>>
82571>>>>>>>>>>>
82571>>>>>>>>>>>    End_Procedure
82572>>>>>>>>>>>
82572>>>>>>>>>>>    Procedure OnTimer Integer wParam Integer lParam
82574>>>>>>>>>>>        Integer iObj
82574>>>>>>>>>>>        Get Integer_Value of (TimersArray(self)) item wParam to iObj
82575>>>>>>>>>>>        If Not iObj Begin
82577>>>>>>>>>>>            Error DFERR_DFTIMER C_$TimerWithoutObject
82578>>>>>>>>>>>>
82578>>>>>>>>>>>            Procedure_Return
82579>>>>>>>>>>>        End
82579>>>>>>>>>>>>
82579>>>>>>>>>>>        Send OnTimer to iObj wParam lParam
82580>>>>>>>>>>>    End_Procedure
82581>>>>>>>>>>>
82581>>>>>>>>>>>    Procedure Destroy_Object
82583>>>>>>>>>>>        Send Kill_All_Timers
82584>>>>>>>>>>>        Forward Send Destroy_Object
82586>>>>>>>>>>>        Move 0 to giTimerManager
82587>>>>>>>>>>>    End_Procedure
82588>>>>>>>>>>>
82588>>>>>>>>>>>End_Class // DFTimerManger
82589>>>>>>>>>>>
82589>>>>>>>>>>>
82589>>>>>>>>>>>
82589>>>>>>>>>>>
82589>>>>>>>>>>>// This class acts as a container for the
82589>>>>>>>>>>>// timer manager object. This is needed because
82589>>>>>>>>>>>// A DFTimerManager object created directly at the
82589>>>>>>>>>>>// desktop doesn't have a Window_Handle which we
82589>>>>>>>>>>>// need to create a Windoows timer. By placing
82589>>>>>>>>>>>// this non-visual container around the timer
82589>>>>>>>>>>>// manager, it does get a Window_Handle.
82589>>>>>>>>>>>// The procedure End_Construct_Object has been
82589>>>>>>>>>>>// augmented to create a window and also
82589>>>>>>>>>>>// automatically page all children, which will
82589>>>>>>>>>>>// be the timer manager.
82589>>>>>>>>>>>//
82589>>>>>>>>>>>Class DFTimerManagerPanel is a dfBasePanel
82590>>>>>>>>>>>
82590>>>>>>>>>>>    Procedure Construct_Object
82592>>>>>>>>>>>        Forward Send Construct_Object
82594>>>>>>>>>>>        Set Visible_State to FALSE
82595>>>>>>>>>>>        Object DFTimerManager is a DFTimerManager
82597>>>>>>>>>>>        End_Object
82598>>>>>>>>>>>    End_Procedure
82599>>>>>>>>>>>
82599>>>>>>>>>>>    Procedure End_Construct_Object
82601>>>>>>>>>>>        Forward Send End_Construct_Object
82603>>>>>>>>>>>        Send Page_Object TRUE
82604>>>>>>>>>>>        Broadcast Send Page_Object TRUE
82606>>>>>>>>>>>    End_Procedure
82607>>>>>>>>>>>
82607>>>>>>>>>>>End_Class
82608>>>>>>>>>>>
82608>>>>>>>>>>>// This is the class the user uses to create DFTimer objects
82608>>>>>>>>>>>
82608>>>>>>>>>>>
82608>>>>>>>>>>>//{ OverrideProperty=Skip_State DesignTime=False }
82608>>>>>>>>>>>//{ OverrideProperty=TypeFace DesignTime=False }
82608>>>>>>>>>>>Class DFTimer is a Textbox
82609>>>>>>>>>>>
82609>>>>>>>>>>>    Procedure Construct_Object
82611>>>>>>>>>>>        Forward Send Construct_Object
82613>>>>>>>>>>>
82613>>>>>>>>>>>        // Make sure this object never appears
82613>>>>>>>>>>>        Set Visible_State to FALSE
82614>>>>>>>>>>>
82614>>>>>>>>>>>        Property Integer Private.Timeout    1000
82615>>>>>>>>>>>
82615>>>>>>>>>>>        Property Integer Timer_Message      0
82616>>>>>>>>>>>        Property Integer Timer_Object       0
82617>>>>>>>>>>>        Property Integer Auto_Start_State   True
82618>>>>>>>>>>>        Property Integer Auto_Stop_State    True
82619>>>>>>>>>>>    End_Procedure
82620>>>>>>>>>>>
82620>>>>>>>>>>>    Procedure Set Timer_Active_State Integer iState
82622>>>>>>>>>>>        Integer iObj
82622>>>>>>>>>>>        Move self to iObj
82623>>>>>>>>>>>        If giTimerManager ;            Set Timer_Active_State of giTimerManager iObj to iState
82626>>>>>>>>>>>    End_Procedure
82627>>>>>>>>>>>
82627>>>>>>>>>>>    Function Timer_Active_State Returns Integer
82629>>>>>>>>>>>        Integer iState
82629>>>>>>>>>>>        Integer iObj
82629>>>>>>>>>>>        Move self to iObj
82630>>>>>>>>>>>        If giTimerManager ;            Get Timer_Active_State of giTimerManager iObj to iState
82633>>>>>>>>>>>        Function_Return iState
82634>>>>>>>>>>>    End_Function
82635>>>>>>>>>>>
82635>>>>>>>>>>>    Procedure Set Timeout Integer iTimeout
82637>>>>>>>>>>>        Integer iActive
82637>>>>>>>>>>>        Set Private.Timeout to iTimeout
82638>>>>>>>>>>>        Get Timer_Active_State to iActive
82639>>>>>>>>>>>        If iActive ;            Set Timer_Active_State to TRUE
82642>>>>>>>>>>>    End_Procedure
82643>>>>>>>>>>>
82643>>>>>>>>>>>    Function Timeout Returns Integer
82645>>>>>>>>>>>        Integer iTimeout
82645>>>>>>>>>>>        Get Private.Timeout to iTimeout
82646>>>>>>>>>>>        Function_Return iTimeout
82647>>>>>>>>>>>    End_Function
82648>>>>>>>>>>>
82648>>>>>>>>>>>    Procedure OnTimer Integer iwParam Integer ilParam
82650>>>>>>>>>>>        Integer iMsg
82650>>>>>>>>>>>        Integer iObj
82650>>>>>>>>>>>        Get Timer_Message to iMsg
82651>>>>>>>>>>>        If (iMsg) Begin
82653>>>>>>>>>>>            Get Timer_Object  to iObj
82654>>>>>>>>>>>            If iObj ;                Send iMsg to iObj iwParam ilParam
82657>>>>>>>>>>>            Else ;                Send iMsg iwParam ilParam
82659>>>>>>>>>>>        End
82659>>>>>>>>>>>>
82659>>>>>>>>>>>    End_Procedure
82660>>>>>>>>>>>
82660>>>>>>>>>>>    // Augmented to Auto_Start a timer
82660>>>>>>>>>>>    //
82660>>>>>>>>>>>    Procedure Page_Object Integer iState
82662>>>>>>>>>>>        Forward Send Page_Object iState
82664>>>>>>>>>>>        If (iState AND Auto_Start_State(self)) ;            Set Timer_Active_State to TRUE
82667>>>>>>>>>>>    End_Procedure
82668>>>>>>>>>>>
82668>>>>>>>>>>>    // Augmented to Auto_Stop a timer
82668>>>>>>>>>>>    //
82668>>>>>>>>>>>    Procedure Page_Delete
82670>>>>>>>>>>>        If (Auto_Stop_State(self)) ;            Set Timer_Active_State to FALSE
82673>>>>>>>>>>>        Forward Send Page_Delete
82675>>>>>>>>>>>    End_Procedure
82676>>>>>>>>>>>
82676>>>>>>>>>>>    // Augmented to stop the timer
82676>>>>>>>>>>>    //
82676>>>>>>>>>>>    Procedure Destroy_Object
82678>>>>>>>>>>>        Set Timer_Active_State to FALSE
82679>>>>>>>>>>>        Forward Send Destroy_Object
82681>>>>>>>>>>>    End_Procedure
82682>>>>>>>>>>>
82682>>>>>>>>>>>End_Class // DFTimer
82683>>>>>>>>>>>
82683>>>>>>>>>>>//
82683>>>>>>>>>>>// This was moved into a method so it can be reliable created
82683>>>>>>>>>>>// at the desktop. Note that cDesktop adds method to cDesktop class (class of desktop)
82683>>>>>>>>>>>//
82683>>>>>>>>>>>Procedure CreateDfTimerManagerPanel FOR cDesktop
82685>>>>>>>>>>>    // Create the Desktop Timer Manager Object.
82685>>>>>>>>>>>    Object DFTimerManagerPanel is a DFTimerManagerPanel
82687>>>>>>>>>>>    End_Object
82688>>>>>>>>>>>End_Procedure
82689>>>>>>>>>>>
82689>>>>>>>>>>>Send CreateDfTimerManagerPanel of DESKTOP
82690>>>>>>>>>>>
82690>>>>>>>>>
82690>>>>>>>>>Class cTimer is a cObject
82691>>>>>>>>>
82691>>>>>>>>>    Procedure Construct_Object
82693>>>>>>>>>        Forward Send Construct_Object
82695>>>>>>>>>        Property Integer piPrivate_Timeout 1000
82696>>>>>>>>>    End_Procedure
82697>>>>>>>>>
82697>>>>>>>>>    Procedure Set pbEnabled Boolean bEnabled
82699>>>>>>>>>        If giTimerManager Begin
82701>>>>>>>>>            Set Timer_Active_State of giTimerManager Self to bEnabled
82702>>>>>>>>>        End
82702>>>>>>>>>>
82702>>>>>>>>>    End_Procedure
82703>>>>>>>>>
82703>>>>>>>>>    Function pbEnabled Returns Boolean
82705>>>>>>>>>        Boolean bEnabled
82705>>>>>>>>>        If giTimerManager Begin
82707>>>>>>>>>            Get Timer_Active_State of giTimerManager Self to bEnabled
82708>>>>>>>>>        End
82708>>>>>>>>>>
82708>>>>>>>>>        Function_Return bEnabled
82709>>>>>>>>>    End_Function
82710>>>>>>>>>
82710>>>>>>>>>    Procedure Set piTimeout Integer iTimeout
82712>>>>>>>>>        Boolean bEnabled
82712>>>>>>>>>        Set piPrivate_Timeout to iTimeout
82713>>>>>>>>>        Get pbEnabled to bEnabled
82714>>>>>>>>>        If bEnabled Begin
82716>>>>>>>>>            Set pbEnabled to True
82717>>>>>>>>>        End
82717>>>>>>>>>>
82717>>>>>>>>>    End_Procedure
82718>>>>>>>>>
82718>>>>>>>>>    Function piTimeout Returns Integer
82720>>>>>>>>>        Integer iTimeout
82720>>>>>>>>>        Get piPrivate_Timeout to iTimeout
82721>>>>>>>>>        Function_Return iTimeout
82722>>>>>>>>>    End_Function
82723>>>>>>>>>
82723>>>>>>>>>    Procedure OnTimer
82725>>>>>>>>>    End_Procedure
82726>>>>>>>>>    
82726>>>>>>>>>    // this is needed by the timer manager 
82726>>>>>>>>>    Function Timeout Returns Integer
82728>>>>>>>>>        Integer iTimeout
82728>>>>>>>>>        Get piPrivate_Timeout to iTimeout
82729>>>>>>>>>        Function_Return iTimeout
82730>>>>>>>>>    End_Function
82731>>>>>>>>>
82731>>>>>>>>>    Procedure Destroy_Object
82733>>>>>>>>>        Set pbEnabled to False
82734>>>>>>>>>        Forward Send Destroy_Object
82736>>>>>>>>>    End_Procedure
82737>>>>>>>>>
82737>>>>>>>>>End_Class
82738>>>>>>>Use cRichEdit.pkg
Including file: cRichEdit.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cRichEdit.pkg)
82738>>>>>>>>>use Windows.pkg
82738>>>>>>>>>Use cEdit_Mixin.pkg
82738>>>>>>>>>
82738>>>>>>>>>// DFO: cRichEdit.Dfo
82738>>>>>>>>>// DFC: cRichEdit.Dfc
82738>>>>>>>>>
82738>>>>>>>>>// constants used for RichEdit Properties
82738>>>>>>>>>// peAlignment 
82738>>>>>>>>>Enum_List 
82738>>>>>>>>>    Define alLeft   for 1 
82738>>>>>>>>>    Define alRight  for 2 
82738>>>>>>>>>    Define alCenter for 3 
82738>>>>>>>>>End_Enum_List 
82738>>>>>>>>>
82738>>>>>>>>>// peBullets 
82738>>>>>>>>>Enum_List 
82738>>>>>>>>>    Define buNone 
82738>>>>>>>>>    Define buBullets 
82738>>>>>>>>>    Define buArabicNumbers 
82738>>>>>>>>>    Define buLowerLetters 
82738>>>>>>>>>    Define buUpperLetters 
82738>>>>>>>>>    Define buLowerRomans 
82738>>>>>>>>>    Define buUpperRomans 
82738>>>>>>>>>End_Enum_List 
82738>>>>>>>>>
82738>>>>>>>>>// peBulletStyle 
82738>>>>>>>>>Enum_List 
82738>>>>>>>>>    Define busRightParen   for 0 
82738>>>>>>>>>    Define busEncloseParen for 256 
82738>>>>>>>>>    Define busPeriod       for 512 
82738>>>>>>>>>    Define busNumberOnly   for 768 
82738>>>>>>>>>    Define busNoDisplay    for 1024 
82738>>>>>>>>>End_Enum_List
82738>>>>>>>>>    
82738>>>>>>>>>// peLineSpacingType
82738>>>>>>>>>Enum_List 
82738>>>>>>>>>    Define lstSingle
82738>>>>>>>>>    Define lstSingleAndOneHalf
82738>>>>>>>>>    Define lstDouble
82738>>>>>>>>>End_Enum_List
82738>>>>>>>>>
82738>>>>>>>>>Class cRichEdit Is A DFBaseRichEdit
82739>>>>>>>>>
82739>>>>>>>>>    Procedure Construct_Object
82741>>>>>>>>>        Forward Send Construct_Object
82743>>>>>>>>>        Send Define_cEdit_Mixin
82744>>>>>>>>>
82744>>>>>>>>>        On_key Key_Ctrl+Key_B send ToggleBold
82745>>>>>>>>>        On_key Key_Ctrl+Key_I send ToggleItalics
82746>>>>>>>>>        On_key Key_Ctrl+Key_U send ToggleUnderline
82747>>>>>>>>>
82747>>>>>>>>>    End_Procedure // Construct_Object
82748>>>>>>>>>
82748>>>>>>>>>    Import_Class_Protocol cEdit_Mixin
82749>>>>>>>>>    
82749>>>>>>>>>    Procedure ToggleBold
82751>>>>>>>>>        Set pbBold to (not(pbBold(self))) 
82752>>>>>>>>>    end_procedure
82753>>>>>>>>>    
82753>>>>>>>>>    Procedure ToggleItalics
82755>>>>>>>>>        Set pbItalics to (not(pbItalics(self))) 
82756>>>>>>>>>    end_procedure
82757>>>>>>>>>    
82757>>>>>>>>>    Procedure ToggleUnderline
82759>>>>>>>>>       Set pbUnderLine to (not(pbUnderLine(self))) 
82760>>>>>>>>>    end_procedure
82761>>>>>>>>>
82761>>>>>>>>>End_Class
82762>>>>>>>>>
82762>>>>>>>Use sql.pkg
Including file: sql.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\sql.pkg)
82762>>>>>>>>>//*****************************************************************************
82762>>>>>>>>>//*** SQL.pkg                                                               ***
82762>>>>>>>>>//***                                                                       ***
82762>>>>>>>>>//*** Author: Ben Weijers                                                   ***
82762>>>>>>>>>//***         Data Access Wordwide                                          ***
82762>>>>>>>>>//***         14 February 2000                                              ***
82762>>>>>>>>>//***                                                                       ***
82762>>>>>>>>>//*** Purpose:                                                              ***
82762>>>>>>>>>//***       Embedded SQL classes for use with Data Access Worldwide CLI     ***
82762>>>>>>>>>//***       Connectivty Kits.                                               ***
82762>>>>>>>>>//***                                                                       ***
82762>>>>>>>>>//*** Last update:                                                          ***
82762>>>>>>>>>//***       February 2014. Current CLI Connectivity Kit 6.0.0.28            ***
82762>>>>>>>>>//***                                                                       ***
82762>>>>>>>>>//*** !! Please Note !!                                                     ***
82762>>>>>>>>>//***       -This version of sql.pkg will only work with CLI Connectivity   ***
82762>>>>>>>>>//***        Kits 6.0.0.28 or later.                                        ***
82762>>>>>>>>>//***       -This version of sql.pkg will no longer function with DataFlex  ***
82762>>>>>>>>>//***        character mode (DataFlex 3.2). To use embedded SQL with        ***
82762>>>>>>>>>//**         DataFlex character mode, use sqlold.pkg.                       ***
82762>>>>>>>>>//***       -This version of sql.pkg no longer contains the embedded SQL    ***
82762>>>>>>>>>//***        command interface. The command interface is still available    ***
82762>>>>>>>>>//***        in sqlold.pkg                                                  ***
82762>>>>>>>>>//***                                                                       ***
82762>>>>>>>>>//*** Changes:                                                              ***
82762>>>>>>>>>//***       February 2014. CLI Connectivity Kit 6.0.0.28                    ***
82762>>>>>>>>>//***                                                                       ***
82762>>>>>>>>>//***       Several performances improvements to speed up SQLColumnValue    ***
82762>>>>>>>>>//***       and SQLGetData                                                  ***
82762>>>>>>>>>//***                                                                       ***
82762>>>>>>>>>//***       New functions:                                                  ***
82762>>>>>>>>>//***           Function SQLFetchRowValues Returns String[]                 ***
82762>>>>>>>>>//***               Fetches a row and returns all columns in an array.      ***
82762>>>>>>>>>//***                                                                       ***
82762>>>>>>>>>//***           Function SQLFetchResultsetValues Returns String[][]         ***
82762>>>>>>>>>//***               Fetches all rows of a result set and returns the        ***
82762>>>>>>>>>//***               result set as a 2-dimensial array.                      ***
82762>>>>>>>>>//***                                                                       ***
82762>>>>>>>>>//*****************************************************************************
82762>>>>>>>>>
82762>>>>>>>>>Use CLI.pkg
82762>>>>>>>>>
82762>>>>>>>>>//*** Global storage for results
82762>>>>>>>>>Integer SQLResult
82762>>>>>>>>>
82762>>>>>>>>>//*** Embedded SQL function constants
82762>>>>>>>>>Define FUNC_SQLCONNECT             For 1000000
82762>>>>>>>>>Define FUNC_SQLFILECONNECT         For 1000001
82762>>>>>>>>>Define FUNC_SQLDISCONNECT          For 1000002
82762>>>>>>>>>Define FUNC_SQLOPEN                For 1000003
82762>>>>>>>>>Define FUNC_SQLCLOSE               For 1000004
82762>>>>>>>>>Define FUNC_SQLPREPARE             For 1000005
82762>>>>>>>>>Define FUNC_SQLEXECUTE             For 1000006
82762>>>>>>>>>Define FUNC_SQLEXECDIRECT          For 1000007
82762>>>>>>>>>Define FUNC_SQLFETCH               For 1000008
82762>>>>>>>>>Define FUNC_SQLCOLUMNINFO          For 1000009
82762>>>>>>>>>Define FUNC_SQLCOLUMNVALUE         For 1000010
82762>>>>>>>>>Define FUNC_SQLBINDFILE            For 1000011
82762>>>>>>>>>Define FUNC_SQLGETDATA             For 1000012
82762>>>>>>>>>Define FUNC_SQLCOLSTRINGATTRIBLEN  For 1000013
82762>>>>>>>>>Define FUNC_SQLCOLSTRINGATTRIB     For 1000014
82762>>>>>>>>>Define FUNC_SQLCOLINTATTRIB        For 1000015
82762>>>>>>>>>Define FUNC_SQLSTMTINTATTRIB       For 1000016
82762>>>>>>>>>Define FUNC_SQLSETPROCNAME         For 1000017
82762>>>>>>>>>DEfine FUNC_SQLSETPROCARG          For 1000018
82762>>>>>>>>>Define FUNC_SQLCALL                For 1000019
82762>>>>>>>>>Define FUNC_SQLGETPROCARGLEN       For 1000020
82762>>>>>>>>>Define FUNC_SQLGETPROCARG          For 1000021
82762>>>>>>>>>Define FUNC_SQLGETPROCRETVALLEN    For 1000022
82762>>>>>>>>>Define FUNC_SQLGETPROCRETVAL       For 1000023
82762>>>>>>>>>Define FUNC_SQLNEXTRESULTSET       For 1000024
82762>>>>>>>>>Define FUNC_SQLBUFFERSTATUS        For 1000025
82762>>>>>>>>>Define FUNC_SQLSETPROCSCHEMA       For 1000026
82762>>>>>>>>>Define FUNC_SQLGETMESSAGE          For 1000027
82762>>>>>>>>>
82762>>>>>>>>>//*** Embedded SQL statement attribute constants
82762>>>>>>>>>Define SQLSTMTATTRIB_COLUMNCOUNT    For 1
82762>>>>>>>>>Define SQLSTMTATTRIB_ROWCOUNT       For 2
82762>>>>>>>>>Define SQLSTMTATTRIB_ROWCOUNT_TYPE  For 3
82762>>>>>>>>>Define SQLSTMTATTRIB_NUMMESSAGES    For 4
82762>>>>>>>>>
82762>>>>>>>>>//*** Embedded SQL column attribute constants
82762>>>>>>>>>Define SQLCOLATTRIB_SIZE           For 1
82762>>>>>>>>>Define SQLCOLATTRIB_LENGTH         For 1
82762>>>>>>>>>Define SQLCOLATTRIB_PRECISION      For 2
82762>>>>>>>>>Define SQLCOLATTRIB_LABEL          For 3
82762>>>>>>>>>Define SQLCOLATTRIB_BASECOLUMNNAME For 4
82762>>>>>>>>>Define SQLCOLATTRIB_BASETABLENAME  For 5
82762>>>>>>>>>Define SQLCOLATTRIB_SQLTYPE        For 6
82762>>>>>>>>>Define SQLCOLATTRIB_NULLABLE       For 7
82762>>>>>>>>>Define SQLCOLATTRIB_DFTYPE         For 8
82762>>>>>>>>>
82762>>>>>>>>>
82762>>>>>>>>>
82762>>>>>>>>>//*****************************************************************************
82762>>>>>>>>>//*** Class  : cSQLStatement                                                ***
82762>>>>>>>>>//*** Purpose: Statement object for embedded sql                            ***
82762>>>>>>>>>//***                                                                       ***
82762>>>>>>>>>//*** Description:                                                          ***
82762>>>>>>>>>//***   An object is created for each statement. These will be children     ***
82762>>>>>>>>>//***   of cSQLConnection objects which manage the create and destruction   ***
82762>>>>>>>>>//***   of these.                                                           ***
82762>>>>>>>>>//*****************************************************************************
82762>>>>>>>>>
82762>>>>>>>>>// Global variables holding last executed embedded SQL connection and statement handles.
82762>>>>>>>>>Integer giLastSQLhdbc
82762>>>>>>>>>Integer giLastSQLhstmt
82762>>>>>>>>>
82762>>>>>>>>>Move -1 to giLastSQLhdbc
82763>>>>>>>>>Move -1 to giLastSQLhstmt
82764>>>>>>>>>
82764>>>>>>>>>Struct tSQLColumn
82764>>>>>>>>>    Integer iSQLType
82764>>>>>>>>>    Integer iSQLSize
82764>>>>>>>>>    Integer iSQLPrecision
82764>>>>>>>>>    Integer iVariableDataType
82764>>>>>>>>>End_Struct
82764>>>>>>>>>
82764>>>>>>>>>Class cSQLStatement is a cObject
82765>>>>>>>>>
82765>>>>>>>>>    Procedure Construct_object 
82767>>>>>>>>>        Forward Send Construct_object 
82769>>>>>>>>>
82769>>>>>>>>>        Property Handle  phCLIStatementHandle   0
82770>>>>>>>>>        Property Handle  phCLIConnectionHandle  0
82771>>>>>>>>>        Property String  psDriverID             ""
82772>>>>>>>>>        
82772>>>>>>>>>        Property Integer piLastColumn      0
82773>>>>>>>>>        Property Integer piLastArgument    0
82774>>>>>>>>>        Property Integer piBindFile        0
82775>>>>>>>>>        Property Integer piColumnCount     0
82776>>>>>>>>>
82776>>>>>>>>>        // Allocated buffer for SQLColumnValue. 
82776>>>>>>>>>        // Allocated size is size of the largest (not variable length) column
82776>>>>>>>>>        Property String  psMaxColValue     ""
82777>>>>>>>>>
82777>>>>>>>>>        // True if there is at least 1 column with a variable length data type                 
82777>>>>>>>>>        Property Integer piHasVariableDataType  0
82778>>>>>>>>>
82778>>>>>>>>>        // Max size of buffer for variable length data. Default 16000        
82778>>>>>>>>>        Property Integer piMaxVariableBufferLength 16000  
82779>>>>>>>>>
82779>>>>>>>>>        // Allocated buffer for SQLGetData. 
82779>>>>>>>>>        Property String  psVariableBuffer  ""
82780>>>>>>>>>
82780>>>>>>>>>        // Allocated size of psVariableBuffer
82780>>>>>>>>>        Property Integer piVariableBufferLength 0
82781>>>>>>>>>
82781>>>>>>>>>        // Stores column properties of a result set.
82781>>>>>>>>>        Property tSQLColumn[] paSQLColumns
82782>>>>>>>>>        
82782>>>>>>>>>        // piFetchResult is set by SQLFetchRowValues and SQLFetchResultSetValues
82782>>>>>>>>>        //               0    = Fetch returned no data.
82782>>>>>>>>>        //               <> 0 = Row fetched
82782>>>>>>>>>        Property Integer piFetchResult     0
82783>>>>>>>>>
82783>>>>>>>>>
82783>>>>>>>>>        Property String psDummyZeroDate              '0001-01-01'
82784>>>>>>>>>        Property String psDummyZeroDateMssqlDatetime '1753-01-01'        
82785>>>>>>>>>
82785>>>>>>>>>    End_Procedure 
82786>>>>>>>>>
82786>>>>>>>>>    //***
82786>>>>>>>>>    //*** Procedure: StoreStatementInfo
82786>>>>>>>>>    //*** Purpose  : Store basic information about the statement.
82786>>>>>>>>>    //***
82786>>>>>>>>>    Procedure StoreStatementInfo Handle hCLIStatementHandle String sDrvrId Handle hCLIConnectionHandle
82788>>>>>>>>>        
82788>>>>>>>>>        Set phCLIStatementHandle   to hCLIStatementHandle
82789>>>>>>>>>        Set phCLIConnectionHandle  to hCLIConnectionHandle
82790>>>>>>>>>        Set psDriverID             to sDrvrId
82791>>>>>>>>>        
82791>>>>>>>>>    End_Procedure 
82792>>>>>>>>>
82792>>>>>>>>>
82792>>>>>>>>>    //***
82792>>>>>>>>>    //*** Procedure: DestroySQLStatement
82792>>>>>>>>>    //*** Purpose  : Destroy the cSQLStatement object
82792>>>>>>>>>    //***
82792>>>>>>>>>    Procedure DestroySQLStatement
82794>>>>>>>>>        Send Destroy
82795>>>>>>>>>    End_Procedure 
82796>>>>>>>>>
82796>>>>>>>>>    //***
82796>>>>>>>>>    //*** Procedure: HandleError
82796>>>>>>>>>    //*** Puprose  : Handle an error that has occured while checking properties.
82796>>>>>>>>>    //***
82796>>>>>>>>>
82796>>>>>>>>>    Procedure HandleError Integer ihstmt Integer ihdbc String sDrvrId String sOriginMsg
82798>>>>>>>>>        Integer iErrHandle
82798>>>>>>>>>        Integer iErrNum
82798>>>>>>>>>        String  sLocationInfo
82798>>>>>>>>>
82798>>>>>>>>>        //*** Get the DataFlex statement identifier
82798>>>>>>>>>        Move Self To iErrHandle
82799>>>>>>>>>
82799>>>>>>>>>        //*** Determine error number
82799>>>>>>>>>        If (ihstmt = 0) ;            Move CLIERR_SQLINVALID_CLI_STMT_HANDLE To iErrNum
82802>>>>>>>>>        Else If (ihdbc = 0) ;            Move CLIERR_SQLINVALID_CLI_CONN_HANDLE To iErrNum
82806>>>>>>>>>        Else If (sDrvrId = "") ;            Move CLIERR_SQLINVALID_DRIVER_ID To iErrNum
82810>>>>>>>>>        Else ;            Move CLIERR_SQL_ERROR To iErrNum
82812>>>>>>>>>
82812>>>>>>>>>        //*** Create location ifnormation
82812>>>>>>>>>        Move "[" To sLocationInfo
82813>>>>>>>>>        If (sOriginMsg <> "") Begin
82815>>>>>>>>>            Move (Append(sLocationInfo, sOriginMsg)) To sLocationInfo
82816>>>>>>>>>            Move (Append(sLocationInfo, ", "))       To sLocationInfo
82817>>>>>>>>>        End
82817>>>>>>>>>>
82817>>>>>>>>>        Move (Append(sLocationInfo, "DataFlex hstmt = ")) To sLocationInfo
82818>>>>>>>>>        Move (Append(sLocationInfo, iErrHandle))          To sLocationInfo
82819>>>>>>>>>        Move (Append(sLocationInfo, "]"))                 To sLocationInfo
82820>>>>>>>>>
82820>>>>>>>>>        //*** Generate the error
82820>>>>>>>>>        Error iErrNum sLocationInfo
82821>>>>>>>>>>
82821>>>>>>>>>    End_Procedure
82822>>>>>>>>>
82822>>>>>>>>>
82822>>>>>>>>>
82822>>>>>>>>>    //***
82822>>>>>>>>>    //*** Procedure: StmtError
82822>>>>>>>>>    //*** Purpose  : Handle general error not related to the properties
82822>>>>>>>>>    //***
82822>>>>>>>>>
82822>>>>>>>>>    Procedure StmtError Integer iErrNum String sErrText String sOriginMsg
82824>>>>>>>>>        Integer iErrHandle
82824>>>>>>>>>        String  sLocationInfo
82824>>>>>>>>>
82824>>>>>>>>>        //*** Get the DataFlex statement identifier
82824>>>>>>>>>        Move Self to iErrHandle
82825>>>>>>>>>
82825>>>>>>>>>        //*** Create location information
82825>>>>>>>>>        Move "[" To sLocationInfo
82826>>>>>>>>>        If (sOriginMsg <> "") Begin
82828>>>>>>>>>            Move (Append(sLocationInfo, sOriginMsg)) To sLocationInfo
82829>>>>>>>>>            Move (Append(sLocationInfo, ", "))       To sLocationInfo
82830>>>>>>>>>        End
82830>>>>>>>>>>
82830>>>>>>>>>        If (sErrtext <> "") Begin
82832>>>>>>>>>            Move (Append(sLocationInfo, sErrtext)) To sLocationInfo
82833>>>>>>>>>            Move (Append(sLocationInfo, ", "))     To sLocationInfo
82834>>>>>>>>>        End
82834>>>>>>>>>>
82834>>>>>>>>>        Move (Append(sLocationInfo, "DataFlex hstmt = ")) To sLocationInfo
82835>>>>>>>>>        Move (Append(sLocationInfo, iErrHandle))          To sLocationInfo
82836>>>>>>>>>        Move (Append(sLocationInfo, "]"))                 To sLocationInfo
82837>>>>>>>>>
82837>>>>>>>>>        //*** Generate the error
82837>>>>>>>>>        Error iErrNum sLocationInfo
82838>>>>>>>>>>
82838>>>>>>>>>    End_Procedure 
82839>>>>>>>>>
82839>>>>>>>>>
82839>>>>>>>>>
82839>>>>>>>>>    //***
82839>>>>>>>>>    //*** Procedure: SQLIllegalAttribute
82839>>>>>>>>>    //*** Purpose  : Handle an illegal attribute error
82839>>>>>>>>>    //***
82839>>>>>>>>>
82839>>>>>>>>>    Procedure SQLIllegalAttribute String sErrText String sOriginMsg
82841>>>>>>>>>        Integer bReport
82841>>>>>>>>>
82841>>>>>>>>>        Get_attribute DF_REPORT_UNSUPPORTED_ATTRIBUTES To bReport
82844>>>>>>>>>        If (bReport) ;            Send StmtError CLIERR_SQLINVALID_ATTRIBUTE sErrtext sOriginMsg
82847>>>>>>>>>    End_Procedure 
82848>>>>>>>>>
82848>>>>>>>>>
82848>>>>>>>>>
82848>>>>>>>>>    //***
82848>>>>>>>>>    //*** Function: SQLPrivateColumnIsLegal
82848>>>>>>>>>    //*** Purpose : Check if a column number is legal
82848>>>>>>>>>    //***
82848>>>>>>>>>
82848>>>>>>>>>    Function SQLPrivateColumnIsLegal Integer ihdbc String sDrvrId Integer ihstmt Integer iCol Returns Integer
82850>>>>>>>>>        Integer bLegal
82850>>>>>>>>>        Integer iNumColumns
82850>>>>>>>>>
82850>>>>>>>>>        Get SQLPrivateStmtAttribute SQLSTMTATTRIB_COLUMNCOUNT ihdbc sDrvrId ihstmt To iNumColumns
82851>>>>>>>>>        If (iCol > 0 And iCol <= iNumColumns) ;            Move DFTRUE To bLegal
82854>>>>>>>>>        Else ;            Move DFFALSE To bLegal
82856>>>>>>>>>
82856>>>>>>>>>        Function_Return bLegal
82857>>>>>>>>>    End_Function 
82858>>>>>>>>>
82858>>>>>>>>>
82858>>>>>>>>>
82858>>>>>>>>>    //***
82858>>>>>>>>>    //*** Procedure: SQLClose
82858>>>>>>>>>    //*** Purpose  : Close a statement and free all alllocated resources
82858>>>>>>>>>    //***
82858>>>>>>>>>
82858>>>>>>>>>    Procedure SQLClose
82860>>>>>>>>>        Integer ihdbc
82860>>>>>>>>>        Integer ihstmt
82860>>>>>>>>>        Integer iVoid
82860>>>>>>>>>        String  sDrvrId
82860>>>>>>>>>        String  sEmpty
82860>>>>>>>>>
82860>>>>>>>>>        //*** Initialize
82860>>>>>>>>>        Move "" To sEmpty
82861>>>>>>>>>
82861>>>>>>>>>        //*** Get the cli handles
82861>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
82862>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
82863>>>>>>>>>        Get psDriverId            to sDrvrId
82864>>>>>>>>>
82864>>>>>>>>>        //*** Free the CLI handle
82864>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
82866>>>>>>>>>            //*** Call the driver function to close
82866>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLCLOSE ;                        Callback Self ;                        Passing ihdbc sEmpty ihstmt ;                        Result iVoid
82871>>>>>>>>>
82871>>>>>>>>>            Move -1 to giLastSQLhstmt
82872>>>>>>>>>            //*** Free the DataFlex handle
82872>>>>>>>>>            Send DestroySQLStatement
82873>>>>>>>>>        End
82873>>>>>>>>>>
82873>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLClose"
82875>>>>>>>>>    End_Procedure
82876>>>>>>>>>
82876>>>>>>>>>
82876>>>>>>>>>
82876>>>>>>>>>    //***
82876>>>>>>>>>    //*** Procedure: SQLPrepare
82876>>>>>>>>>    //*** Purpose  : Prepare a statement for execution
82876>>>>>>>>>    //***
82876>>>>>>>>>
82876>>>>>>>>>    Procedure SQLPrepare String sStatement
82878>>>>>>>>>        Integer ihdbc
82878>>>>>>>>>        Integer ihstmt
82878>>>>>>>>>        Integer iVoid
82878>>>>>>>>>        String  sDrvrId
82878>>>>>>>>>
82878>>>>>>>>>        //*** Get the cli handles
82878>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
82879>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
82880>>>>>>>>>        Get psDriverId            to sDrvrId
82881>>>>>>>>>
82881>>>>>>>>>        //*** Prepare
82881>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
82883>>>>>>>>>            //*** Call the driver function to prepare
82883>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLPREPARE ;                        Callback Self ;                        Passing ihdbc sStatement ihstmt ;                        Result iVoid
82888>>>>>>>>>        End
82888>>>>>>>>>>
82888>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLPrepare"
82890>>>>>>>>>    End_Procedure
82891>>>>>>>>>
82891>>>>>>>>>    Procedure SQLGetStatementAttributes
82893>>>>>>>>>        Integer ihdbc ihstmt iNumColumns iCol iMaxSize
82893>>>>>>>>>        String sMaxValue
82893>>>>>>>>>        tSQLColumn[] aSQLColumns
82893>>>>>>>>>        tSQLColumn[] aSQLColumns
82894>>>>>>>>>        
82894>>>>>>>>>        Integer iSqlType
82894>>>>>>>>>        Integer iSQLSize
82894>>>>>>>>>        Integer iSQLprecision
82894>>>>>>>>>        Integer iVariableDataType
82894>>>>>>>>>        
82894>>>>>>>>>        String  sDrvrId
82894>>>>>>>>>
82894>>>>>>>>>        Integer iHasVariableDataType
82894>>>>>>>>>
82894>>>>>>>>>        Move 0 to iHasVariableDataType
82895>>>>>>>>>
82895>>>>>>>>>
82895>>>>>>>>>        //*** Get the cli handles
82895>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
82896>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
82897>>>>>>>>>        Get psDriverId            to sDrvrId
82898>>>>>>>>>
82898>>>>>>>>>        Get SQLPrivateStmtAttribute SQLSTMTATTRIB_COLUMNCOUNT ihdbc sDrvrId ihstmt to iNumColumns
82899>>>>>>>>>        
82899>>>>>>>>>        Set piColumnCount to iNumColumns
82900>>>>>>>>>        
82900>>>>>>>>>        // Fill columns array
82900>>>>>>>>>        For iCol from 1 to iNumColumns
82906>>>>>>>>>>
82906>>>>>>>>>            Move 0 to iVariableDataType
82907>>>>>>>>>            
82907>>>>>>>>>            Get SQLPrivateColAttribute iCol SQLCOLATTRIB_SQLTYPE ihdbc sDrvrId ihstmt to iSQLType
82908>>>>>>>>>            Get SQLPrivateColAttribute iCol SQLCOLATTRIB_SIZE ihdbc sDrvrId ihstmt to iSQLSize
82909>>>>>>>>>            Get SQLPrivateColAttribute iCol SQLCOLATTRIB_PRECISION ihdbc sDrvrId ihstmt to iSQLPrecision
82910>>>>>>>>>            
82910>>>>>>>>>            If ( (iSQLType = SQL_LONGVARCHAR) or (iSQLType = SQL_WLONGVARCHAR) ) Begin
82912>>>>>>>>>                 // text type 
82912>>>>>>>>>                Move 1 to iVariableDataType
82913>>>>>>>>>            End
82913>>>>>>>>>>
82913>>>>>>>>>            Else Begin
82914>>>>>>>>>                If (sDrvrId = "MSSQLDRV") Begin
82916>>>>>>>>>                    // SQL Server varchar(max) and nvarchar(max) types return Size = 0                   
82916>>>>>>>>>                    If ( ((iSQLType = SQL_VARCHAR) and (iSQLSize = 0) ) or ;                         ((iSQLType = SQL_WVARCHAR) and (iSQLSize = 0) ) ) Begin
82918>>>>>>>>>                            
82918>>>>>>>>>                        Move 1 to iVariableDataType     
82919>>>>>>>>>                    End
82919>>>>>>>>>>
82919>>>>>>>>>                End
82919>>>>>>>>>>
82919>>>>>>>>>            End
82919>>>>>>>>>>
82919>>>>>>>>>
82919>>>>>>>>>            Move iSqlType           to aSQLColumns[iCol].iSQLType            
82920>>>>>>>>>            Move iSQLSize           to aSQLColumns[iCol].iSQLSize
82921>>>>>>>>>            Move iSQLPrecision      to aSQLColumns[iCol].iSQLPrecision
82922>>>>>>>>>            Move iVariableDataType  to aSQLColumns[iCol].iVariableDataType
82923>>>>>>>>>            
82923>>>>>>>>>            If (not(iVariableDataType)) Begin
82925>>>>>>>>>                If (iSQLSize > iMaxSize) Begin
82927>>>>>>>>>                    Move iSQLSize to iMaxSize
82928>>>>>>>>>                End
82928>>>>>>>>>>
82928>>>>>>>>>            End
82928>>>>>>>>>>
82928>>>>>>>>>            Else Begin
82929>>>>>>>>>                Move 1 to iHasVariableDataType
82930>>>>>>>>>            End
82930>>>>>>>>>>
82930>>>>>>>>>            
82930>>>>>>>>>        Loop
82931>>>>>>>>>>
82931>>>>>>>>>        
82931>>>>>>>>>        Move (Repeat(' ', iMaxSize + 3)) to sMaxValue
82932>>>>>>>>>        Set psMaxColValue to sMaxValue
82933>>>>>>>>>        
82933>>>>>>>>>        Set paSQLColumns   to aSQLColumns        
82934>>>>>>>>>        Set piHasVariableDataType to iHasVariableDataType
82935>>>>>>>>>        
82935>>>>>>>>>    End_Procedure
82936>>>>>>>>>
82936>>>>>>>>>    //***
82936>>>>>>>>>    //*** Procedure: SQLExecute
82936>>>>>>>>>    //*** Purpose  : Execute a prepared statement
82936>>>>>>>>>    //***
82936>>>>>>>>>
82936>>>>>>>>>    Procedure SQLExecute
82938>>>>>>>>>        Integer ihdbc
82938>>>>>>>>>        Integer ihstmt
82938>>>>>>>>>        Integer iVoid
82938>>>>>>>>>        String  sDrvrId
82938>>>>>>>>>        String  sEmpty
82938>>>>>>>>>
82938>>>>>>>>>        //*** Initialize
82938>>>>>>>>>        Move "" To sEmpty
82939>>>>>>>>>
82939>>>>>>>>>        //*** Get the cli handles
82939>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
82940>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
82941>>>>>>>>>        Get psDriverId            to sDrvrId
82942>>>>>>>>>
82942>>>>>>>>>        //*** Execute
82942>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
82944>>>>>>>>>            //*** Call the driver function to execute
82944>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLEXECUTE ;                        Callback Self ;                        Passing ihdbc sEmpty ihstmt ;                        Result iVoid
82949>>>>>>>>>            Send SQLGetStatementAttributes
82950>>>>>>>>>        End
82950>>>>>>>>>>
82950>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLExecute"
82952>>>>>>>>>    End_Procedure
82953>>>>>>>>>
82953>>>>>>>>>
82953>>>>>>>>>
82953>>>>>>>>>    //***
82953>>>>>>>>>    //*** Procedure: SQLExecDirect
82953>>>>>>>>>    //*** Purpose  : Prepare and execute a statement
82953>>>>>>>>>    //***
82953>>>>>>>>>
82953>>>>>>>>>    Procedure SQLExecDirect String sStatement
82955>>>>>>>>>        Integer ihdbc
82955>>>>>>>>>        Integer ihstmt
82955>>>>>>>>>        Integer iVoid
82955>>>>>>>>>        String  sDrvrId
82955>>>>>>>>>
82955>>>>>>>>>        //*** Get the cli handles
82955>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
82956>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
82957>>>>>>>>>        Get psDriverId            to sDrvrId
82958>>>>>>>>>
82958>>>>>>>>>        //*** ExecDirect
82958>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
82960>>>>>>>>>            //*** Call the driver function to execdirect
82960>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLEXECDIRECT ;                        Callback Self ;                        Passing ihdbc sStatement ihstmt ;                        Result iVoid
82965>>>>>>>>>            Send SQLGetStatementAttributes
82966>>>>>>>>>        End
82966>>>>>>>>>>
82966>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLExecDirect"
82968>>>>>>>>>    End_Procedure
82969>>>>>>>>>
82969>>>>>>>>>
82969>>>>>>>>>
82969>>>>>>>>>    //***
82969>>>>>>>>>    //*** Procedure: SQLFetch
82969>>>>>>>>>    //*** Purpose  : Fetch the next row
82969>>>>>>>>>    //*** Returns  : 0   = No more data
82969>>>>>>>>>    //***            <>0 = Success
82969>>>>>>>>>    //***
82969>>>>>>>>>    Function SQLFetch Returns Integer
82971>>>>>>>>>        Integer ihdbc
82971>>>>>>>>>        Integer ihstmt
82971>>>>>>>>>        Integer iResult
82971>>>>>>>>>        String  sDrvrId
82971>>>>>>>>>        String  sEmpty
82971>>>>>>>>>
82971>>>>>>>>>        //*** Initialize
82971>>>>>>>>>        Move "" To sEmpty
82972>>>>>>>>>        Move 0  To iResult
82973>>>>>>>>>
82973>>>>>>>>>        //*** Get the cli handles
82973>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
82974>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
82975>>>>>>>>>        Get psDriverId            to sDrvrId
82976>>>>>>>>>
82976>>>>>>>>>        //*** Fetch
82976>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
82978>>>>>>>>>            Indicate Err False
82979>>>>>>>>>
82979>>>>>>>>>            //*** Call the driver function to fetch
82979>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLFETCH Callback Self Passing ihdbc sEmpty ihstmt Result iResult
82984>>>>>>>>>
82984>>>>>>>>>            //*** If something went wrong, adjust the result
82984>>>>>>>>>            If (Err) Move 0 to iResult
82987>>>>>>>>>
82987>>>>>>>>>            Set piLastcolumn To 0
82988>>>>>>>>>        End
82988>>>>>>>>>>
82988>>>>>>>>>        Else Send HandleError ihstmt ihdbc sDrvrId "SQLFetch"
82990>>>>>>>>>
82990>>>>>>>>>        Function_return iResult
82991>>>>>>>>>    End_Function
82992>>>>>>>>>
82992>>>>>>>>>
82992>>>>>>>>>    //***
82992>>>>>>>>>    //*** Procedure: SQLFetchRowValues
82992>>>>>>>>>    //*** Purpose  : Fetch the next row and return an array with all column values
82992>>>>>>>>>    //*** Returns  : Array of strings with all column values
82992>>>>>>>>>    //***            Sets piFetchResult property 
82992>>>>>>>>>    //***               0    = No more data
82992>>>>>>>>>    //***               <> 0 = Success
82992>>>>>>>>>    //***
82992>>>>>>>>>    Function SQLFetchRowValues Returns String[] 
82994>>>>>>>>>      
82994>>>>>>>>>        String[] asValues
82995>>>>>>>>>
82995>>>>>>>>>        tSQLColumn[] aSQLColumns        
82995>>>>>>>>>        tSQLColumn[] aSQLColumns        
82996>>>>>>>>>        
82996>>>>>>>>>        Integer ihdbc
82996>>>>>>>>>        Integer ihstmt
82996>>>>>>>>>        Integer iResult iVoid
82996>>>>>>>>>        Integer iColCount iCol
82996>>>>>>>>>        String  sDrvrId
82996>>>>>>>>>        String  sEmpty 
82996>>>>>>>>>        String  sResult
82996>>>>>>>>>        String  sVariableResult
82996>>>>>>>>>        Integer iHasVariableDataType
82996>>>>>>>>>        Integer iLen
82996>>>>>>>>>        Integer iVariableBufferLength
82996>>>>>>>>>
82996>>>>>>>>>        //*** Initialize
82996>>>>>>>>>        Move "" to sEmpty
82997>>>>>>>>>        Move 0  to iResult
82998>>>>>>>>>
82998>>>>>>>>>        //*** Get the cli handles
82998>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
82999>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83000>>>>>>>>>        Get psDriverId            to sDrvrId
83001>>>>>>>>>        
83001>>>>>>>>>        Get paSQLColumns to aSQLColumns
83002>>>>>>>>>        Get piColumnCount to iColCount
83003>>>>>>>>>        Get piHasVariableDataType to iHasVariableDataType
83004>>>>>>>>>        
83004>>>>>>>>>        If (iHasVariableDataType) Begin
83006>>>>>>>>>            
83006>>>>>>>>>            Get piVariableBufferLength      to iVariableBufferLength
83007>>>>>>>>>            Get piMaxVariableBufferLength   to iLen
83008>>>>>>>>>            
83008>>>>>>>>>            If (iLen > iVariableBufferLength) Begin
83010>>>>>>>>>                //*** Allocate
83010>>>>>>>>>                Move (Repeat(' ', iLen)) to sVariableResult
83011>>>>>>>>>               
83011>>>>>>>>>                Set piVariableBufferLength to iLen
83012>>>>>>>>>                Set psVariableBuffer       to sVariableResult
83013>>>>>>>>>                
83013>>>>>>>>>                Get piVariableBufferLength to iVariableBufferLength                
83014>>>>>>>>>            End
83014>>>>>>>>>>
83014>>>>>>>>>        End
83014>>>>>>>>>>
83014>>>>>>>>>
83014>>>>>>>>>        //*** Fetch
83014>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
83016>>>>>>>>>            Move (False) to Err
83017>>>>>>>>>
83017>>>>>>>>>            // FUNC_SQLCOLUMNINFO will tell the driver which hdbc and hstmt to use 
83017>>>>>>>>>            // in the next FUNC_SQLCOLUMNVALUE call.
83017>>>>>>>>>            // If hdbc and hstmt have not changed since the last call we don't have to set it.
83017>>>>>>>>>            If (ihstmt <> giLastSQLhstmt or ihdbc <> giLastSQLhdbc) Begin
83019>>>>>>>>>                //*** Setup function arguments
83019>>>>>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO Callback 0 Passing ihdbc iCol ihstmt Result iVoid
83024>>>>>>>>>                Move ihstmt to giLastSQLhstmt
83025>>>>>>>>>                Move ihdbc to giLastSQLhdbc
83026>>>>>>>>>            End
83026>>>>>>>>>>
83026>>>>>>>>>
83026>>>>>>>>>            //*** Call the driver function to fetch
83026>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLFETCH Callback 0 Passing ihdbc sEmpty ihstmt Result iResult
83031>>>>>>>>>
83031>>>>>>>>>            //*** If something went wrong, adjust the result
83031>>>>>>>>>            If (Err) Move 0 to iResult
83034>>>>>>>>>            
83034>>>>>>>>>            If (iResult) Begin
83036>>>>>>>>>                For iCol from 1 to iColCount
83042>>>>>>>>>>
83042>>>>>>>>>                    
83042>>>>>>>>>                    If (not(aSQLColumns[iCol].iVariableDataType)) Begin
83044>>>>>>>>>                        Get psMaxColValue to sResult
83045>>>>>>>>>                        Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNVALUE Callback 0 Passing sResult sEmpty iCol Result iVoid
83050>>>>>>>>>
83050>>>>>>>>>                        Move sResult to asValues[iCol - 1]
83051>>>>>>>>>                    End
83051>>>>>>>>>>
83051>>>>>>>>>                    Else Begin
83052>>>>>>>>>                        Get psVariableBuffer       to sVariableResult
83053>>>>>>>>>                        Call_Driver 0 sDrvrId Function FUNC_SQLGETDATA ;                                    Callback 0 ;                                    Passing sVariableResult iCol iVariableBufferLength ;                                    Result iVoid
83058>>>>>>>>>                                    
83058>>>>>>>>>                        Move sVariableResult to asValues[iCol - 1]
83059>>>>>>>>>                    End
83059>>>>>>>>>>
83059>>>>>>>>>                    
83059>>>>>>>>>                Loop
83060>>>>>>>>>>
83060>>>>>>>>>            End
83060>>>>>>>>>>
83060>>>>>>>>>        End
83060>>>>>>>>>>
83060>>>>>>>>>        Else Begin    
83061>>>>>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLFetchRowValues"
83062>>>>>>>>>        End
83062>>>>>>>>>>
83062>>>>>>>>>
83062>>>>>>>>>        Set piFetchResult to iResult
83063>>>>>>>>>
83063>>>>>>>>>        Function_Return asValues
83064>>>>>>>>>        
83064>>>>>>>>>    End_Function 
83065>>>>>>>>>
83065>>>>>>>>>    //***
83065>>>>>>>>>    //*** Procedure: SQLFetchResultsetValues
83065>>>>>>>>>    //*** Purpose  : Fetch a complete result set. 
83065>>>>>>>>>    //*** Returns  : 2-dimensional array of strings with result set
83065>>>>>>>>>    //***            Sets piFetchResult property 
83065>>>>>>>>>    //***               0    = No more data
83065>>>>>>>>>    //***               <> 0 = Success
83065>>>>>>>>>    //***
83065>>>>>>>>>    Function SQLFetchResultsetValues Returns String[][] 
83067>>>>>>>>>        
83067>>>>>>>>>        String[][] asValues 
83068>>>>>>>>>        
83068>>>>>>>>>        Integer ihdbc ihstmt iResult iVoid iColCount iCol iRow
83068>>>>>>>>>        String sDrvrId sEmpty sResult sMax
83068>>>>>>>>>
83068>>>>>>>>>        tSQLColumn[] aSQLColumns        
83068>>>>>>>>>        tSQLColumn[] aSQLColumns        
83069>>>>>>>>>        String  sVariableResult
83069>>>>>>>>>        Integer iHasVariableDataType
83069>>>>>>>>>        Integer iLen
83069>>>>>>>>>        Integer iVariableBufferLength
83069>>>>>>>>>
83069>>>>>>>>>        //*** Initialize
83069>>>>>>>>>        Move "" to sEmpty
83070>>>>>>>>>        Move 0  to iResult
83071>>>>>>>>>
83071>>>>>>>>>        //*** Get the cli handles
83071>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
83072>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83073>>>>>>>>>        Get psDriverId            to sDrvrId
83074>>>>>>>>>
83074>>>>>>>>>        //*** Fetch
83074>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
83076>>>>>>>>>            Indicate Err False
83077>>>>>>>>>            
83077>>>>>>>>>            // FUNC_SQLCOLUMNINFO will tell the driver which hdbc and hstmt to use 
83077>>>>>>>>>            // in the next FUNC_SQLCOLUMNVALUE call.
83077>>>>>>>>>            // If hdbc and hstmt have not changed since the last call we don't have to set it.
83077>>>>>>>>>            If (ihstmt <> giLastSQLhstmt or ihdbc <> giLastSQLhdbc) Begin
83079>>>>>>>>>                //*** Setup function arguments
83079>>>>>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO Callback 0 Passing ihdbc iCol ihstmt Result iVoid
83084>>>>>>>>>                Move ihstmt to giLastSQLhstmt
83085>>>>>>>>>                Move ihdbc to giLastSQLhdbc
83086>>>>>>>>>            End
83086>>>>>>>>>>
83086>>>>>>>>>
83086>>>>>>>>>
83086>>>>>>>>>            Get paSQLColumns to aSQLColumns
83087>>>>>>>>>            Get piColumnCount to iColCount
83088>>>>>>>>>            Get piHasVariableDataType to iHasVariableDataType
83089>>>>>>>>>            If (iHasVariableDataType) Begin
83091>>>>>>>>>                Get piVariableBufferLength      to iVariableBufferLength
83092>>>>>>>>>                Get piMaxVariableBufferLength   to iLen
83093>>>>>>>>>                If (iLen > iVariableBufferLength) Begin
83095>>>>>>>>>                    //*** Allocate
83095>>>>>>>>>                    Move (Repeat(' ', iLen)) to sVariableResult
83096>>>>>>>>>                   
83096>>>>>>>>>                    Set piVariableBufferLength to iLen
83097>>>>>>>>>                    Set psVariableBuffer       to sVariableResult
83098>>>>>>>>>                    
83098>>>>>>>>>                    Get piVariableBufferLength to iVariableBufferLength                
83099>>>>>>>>>                End
83099>>>>>>>>>>
83099>>>>>>>>>                Else Begin
83100>>>>>>>>>                   Set psVariableBuffer       to sVariableResult
83101>>>>>>>>>                End
83101>>>>>>>>>>
83101>>>>>>>>>            End
83101>>>>>>>>>>
83101>>>>>>>>>
83101>>>>>>>>>            Get psMaxColValue to sMax
83102>>>>>>>>>
83102>>>>>>>>>            //*** Call the driver function to fetch
83102>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLFETCH Callback Self Passing ihdbc sEmpty ihstmt Result iResult
83107>>>>>>>>>            If (Err) Move 0 to iResult
83110>>>>>>>>>
83110>>>>>>>>>            While (iResult <> 0)
83114>>>>>>>>>
83114>>>>>>>>>                For iCol from 1 to (iColCount)
83120>>>>>>>>>>
83120>>>>>>>>>                    
83120>>>>>>>>>                    If (not(aSQLColumns[iCol].iVariableDataType)) Begin
83122>>>>>>>>>                        Move sMax to sResult
83123>>>>>>>>>                        Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNVALUE ;                                    Callback 0 ;                                    Passing sResult sEmpty iCol ;                                    Result iVoid
83128>>>>>>>>>                        Move sResult to asValues[iRow][iCol - 1]
83129>>>>>>>>>                    End
83129>>>>>>>>>>
83129>>>>>>>>>                    Else Begin
83130>>>>>>>>>                        //Variable data    
83130>>>>>>>>>                        Move sVariableResult to sResult
83131>>>>>>>>>                        Call_Driver 0 sDrvrId Function FUNC_SQLGETDATA ;                                    Callback 0 ;                                    Passing sResult iCol iVariableBufferLength ;                                    Result iVoid
83136>>>>>>>>>                                    
83136>>>>>>>>>                        Move sResult to asValues[iRow][iCol - 1]
83137>>>>>>>>>                    End
83137>>>>>>>>>>
83137>>>>>>>>>                Loop
83138>>>>>>>>>>
83138>>>>>>>>>
83138>>>>>>>>>                Increment iRow
83139>>>>>>>>>
83139>>>>>>>>>                //*** Call the driver function to fetch
83139>>>>>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLFETCH Callback Self Passing ihdbc sEmpty ihstmt Result iResult
83144>>>>>>>>>                If (Err) Move 0 to iResult
83147>>>>>>>>>
83147>>>>>>>>>            Loop
83148>>>>>>>>>>
83148>>>>>>>>>
83148>>>>>>>>>        End
83148>>>>>>>>>>
83148>>>>>>>>>        Else Send HandleError ihstmt ihdbc sDrvrId "SQLFetchResultsetValues"
83150>>>>>>>>>
83150>>>>>>>>>        Set piFetchResult to iResult
83151>>>>>>>>>
83151>>>>>>>>>        Function_Return asValues
83152>>>>>>>>>    End_Function 
83153>>>>>>>>>
83153>>>>>>>>>
83153>>>>>>>>>
83153>>>>>>>>>    //***
83153>>>>>>>>>    //*** Function: SQLNextColumn
83153>>>>>>>>>    //*** Purpose : Get the next column
83153>>>>>>>>>    //***
83153>>>>>>>>>
83153>>>>>>>>>    Function SQLNextColumn Returns String
83155>>>>>>>>>        Integer iCol
83155>>>>>>>>>        String  sResult
83155>>>>>>>>>
83155>>>>>>>>>        Get piLastColumn To iCol
83156>>>>>>>>>        Increment iCol
83157>>>>>>>>>        Get SQLColumnValue iCol To sResult
83158>>>>>>>>>        Set piLastColumn To iCol
83159>>>>>>>>>
83159>>>>>>>>>        Function_return sResult
83160>>>>>>>>>    End_Function 
83161>>>>>>>>>
83161>>>>>>>>>
83161>>>>>>>>>    //***
83161>>>>>>>>>    //*** Function: SQLColumnType
83161>>>>>>>>>    //*** Purpose : Returns the native type of a column
83161>>>>>>>>>    //***
83161>>>>>>>>>    Function SQLColumnType Integer iCol Returns Integer
83163>>>>>>>>>        Integer ihdbc
83163>>>>>>>>>        Integer ihstmt
83163>>>>>>>>>        String  sDrvrId
83163>>>>>>>>>        Integer iSQLType
83163>>>>>>>>>        Integer iColumns
83163>>>>>>>>>        
83163>>>>>>>>>        tSQLColumn[] aSQLColumns
83163>>>>>>>>>        tSQLColumn[] aSQLColumns
83164>>>>>>>>>        
83164>>>>>>>>>        //*** Get the cli handles
83164>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
83165>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83166>>>>>>>>>        Get psDriverId            to sDrvrId
83167>>>>>>>>>
83167>>>>>>>>>        //*** Get the value
83167>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
83169>>>>>>>>>        
83169>>>>>>>>>            Get paSQLColumns   to aSQLColumns        
83170>>>>>>>>>            Move (SizeOfArray(aSQLColumns)) to iColumns
83171>>>>>>>>>            
83171>>>>>>>>>            If (iCol >= 1 and iCol <= iColumns) Begin
83173>>>>>>>>>                Move aSQLColumns[iCol].iSQLType to iSQLType
83174>>>>>>>>>            End
83174>>>>>>>>>>
83174>>>>>>>>>            Else Begin
83175>>>>>>>>>                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLColumnType"        
83176>>>>>>>>>            End
83176>>>>>>>>>>
83176>>>>>>>>>        End
83176>>>>>>>>>>
83176>>>>>>>>>        Else Begin
83177>>>>>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLColumnType"
83178>>>>>>>>>        End
83178>>>>>>>>>>
83178>>>>>>>>>
83178>>>>>>>>>        Function_Return iSQLType
83179>>>>>>>>>    End_Function 
83180>>>>>>>>>
83180>>>>>>>>>    //***
83180>>>>>>>>>    //*** Function: SQLColumnSize
83180>>>>>>>>>    //*** Purpose : Returns the size (max length) of a column
83180>>>>>>>>>    //***
83180>>>>>>>>>    Function SQLColumnSize Integer iCol Returns Integer
83182>>>>>>>>>        Integer ihdbc
83182>>>>>>>>>        Integer ihstmt
83182>>>>>>>>>        String  sDrvrId
83182>>>>>>>>>        Integer iSQLSize
83182>>>>>>>>>        Integer iColumns
83182>>>>>>>>>        
83182>>>>>>>>>        tSQLColumn[] aSQLColumns
83182>>>>>>>>>        tSQLColumn[] aSQLColumns
83183>>>>>>>>>        
83183>>>>>>>>>        //*** Get the cli handles
83183>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
83184>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83185>>>>>>>>>        Get psDriverId            to sDrvrId
83186>>>>>>>>>
83186>>>>>>>>>        //*** Get the value
83186>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
83188>>>>>>>>>        
83188>>>>>>>>>            Get paSQLColumns   to aSQLColumns        
83189>>>>>>>>>            Move (SizeOfArray(aSQLColumns)) to iColumns
83190>>>>>>>>>            
83190>>>>>>>>>            If (iCol >= 1 and iCol <= iColumns) Begin
83192>>>>>>>>>                Move aSQLColumns[iCol].iSQLSize to iSQLSize
83193>>>>>>>>>            End
83193>>>>>>>>>>
83193>>>>>>>>>            Else Begin
83194>>>>>>>>>                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLColumnSize"        
83195>>>>>>>>>            End
83195>>>>>>>>>>
83195>>>>>>>>>        End
83195>>>>>>>>>>
83195>>>>>>>>>        Else Begin
83196>>>>>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLColumnSize"
83197>>>>>>>>>        End
83197>>>>>>>>>>
83197>>>>>>>>>
83197>>>>>>>>>        Function_Return iSQLSize
83198>>>>>>>>>    End_Function 
83199>>>>>>>>>
83199>>>>>>>>>    //***
83199>>>>>>>>>    //*** Function: SQLColumnVariableDatatype
83199>>>>>>>>>    //*** Purpose : Returns 1 for variable length datatypes. 
83199>>>>>>>>>    //***           For example SQL Server varchar(max) or text type
83199>>>>>>>>>    //***           The data of variable length datatype columns should be retrieved with SQLGetData 
83199>>>>>>>>>    Function SQLColumnVariableDatatype Integer iCol Returns Integer
83201>>>>>>>>>        Integer ihdbc
83201>>>>>>>>>        Integer ihstmt
83201>>>>>>>>>        String  sDrvrId
83201>>>>>>>>>        Integer iVariableDataType
83201>>>>>>>>>        Integer iColumns
83201>>>>>>>>>        
83201>>>>>>>>>        tSQLColumn[] aSQLColumns
83201>>>>>>>>>        tSQLColumn[] aSQLColumns
83202>>>>>>>>>        
83202>>>>>>>>>        //*** Get the cli handles
83202>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
83203>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83204>>>>>>>>>        Get psDriverId            to sDrvrId
83205>>>>>>>>>
83205>>>>>>>>>        //*** Get the value
83205>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
83207>>>>>>>>>        
83207>>>>>>>>>            Get paSQLColumns   to aSQLColumns        
83208>>>>>>>>>            Move (SizeOfArray(aSQLColumns)) to iColumns
83209>>>>>>>>>            
83209>>>>>>>>>            If (iCol >= 1 and iCol <= iColumns) Begin
83211>>>>>>>>>                Move aSQLColumns[iCol].iVariableDataType to iVariableDataType
83212>>>>>>>>>            End
83212>>>>>>>>>>
83212>>>>>>>>>            Else Begin
83213>>>>>>>>>                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLColumnVariableDatatype"        
83214>>>>>>>>>            End
83214>>>>>>>>>>
83214>>>>>>>>>        End
83214>>>>>>>>>>
83214>>>>>>>>>        Else Begin
83215>>>>>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLColumnVariableDatatype"
83216>>>>>>>>>        End
83216>>>>>>>>>>
83216>>>>>>>>>
83216>>>>>>>>>        Function_Return iVariableDataType
83217>>>>>>>>>    End_Function 
83218>>>>>>>>>
83218>>>>>>>>>
83218>>>>>>>>>
83218>>>>>>>>>
83218>>>>>>>>>    //***
83218>>>>>>>>>    //*** Function: SQLColumnValue
83218>>>>>>>>>    //*** Purpose : Return the value of a column in a fetched row of a given
83218>>>>>>>>>    //***           statement.
83218>>>>>>>>>    //***
83218>>>>>>>>>    Function SQLColumnValue Integer iCol Returns String
83220>>>>>>>>>        Integer ihdbc
83220>>>>>>>>>        Integer ihstmt
83220>>>>>>>>>        String  sDrvrId
83220>>>>>>>>>        String  sResult
83220>>>>>>>>>
83220>>>>>>>>>        Integer iVoid
83220>>>>>>>>>        Integer iColSize
83220>>>>>>>>>        Integer iColPrecision
83220>>>>>>>>>        String  sEmpty
83220>>>>>>>>>        Integer bLegalColumn
83220>>>>>>>>>
83220>>>>>>>>>        //*** Initialize
83220>>>>>>>>>        Move "" To sResult
83221>>>>>>>>>
83221>>>>>>>>>        //*** Get the cli handles
83221>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
83222>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83223>>>>>>>>>        Get psDriverId            to sDrvrId
83224>>>>>>>>>
83224>>>>>>>>>        // FUNC_SQLCOLUMNINFO will tell the driver which hdbc and hstmt to use 
83224>>>>>>>>>        // in the next FUNC_SQLCOLUMNVALUE call.
83224>>>>>>>>>        // If hdbc and hstmt have not changed since the last call we don't have to set it.
83224>>>>>>>>>        If (ihstmt <> giLastSQLhstmt or ihdbc <> giLastSQLhdbc) Begin
83226>>>>>>>>>            //*** Setup function arguments
83226>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                        Callback 0 ;                        Passing ihdbc iCol ihstmt ;                        Result iVoid
83231>>>>>>>>>            Move ihstmt to giLastSQLhstmt
83232>>>>>>>>>            Move ihdbc to giLastSQLhdbc
83233>>>>>>>>>        End
83233>>>>>>>>>>
83233>>>>>>>>>
83233>>>>>>>>>        If (iCol >= 1 and iCol <= piColumnCount(Self)) Begin
83235>>>>>>>>>            Get psMaxColValue to sResult
83236>>>>>>>>>            //*** Call the driver function to get the value
83236>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNVALUE ;                        Callback 0 ;                        Passing sResult sEmpty iCol ;                        Result iVoid
83241>>>>>>>>>        End
83241>>>>>>>>>>
83241>>>>>>>>>        Else Begin
83242>>>>>>>>>            Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLColumnValue"
83243>>>>>>>>>        End
83243>>>>>>>>>>
83243>>>>>>>>>
83243>>>>>>>>>        Function_Return sResult
83244>>>>>>>>>        
83244>>>>>>>>>    End_Function
83245>>>>>>>>>
83245>>>>>>>>>
83245>>>>>>>>>
83245>>>>>>>>>    //***
83245>>>>>>>>>    //*** Procedure: SQLBindFile
83245>>>>>>>>>    //*** Purpose  : Add a file to the files used to place the statement result in.
83245>>>>>>>>>    //***
83245>>>>>>>>>
83245>>>>>>>>>    Procedure SQLBindFile Integer iFileNum
83247>>>>>>>>>        Integer ihdbc
83247>>>>>>>>>        Integer ihstmt
83247>>>>>>>>>        Integer iVoid
83247>>>>>>>>>        String  sDrvrId
83247>>>>>>>>>        String  sFileType
83247>>>>>>>>>        Integer bIsOpen
83247>>>>>>>>>
83247>>>>>>>>>        //*** Get the cli handles
83247>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
83248>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83249>>>>>>>>>        Get psDriverId            to sDrvrId
83250>>>>>>>>>
83250>>>>>>>>>        //*** If a file number is not passed see if we can use the statement's
83250>>>>>>>>>        //*** default file number which is usually set with SetFileConnection
83250>>>>>>>>>        If (iFileNum = 0) Begin
83252>>>>>>>>>            Get piBindFile To iFileNum
83253>>>>>>>>>            If (iFileNum = 0) Begin
83255>>>>>>>>>                //*** Logic error, if 0 is passed as filenumber, piBindFile should be set.
83255>>>>>>>>>                Send StmtError CLIERR_SQLINVALID_BIND_FILE "piBindFile should be set" "SQLBindFile"
83256>>>>>>>>>
83256>>>>>>>>>                Move 0 to SQLResult
83257>>>>>>>>>                Procedure_Return
83258>>>>>>>>>            End
83258>>>>>>>>>>
83258>>>>>>>>>        End
83258>>>>>>>>>>
83258>>>>>>>>>
83258>>>>>>>>>        //*** Bind the file
83258>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
83260>>>>>>>>>            //*** Chek if the file is open
83260>>>>>>>>>            Get_attribute DF_FILE_OPENED Of iFileNum To bIsOpen
83263>>>>>>>>>            If (bIsOpen) Begin
83265>>>>>>>>>                //*** Check if the file has the correct type
83265>>>>>>>>>                Get_attribute DF_FILE_DRIVER Of iFileNum To sFileType
83268>>>>>>>>>                If (sFileType = sDrvrId) Begin
83270>>>>>>>>>                    //*** Call the driver function to add a file to a statement
83270>>>>>>>>>                    Call_driver 0 sDrvrId Function FUNC_SQLBINDFILE ;                                Callback Self ;                                Passing ihdbc iFileNum ihstmt ;                                Result iVoid
83275>>>>>>>>>                End
83275>>>>>>>>>>
83275>>>>>>>>>                Else ;                    Send StmtError CLIERR_SQLINVALID_BIND_FILE ("File" * String(iFileNum) * "type incompatible with statement ("  + sFileType + ")") "SQLBindFile"
83277>>>>>>>>>            End
83277>>>>>>>>>>
83277>>>>>>>>>            Else ;                Send StmtError CLIERR_SQLINVALID_BIND_FILE ("File not open (number =" * String(iFileNum) + ")") "SQLBindFile"
83279>>>>>>>>>        End
83279>>>>>>>>>>
83279>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLBindFile"
83281>>>>>>>>>    End_Procedure 
83282>>>>>>>>>
83282>>>>>>>>>
83282>>>>>>>>>
83282>>>>>>>>>    //*************************************************************************
83282>>>>>>>>>    //*** Function: SQLGetData                                              ***
83282>>>>>>>>>    //*** Purpose : Get data of a column.                                   ***
83282>>>>>>>>>    //*************************************************************************
83282>>>>>>>>>
83282>>>>>>>>>    Function SQLGetData Integer iCol Integer iLen Returns String
83284>>>>>>>>>        Integer ihdbc
83284>>>>>>>>>        Integer ihstmt
83284>>>>>>>>>        Integer iVoid
83284>>>>>>>>>        Integer iColSize
83284>>>>>>>>>        Integer iResult
83284>>>>>>>>>        String  sDrvrId
83284>>>>>>>>>        String  sResult
83284>>>>>>>>>        String  sEmpty
83284>>>>>>>>>        Integer bLegalColumn
83284>>>>>>>>>        
83284>>>>>>>>>        Integer iVariableBufferLength
83284>>>>>>>>>
83284>>>>>>>>>        //*** Initialize
83284>>>>>>>>>        Move "" To sEmpty
83285>>>>>>>>>        Move 0 To iResult
83286>>>>>>>>>
83286>>>>>>>>>        //*** Get the cli handles
83286>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
83287>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83288>>>>>>>>>        Get psDriverId            to sDrvrId
83289>>>>>>>>>
83289>>>>>>>>>        //*** Get the data
83289>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
83291>>>>>>>>>            //*** Check if the column exists
83291>>>>>>>>>            If (iCol >= 1 and iCol <= piColumnCount(Self)) Begin
83293>>>>>>>>>                If (iLen = 0) Begin
83295>>>>>>>>>                    Get SQLColumnValue iCol to sResult
83296>>>>>>>>>                End
83296>>>>>>>>>>
83296>>>>>>>>>                Else Begin
83297>>>>>>>>>                    // Add 1 for string terminator
83297>>>>>>>>>                    Move (iLen + 1) to iLen
83298>>>>>>>>>
83298>>>>>>>>>                    Get piVariableBufferLength to iVariableBufferLength
83299>>>>>>>>>                    If (iLen > iVariableBufferLength) Begin
83301>>>>>>>>>                        //*** Allocate
83301>>>>>>>>>                        Move (Repeat(' ', iLen)) to sResult
83302>>>>>>>>>                       
83302>>>>>>>>>                        Set piVariableBufferLength to iLen
83303>>>>>>>>>                        Set psVariableBuffer       to sResult
83304>>>>>>>>>                    End
83304>>>>>>>>>>
83304>>>>>>>>>                    Else Begin
83305>>>>>>>>>                        Get psVariableBuffer       to sResult
83306>>>>>>>>>                    End
83306>>>>>>>>>>
83306>>>>>>>>>
83306>>>>>>>>>
83306>>>>>>>>>                    // FUNC_SQLCOLUMNINFO will tell the driver which hdbc and hstmt to use 
83306>>>>>>>>>                    // in the next FUNC_SQLCOLUMNVALUE call.
83306>>>>>>>>>                    // If hdbc and hstmt have not changed since the last call we don't have to set it.
83306>>>>>>>>>                    If (ihstmt <> giLastSQLhstmt or ihdbc <> giLastSQLhdbc) Begin
83308>>>>>>>>>                        //*** Setup function arguments
83308>>>>>>>>>                        Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                                    Callback 0 ;                                    Passing ihdbc iCol ihstmt ;                                    Result iVoid
83313>>>>>>>>>                        Move ihstmt to giLastSQLhstmt
83314>>>>>>>>>                        Move ihdbc to giLastSQLhdbc
83315>>>>>>>>>                    End
83315>>>>>>>>>>
83315>>>>>>>>>
83315>>>>>>>>>                    Indicate Err False
83316>>>>>>>>>                    //*** Call the driver function to get the data
83316>>>>>>>>>                    Call_driver 0 sDrvrId Function FUNC_SQLGETDATA ;                                Callback Self ;                                Passing sResult iCol iLen ;                                Result iResult
83321>>>>>>>>>
83321>>>>>>>>>                    //*** If something went wrong, adjust the result
83321>>>>>>>>>                    If (Err) Begin
83323>>>>>>>>>                        Move 0 to iResult
83324>>>>>>>>>                    End
83324>>>>>>>>>>
83324>>>>>>>>>                End
83324>>>>>>>>>>
83324>>>>>>>>>            End
83324>>>>>>>>>>
83324>>>>>>>>>            Else Begin
83325>>>>>>>>>                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLGetData"
83326>>>>>>>>>            End
83326>>>>>>>>>>
83326>>>>>>>>>        End
83326>>>>>>>>>>
83326>>>>>>>>>        Else Begin
83327>>>>>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLGetData"
83328>>>>>>>>>        End
83328>>>>>>>>>>
83328>>>>>>>>>
83328>>>>>>>>>        //*** Fill global result
83328>>>>>>>>>        Move iResult To SQLResult
83329>>>>>>>>>
83329>>>>>>>>>        Function_Return sResult
83330>>>>>>>>>    End_Function 
83331>>>>>>>>>
83331>>>>>>>>>
83331>>>>>>>>>
83331>>>>>>>>>    //***
83331>>>>>>>>>    //*** Function: SQLColumnMap
83331>>>>>>>>>    //*** Purpose : Map a column name to a number, if the name id not found no
83331>>>>>>>>>    //***           error is generated the returned number will be 0 (zero) in
83331>>>>>>>>>    //***           that case
83331>>>>>>>>>    //***
83331>>>>>>>>>
83331>>>>>>>>>    Function SQLColumnMap String sColname Returns Integer
83333>>>>>>>>>        Integer ihdbc
83333>>>>>>>>>        Integer ihstmt
83333>>>>>>>>>        Integer iNumColumns
83333>>>>>>>>>        Integer iColCount
83333>>>>>>>>>        Integer iColNum
83333>>>>>>>>>        String  sDrvrId
83333>>>>>>>>>        String  sCurColName
83333>>>>>>>>>
83333>>>>>>>>>        //*** Get the cli handles
83333>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
83334>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83335>>>>>>>>>        Get psDriverId            to sDrvrId
83336>>>>>>>>>
83336>>>>>>>>>        //*** Get the number by looping through the column names
83336>>>>>>>>>        Move 0 To iColNum
83337>>>>>>>>>        Get SQLPrivateStmtAttribute SQLSTMTATTRIB_COLUMNCOUNT ihdbc sDrvrId ihstmt To iNumColumns
83338>>>>>>>>>        For iColCount From 1 To iNumColumns
83344>>>>>>>>>>
83344>>>>>>>>>            Get SQLPrivateColAttribute iColCount SQLCOLATTRIB_LABEL ihdbc sDrvrId ihstmt To sCurColName
83345>>>>>>>>>            If (Uppercase(Trim(sColName)) = Uppercase(Trim(sCurColName))) ;                Move iColCount To iColNum
83348>>>>>>>>>
83348>>>>>>>>>            If (iColNum) ;                Break
83351>>>>>>>>>        Loop
83352>>>>>>>>>>
83352>>>>>>>>>
83352>>>>>>>>>        Function_return iColNum
83353>>>>>>>>>    End_Function 
83354>>>>>>>>>
83354>>>>>>>>>
83354>>>>>>>>>
83354>>>>>>>>>    //***
83354>>>>>>>>>    //*** Function: SQLStmtAttribute
83354>>>>>>>>>    //*** Purpose : Get a statement attribute
83354>>>>>>>>>    //***
83354>>>>>>>>>
83354>>>>>>>>>    Function SQLStmtAttribute Integer iAttribId Returns String
83356>>>>>>>>>        Integer ihdbc
83356>>>>>>>>>        Integer ihstmt
83356>>>>>>>>>        String  sResult
83356>>>>>>>>>        String  sDrvrId
83356>>>>>>>>>
83356>>>>>>>>>        //*** Initialize
83356>>>>>>>>>        Move "" To sResult
83357>>>>>>>>>
83357>>>>>>>>>        //*** Get the cli handles
83357>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
83358>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83359>>>>>>>>>        Get psDriverId            to sDrvrId
83360>>>>>>>>>
83360>>>>>>>>>        //*** Get the attribute
83360>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") ;            Get SQLPrivateStmtAttribute iAttribId ihdbc sDrvrId ihstmt To sResult
83363>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLStmtAttribute"
83365>>>>>>>>>
83365>>>>>>>>>        Function_Return sResult
83366>>>>>>>>>    End_Function 
83367>>>>>>>>>
83367>>>>>>>>>    Function SQLPrivateStmtAttribute Integer iAttribId Integer ihdbc String sDrvrId Integer ihstmt Returns String
83369>>>>>>>>>        String  sResult
83369>>>>>>>>>        Integer iLen
83369>>>>>>>>>        Integer bLegalAttrib
83369>>>>>>>>>
83369>>>>>>>>>        //*** Initialize
83369>>>>>>>>>        Move ""     To sResult
83370>>>>>>>>>
83370>>>>>>>>>        //*** Get the attribute
83370>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
83372>>>>>>>>>            Case Begin
83372>>>>>>>>>                Case (iAttribId = SQLSTMTATTRIB_COLUMNCOUNT)
83374>>>>>>>>>                Case (iAttribId = SQLSTMTATTRIB_ROWCOUNT)
83377>>>>>>>>>                Case (iAttribId = SQLSTMTATTRIB_ROWCOUNT_TYPE)
83380>>>>>>>>>                Case (iAttribId = SQLSTMTATTRIB_NUMMESSAGES)
83383>>>>>>>>>                    Move DFTRUE To bLegalAttrib
83384>>>>>>>>>                    Break
83385>>>>>>>>>
83385>>>>>>>>>                Case Else
83385>>>>>>>>>                    Move DFFALSE To bLegalAttrib
83386>>>>>>>>>                    Send SQLIllegalAttribute ("Attribute is = " + String(iAttribId) + ")") "SQLPrivateStmtAttribute"
83387>>>>>>>>>            Case End
83387>>>>>>>>>
83387>>>>>>>>>            If (bLegalAttrib) Begin
83389>>>>>>>>>                //*** Setup function arguments
83389>>>>>>>>>                Call_driver 0 sDrvrId Function FUNC_SQLSTMTINTATTRIB ;                            Callback Self ;                            Passing ihdbc iAttribId ihstmt ;                            Result sResult
83394>>>>>>>>>            End
83394>>>>>>>>>>
83394>>>>>>>>>        End
83394>>>>>>>>>>
83394>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLPrivateStmtAttribute"
83396>>>>>>>>>
83396>>>>>>>>>        Function_Return sResult
83397>>>>>>>>>    End_Function 
83398>>>>>>>>>
83398>>>>>>>>>
83398>>>>>>>>>
83398>>>>>>>>>    //***
83398>>>>>>>>>    //*** Function: SQLColAttribute
83398>>>>>>>>>    //*** Purpose : Get a column's attribute
83398>>>>>>>>>    //***
83398>>>>>>>>>
83398>>>>>>>>>    Function SQLColAttribute Integer iCol Integer iAttribId Returns String
83400>>>>>>>>>        Integer ihdbc
83400>>>>>>>>>        Integer ihstmt
83400>>>>>>>>>        String  sResult
83400>>>>>>>>>        String  sDrvrId
83400>>>>>>>>>
83400>>>>>>>>>        //*** Initialize
83400>>>>>>>>>        Move "" To sResult
83401>>>>>>>>>
83401>>>>>>>>>        //*** Get the cli handles
83401>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
83402>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83403>>>>>>>>>        Get psDriverId            to sDrvrId
83404>>>>>>>>>
83404>>>>>>>>>        //*** Get the attribute
83404>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") ;            Get SQLPrivateColAttribute iCol iAttribId ihdbc sDrvrId ihstmt To sResult
83407>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLColAttribute"
83409>>>>>>>>>
83409>>>>>>>>>        Function_Return sResult
83410>>>>>>>>>    End_Function 
83411>>>>>>>>>
83411>>>>>>>>>    Function SQLPrivateColAttribute Integer iCol Integer iAttribId Integer ihdbc String sDrvrId Integer ihstmt Returns String
83413>>>>>>>>>        String  sResult
83413>>>>>>>>>        String  sEmpty
83413>>>>>>>>>        Integer bIsStringAttribute
83413>>>>>>>>>        Integer iLen
83413>>>>>>>>>        Integer iVoid
83413>>>>>>>>>        Integer bLegalAttrib
83413>>>>>>>>>        Integer bLegalColumn
83413>>>>>>>>>
83413>>>>>>>>>        //*** Initialize
83413>>>>>>>>>        Move "" To sResult
83414>>>>>>>>>        Move "" To sEmpty
83415>>>>>>>>>        MOve 0  To iLen
83416>>>>>>>>>
83416>>>>>>>>>        //*** Get the attribute
83416>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
83418>>>>>>>>>            Get SQLPrivateColumnIsLegal ihdbc sDrvrId ihstmt iCol To bLegalColumn
83419>>>>>>>>>            If (bLegalColumn) Begin
83421>>>>>>>>>                //*** Determine the atributes type
83421>>>>>>>>>                Case Begin
83421>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_SIZE)
83423>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_LENGTH)
83426>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_PRECISION)
83429>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_SQLTYPE)
83432>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_NULLABLE)
83435>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_DFTYPE)
83438>>>>>>>>>                        Move DFFALSE To bIsStringAttribute
83439>>>>>>>>>                        Move DFTRUE To bLegalAttrib
83440>>>>>>>>>                        Break
83441>>>>>>>>>
83441>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_LABEL)
83444>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_BASECOLUMNNAME)
83447>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_BASETABLENAME)
83450>>>>>>>>>                        Move DFTRUE To bIsStringAttribute
83451>>>>>>>>>                        Move DFTRUE To bLegalAttrib
83452>>>>>>>>>                        Break
83453>>>>>>>>>
83453>>>>>>>>>                    Case Else
83453>>>>>>>>>                        Move DFFALSE To bLegalAttrib
83454>>>>>>>>>                        Send SQLIllegalAttribute ("Attribute is = " + String(iAttribId) + ")") "SQLPrivateColAttribute"
83455>>>>>>>>>                Case End
83455>>>>>>>>>
83455>>>>>>>>>                If (bLegalAttrib) Begin
83457>>>>>>>>>                    //*** Setup function arguments
83457>>>>>>>>>                    Call_driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                                Callback Self ;                                Passing ihdbc iCol ihstmt ;                                Result iVoid
83462>>>>>>>>>
83462>>>>>>>>>                    If (bIsStringAttribute) Begin
83464>>>>>>>>>                        //*** Call the driver function to get the data length
83464>>>>>>>>>                        Call_driver 0 sDrvrId Function FUNC_SQLCOLSTRINGATTRIBLEN ;                                    Callback Self ;                                    Passing sEmpty sEmpty iAttribId ;                                    Result iLen
83469>>>>>>>>>
83469>>>>>>>>>                        If (iLen) Begin
83471>>>>>>>>>                            //*** Allocate
83471>>>>>>>>>                            Move (Repeat(' ', iLen)) To sResult
83472>>>>>>>>>
83472>>>>>>>>>                            //*** Call the driver function to get the name
83472>>>>>>>>>                            Call_driver 0 sDrvrId Function FUNC_SQLCOLSTRINGATTRIB ;                                        Callback Self ;                                        Passing sResult sEmpty iAttribId ;                                        Result iVoid
83477>>>>>>>>>                        End
83477>>>>>>>>>>
83477>>>>>>>>>                    End
83477>>>>>>>>>>
83477>>>>>>>>>                    Else Begin
83478>>>>>>>>>                        //*** get the attribute
83478>>>>>>>>>                        Call_driver 0 sDrvrId Function FUNC_SQLCOLINTATTRIB ;                                    Callback Self ;                                    Passing sEmpty sEmpty iAttribId ;                                    Result sResult
83483>>>>>>>>>                    End
83483>>>>>>>>>>
83483>>>>>>>>>                End
83483>>>>>>>>>>
83483>>>>>>>>>            End
83483>>>>>>>>>>
83483>>>>>>>>>            Else ;                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLPrivateColAttribute"
83485>>>>>>>>>        End
83485>>>>>>>>>>
83485>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLPrivateColAttribute"
83487>>>>>>>>>
83487>>>>>>>>>        Function_Return sResult
83488>>>>>>>>>    End_Function 
83489>>>>>>>>>
83489>>>>>>>>>
83489>>>>>>>>>
83489>>>>>>>>>    //***
83489>>>>>>>>>    //*** Procedure: SQLSetProcedureName
83489>>>>>>>>>    //*** Purpsoe  : Preapre for calling a stored procedure, pass the procedure name.
83489>>>>>>>>>    //***
83489>>>>>>>>>
83489>>>>>>>>>    Procedure SQLSetProcedureName String sProcName String sSchemaArg
83491>>>>>>>>>        Integer ihdbc
83491>>>>>>>>>        Integer ihstmt
83491>>>>>>>>>        String  sDrvrId
83491>>>>>>>>>        Integer iVoid
83491>>>>>>>>>        String  sSchema
83491>>>>>>>>>        String  sEmpty
83491>>>>>>>>>
83491>>>>>>>>>        //*** Initialize
83491>>>>>>>>>        Move "" To sEmpty
83492>>>>>>>>>
83492>>>>>>>>>        //*** Get the cli handles
83492>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
83493>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83494>>>>>>>>>        Get psDriverId            to sDrvrId
83495>>>>>>>>>
83495>>>>>>>>>        //*** Call the procedure
83495>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
83497>>>>>>>>>            If (Num_Arguments >= 2) ;                Move sSchemaArg To sSchema
83500>>>>>>>>>            Else ;                Move "" To sSchema
83502>>>>>>>>>
83502>>>>>>>>>            If (sSchema <> "") Begin
83504>>>>>>>>>                Call_driver 0 sDrvrId Function FUNC_SQLSETPROCSCHEMA ;                            Callback Self ;                            Passing ihdbc sSchema ihstmt ;                            Result iVoid
83509>>>>>>>>>            End
83509>>>>>>>>>>
83509>>>>>>>>>
83509>>>>>>>>>            //*** Call the procedure
83509>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLSETPROCNAME ;                        Callback Self ;                        Passing ihdbc sProcName ihstmt ;                        Result iVoid
83514>>>>>>>>>
83514>>>>>>>>>            Set piLastArgument To 0
83515>>>>>>>>>        End
83515>>>>>>>>>>
83515>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLSetProcedurename"
83517>>>>>>>>>    End_Procedure 
83518>>>>>>>>>
83518>>>>>>>>>
83518>>>>>>>>>
83518>>>>>>>>>    //***
83518>>>>>>>>>    //*** Function: SQLSetNextArgument
83518>>>>>>>>>    //*** Purpose : Pass the next argument
83518>>>>>>>>>    //***
83518>>>>>>>>>
83518>>>>>>>>>    Procedure SQLSetNextArgument String sArgument
83520>>>>>>>>>        Integer iArgnum
83520>>>>>>>>>
83520>>>>>>>>>        Get piLastArgument To iArgnum
83521>>>>>>>>>        Increment iArgnum
83522>>>>>>>>>        Send SQLSetArgument iArgnum sArgument
83523>>>>>>>>>        Set piLastArgument To iArgnum
83524>>>>>>>>>    End_Procedure 
83525>>>>>>>>>
83525>>>>>>>>>
83525>>>>>>>>>
83525>>>>>>>>>    //***
83525>>>>>>>>>    //*** Procedure: SQLSetArgument
83525>>>>>>>>>    //*** Purpose  : Set the next argument
83525>>>>>>>>>    //***
83525>>>>>>>>>
83525>>>>>>>>>    Procedure SQLSetArgument Integer iArgnum String sArgument
83527>>>>>>>>>        Integer ihdbc
83527>>>>>>>>>        Integer ihstmt
83527>>>>>>>>>        String  sDrvrId
83527>>>>>>>>>        Integer iVoid
83527>>>>>>>>>        String  sEmpty
83527>>>>>>>>>
83527>>>>>>>>>        //*** Initialize
83527>>>>>>>>>        Move "" To sEmpty
83528>>>>>>>>>
83528>>>>>>>>>        //*** Get the cli handles
83528>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
83529>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83530>>>>>>>>>        Get psDriverId            to sDrvrId
83531>>>>>>>>>
83531>>>>>>>>>        //*** Call the procedure
83531>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
83533>>>>>>>>>            //*** Pass the information
83533>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                        Callback Self ;                        Passing ihdbc iArgnum ihstmt ;                        Result iVoid
83538>>>>>>>>>
83538>>>>>>>>>            //*** Pass the argument
83538>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLSETPROCARG ;                        Callback Self ;                        Passing sArgument sEmpty 0 ;                        Result iVoid
83543>>>>>>>>>        End
83543>>>>>>>>>>
83543>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLSetArgument"
83545>>>>>>>>>    End_Procedure
83546>>>>>>>>>
83546>>>>>>>>>
83546>>>>>>>>>
83546>>>>>>>>>    //***
83546>>>>>>>>>    //*** Procedure: SQLCall
83546>>>>>>>>>    //*** Purpose  : Call a stored procedure
83546>>>>>>>>>    //***
83546>>>>>>>>>
83546>>>>>>>>>    Procedure SQLCall
83548>>>>>>>>>        Integer ihdbc
83548>>>>>>>>>        Integer ihstmt
83548>>>>>>>>>        String  sDrvrId
83548>>>>>>>>>        Integer iVoid
83548>>>>>>>>>        String  sEmpty
83548>>>>>>>>>
83548>>>>>>>>>        //*** Initialize
83548>>>>>>>>>        Move "" To sEmpty
83549>>>>>>>>>
83549>>>>>>>>>        //*** Get the cli handles
83549>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
83550>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83551>>>>>>>>>        Get psDriverId            to sDrvrId
83552>>>>>>>>>
83552>>>>>>>>>        //*** Call the procedure
83552>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
83554>>>>>>>>>            //*** Call the procedure
83554>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLCALL ;                        Callback Self ;                        Passing ihdbc sEmpty ihstmt ;                        Result iVoid
83559>>>>>>>>>                        
83559>>>>>>>>>            Send SQLGetStatementAttributes
83560>>>>>>>>>            Set piLastArgument To 0
83561>>>>>>>>>        End
83561>>>>>>>>>>
83561>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLCall"
83563>>>>>>>>>    End_Procedure 
83564>>>>>>>>>
83564>>>>>>>>>
83564>>>>>>>>>
83564>>>>>>>>>    //***
83564>>>>>>>>>    //*** Function: SQLGetNextArgument
83564>>>>>>>>>    //*** Purpose : Get the next argument
83564>>>>>>>>>    //***
83564>>>>>>>>>
83564>>>>>>>>>    Function SQLGetNextArgument Returns String
83566>>>>>>>>>        Integer iArgnum
83566>>>>>>>>>        String  sResult
83566>>>>>>>>>
83566>>>>>>>>>        Get piLastArgument To iArgnum
83567>>>>>>>>>        Increment iArgnum
83568>>>>>>>>>        Get SQLGetArgument iArgnum To sResult
83569>>>>>>>>>        Set piLastArgument To iArgnum
83570>>>>>>>>>
83570>>>>>>>>>        Function_return sResult
83571>>>>>>>>>    End_Function 
83572>>>>>>>>>
83572>>>>>>>>>
83572>>>>>>>>>
83572>>>>>>>>>    //***
83572>>>>>>>>>    //*** Function: SQLGetArgument
83572>>>>>>>>>    //*** Purpose : Get the specified argument from a procedure
83572>>>>>>>>>    //***
83572>>>>>>>>>
83572>>>>>>>>>    Function SQLGetArgument Integer iArgnum Returns String
83574>>>>>>>>>        Integer ihdbc
83574>>>>>>>>>        Integer ihstmt
83574>>>>>>>>>        String  sDrvrId
83574>>>>>>>>>        Integer iVoid
83574>>>>>>>>>        String  sEmpty
83574>>>>>>>>>        String  sArgument
83574>>>>>>>>>        Integer iLen
83574>>>>>>>>>
83574>>>>>>>>>        //*** Initialize
83574>>>>>>>>>        Move "" To sEmpty
83575>>>>>>>>>        Move "" To sArgument
83576>>>>>>>>>
83576>>>>>>>>>        //*** Get the cli handles
83576>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
83577>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83578>>>>>>>>>        Get psDriverId            to sDrvrId
83579>>>>>>>>>
83579>>>>>>>>>        //*** Call the procedure
83579>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
83581>>>>>>>>>            //*** Pass the information
83581>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                        Callback Self ;                        Passing ihdbc iArgnum ihstmt ;                        Result iVoid
83586>>>>>>>>>
83586>>>>>>>>>            //*** Get the length
83586>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLGETPROCARGLEN ;                        Callback Self ;                        Passing sEmpty sEmpty 0 ;                        Result iLen
83591>>>>>>>>>
83591>>>>>>>>>            If (iLen) Begin
83593>>>>>>>>>                //*** Allocate
83593>>>>>>>>>                Move (Repeat(' ', iLen)) To sArgument
83594>>>>>>>>>
83594>>>>>>>>>                //*** Pass the argument
83594>>>>>>>>>                Call_driver 0 sDrvrId Function FUNC_SQLGETPROCARG ;                            Callback Self ;                            Passing sArgument sEmpty 0 ;                            Result iVoid
83599>>>>>>>>>            End
83599>>>>>>>>>>
83599>>>>>>>>>        End
83599>>>>>>>>>>
83599>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLGetArgument"
83601>>>>>>>>>
83601>>>>>>>>>        Function_Return sArgument
83602>>>>>>>>>    End_Function 
83603>>>>>>>>>
83603>>>>>>>>>
83603>>>>>>>>>
83603>>>>>>>>>    //***
83603>>>>>>>>>    //*** Function: SQLReturnValue
83603>>>>>>>>>    //*** Purpose : Get the return value of a stored function
83603>>>>>>>>>    //***
83603>>>>>>>>>
83603>>>>>>>>>    Function SQLReturnValue Returns String
83605>>>>>>>>>        Integer ihdbc
83605>>>>>>>>>        Integer ihstmt
83605>>>>>>>>>        String  sDrvrId
83605>>>>>>>>>        Integer iVoid
83605>>>>>>>>>        String  sEmpty
83605>>>>>>>>>        String  sRetval
83605>>>>>>>>>        Integer iLen
83605>>>>>>>>>
83605>>>>>>>>>        //*** Initialize
83605>>>>>>>>>        Move "" To sEmpty
83606>>>>>>>>>        Move "" To sRetval
83607>>>>>>>>>
83607>>>>>>>>>        //*** Get the cli handles
83607>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
83608>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83609>>>>>>>>>        Get psDriverId            to sDrvrId
83610>>>>>>>>>
83610>>>>>>>>>        //*** Call the procedure
83610>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
83612>>>>>>>>>            //*** Get the length
83612>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLGETPROCRETVALLEN ;                        Callback Self ;                        Passing ihdbc sEmpty ihstmt  ;                        Result iLen
83617>>>>>>>>>
83617>>>>>>>>>            If (iLen) Begin
83619>>>>>>>>>                //*** Allocate
83619>>>>>>>>>                Move (Repeat(' ', iLen)) To sRetval
83620>>>>>>>>>
83620>>>>>>>>>                //*** Pass the argument
83620>>>>>>>>>                Call_driver 0 sDrvrId Function FUNC_SQLGETPROCRETVAL ;                            Callback Self ;                            Passing ihdbc sRetval ihstmt ;                            Result iVoid
83625>>>>>>>>>            End
83625>>>>>>>>>>
83625>>>>>>>>>        End
83625>>>>>>>>>>
83625>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLReturnValue"
83627>>>>>>>>>
83627>>>>>>>>>        Function_Return sRetval
83628>>>>>>>>>    End_Function 
83629>>>>>>>>>
83629>>>>>>>>>
83629>>>>>>>>>
83629>>>>>>>>>    //***
83629>>>>>>>>>    //*** Function: SQLNextResultSet
83629>>>>>>>>>    //*** Purpose : Switch to the next set
83629>>>>>>>>>    //*** Returns : 0   = No more result sets
83629>>>>>>>>>    //***           <>0 = Switched to next set
83629>>>>>>>>>    //***
83629>>>>>>>>>
83629>>>>>>>>>    Function SQLNextResultSet Returns Integer
83631>>>>>>>>>        Integer ihdbc
83631>>>>>>>>>        Integer ihstmt
83631>>>>>>>>>        String  sDrvrId
83631>>>>>>>>>        Integer iResult
83631>>>>>>>>>        String  sEmpty
83631>>>>>>>>>
83631>>>>>>>>>        //*** Initialize
83631>>>>>>>>>        Move "" To sEmpty
83632>>>>>>>>>        Move 0  To iResult
83633>>>>>>>>>
83633>>>>>>>>>        //*** Get the cli handles
83633>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
83634>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83635>>>>>>>>>        Get psDriverId            to sDrvrId
83636>>>>>>>>>
83636>>>>>>>>>        //*** Call the procedure
83636>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
83638>>>>>>>>>            //*** Get the length
83638>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLNEXTRESULTSET ;                        Callback Self ;                        Passing ihdbc sEmpty ihstmt  ;                        Result iResult
83643>>>>>>>>>                        
83643>>>>>>>>>            Send SQLGetStatementAttributes
83644>>>>>>>>>            Set piLastArgument to 0
83645>>>>>>>>>        End
83645>>>>>>>>>>
83645>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLNextResultSet"
83647>>>>>>>>>
83647>>>>>>>>>        Function_Return iResult
83648>>>>>>>>>    End_Function
83649>>>>>>>>>
83649>>>>>>>>>
83649>>>>>>>>>
83649>>>>>>>>>    //***
83649>>>>>>>>>    //*** Procedure: SQLFetchActivatesBuffer
83649>>>>>>>>>    //*** Purpose  : Setup a file that will be acivated after a succesfull
83649>>>>>>>>>    //***            fetch on the statement
83649>>>>>>>>>    //***
83649>>>>>>>>>
83649>>>>>>>>>    Procedure SQLFetchActivatesBuffer Integer iFileNum Integer bState
83651>>>>>>>>>        Integer ihdbc
83651>>>>>>>>>        Integer ihstmt
83651>>>>>>>>>        String  sDrvrId
83651>>>>>>>>>        Integer iResult
83651>>>>>>>>>        Integer bIsOpen
83651>>>>>>>>>        Integer iVoid
83651>>>>>>>>>        String  sFileType
83651>>>>>>>>>
83651>>>>>>>>>        //*** Check if file is open
83651>>>>>>>>>        Get_attribute DF_FILE_OPENED Of iFileNum To bIsOpen
83654>>>>>>>>>        If (bIsOpen) Begin
83656>>>>>>>>>            //*** Get the cli handles
83656>>>>>>>>>            Get phCLIStatementHandle  to ihstmt
83657>>>>>>>>>            Get phCLIConnectionHandle to ihdbc
83658>>>>>>>>>            Get psDriverId            to sDrvrId
83659>>>>>>>>>
83659>>>>>>>>>            //*** Call the procedure
83659>>>>>>>>>            If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
83661>>>>>>>>>                //*** Check if the file has the correct type
83661>>>>>>>>>                Get_attribute DF_FILE_DRIVER Of iFileNum To sFileType
83664>>>>>>>>>                If (sFileType = sDrvrId) Begin
83666>>>>>>>>>                    //*** Setup the buffer
83666>>>>>>>>>                    Call_driver iFileNum sDrvrId Function FUNC_SQLBUFFERSTATUS ;                                Callback Self ;                                Passing ihdbc bState ihstmt  ;                                Result iVoid
83671>>>>>>>>>                End
83671>>>>>>>>>>
83671>>>>>>>>>                Else ;                    Send StmtError CLIERR_SQLINVALID_BIND_FILE ("File" * String(iFileNum) * "type incompatible with statement ("  + sFileType + ")") "SQLBindFile"
83673>>>>>>>>>            End
83673>>>>>>>>>>
83673>>>>>>>>>            Else ;                Send HandleError ihstmt ihdbc sDrvrId "SQLFetchActivatesBuffer"
83675>>>>>>>>>        End
83675>>>>>>>>>>
83675>>>>>>>>>        Else ;            Send StmtError CLIERR_SQLINVALID_BUFFER ("File not open (number =" * String(iFileNum) + ")") "SQLFetchActivatesBuffer"
83677>>>>>>>>>    End_Procedure 
83678>>>>>>>>>
83678>>>>>>>>>
83678>>>>>>>>>
83678>>>>>>>>>    Function SQLGetMessage Integer iMessageNum Returns String
83680>>>>>>>>>        Integer ihdbc
83680>>>>>>>>>        Integer ihstmt
83680>>>>>>>>>        String  sDrvrId
83680>>>>>>>>>        String  sMessage
83680>>>>>>>>>        Integer iVoid
83680>>>>>>>>>
83680>>>>>>>>>        //*** Initialize
83680>>>>>>>>>        Move "" To sMessage
83681>>>>>>>>>
83681>>>>>>>>>        //*** Get the cli handles
83681>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
83682>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83683>>>>>>>>>        Get psDriverId            to sDrvrId
83684>>>>>>>>>
83684>>>>>>>>>        //*** Call the procedure
83684>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
83686>>>>>>>>>            //*** Setup function arguments
83686>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                        Callback Self ;                        Passing ihdbc iMessageNum ihstmt ;                        Result iVoid
83691>>>>>>>>>
83691>>>>>>>>>            Move (Repeat(' ', 1024)) To sMessage
83692>>>>>>>>>            //*** Get the length
83692>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLGETMESSAGE ;                        Callback Self ;                        Passing iVoid sMessage iVoid ;                        Result iVoid
83697>>>>>>>>>        End
83697>>>>>>>>>>
83697>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLGetDiagRec"
83699>>>>>>>>>
83699>>>>>>>>>        Function_Return sMessage
83700>>>>>>>>>    End_Function 
83701>>>>>>>>>
83701>>>>>>>>>
83701>>>>>>>>>
83701>>>>>>>>>    //***
83701>>>>>>>>>    //*** Function: RemoveComponentIdentifier
83701>>>>>>>>>    //*** Purpose : Remove the component identifier from a diagnostic message
83701>>>>>>>>>    //***
83701>>>>>>>>>
83701>>>>>>>>>    Function RemoveComponentIdentifier String sDiagMessage Returns String
83703>>>>>>>>>        While (Left(sDiagMessage, 1) = "[")
83707>>>>>>>>>            Move (Right(sDiagMessage, Length(sDiagMessage) - Pos("]", sDiagMessage))) To sDiagMessage
83708>>>>>>>>>        End
83709>>>>>>>>>>
83709>>>>>>>>>
83709>>>>>>>>>        Function_Return sDiagMessage
83710>>>>>>>>>    End_Function
83711>>>>>>>>>
83711>>>>>>>>>
83711>>>>>>>>>
83711>>>>>>>>>    //***
83711>>>>>>>>>    //*** Function: DFDateToSQLDate
83711>>>>>>>>>    //*** Purpose : Convert a DataFlex date to a SQL Date. Use dummy zero dates.
83711>>>>>>>>>    //***
83711>>>>>>>>>    Function DFDateToSQLDate Date dDFDate Integer iSQLType Returns String
83713>>>>>>>>>        
83713>>>>>>>>>        Integer iType
83713>>>>>>>>>        String  sSQLDate
83713>>>>>>>>>        Integer iOrgDateFmt
83713>>>>>>>>>        Integer iOrgDateSep
83713>>>>>>>>>
83713>>>>>>>>>        String sDriverId
83713>>>>>>>>>        String sDummyZeroDate
83713>>>>>>>>>        String sDummyZeroDateMssqlDatetime
83713>>>>>>>>>
83713>>>>>>>>>        //*** Change date format to military, SQL dates are military dates
83713>>>>>>>>>        Get_Attribute DF_DATE_FORMAT to iOrgDateFmt
83716>>>>>>>>>        Get_Attribute DF_DATE_SEPARATOR to iOrgDateSep
83719>>>>>>>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_MILITARY
83722>>>>>>>>>        Set_Attribute DF_DATE_SEPARATOR to (Ascii('-'))
83725>>>>>>>>>
83725>>>>>>>>>        //*** We only need to convert if the date is 0
83725>>>>>>>>>        If (Integer(dDFDate = 0)) Begin
83727>>>>>>>>>
83727>>>>>>>>>            If (num_arguments < 2) Begin
83729>>>>>>>>>                Move SQL_TYPE_TIMESTAMP to iType
83730>>>>>>>>>            End
83730>>>>>>>>>>
83730>>>>>>>>>            Else Begin
83731>>>>>>>>>                Move iSQLType to iType
83732>>>>>>>>>            End
83732>>>>>>>>>>
83732>>>>>>>>>
83732>>>>>>>>>            
83732>>>>>>>>>            Get psDriverID to sDriverId
83733>>>>>>>>>            Get psDummyZeroDate to sDummyZeroDate
83734>>>>>>>>>                
83734>>>>>>>>>            If ( (iType = SQL_TYPE_TIMESTAMP) and (sDriverID = 'MSSQLDRV') ) Begin
83736>>>>>>>>>                Get psDummyZeroDateMssqlDatetime to sDummyZeroDateMssqlDatetime
83737>>>>>>>>>                Move sDummyZeroDateMssqlDatetime to sSQLDate
83738>>>>>>>>>            End
83738>>>>>>>>>>
83738>>>>>>>>>            Else Begin
83739>>>>>>>>>                Move sDummyZeroDate to sSQLDate
83740>>>>>>>>>            End
83740>>>>>>>>>>
83740>>>>>>>>>            
83740>>>>>>>>>            //CLI_Get_Driver_Attribute sDRiver DRVR_DUMMY_ZERO_DATE_VALUE to sSQLDate
83740>>>>>>>>>        End
83740>>>>>>>>>>
83740>>>>>>>>>        Else Begin
83741>>>>>>>>>            Move dDFDate to sSQLDate
83742>>>>>>>>>        End
83742>>>>>>>>>>
83742>>>>>>>>>
83742>>>>>>>>>        //*** Change date format back to original
83742>>>>>>>>>        Set_Attribute DF_DATE_FORMAT to iOrgDateFmt
83745>>>>>>>>>        Set_Attribute DF_DATE_SEPARATOR to iOrgDateSep
83748>>>>>>>>>
83748>>>>>>>>>        Function_Return sSQLDate
83749>>>>>>>>>    End_Function 
83750>>>>>>>>>
83750>>>>>>>>>
83750>>>>>>>>>    //***
83750>>>>>>>>>    //*** Function: SQLDateToDFDate
83750>>>>>>>>>    //*** Purpose : Convert a SQL date to a DataFlex Date. Use dummy zero dates.
83750>>>>>>>>>    //***
83750>>>>>>>>>    Function SQLDateToDFDate String sSQLDate Returns Date
83752>>>>>>>>>        
83752>>>>>>>>>        Integer iType
83752>>>>>>>>>        Date    dDFDate
83752>>>>>>>>>        Integer iOrgDateFmt
83752>>>>>>>>>        Integer iOrgDateSep
83752>>>>>>>>>        
83752>>>>>>>>>        String  sDriverId
83752>>>>>>>>>        String  sDummyZeroDate
83752>>>>>>>>>        String  sDummyZeroDateMssqlDatetime
83752>>>>>>>>>        
83752>>>>>>>>>        Get psDriverID to sDriverId
83753>>>>>>>>>        
83753>>>>>>>>>        Get psDummyZeroDate to sDummyZeroDate
83754>>>>>>>>>        Get psDummyZeroDateMssqlDatetime to sDummyZeroDateMssqlDatetime
83755>>>>>>>>>        
83755>>>>>>>>>        Get_Attribute DF_DATE_FORMAT to iOrgDateFmt
83758>>>>>>>>>        Get_Attribute DF_DATE_SEPARATOR to iOrgDateSep
83761>>>>>>>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_MILITARY
83764>>>>>>>>>        Set_Attribute DF_DATE_SEPARATOR to (Ascii('-'))
83767>>>>>>>>>        
83767>>>>>>>>>        Move (Left(sSQLDate,10)) to sSQLDate 
83768>>>>>>>>>
83768>>>>>>>>>        If ( (sSQLDate = sDummyZeroDate) or ;             ( (sDriverId = 'MSSQLDRV') and (sSQLDate = sDummyZeroDateMssqlDatetime) ) )  Begin
83770>>>>>>>>>            Move 0 to dDFDate
83771>>>>>>>>>        End
83771>>>>>>>>>>
83771>>>>>>>>>        Else Begin
83772>>>>>>>>>            Move sSQLDate to dDFDate
83773>>>>>>>>>        End
83773>>>>>>>>>>
83773>>>>>>>>>
83773>>>>>>>>>        //*** Change date format back to original
83773>>>>>>>>>        Set_Attribute DF_DATE_FORMAT to iOrgDateFmt
83776>>>>>>>>>        Set_Attribute DF_DATE_SEPARATOR to iOrgDateSep
83779>>>>>>>>>
83779>>>>>>>>>        Function_Return dDFDate
83780>>>>>>>>>    End_Function 
83781>>>>>>>>>
83781>>>>>>>>>End_Class 
83782>>>>>>>>>
83782>>>>>>>>>
83782>>>>>>>>>//*****************************************************************************
83782>>>>>>>>>//*** Class  : cSQLConnection                                               ***
83782>>>>>>>>>//*** Purpose: Connection object for embedded SQL                           ***
83782>>>>>>>>>//***                                                                       ***
83782>>>>>>>>>//*** Description:                                                          ***
83782>>>>>>>>>//***   This provides the ability to create a connection for a driver.      ***
83782>>>>>>>>>//***   It will contain child statement objects                             ***
83782>>>>>>>>>//*****************************************************************************
83782>>>>>>>>>
83782>>>>>>>>>Class cSQLConnection is a cObject
83783>>>>>>>>>
83783>>>>>>>>>    Procedure Construct_object 
83785>>>>>>>>>        Forward Send Construct_object 
83787>>>>>>>>>
83787>>>>>>>>>        Property Integer phCLIConnectionHandle       0
83788>>>>>>>>>        
83788>>>>>>>>>        Property String  psDriverID        ""
83789>>>>>>>>>        Property Integer piBindFile        0
83790>>>>>>>>>        
83790>>>>>>>>>        Property String psDummyZeroDate              '0001-01-01'
83791>>>>>>>>>        Property String psDummyZeroDateMssqlDatetime '1753-01-01'        
83792>>>>>>>>>
83792>>>>>>>>>    End_Procedure
83793>>>>>>>>>
83793>>>>>>>>>
83793>>>>>>>>>
83793>>>>>>>>>    //***
83793>>>>>>>>>    //*** Procedure: StoreConnectionInfo
83793>>>>>>>>>    //*** Purpose  : Store basic information about the connection
83793>>>>>>>>>    //***
83793>>>>>>>>>    Procedure StoreConnectionInfo Handle hCLIConnectionHandle String sDrvrId 
83795>>>>>>>>>        
83795>>>>>>>>>        String sDummyZeroDate
83795>>>>>>>>>        
83795>>>>>>>>>        Set phCLIConnectionHandle to hCLIConnectionHandle
83796>>>>>>>>>        Set psDriverID            to sDrvrId
83797>>>>>>>>>        
83797>>>>>>>>>        Case Begin
83797>>>>>>>>>            Case (sDrvrId = "MSSQLDRV")
83799>>>>>>>>>                Set psDummyZeroDate to '0001-01-01'
83800>>>>>>>>>                Set psDummyZeroDateMssqlDatetime to '1753-01-01'
83801>>>>>>>>>                Break
83802>>>>>>>>>            Case (sDrvrId = "DB2_DRV")
83805>>>>>>>>>                Set psDummyZeroDate to '0001-01-01'
83806>>>>>>>>>                Break
83807>>>>>>>>>            Case (sDrvrId = "ODBC_DRV")
83810>>>>>>>>>                CLI_Get_Driver_Attribute sDrvrId DRVR_DUMMY_ZERO_DATE_VALUE to sDummyZeroDate
83817>>>>>>>>>                Set psDummyZeroDate to sDummyZeroDate
83818>>>>>>>>>                Break
83819>>>>>>>>>        Case End
83819>>>>>>>>>        
83819>>>>>>>>>    End_Procedure 
83820>>>>>>>>>
83820>>>>>>>>>
83820>>>>>>>>>    //***
83820>>>>>>>>>    //*** Procedure: DestroySQLConnection
83820>>>>>>>>>    //*** Purpose : Destroy the SQLConnection object
83820>>>>>>>>>    //***
83820>>>>>>>>>    Procedure DestroySQLConnection
83822>>>>>>>>>        Send Destroy
83823>>>>>>>>>    End_Procedure 
83824>>>>>>>>>
83824>>>>>>>>>
83824>>>>>>>>>    //***
83824>>>>>>>>>    //*** Function: SQLConnect
83824>>>>>>>>>    //*** Purpose : Connect to a database server
83824>>>>>>>>>    //*** Returns : 1 Succesfully connected
83824>>>>>>>>>    //***           0 Not connected
83824>>>>>>>>>    Function SQLConnect String sDrvrID String sConnect Returns Integer
83826>>>>>>>>>        Integer ihdbc
83826>>>>>>>>>        String  sEmpty
83826>>>>>>>>>
83826>>>>>>>>>        //*** Initialize
83826>>>>>>>>>        Move "" To sEmpty
83827>>>>>>>>>        Move 0  To ihdbc
83828>>>>>>>>>
83828>>>>>>>>>        Indicate Err False
83829>>>>>>>>>
83829>>>>>>>>>        //*** Call the driver function to connect
83829>>>>>>>>>        Call_driver 0 sDrvrId Function FUNC_SQLCONNECT ;                    Callback Self ;                    Passing sConnect sEmpty Self ;                    Result ihdbc
83834>>>>>>>>>
83834>>>>>>>>>        //*** If there was an error, make result invalid
83834>>>>>>>>>        If (Err) ;            Move 0 To ihdbc
83837>>>>>>>>>
83837>>>>>>>>>        //*** Check result and store it
83837>>>>>>>>>        If (ihdbc <> 0) ;            Send StoreConnectionInfo ihdbc sDrvrId
83840>>>>>>>>>
83840>>>>>>>>>        //*** Return success status
83840>>>>>>>>>        Function_Return (ihdbc <> 0)
83841>>>>>>>>>    End_Function 
83842>>>>>>>>>
83842>>>>>>>>>
83842>>>>>>>>>
83842>>>>>>>>>    //***
83842>>>>>>>>>    //*** Function: SQLFileConnect
83842>>>>>>>>>    //*** Purpose : Use a connection of an already open file
83842>>>>>>>>>    //***
83842>>>>>>>>>    Function SQLFileConnect Integer iFileNum Returns Integer
83844>>>>>>>>>        Integer ihdbc
83844>>>>>>>>>        Integer bIsOpen
83844>>>>>>>>>        String  sDrvrId
83844>>>>>>>>>        String  sEmpty
83844>>>>>>>>>
83844>>>>>>>>>        //*** Initialize
83844>>>>>>>>>        Move "" To sEmpty
83845>>>>>>>>>        Move 0  To ihdbc
83846>>>>>>>>>
83846>>>>>>>>>        //*** Check if file is open
83846>>>>>>>>>        Get_attribute DF_FILE_OPENED Of iFileNum To bIsOpen
83849>>>>>>>>>        If (bIsOpen) Begin
83851>>>>>>>>>            //*** Fill the driver id, assume longest is 255 characters
83851>>>>>>>>>            Move (Repeat(' ', 255)) To sDrvrId
83852>>>>>>>>>            Get_attribute DF_FILE_DRIVER Of iFileNum To sDrvrId
83855>>>>>>>>>
83855>>>>>>>>>            Indicate Err False
83856>>>>>>>>>
83856>>>>>>>>>            //*** Call the driver function to connect
83856>>>>>>>>>            Call_driver iFileNum sDrvrId Function FUNC_SQLFILECONNECT ;                        Callback Self ;                        Passing sEmpty sEmpty 0 ;                        Result ihdbc
83861>>>>>>>>>
83861>>>>>>>>>            //*** If there was an error, make result invalid
83861>>>>>>>>>            If (Err) ;                Move 0 To ihdbc
83864>>>>>>>>>
83864>>>>>>>>>            //*** Check result and store it
83864>>>>>>>>>            If (ihdbc <> 0) Begin
83866>>>>>>>>>                //*** Somehow Call_driver overwrites the sDrvrId variable, restore it here
83866>>>>>>>>>                Get_attribute DF_FILE_DRIVER Of iFileNum To sDrvrId
83869>>>>>>>>>                Send StoreConnectionInfo ihdbc sDrvrId
83870>>>>>>>>>
83870>>>>>>>>>                //*** Set filenum so it can be used for fetching
83870>>>>>>>>>                Set piBindFile To iFileNum
83871>>>>>>>>>            End
83871>>>>>>>>>>
83871>>>>>>>>>        End
83871>>>>>>>>>>
83871>>>>>>>>>
83871>>>>>>>>>        //*** Return success status
83871>>>>>>>>>        Function_Return (ihdbc <> 0)
83872>>>>>>>>>    End_Function
83873>>>>>>>>>
83873>>>>>>>>>
83873>>>>>>>>>
83873>>>>>>>>>    //***
83873>>>>>>>>>    //*** Procedure: SQLDisconnect
83873>>>>>>>>>    //*** Purpose  : Disconnect from an embedded SQL server and free allocated
83873>>>>>>>>>    //***            resources
83873>>>>>>>>>    //***
83873>>>>>>>>>    Procedure SQLDisconnect
83875>>>>>>>>>        Integer ihdbc
83875>>>>>>>>>        Integer iVoid
83875>>>>>>>>>        String  sDrvrId
83875>>>>>>>>>        String  sEmpty
83875>>>>>>>>>
83875>>>>>>>>>        //*** Initialize
83875>>>>>>>>>        Move "" To sEmpty
83876>>>>>>>>>
83876>>>>>>>>>        //*** Get the cli handle
83876>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83877>>>>>>>>>        Get psDriverId To sDrvrId
83878>>>>>>>>>
83878>>>>>>>>>        //*** Free the CLI handle
83878>>>>>>>>>        If (ihdbc <> 0) Begin
83880>>>>>>>>>            //*** Call the driver function to disconnect
83880>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLDISCONNECT ;                        Callback Self ;                        Passing sEmpty sEmpty ihdbc ;                        Result iVoid
83885>>>>>>>>>
83885>>>>>>>>>            Move -1 to giLastSQLhdbc
83886>>>>>>>>>
83886>>>>>>>>>            //*** Free the DataFlex handle
83886>>>>>>>>>            Send DestroySQLConnection
83887>>>>>>>>>        End
83887>>>>>>>>>>
83887>>>>>>>>>    End_Procedure 
83888>>>>>>>>>
83888>>>>>>>>>
83888>>>>>>>>>
83888>>>>>>>>>    //***
83888>>>>>>>>>    //*** Function: CreateSQLStatement
83888>>>>>>>>>    //*** Purpose : Create a cSQLStatement object
83888>>>>>>>>>    //***
83888>>>>>>>>>    Function CreateSQLStatement Returns Handle
83890>>>>>>>>>        
83890>>>>>>>>>        Handle hoSQLStatement
83890>>>>>>>>>        Get Create (RefClass(cSQLStatement)) to hoSQLStatement
83891>>>>>>>>>        
83891>>>>>>>>>        //*** If the connection has a default Bind File, assign it to the
83891>>>>>>>>>        //*** statement object. The default is set when you open a file with a
83891>>>>>>>>>        //*** SetFileConnection command.
83891>>>>>>>>>        Set piBindFile of hoSQLStatement to (piBindFile(Self))
83892>>>>>>>>>        
83892>>>>>>>>>        Function_Return hoSQLStatement
83893>>>>>>>>>    End_Function 
83894>>>>>>>>>
83894>>>>>>>>>
83894>>>>>>>>>    //***
83894>>>>>>>>>    //*** Function: SQLOpen
83894>>>>>>>>>    //*** Prupose : Open a statement for use
83894>>>>>>>>>    //***
83894>>>>>>>>>    Function SQLOpen Returns Handle
83896>>>>>>>>>        Handle  hoSQLStatement
83896>>>>>>>>>        Integer ihdbc
83896>>>>>>>>>        Integer ihstmt
83896>>>>>>>>>        Integer iVoid
83896>>>>>>>>>        String  sDrvrId
83896>>>>>>>>>        String  sEmpty
83896>>>>>>>>>        String  sDummyZeroDate
83896>>>>>>>>>        String  sDummyZeroDateMssqlDatetime 
83896>>>>>>>>>
83896>>>>>>>>>        //*** Initialize
83896>>>>>>>>>        Move "" To sEmpty
83897>>>>>>>>>
83897>>>>>>>>>        //*** Get the cli handle to the connection
83897>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83898>>>>>>>>>        Get psDriverId  To sDrvrId
83899>>>>>>>>>
83899>>>>>>>>>        //*** Allocate a new handle and populate it
83899>>>>>>>>>        If (ihdbc <> 0) Begin
83901>>>>>>>>>            //**** Create a new cSQLStatement object
83901>>>>>>>>>            Get CreateSQLStatement to hoSQLStatement
83902>>>>>>>>>
83902>>>>>>>>>            //*** Call the driver function to allocate a cli statement handle
83902>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLOPEN ;                        Callback Self ;                        Passing hoSQLStatement sEmpty ihdbc ;                        Result ihstmt
83907>>>>>>>>>
83907>>>>>>>>>            //*** If unsuccessful destroy hoSQLStatement
83907>>>>>>>>>            If (ihstmt = 0) Begin
83909>>>>>>>>>                Send DestroySQLStatement of hoSQLStatement
83910>>>>>>>>>                Move 0 to hoSQLStatement
83911>>>>>>>>>            End
83911>>>>>>>>>>
83911>>>>>>>>>            Else Begin
83912>>>>>>>>>                Send StoreStatementInfo of hoSQLStatement ihstmt sDrvrId ihdbc
83913>>>>>>>>>
83913>>>>>>>>>                // Store DummyZeroDate of hoSQLConnection in hoSQLStatement
83913>>>>>>>>>                Get psDummyZeroDate              to sDummyZeroDate
83914>>>>>>>>>                Get psDummyZeroDateMssqlDatetime to sDummyZeroDateMssqlDatetime
83915>>>>>>>>>                
83915>>>>>>>>>                Set psDummyZeroDate              of hoSQLStatement to sDummyZeroDate
83916>>>>>>>>>                Set psDummyZeroDateMssqlDatetime of hoSQLStatement to sDummyZeroDateMssqlDatetime
83917>>>>>>>>>                
83917>>>>>>>>>            End
83917>>>>>>>>>>
83917>>>>>>>>>        End
83917>>>>>>>>>>
83917>>>>>>>>>
83917>>>>>>>>>        Function_Return hoSQLStatement
83918>>>>>>>>>    End_Function 
83919>>>>>>>>>
83919>>>>>>>>>End_Class 
83920>>>>>>>>>
83920>>>>>>>>>
83920>>>>>>>>>
83920>>>>>>>>>//*****************************************************************************
83920>>>>>>>>>//*** Class  : cSQLHandlemanager                                            ***
83920>>>>>>>>>//*** Purpose: Manager for embedded SQL handles.                            ***
83920>>>>>>>>>//***                                                                       ***
83920>>>>>>>>>//*** Description:                                                          ***
83920>>>>>>>>>//***   We want to be able to use multiple drivers and multiple             ***
83920>>>>>>>>>//***   connections within a driver and multiple statements within a        ***
83920>>>>>>>>>//***   connection. To allow this we have placed our own handle logic on    ***
83920>>>>>>>>>//***   top of the driver handle logic. This way we can handle the          ***
83920>>>>>>>>>//***   situation where two driver handles may be equal.                    ***
83920>>>>>>>>>//*****************************************************************************
83920>>>>>>>>>
83920>>>>>>>>>Class cSQLHandleManager is a cObject
83921>>>>>>>>>
83921>>>>>>>>>    Procedure Construct_object 
83923>>>>>>>>>        Forward Send Construct_object 
83925>>>>>>>>>
83925>>>>>>>>>        Property String  psDefaultDriver      ""
83926>>>>>>>>>        Property String  psDefaultConnection  ""
83927>>>>>>>>>
83927>>>>>>>>>    End_Procedure 
83928>>>>>>>>>
83928>>>>>>>>>    //***
83928>>>>>>>>>    //*** Function: CreateSQLConnection
83928>>>>>>>>>    //*** Purpose : Create a cSQLConnection object
83928>>>>>>>>>    //***
83928>>>>>>>>>    Function CreateSQLConnection Returns Handle
83930>>>>>>>>>        Handle hoSQLConnection
83930>>>>>>>>>        Get Create (RefClass(cSQLConnection)) to hoSQLConnection
83931>>>>>>>>>        Function_Return hoSQLConnection
83932>>>>>>>>>    End_Function 
83933>>>>>>>>>
83933>>>>>>>>>
83933>>>>>>>>>    //***
83933>>>>>>>>>    //*** Procedure: SQLSetConnect
83933>>>>>>>>>    //*** Purpose  : Store default connection information
83933>>>>>>>>>    //***
83933>>>>>>>>>
83933>>>>>>>>>    Procedure SQLSetConnect String sDriver String sConnect
83935>>>>>>>>>        Set psDefaultDriver      To sDriver
83936>>>>>>>>>        Set psDefaultConnection  To sConnect
83937>>>>>>>>>    End_Procedure 
83938>>>>>>>>>
83938>>>>>>>>>
83938>>>>>>>>>
83938>>>>>>>>>    //***
83938>>>>>>>>>    //*** Function: SQLConnect
83938>>>>>>>>>    //*** Purpose : Make a connection to an embedded SQL server
83938>>>>>>>>>    //*** Returns : The DataFlex handle to the connection
83938>>>>>>>>>    //***
83938>>>>>>>>>    Function SQLConnect String sDrvrID String sConnect Returns integer
83940>>>>>>>>>        Handle hoSQLConnection
83940>>>>>>>>>        Integer bOK
83940>>>>>>>>>
83940>>>>>>>>>        //*** Check arguments
83940>>>>>>>>>        If (sDrvrID = "" And sConnect = "") Begin
83942>>>>>>>>>            Get psDefaultDriver      To sDrvrId
83943>>>>>>>>>            Get psDefaultConnection  To sConnect
83944>>>>>>>>>        End
83944>>>>>>>>>>
83944>>>>>>>>>
83944>>>>>>>>>        //*** Create a cSQLConnection object
83944>>>>>>>>>        Get CreateSQLConnection to hoSQLConnection
83945>>>>>>>>>        //*** Connect to the database 
83945>>>>>>>>>        Get SQLConnect of hoSQLConnection sDrvrID sConnect to bOK
83946>>>>>>>>>
83946>>>>>>>>>        //*** If connection to the database failed, destroy the cSQLConnection object and return a 0 handle
83946>>>>>>>>>        If (not(bOK)) Begin
83948>>>>>>>>>            Send DestroySQLConnection of hoSQLConnection
83949>>>>>>>>>            Move 0 to hoSQLConnection
83950>>>>>>>>>        End
83950>>>>>>>>>>
83950>>>>>>>>>
83950>>>>>>>>>        Function_Return hoSQLConnection
83951>>>>>>>>>    End_Function 
83952>>>>>>>>>
83952>>>>>>>>>
83952>>>>>>>>>
83952>>>>>>>>>    //***
83952>>>>>>>>>    //*** Function: SQLFileConnect
83952>>>>>>>>>    //*** Purpose : Make an existing connection available for use with Embedded SQL.
83952>>>>>>>>>    //***           The connection is identified by the number of a file
83952>>>>>>>>>    //***           that is open for that connection.
83952>>>>>>>>>    //***
83952>>>>>>>>>
83952>>>>>>>>>    Function SQLFileConnect Integer iFileNum Returns Handle
83954>>>>>>>>>        Handle hoSQLConnection
83954>>>>>>>>>        Integer bOK
83954>>>>>>>>>
83954>>>>>>>>>        //*** Create a cSQLConnection object
83954>>>>>>>>>        Get CreateSQLConnection to hoSQLConnection
83955>>>>>>>>>        Get SQLFileConnect of hoSQLConnection iFileNum To bOK
83956>>>>>>>>>
83956>>>>>>>>>        //*** If connection to the database failed, destroy the cSQLConnection object and return a 0 handle
83956>>>>>>>>>        If (not(bOK)) Begin
83958>>>>>>>>>            Send DestroySQLConnection of hoSQLConnection
83959>>>>>>>>>            Move 0 to hoSQLConnection
83960>>>>>>>>>        End
83960>>>>>>>>>>
83960>>>>>>>>>
83960>>>>>>>>>        Function_Return hoSQLConnection
83961>>>>>>>>>    End_Function 
83962>>>>>>>>>
83962>>>>>>>>>End_Class 
83963>>>>>>>>>
83963>>>>>>>
83963>>>>>>>// defines interface for cWindowMesageHook - currently a private runtime class
83963>>>>>>>Define     U_DFWINDOWSMESSAGEHOOK  for |CI0106
83963>>>>>>>Define     GET_ENABLEWINDOWSHOOK   for |CI$0542
83963>>>>>>>Define     MSG_DISABLEWINDOWSHOOK  for |CI$0543
83963>>>>>>>Define     GET_ONWINDOWSHOOK       for |CI$0544
83963>>>>>>>Define     WH_MOUSE for 7
83963>>>>>>>Define     WH_KEYBOARD for 2
83963>>>>>>>
83963>>>>>>>
83963>>>>>>>// suggestion lists use a global timer and a global suggestion list
83963>>>>>>>Global_Variable Handle ghoSuggestionList 
83963>>>>>>>Move 0 to ghoSuggestionList
83964>>>>>>>
83964>>>>>>>Global_Variable Handle ghoSuggestionTimer
83964>>>>>>>Move 0 to ghoSuggestionTimer
83965>>>>>>>
83965>>>>>>>// this will get created the first time it is needed. 
83965>>>>>>>Class cSuggestionTimer is a cTimer
83966>>>>>>>
83966>>>>>>>    Procedure Construct_Object
83968>>>>>>>        Forward Send Construct_Object
83970>>>>>>>        Property Handle phoTimerOwner 0
83971>>>>>>>        Set piTimeout to 50
83972>>>>>>>    End_Procedure
83973>>>>>>>  
83973>>>>>>>    Procedure OnTimer 
83975>>>>>>>        Handle hoOwner
83975>>>>>>>        Get phoTimerOwner to hoOwner
83976>>>>>>>        // do this in case progam close destroys owner before timer
83976>>>>>>>        Get Object_Id of hoOwner to hoOwner
83977>>>>>>>        If hoOwner Begin
83979>>>>>>>            Send OnSuggestionTimer to hoOwner
83980>>>>>>>        End
83980>>>>>>>>
83980>>>>>>>        Else Begin
83981>>>>>>>            // something wrong, shut off timer
83981>>>>>>>            Set pbEnabled to False   
83982>>>>>>>        End                                
83982>>>>>>>>
83982>>>>>>>    End_Procedure
83983>>>>>>>    
83983>>>>>>>End_Class
83984>>>>>>>
83984>>>>>>>Class cSuggestionHookMouse is a DFWindowsMessageHook
83985>>>>>>>    
83985>>>>>>>    // If mouse not in suggestion list or form, close suggestionlist
83985>>>>>>>    Function OnWindowsHook Integer i1 Integer i2 Integer i3 Returns Integer
83987>>>>>>>        tWinMouseHookStruct MouseHook
83987>>>>>>>        tWinMouseHookStruct MouseHook
83987>>>>>>>        Integer ivoid hObj
83987>>>>>>>        Handle hoOwner hoParent
83987>>>>>>>        If (i1=0 and (i2=WM_LBUTTONDOWN or i2=WM_RBUTTONDOWN or i2=WM_MBUTTONDOWN or ;                      i2=WM_NCLBUTTONDOWN or i2=WM_NCRBUTTONDOWN or i2=WM_NCMBUTTONDOWN)) Begin
83989>>>>>>>            Move (CopyMemory(AddressOf(MouseHook), i3, SizeOfType(tWinMouseHookStruct))) to iVoid
83990>>>>>>>            GET_OBJECT_FROM_WINDOW MouseHook.hwnd to hObj
83991>>>>>>>            Get Parent to hoParent
83992>>>>>>>            Get phoOwner of hoParent to hoOwner
83993>>>>>>>            If (not(hObj) or (hObj<>hoParent and hObj<>hoOwner)) Begin
83995>>>>>>>                Send DisableWindowsHook
83996>>>>>>>                Send DeActivateSuggestionList of hoOwner
83997>>>>>>>            End
83997>>>>>>>>
83997>>>>>>>        End
83997>>>>>>>>
83997>>>>>>>    End_Function
83998>>>>>>>
83998>>>>>>>    Procedure End_Construct_Object
84000>>>>>>>        Boolean bOk
84000>>>>>>>        Forward Send End_Construct_Object
84002>>>>>>>        Get EnableWindowsHook WH_MOUSE to bOk 
84003>>>>>>>    End_Procedure
84004>>>>>>>
84004>>>>>>>End_Class
84005>>>>>>>
84005>>>>>>>Class cSuggestionHookKbd is a DFWindowsMessageHook
84006>>>>>>>    
84006>>>>>>>    // If menu key, close suggestionlist
84006>>>>>>>    Function OnWindowsHook Integer i1 Integer i2 Integer i3 Returns Integer
84008>>>>>>>        Handle hoOwner
84008>>>>>>>        If (i1=0 and i2=VK_MENU) Begin
84010>>>>>>>            Delegate Get phoOwner to hoOwner
84012>>>>>>>            Send DisableWindowsHook
84013>>>>>>>            Send DeActivateSuggestionList of hoOwner
84014>>>>>>>        End
84014>>>>>>>>
84014>>>>>>>    End_Function
84015>>>>>>>    
84015>>>>>>>    Procedure End_Construct_Object
84017>>>>>>>        Boolean bOk
84017>>>>>>>        Forward Send End_Construct_Object
84019>>>>>>>        Get EnableWindowsHook WH_KEYBOARD  to bOk  
84020>>>>>>>    End_Procedure
84021>>>>>>>
84021>>>>>>>End_Class
84022>>>>>>>
84022>>>>>>>Class cSuggestionList is a cRichEdit
84023>>>>>>>    
84023>>>>>>>    Procedure Construct_Object
84025>>>>>>>        Handle hoObj
84025>>>>>>>        Forward Send Construct_Object
84027>>>>>>>        Property Handle phoOwner
84028>>>>>>>        Set Focus_Mode to NonFocusable
84029>>>>>>>        Set Attach_Parent_State to True
84030>>>>>>>        Set pbWrap to False
84031>>>>>>>        If (ghoSuggestionList) Begin
84033>>>>>>>            Send Destroy of ghoSuggestionList
84034>>>>>>>        End
84034>>>>>>>>
84034>>>>>>>        Get CreateNamed (RefClass(cSuggestionHookMouse)) "oMouseHook" to hoObj
84035>>>>>>>        Get CreateNamed (RefClass(cSuggestionHookKbd))"oKbdHook" to hoObj
84036>>>>>>>    End_Procedure
84037>>>>>>>    
84037>>>>>>>    Procedure Destroy_Object
84039>>>>>>>        Forward Send Destroy_Object
84041>>>>>>>        Move 0 to ghoSuggestionList
84042>>>>>>>    End_Procedure
84043>>>>>>>    
84043>>>>>>>    Procedure DeactivateList
84045>>>>>>>        Set pbEnabled of ghoSuggestionTimer to False
84046>>>>>>>        Send Deactivate
84047>>>>>>>        Send Destroy
84048>>>>>>>    End_Procedure
84049>>>>>>>    
84049>>>>>>>    Procedure InitList Handle hoForm
84051>>>>>>>        Integer iSize iLoc iLoc2
84051>>>>>>>        Get GuiSize of hoForm to iSize
84052>>>>>>>        Set GuiSize to (Hi(iSize)) (1000)
84053>>>>>>>        Get Absolute_GUIOrigin of hoForm to iLoc
84054>>>>>>>        Delegate Get Absolute_GUIOrigin to iLoc2
84056>>>>>>>        Set GuiLocation to (Hi(iLoc)-Hi(iLoc2)+Hi(iSize)+2) (Low(iLoc)+2-Low(iLoc2))
84057>>>>>>>        Set Visible_State to False
84058>>>>>>>    End_Procedure
84059>>>>>>>    
84059>>>>>>>    // scroll up one line
84059>>>>>>>    Procedure ScrollUp
84061>>>>>>>        Integer iLine
84061>>>>>>>        Get SelectedRow to iLine
84062>>>>>>>        If (iLine) Begin
84064>>>>>>>            Send SelectRow (iLine-1)
84065>>>>>>>        End
84065>>>>>>>>
84065>>>>>>>    End_Procedure
84066>>>>>>>    
84066>>>>>>>    // scroll down one line
84066>>>>>>>    Procedure ScrollDown
84068>>>>>>>        Integer iLine iLines
84068>>>>>>>        Get Line_Count to iLines
84069>>>>>>>        Get SelectedRow to iLine
84070>>>>>>>        // there can be an extra line at the end
84070>>>>>>>        If (iLine<iLines-1) Begin
84072>>>>>>>            Send SelectRow (iLine+1)
84073>>>>>>>        End
84073>>>>>>>>
84073>>>>>>>    End_Procedure
84074>>>>>>>    
84074>>>>>>>    // sets the current line to iLine and highlights it
84074>>>>>>>    Procedure SelectRow Integer iLine
84076>>>>>>>        Integer iPos iLen
84076>>>>>>>        Get FirstCharInLinePos iLine to iPos
84077>>>>>>>        Get LineLength iLine to iLen
84078>>>>>>>        Send SetSel iPos (iPos+iLen)
84079>>>>>>>    End_Procedure
84080>>>>>>>    
84080>>>>>>>    // get the current selected Line
84080>>>>>>>    Function SelectedRow Returns Integer
84082>>>>>>>        Integer iLine
84082>>>>>>>        Get LineFromChar -1 to iLine
84083>>>>>>>        Function_Return iLine
84084>>>>>>>    End_Function
84085>>>>>>>
84085>>>>>>>    // select the current row 
84085>>>>>>>    Procedure Mouse_Up Integer hCell Integer iPos
84087>>>>>>>        Handle hoObj
84087>>>>>>>        Get phoOwner to hoObj
84088>>>>>>>        Send Activate of hoObj // move focus to owner, which will close the list
84089>>>>>>>        Send SelectSuggestion of hoObj
84090>>>>>>>    End_Procedure // Mouse_Up
84091>>>>>>>      
84091>>>>>>>End_Class
84092>>>>>>>
84092>>>>>>>// This contains mixin support for suggestion logic and contains the interface that
84092>>>>>>>// is accessed publicly. This should be mixed into the form or column DEO object
84092>>>>>>>Class cSuggestion_mixin is a Mixin
84093>>>>>>>    
84093>>>>>>>    Procedure Define_cSuggestion_mixin
84095>>>>>>>        
84095>>>>>>>        Property Integer peSuggestionMode smFind
84096>>>>>>>        Property Boolean pbFullText False
84097>>>>>>>        Property Boolean pbCaseSensitive False
84098>>>>>>>        Property Integer piMaxResults 15
84099>>>>>>>        Property Integer piStartAtChar 2
84100>>>>>>>        Property Boolean pbFullWidth True
84101>>>>>>>        Property Integer piFindIndex 0
84102>>>>>>>        Property Boolean pbFindOnSelect True
84103>>>>>>>        Property Integer piPopupTimeout 50
84104>>>>>>>        
84104>>>>>>>        Property tSuggestion[] pSearchResults
84105>>>>>>>
84105>>>>>>>        Property Handle phcSuggestionListClass (RefClass(cSuggestionList))
84106>>>>>>>        
84106>>>>>>>    End_Procedure
84107>>>>>>>    
84107>>>>>>>    // Display one Suggestion Line in Suggestion List. Good for augmentation although
84107>>>>>>>    // this must be done carefully as you must know the suggestionlist interface, which
84107>>>>>>>    // if private
84107>>>>>>>    Procedure ShowSuggestion tSuggestion SuggestionData String sSearch
84109>>>>>>>        Integer i iCols iPos
84109>>>>>>>        String sValue
84109>>>>>>>        Integer eSuggestionMode
84109>>>>>>>        Boolean bFullText
84109>>>>>>>        
84109>>>>>>>        Get peSuggestionMode to eSuggestionMode
84110>>>>>>>        Get pbFullText to bFullText
84111>>>>>>>        
84111>>>>>>>        Move SuggestionData.aValues[0] to sValue
84112>>>>>>>        If (not(bFullText)) Begin
84114>>>>>>>            Set pbBold of ghoSuggestionList to True
84115>>>>>>>            Send AppendText of ghoSuggestionList (Left(sValue,Length(sSearch))) 
84116>>>>>>>            Set pbBold of ghoSuggestionList to False
84117>>>>>>>            Send AppendText of ghoSuggestionList (Mid(sValue,255,Length(sSearch)+1)) 
84118>>>>>>>        End
84118>>>>>>>>
84118>>>>>>>        Else Begin
84119>>>>>>>            Set pbBold of ghoSuggestionList to False
84120>>>>>>>            Move (Pos(Uppercase(sSearch),Uppercase(sValue))) to iPos
84121>>>>>>>            If (iPos) Begin
84123>>>>>>>                Send AppendText of ghoSuggestionList (Left(sValue,iPos-1)) 
84124>>>>>>>                Set pbBold of ghoSuggestionList to True
84125>>>>>>>                Send AppendText of ghoSuggestionList (Mid(sValue,Length(sSearch),iPos)) 
84126>>>>>>>                Set pbBold of ghoSuggestionList to False
84127>>>>>>>            End
84127>>>>>>>>
84127>>>>>>>            Send AppendText of ghoSuggestionList (Mid(sValue,255,iPos+Length(sSearch))) 
84128>>>>>>>        End
84128>>>>>>>>
84128>>>>>>>        
84128>>>>>>>        // if addiitonal columns (usually validation) we assume the first value is the one that is
84128>>>>>>>        // matched and we display all other values (usually just one) to the
84128>>>>>>>        // right of it. 
84128>>>>>>>        Move (SizeOfArray(SuggestionData.aValues)) to iCols
84129>>>>>>>        If (iCols>1) Begin
84131>>>>>>>            Move "" to sValue
84132>>>>>>>            For i from 1 to (iCols-1)
84138>>>>>>>>
84138>>>>>>>                Move (sValue + If(i=1," - ","  ") + SuggestionData.aValues[i]) to sValue
84139>>>>>>>            Loop
84140>>>>>>>>
84140>>>>>>>            Send AppendText of ghoSuggestionList sValue
84141>>>>>>>        End
84141>>>>>>>>
84141>>>>>>>    End_Procedure
84142>>>>>>>    
84142>>>>>>>    // used to catch a set_field_value_Error
84142>>>>>>>    Procedure Error_Report Integer iError Integer iLine String sErr
84144>>>>>>>    End_Procedure
84145>>>>>>>    
84145>>>>>>>    // does a Set_Field_Value with error testing around it.
84145>>>>>>>    Function SafeSetFieldValue Integer iFile Integer iField String sValue Returns Boolean
84147>>>>>>>        Handle hoOldError
84147>>>>>>>        Boolean bErr
84147>>>>>>>        Move Error_Object_Id to hoOldError
84148>>>>>>>        Move Self to Error_Object_Id
84149>>>>>>>        Move False to Err 
84150>>>>>>>        Set_Field_Value iFile iField to sValue
84153>>>>>>>        Move Err to bErr
84154>>>>>>>        Move hoOldError to Error_Object_Id
84155>>>>>>>        Function_Return bErr        
84156>>>>>>>    End_Function
84157>>>>>>>
84157>>>>>>>
84157>>>>>>>    Procedure SuggestionsFindIncremental String sSearch tSuggestion[] ByRef aSuggestions
84159>>>>>>>        Integer iFile iField iIndex iLen iRow iMax eType iLength iDec
84159>>>>>>>        Handle hoServer
84159>>>>>>>        Boolean bContinue bCase bOldRelate bNeedsRelate bInvalid
84159>>>>>>>        String sVal sLowSearch
84159>>>>>>>        RowID riTest
84159>>>>>>>        
84159>>>>>>>        Get Server to hoServer
84160>>>>>>>        Get Data_File  to iFile
84161>>>>>>>        Get Data_Field to iField       
84162>>>>>>>        
84162>>>>>>>        If ((hoServer <> 0) and (iFile <> 0)) Begin
84164>>>>>>>            Get piFindIndex to iIndex
84165>>>>>>>            Get piMaxResults to iMax
84166>>>>>>>            Get pbCaseSensitive to bCase
84167>>>>>>>            
84167>>>>>>>            Get_Attribute DF_FIELD_TYPE of iFile iField to eType
84170>>>>>>>            Get_Attribute DF_FIELD_LENGTH of iFile iField to iLength
84173>>>>>>>            Get_Attribute DF_FIELD_PRECISION of iFile iField to iDec
84176>>>>>>>            
84176>>>>>>>            Move (iLength - iDec) to iLength
84177>>>>>>>            
84177>>>>>>>            If (iIndex <= 0) Begin
84179>>>>>>>                Get_Attribute DF_FIELD_INDEX of iFile iField to iIndex
84182>>>>>>>            End
84182>>>>>>>>
84182>>>>>>>            
84182>>>>>>>            
84182>>>>>>>            
84182>>>>>>>            If (iIndex > 0) Begin
84184>>>>>>>                Get No_Relate_State of hoServer to bOldRelate
84185>>>>>>>                Get DDOConstraintNeedsRelate of hoServer iIndex to bNeedsRelate
84186>>>>>>>                Set No_Relate_State of hoServer to (not(bNeedsRelate))
84187>>>>>>>                                
84187>>>>>>>                Move True to bContinue
84188>>>>>>>                Move (Length(sSearch)) to iLen
84189>>>>>>>                Move (Lowercase(sSearch)) to sLowSearch
84190>>>>>>>                Move 0 to iRow
84191>>>>>>>                
84191>>>>>>>                //  Find first record
84191>>>>>>>                Send Request_Read of hoServer FIRST_RECORD iFile iIndex
84192>>>>>>>                Get SafeSetFieldValue iFile iField sSearch to bInvalid
84193>>>>>>>                If bInvalid Begin
84195>>>>>>>                    Move False to bContinue
84196>>>>>>>                End
84196>>>>>>>>
84196>>>>>>>                
84196>>>>>>>                If (bContinue) Begin
84198>>>>>>>                    Send Request_Read of hoServer GE iFile iIndex
84199>>>>>>>                End
84199>>>>>>>>
84199>>>>>>>                
84199>>>>>>>                While (Found and bContinue)
84203>>>>>>>                    Get_Field_Value iFile iField to sVal
84206>>>>>>>                    
84206>>>>>>>                    If ((not(bCase) and Lowercase(Left(sVal, iLen)) = sLowSearch) or (bCase and Left(sVal, iLen) = sSearch)) Begin
84208>>>>>>>
84208>>>>>>>                        Move (SerializeRowID(GetRowID(iFile)))  to aSuggestions[iRow].sRowId
84209>>>>>>>                        Move (Trim(sVal))                       to aSuggestions[iRow].aValues[0]
84210>>>>>>>                        Increment iRow
84211>>>>>>>                        
84211>>>>>>>                        Move (iRow < iMax) to bContinue
84212>>>>>>>                       
84212>>>>>>>                        Send Request_Read of hoServer GT iFile iIndex  
84213>>>>>>>                    End
84213>>>>>>>>
84213>>>>>>>                    Else Begin
84214>>>>>>>                        If (eType = DF_BCD and Length(sSearch) < iLength) Begin
84216>>>>>>>                            //  For numeric fields we'll jump in the index to the next possible value (for example from 40 to 400)
84216>>>>>>>                            
84216>>>>>>>                            Move (GetRowID(iFile)) to riTest
84217>>>>>>>                            
84217>>>>>>>                            Move (sSearch * 10) to sSearch
84218>>>>>>>                            
84218>>>>>>>                            Get SafeSetFieldValue iFile iField sSearch to bInvalid
84219>>>>>>>                            If bInvalid Begin
84221>>>>>>>                                Move False to bContinue
84222>>>>>>>                            End
84222>>>>>>>>
84222>>>>>>>                            Else Begin
84223>>>>>>>                                Send Request_Read of hoServer GE iFile iIndex
84224>>>>>>>                                Move (not(IsSameRowID(riTest, GetRowID(iFile)))) to bContinue
84225>>>>>>>                            End 
84225>>>>>>>>
84225>>>>>>>                        End
84225>>>>>>>>
84225>>>>>>>                        Else Begin
84226>>>>>>>                            Move False to bContinue
84227>>>>>>>                        End
84227>>>>>>>>
84227>>>>>>>                    End
84227>>>>>>>>
84227>>>>>>>                    
84227>>>>>>>                Loop
84228>>>>>>>>
84228>>>>>>>                Set No_Relate_State of hoServer to bOldRelate
84229>>>>>>>            End
84229>>>>>>>>
84229>>>>>>>        End
84229>>>>>>>>
84229>>>>>>>    End_Procedure
84230>>>>>>>    
84230>>>>>>>    Procedure SuggestionsFindFullText String sSearch tSuggestion[] ByRef aSuggestions
84232>>>>>>>        Integer iFile iField iIndex iRow iMax
84232>>>>>>>        Handle hoServer
84232>>>>>>>        Boolean bContinue bCase  bOldRelate bNeedsRelate
84232>>>>>>>        String sVal sLowSearch
84232>>>>>>>        
84232>>>>>>>        Get Server to hoServer
84233>>>>>>>        Get Data_File  to iFile
84234>>>>>>>        Get Data_Field to iField       
84235>>>>>>>        
84235>>>>>>>        If ((hoServer <> 0) and (iFile <> 0)) Begin
84237>>>>>>>            Get piMaxResults to iMax
84238>>>>>>>            Get pbCaseSensitive to bCase
84239>>>>>>>            
84239>>>>>>>            Get piFindIndex to iIndex
84240>>>>>>>            If (iIndex <= 0) Begin
84242>>>>>>>                Get_Attribute DF_FIELD_INDEX of iFile iField to iIndex
84245>>>>>>>            End
84245>>>>>>>>
84245>>>>>>>            
84245>>>>>>>            Get No_Relate_State of hoServer to bOldRelate
84246>>>>>>>            Get DDOConstraintNeedsRelate of hoServer iIndex to bNeedsRelate
84247>>>>>>>            Set No_Relate_State of hoServer to (not(bNeedsRelate))
84248>>>>>>>            
84248>>>>>>>            
84248>>>>>>>            Move (Lowercase(sSearch)) to sLowSearch
84249>>>>>>>            Move True to bContinue
84250>>>>>>>            Move 0 to iRow
84251>>>>>>>                
84251>>>>>>>            //  Find first record
84251>>>>>>>            Send Request_Read of hoServer FIRST_RECORD iFile iIndex
84252>>>>>>>            
84252>>>>>>>            While (Found and (iRow < iMax))
84256>>>>>>>                Get_Field_Value iFile iField to sVal
84259>>>>>>>                
84259>>>>>>>                If ((bCase and sVal contains sSearch) or (not(bCase) and Lowercase(sVal) contains sLowSearch)) Begin
84261>>>>>>>                    Move (SerializeRowID(GetRowID(iFile)))  to aSuggestions[iRow].sRowId
84262>>>>>>>                    Move (Trim(sVal))                       to aSuggestions[iRow].aValues[0]
84263>>>>>>>                    Increment iRow
84264>>>>>>>                End
84264>>>>>>>>
84264>>>>>>>                
84264>>>>>>>                Send Request_Read of hoServer GT iFile iIndex 
84265>>>>>>>            Loop
84266>>>>>>>>
84266>>>>>>>            Set No_Relate_State of hoServer to bOldRelate
84267>>>>>>>        End
84267>>>>>>>>
84267>>>>>>>    End_Procedure
84268>>>>>>>    
84268>>>>>>>    Procedure SuggestionsSQLFullText String sSearch tSuggestion[] ByRef aSuggestions
84270>>>>>>>        Integer iFile iField iIndex iRow iMax
84270>>>>>>>        Handle hoServer
84270>>>>>>>        Boolean bContinue bOrigActive  bOldRelate bNeedsRelate
84270>>>>>>>        String sVal sOrigFilter sFilter sFile sField
84270>>>>>>>        
84270>>>>>>>        Get Server to hoServer
84271>>>>>>>        Get Data_File  to iFile
84272>>>>>>>        Get Data_Field to iField       
84273>>>>>>>        
84273>>>>>>>        If ((hoServer <> 0) and (iFile <> 0)) Begin
84275>>>>>>>            
84275>>>>>>>            // make sure we send DD messages to owner DDO
84275>>>>>>>            Get Which_Data_Set of hoServer iFile to hoServer
84276>>>>>>>            If (hoServer=0) Begin
84278>>>>>>>                Procedure_Return
84279>>>>>>>            End
84279>>>>>>>>
84279>>>>>>>            
84279>>>>>>>            Get piMaxResults to iMax
84280>>>>>>>            Get piFindIndex to iIndex
84281>>>>>>>            If (iIndex <= 0) Begin
84283>>>>>>>                Get_Attribute DF_FIELD_INDEX of iFile iField to iIndex
84286>>>>>>>            End
84286>>>>>>>>
84286>>>>>>>            
84286>>>>>>>            //  Determine current filter settings
84286>>>>>>>            Get psSQLFilter of hoServer to sOrigFilter
84287>>>>>>>            Get pbUseDDSqlFilters of hoServer to bOrigActive
84288>>>>>>>            
84288>>>>>>>            // generate the Like filter string
84288>>>>>>>            Get SQLStrLike of hoServer iField sSearch to sFilter
84289>>>>>>>            // If filtering was active append this to what's there
84289>>>>>>>            If (bOrigActive) Begin
84291>>>>>>>                Get SQLStrAppend of hoServer sOrigFilter sFilter to sFilter
84292>>>>>>>            End
84292>>>>>>>>
84292>>>>>>>            
84292>>>>>>>            //  Set filter
84292>>>>>>>            Set psSQLFilter of hoServer to sFilter
84293>>>>>>>            Set pbUseDDSqlFilters of hoServer to True
84294>>>>>>>            
84294>>>>>>>            
84294>>>>>>>            // this will optimize No_relate. If your DF constraint does not
84294>>>>>>>            // need a post-relate test, we will disabled relates for this
84294>>>>>>>            Get No_Relate_State of hoServer to bOldRelate
84295>>>>>>>            Get DDOConstraintNeedsRelate of hoServer iIndex to bNeedsRelate
84296>>>>>>>            Set No_Relate_State of hoServer to (not(bNeedsRelate))
84297>>>>>>>
84297>>>>>>>            //  Find records
84297>>>>>>>            Move True to bContinue
84298>>>>>>>            Move 0 to iRow
84299>>>>>>>            
84299>>>>>>>            Send Request_Read of hoServer FIRST_RECORD iFile iIndex
84300>>>>>>>            
84300>>>>>>>            While (bContinue)
84304>>>>>>>                Get_Field_Value iFile iField to sVal
84307>>>>>>>                
84307>>>>>>>                If (Found) Begin // and ((bCase and sVal contains sSearch) or (not(bCase) and Lowercase(sVal) contains sLowSearch))) Begin
84309>>>>>>>                    Move (SerializeRowID(GetRowID(iFile)))  to aSuggestions[iRow].sRowId
84310>>>>>>>                    Move (Trim(sVal))                       to aSuggestions[iRow].aValues[0]
84311>>>>>>>                    Increment iRow
84312>>>>>>>                    
84312>>>>>>>                    Move (iRow < iMax) to bContinue
84313>>>>>>>                   
84313>>>>>>>                    Send Request_Read of hoServer GT iFile iIndex 
84314>>>>>>>                End
84314>>>>>>>>
84314>>>>>>>                Else Begin
84315>>>>>>>                    Move False to bContinue
84316>>>>>>>                End
84316>>>>>>>>
84316>>>>>>>                
84316>>>>>>>            Loop
84317>>>>>>>>
84317>>>>>>>            
84317>>>>>>>            //  Restore filters
84317>>>>>>>            Set psSQLFilter of hoServer to sOrigFilter
84318>>>>>>>            Set pbUseDDSqlFilters of hoServer to bOrigActive
84319>>>>>>>            Set No_Relate_State of hoServer to bOldRelate
84320>>>>>>>        End
84320>>>>>>>>
84320>>>>>>>    End_Procedure
84321>>>>>>>    
84321>>>>>>>    Procedure SuggestionsValidation String sSearch tSuggestion[] ByRef aSuggestions Boolean bFullText
84323>>>>>>>        Handle hoServer hoTable
84323>>>>>>>        Integer iFile iField iRow iCount iFound iMax iLen
84323>>>>>>>        Variant[][] aData
84324>>>>>>>        Boolean bCaseSensitive bContinue
84324>>>>>>>        String sDescr sVal
84324>>>>>>>        
84324>>>>>>>        Get Server to hoServer
84325>>>>>>>        Get Data_File  to iFile
84326>>>>>>>        Get Data_Field to iField       
84327>>>>>>>        
84327>>>>>>>        If ((hoServer <> 0) and (iFile <> 0)) Begin
84329>>>>>>>            Get File_Field_Table_Object of hoServer iFile iField to hoTable
84330>>>>>>>            If (hoTable <> 0) Begin
84332>>>>>>>                Get tabledata of hoTable to aData
84333>>>>>>>        
84333>>>>>>>                Get piMaxResults to iMax
84334>>>>>>>                Get pbCaseSensitive to bCaseSensitive  
84335>>>>>>>            
84335>>>>>>>                If (not(bCaseSensitive)) Begin
84337>>>>>>>                    Move (Lowercase(sSearch)) to sSearch
84338>>>>>>>                End
84338>>>>>>>>
84338>>>>>>>                
84338>>>>>>>                
84338>>>>>>>                Move (SizeOfArray(aData)) to iCount
84339>>>>>>>                Move 0 to iRow
84340>>>>>>>                Move (Length(sSearch)) to iLen
84341>>>>>>>                Move True to bContinue
84342>>>>>>>                
84342>>>>>>>            
84342>>>>>>>                While (iFound < iMax and iRow < iCount and bContinue)
84346>>>>>>>                    If (not(bCaseSensitive)) Begin
84348>>>>>>>                        Move (Lowercase(aData[iRow][0])) to sVal
84349>>>>>>>                        Move (Lowercase(aData[iRow][1])) to sDescr
84350>>>>>>>                    End
84350>>>>>>>>
84350>>>>>>>                    Else Begin
84351>>>>>>>                        Move aData[iRow][0] to sVal
84352>>>>>>>                        Move aData[iRow][1] to sDescr
84353>>>>>>>                    End
84353>>>>>>>>
84353>>>>>>>                    
84353>>>>>>>                    If ((bFullText and (sVal contains sSearch)) or (not(bFullText) and (Left(sVal, iLen) = sSearch))) Begin
84355>>>>>>>                        Move aData[iRow][0] to aSuggestions[iFound].sRowId
84356>>>>>>>                        Move aData[iRow][0] to aSuggestions[iFound].aValues[0]
84357>>>>>>>                        Move aData[iRow][1] to aSuggestions[iFound].aValues[1]
84358>>>>>>>                        Increment iFound
84359>>>>>>>                    End
84359>>>>>>>>
84359>>>>>>>                    Else Begin
84360>>>>>>>                        Move (bFullText or iFound = 0) to bContinue
84361>>>>>>>                    End
84361>>>>>>>>
84361>>>>>>>                    
84361>>>>>>>                    Increment iRow
84362>>>>>>>                Loop
84363>>>>>>>>
84363>>>>>>>            End
84363>>>>>>>>
84363>>>>>>>        End
84363>>>>>>>>
84363>>>>>>>         
84363>>>>>>>    End_Procedure
84364>>>>>>>    
84364>>>>>>>    
84364>>>>>>>    Procedure OnFindSuggestions String sSearch tSuggestion[] ByRef aSuggestions
84366>>>>>>>        Integer iMode iFile
84366>>>>>>>        Boolean bFullText bResult bSupportsSQL
84366>>>>>>>        Handle hoServer
84366>>>>>>>        
84366>>>>>>>        Get Server to hoServer
84367>>>>>>>        Get Data_File  to iFile
84368>>>>>>>        
84368>>>>>>>        If ((hoServer <> 0) and (iFile <> 0)) Begin
84370>>>>>>>            
84370>>>>>>>            Get peSuggestionMode to iMode
84371>>>>>>>            Get pbFullText to bFullText
84372>>>>>>>            
84372>>>>>>>            If (iMode = smFind) Begin
84374>>>>>>>                If (not(bFullText)) Begin
84376>>>>>>>                    Send SuggestionsFindIncremental sSearch (&aSuggestions)
84377>>>>>>>                End
84377>>>>>>>>
84377>>>>>>>                Else Begin
84378>>>>>>>                    Get SupportsSQLFilters of hoServer to bSupportsSQL
84379>>>>>>>                    If (bSupportsSQL) Begin
84381>>>>>>>                        Send SuggestionsSQLFullText sSearch (&aSuggestions)
84382>>>>>>>                    End
84382>>>>>>>>
84382>>>>>>>                    Else Begin
84383>>>>>>>                        Send SuggestionsFindFullText sSearch (&aSuggestions)
84384>>>>>>>                    End
84384>>>>>>>>
84384>>>>>>>                End
84384>>>>>>>>
84384>>>>>>>            End
84384>>>>>>>>
84384>>>>>>>            Else If (iMode = smValidationTable) Begin
84387>>>>>>>                Send SuggestionsValidation sSearch (&aSuggestions) bFullText
84388>>>>>>>            End
84388>>>>>>>>
84388>>>>>>>        End
84388>>>>>>>>
84388>>>>>>>    End_Procedure
84389>>>>>>>    
84389>>>>>>>    Procedure OnSelectSuggestion String sSearch tSuggestion Suggestion
84391>>>>>>>        Handle hoServer
84391>>>>>>>        Integer iFile iField iMode
84391>>>>>>>        Boolean bFind
84391>>>>>>>        RowID rRowId
84391>>>>>>>        
84391>>>>>>>        Get Server to hoServer
84392>>>>>>>        Get Data_File  to iFile
84393>>>>>>>        Get Data_Field to iField       
84394>>>>>>>        
84394>>>>>>>        If ((hoServer <> 0) and (iFile <> 0)) Begin
84396>>>>>>>            Get peSuggestionMode to iMode
84397>>>>>>>            
84397>>>>>>>            If (iMode = smFind) Begin
84399>>>>>>>                Get pbFindOnSelect to bFind
84400>>>>>>>                If (bFind) Begin
84402>>>>>>>                    Move (DeserializeRowID(Suggestion.sRowId)) to rRowId    
84403>>>>>>>                    
84403>>>>>>>                    If (not(IsNullRowID(rRowId))) Begin
84405>>>>>>>                        Send FindByRowId of hoServer iFile rRowId
84406>>>>>>>                    End
84406>>>>>>>>
84406>>>>>>>                End
84406>>>>>>>>
84406>>>>>>>                Else Begin
84407>>>>>>>                    Set Value to Suggestion.aValues[0]
84408>>>>>>>                    Set Item_Changed_State to True
84409>>>>>>>                End
84409>>>>>>>>
84409>>>>>>>            End
84409>>>>>>>>
84409>>>>>>>            Else If (imode = smValidationTable) Begin
84412>>>>>>>                Set Value to Suggestion.sRowId
84413>>>>>>>                Set Item_Changed_State to True
84414>>>>>>>            End
84414>>>>>>>>
84414>>>>>>>            
84414>>>>>>>        End
84414>>>>>>>>
84414>>>>>>>    End_Procedure
84415>>>>>>>    
84415>>>>>>>    // Return true if Suggestion should be invoked. Can be augmented
84415>>>>>>>    Function ShouldSuggestion String sValue Boolean bChanged Returns Boolean
84417>>>>>>>        Integer iStartAtChar
84417>>>>>>>        Get piStartAtChar to iStartAtChar
84418>>>>>>>        Function_Return (bChanged and Length(sValue)>=iStartAtChar)
84419>>>>>>>    End_Function
84420>>>>>>>    
84420>>>>>>>    
84420>>>>>>>End_Class
84421>>>>>>>
84421>>>>>>>
84421>>>>>>>// This contains logic that deals with the Windows object. It relies on the interface in 
84421>>>>>>>// sSuggestion_mixin, which means it must be mixed in as a sibling of this object (as is done
84421>>>>>>>// in dbSuggestionForm or as a child of this object (as is done in cDbCJGridColumnSuggestion), which
84421>>>>>>>// means messages are resolved via delegation. sSuggestion_mixin does not send messages to this class.
84421>>>>>>>// Note that cSuggestion_mixin and cSuggestionControl_mixin are designed so they can be mixed in at
84421>>>>>>>// the same level or mixed in such that cSuggestionControl_mixin is in the child object and cSuggestion_mixin
84421>>>>>>>// is in the parent
84421>>>>>>> 
84421>>>>>>>Class cSuggestionControl_mixin is a Mixin
84422>>>>>>>    
84422>>>>>>>    Procedure Define_cSuggestionControl_mixin
84424>>>>>>>        
84424>>>>>>>        Property Integer piTimeOutTicks 0
84425>>>>>>>        
84425>>>>>>>        On_Key kEnter Send SelectSuggestion
84426>>>>>>>        On_Key Key_Escape Send DeActivateSuggestionList
84427>>>>>>>        On_Key Key_Up_Arrow Send Up
84428>>>>>>>        On_Key Key_Down_Arrow Send Down
84429>>>>>>>
84429>>>>>>>    End_Procedure
84430>>>>>>>
84430>>>>>>>    Procedure AdjustSuggestionListSize Integer iLines
84432>>>>>>>        Integer i  iX iMax iY
84432>>>>>>>        String sTxt
84432>>>>>>>        Boolean bFullWidth
84432>>>>>>>        For i from 0 to (iLines-1)
84438>>>>>>>>
84438>>>>>>>            Get Line of ghoSuggestionList i to sTxt
84439>>>>>>>            Get Text_Extent of ghoSuggestionList sTxt to iX
84440>>>>>>>            Move (Low(iX) max iMax) to iMax
84441>>>>>>>            Move (Hi(iX)) to iY
84442>>>>>>>        Loop
84443>>>>>>>>
84443>>>>>>>        Move (iMax + 20) to imax
84444>>>>>>>        Get pbFullWidth to bFullWidth
84445>>>>>>>        If bFullWidth Begin
84447>>>>>>>            Move (iMax max (Low(GuiSize(Self)))) to iMax
84448>>>>>>>        End
84448>>>>>>>>
84448>>>>>>>        If (iLines) Begin
84450>>>>>>>            Set GuiSize of ghoSuggestionList to (iY*(iLines)+8) iMax
84451>>>>>>>            Send SelectRow of ghoSuggestionList 0 // go to first line
84452>>>>>>>        End
84452>>>>>>>>
84452>>>>>>>        Else Begin
84453>>>>>>>            Set GuiSize of ghoSuggestionList to (Hi(GuiSize(Self))) (low(GuiSize(Self)))
84454>>>>>>>        End
84454>>>>>>>>
84454>>>>>>>    End_Procedure
84455>>>>>>>    
84455>>>>>>>    // show all suggestions
84455>>>>>>>    Procedure ShowSuggestions
84457>>>>>>>        tSuggestion[] aResults
84457>>>>>>>        tSuggestion[] aResults
84458>>>>>>>        Integer i iLines
84458>>>>>>>        String sSearch 
84458>>>>>>>        Get pSearchResults to aResults
84459>>>>>>>        Get Value to sSearch
84460>>>>>>>        Send Delete_Data of ghoSuggestionList
84461>>>>>>>        Move (SizeOfArray(aResults)) to iLines
84462>>>>>>>        For i from 0 to (iLines-1)
84468>>>>>>>>
84468>>>>>>>            Send ShowSuggestion aResults[i] sSearch
84469>>>>>>>            If ((iLines-1)<>i) Begin
84471>>>>>>>                Send AppendTextLn of ghoSuggestionList ""
84472>>>>>>>            End
84472>>>>>>>>
84472>>>>>>>        Loop
84473>>>>>>>>
84473>>>>>>>        Send AdjustSuggestionListSize iLines
84474>>>>>>>    End_Procedure
84475>>>>>>>
84475>>>>>>>    Procedure FindSuggestions 
84477>>>>>>>        String sSearch
84477>>>>>>>        tSuggestion[] aResults
84477>>>>>>>        tSuggestion[] aResults
84478>>>>>>>        String[] aParams
84479>>>>>>>        Get Value to sSearch
84480>>>>>>>        Send OnFindSuggestions sSearch (&aResults)
84481>>>>>>>        Set pSearchResults to aResults
84482>>>>>>>        // if an error was raised, the suggestion list will be gone
84482>>>>>>>        If (ghoSuggestionList) Begin
84484>>>>>>>            Send ShowSuggestions
84485>>>>>>>        End
84485>>>>>>>>
84485>>>>>>>    End_Procedure
84486>>>>>>>
84486>>>>>>>    Procedure SelectSuggestion 
84488>>>>>>>        String sSearch
84488>>>>>>>        tSuggestion[] aData
84488>>>>>>>        tSuggestion[] aData
84489>>>>>>>        Integer iSelRow
84489>>>>>>>        If ghoSuggestionList Begin
84491>>>>>>>            Get SelectedRow of ghoSuggestionList to iSelRow
84492>>>>>>>            Get Value to sSearch
84493>>>>>>>            Get pSearchResults to aData        
84494>>>>>>>            Send DeActivateSuggestionList
84495>>>>>>>            Send CancelEditIfGrid
84496>>>>>>>            If (iSelRow>=0 and SizeOfArray(aData)>iSelRow) Begin
84498>>>>>>>                Send OnSelectSuggestion sSearch aData[iSelRow] 
84499>>>>>>>            End
84499>>>>>>>>
84499>>>>>>>        End
84499>>>>>>>>
84499>>>>>>>        Else Begin
84500>>>>>>>            Send Default_Action
84501>>>>>>>        End
84501>>>>>>>>
84501>>>>>>>    End_Procedure
84502>>>>>>>    
84502>>>>>>>    Procedure CancelEditIfGrid
84504>>>>>>>        // do nothing with forms, remember
84504>>>>>>>        // to replace or augment with grid to
84504>>>>>>>        // cancel the edit control
84504>>>>>>>    End_Procedure
84505>>>>>>>
84505>>>>>>>    
84505>>>>>>>    Function ParentForSuggestion Returns Handle
84507>>>>>>>        Handle hoMain hoMainPanel
84507>>>>>>>
84507>>>>>>>        // we must have an application object and a main panel object
84507>>>>>>>        If ghoApplication Begin
84509>>>>>>>            Get phoMainPanel of ghoApplication to hoMainPanel
84510>>>>>>>        End
84510>>>>>>>>
84510>>>>>>>        If (hoMainPanel=0 or Self<=Desktop) Begin
84512>>>>>>>            Function_Return 0
84513>>>>>>>        End
84513>>>>>>>>
84513>>>>>>>
84513>>>>>>>        Move Self to hoMain
84514>>>>>>>        Repeat
84514>>>>>>>>
84514>>>>>>>            Get Parent of hoMain to hoMain
84515>>>>>>>        Until (hoMain=Desktop or Block_Mouse_State(hoMain) or hoMainPanel=hoMain)
84517>>>>>>>
84517>>>>>>>        Function_Return (If(hoMain>Desktop,hoMain,0))
84518>>>>>>>        
84518>>>>>>>    End_Function
84519>>>>>>>    
84519>>>>>>>    Procedure ActivateSuggestionList
84521>>>>>>>        Handle hoView hcSuggest
84521>>>>>>>        Get ParentForSuggestion to hoView
84522>>>>>>>        If hoView Begin
84524>>>>>>>            Get phcSuggestionListClass to hcSuggest
84525>>>>>>>            Get CreateNamed of hoView hcSuggest "oSuggestList" to ghoSuggestionList
84526>>>>>>>            Send InitList of ghoSuggestionList Self
84527>>>>>>>            Set Focus_Mode of ghoSuggestionList to Focusable
84528>>>>>>>            Set phoOwner of ghoSuggestionList to Self
84529>>>>>>>            Send Add_Focus of ghoSuggestionList hoView
84530>>>>>>>        End
84530>>>>>>>>
84530>>>>>>>    End_Procedure
84531>>>>>>>    
84531>>>>>>>    Procedure DeActivateSuggestionList
84533>>>>>>>        If ghoSuggestionList Begin
84535>>>>>>>            Send DeactivateList of ghoSuggestionList
84536>>>>>>>        End
84536>>>>>>>>
84536>>>>>>>    End_Procedure
84537>>>>>>>    
84537>>>>>>>    // augment to kill suggest list if focus is not moving to it  
84537>>>>>>>    // customized for grid
84537>>>>>>>    Procedure OnKillFocus
84539>>>>>>>        // note focus has already changed here
84539>>>>>>>        If (ghoSuggestionList) Begin
84541>>>>>>>            If (Focus(Self)<>ghoSuggestionList) Begin
84543>>>>>>>                Send DeActivateSuggestionList
84544>>>>>>>                Forward Send OnKillFocus
84546>>>>>>>            End
84546>>>>>>>>
84546>>>>>>>            Else Begin
84547>>>>>>>                // giving focus to the suggestion list here
84547>>>>>>>            End
84547>>>>>>>>
84547>>>>>>>        End
84547>>>>>>>>
84547>>>>>>>        Else Begin
84548>>>>>>>            Forward Send OnKillFocus
84550>>>>>>>        End
84550>>>>>>>>
84550>>>>>>>    End_Procedure
84551>>>>>>>    
84551>>>>>>>    Procedure Up
84553>>>>>>>        If (Focus(Desktop) = Self and ghoSuggestionList) Begin
84555>>>>>>>           Send ScrollUp of ghoSuggestionList
84556>>>>>>>        End
84556>>>>>>>>
84556>>>>>>>    End_Procedure
84557>>>>>>>
84557>>>>>>>    Procedure Down
84559>>>>>>>        If (Focus(Desktop) = Self and ghoSuggestionList) Begin
84561>>>>>>>           Send ScrollDown of ghoSuggestionList
84562>>>>>>>        End
84562>>>>>>>>
84562>>>>>>>    End_Procedure
84563>>>>>>>    
84563>>>>>>>
84563>>>>>>>    Procedure Key Integer iKey
84565>>>>>>>        Integer iEndTicks
84565>>>>>>>        
84565>>>>>>>        If (Focus(Desktop) <> Self) Begin
84567>>>>>>>          Forward Send Key iKey
84569>>>>>>>          Procedure_Return
84570>>>>>>>        End
84570>>>>>>>>
84570>>>>>>>        
84570>>>>>>>        Send DeActivateSuggestionList
84571>>>>>>>        Move (GetTickCount()) to iEndTicks
84572>>>>>>>        // record the time of key press
84572>>>>>>>        If (piTimeOutTicks(Self) = 0) Begin
84574>>>>>>>         
84574>>>>>>>            If (ghoSuggestionTimer=0) Begin
84576>>>>>>>               Send CreateSuggestionTimer
84577>>>>>>>            End
84577>>>>>>>>
84577>>>>>>>         
84577>>>>>>>            Set pbEnabled of ghoSuggestionTimer to True
84578>>>>>>>            Set phoTimerOwner of ghoSuggestionTimer to Self
84579>>>>>>>        End
84579>>>>>>>>
84579>>>>>>>        Set piTimeOutTicks to iEndTicks
84580>>>>>>>        
84580>>>>>>>        Forward Send Key iKey
84582>>>>>>>    End_Procedure
84583>>>>>>>    
84583>>>>>>>    Procedure CreateSuggestionTimer
84585>>>>>>>        Handle hoMainPanel
84585>>>>>>>        // we must have an application object and a main panel object
84585>>>>>>>        If ghoApplication Begin
84587>>>>>>>            Get phoMainPanel of ghoApplication to hoMainPanel
84588>>>>>>>        End
84588>>>>>>>>
84588>>>>>>>        If (hoMainPanel=0) Begin
84590>>>>>>>            Error DFERR_PROGRAM "Auto-suggest requires an application object and a main panel object"
84591>>>>>>>>
84591>>>>>>>            Procedure_Return
84592>>>>>>>        End
84592>>>>>>>>
84592>>>>>>>        Get CreateNamed of hoMainPanel (RefClass(cSuggestionTimer)) "oSuggestionTimer" to ghoSuggestionTimer
84593>>>>>>>    End_Procedure
84594>>>>>>>  
84594>>>>>>>    // sent by Auto Suggest Timer. Invoke suggestion list as needed
84594>>>>>>>    Procedure OnSuggestionTimer
84596>>>>>>>        Boolean bDoIt
84596>>>>>>>        Integer iEndTicks iStartTicks iTicks iTimeOut iChanged
84596>>>>>>>        String sValue
84596>>>>>>>        
84596>>>>>>>        If (Focus(Desktop) <> Self) Begin
84598>>>>>>>            // focus out of whack. Stop the timer
84598>>>>>>>            Set pbEnabled of ghoSuggestionTimer to False
84599>>>>>>>            Send DeActivateSuggestionList   
84600>>>>>>>            Procedure_Return
84601>>>>>>>        End                                
84601>>>>>>>>
84601>>>>>>>
84601>>>>>>>        Get piTimeOutTicks to iStartTicks
84602>>>>>>>        If (iStartTicks <> 0) Begin           
84604>>>>>>>            Move (GetTickCount()) to iEndTicks 
84605>>>>>>>            Move (iEndTicks - iStartTicks) to iTicks
84606>>>>>>>            // If tick count rolled over
84606>>>>>>>            If (iTicks < 0) Begin
84608>>>>>>>                Move (-iTicks) to iTicks 
84609>>>>>>>            End
84609>>>>>>>>
84609>>>>>>>        End
84609>>>>>>>>
84609>>>>>>>        Get piPopupTimeout to iTimeOut
84610>>>>>>>        If (iTicks >= iTimeOut) Begin
84612>>>>>>>            // If time delay has been met, launch autocomplete
84612>>>>>>>            Set pbEnabled  of ghoSuggestionTimer to False
84613>>>>>>>            Get Value to sValue
84614>>>>>>>            Get Item_Changed_State 0 to iChanged
84615>>>>>>>            Get ShouldSuggestion sValue iChanged to bDoIt
84616>>>>>>>            If bDoIt Begin
84618>>>>>>>                Send ActivateSuggestionList
84619>>>>>>>                Send FindSuggestions
84620>>>>>>>                Set Visible_State of ghoSuggestionList to True
84621>>>>>>>            End
84621>>>>>>>>
84621>>>>>>>            Set piTimeOutTicks to 0
84622>>>>>>>        End
84622>>>>>>>>
84622>>>>>>>    End_Procedure
84623>>>>>>>
84623>>>>>>>End_Class
84624>>>>>>>
84624>>>>>
84624>>>>>Class DbSuggestionForm is a dbForm
84625>>>>>    
84625>>>>>    Import_Class_Protocol cSuggestionControl_mixin
84626>>>>>    Import_Class_Protocol cSuggestion_mixin
84627>>>>>    
84627>>>>>    Procedure Construct_Object
84629>>>>>        Forward Send Construct_Object
84631>>>>>        Send Define_cSuggestionControl_mixin
84632>>>>>        Send Define_cSuggestion_mixin    
84633>>>>>    End_Procedure
84634>>>>>    
84634>>>>>End_Class
84635>>>>>
84635>>>Use cDbCJGridColumnSuggestion.pkg
Including file: cDbCJGridColumnSuggestion.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cDbCJGridColumnSuggestion.pkg)
84635>>>>>Use WinSuggestion.pkg
84635>>>>>Use cDbCJGridColumn.pkg
84635>>>>>Use cDbCJGridColumnEdit.pkg
84635>>>>>
84635>>>>>// This is the edit control that gets embedded in cDbCJGridColumnSuggestion object.
84635>>>>>
84635>>>>>Class cDbCJGridColumnSuggestionEdit is a cDbCJGridColumnEdit
84636>>>>>
84636>>>>>    Import_Class_Protocol cSuggestionControl_mixin
84637>>>>>
84637>>>>>    Procedure Construct_Object
84639>>>>>        Forward Send Construct_Object
84641>>>>>        Send Define_cSuggestionControl_mixin
84642>>>>>    End_Procedure
84643>>>>>    
84643>>>>>    // Called when closing a suggestion form. With grids we must also make sure that the
84643>>>>>    // edit is canceled. 
84643>>>>>    Procedure CancelEditIfGrid
84645>>>>>        Send CancelEdit
84646>>>>>    End_Procedure
84647>>>>>    
84647>>>>>End_Class
84648>>>>>
84648>>>>>// A cDbCJGridColumnSuggestion would be dropped inside of cDbCJGrid.
84648>>>>>
84648>>>>>Class cDbCJGridColumnSuggestion is a cDbCJGridColumn
84649>>>>>    
84649>>>>>    Import_Class_Protocol cSuggestion_mixin            
84650>>>>>    
84650>>>>>    Procedure Construct_Object
84652>>>>>        Forward Send Construct_Object
84654>>>>>
84654>>>>>        Send Define_cSuggestion_mixin
84655>>>>>        Set phcEditClass to (RefClass(cDbCJGridColumnSuggestionEdit))
84656>>>>>    End_Procedure
84657>>>>>    
84657>>>>>End_Class
84658>>>
84658>>>Use Customer.DD
84658>>>Use Vendor.DD
84658>>>Use dfTabDlg.pkg
84658>>>
84658>>>
84658>>>Deferred_View Activate_oDemoSuggestionForm for ;Object oDemoSuggestionForm is a dbView
84683>>>
84683>>>    Set Border_Style to Border_Thick
84684>>>    Set Size to 227 300
84685>>>    Set Location to 2 2
84686>>>    Set Label to "Suggestion Forms and Grids"
84687>>>
84687>>>    Object oSuggestionsTP is a dbTabDialogView
84689>>>        Set Size to 208 284
84690>>>        Set Location to 10 7
84691>>>
84691>>>        Object oVendor_DD is a Vendor_DataDictionary
84693>>>        End_Object
84694>>>    
84694>>>        Object oCustomer_DD is a Customer_DataDictionary
84696>>>            Procedure Field_defaults
84699>>>                Forward Send Field_Defaults
84701>>>                Set Field_Changed_Value   Field Customer.State to ""
84702>>>            End_Procedure
84703>>>        End_Object
84704>>>    
84704>>>        Set Main_DD to oCustomer_DD
84705>>>        Set Server to oCustomer_DD
84706>>>
84706>>>        Object oSuggestionForms is a dbTabView
84708>>>            Set Label to 'dbSuggestionForm'
84709>>>
84709>>>            Object oLabel1 is a TextBox
84711>>>                Set Auto_Size_State to False
84712>>>                Set Size to 10 237
84713>>>                Set Location to 17 16
84714>>>                Set Label to "Data bound, incremental, starting at character 1"
84715>>>                Set FontWeight to fw_Bold
84716>>>            End_Object
84717>>>            Object oSuggestionForm2 is a dbSuggestionForm
84719>>>                Set Location to 28 74
84720>>>                Entry_Item Customer.Customer_Number
84721>>>                Set size to 14 45
84722>>>                Set Label to "Customer Num:"
84723>>>                Set piStartAtChar to 1
84724>>>            End_Object
84725>>>            Object oSuggestionForm1 is a dbSuggestionForm
84727>>>                Set Location to 44 74
84728>>>                Entry_Item Customer.Name
84729>>>                Set size to 14 146
84730>>>                Set Label to "Customer Name:"
84731>>>                Set piStartAtChar to 1
84732>>>            End_Object
84733>>>            Object oLabel3 is a TextBox
84735>>>                Set Auto_Size_State to False
84736>>>                Set Size to 9 211
84737>>>                Set Location to 77 17
84738>>>                Set Label to "Validation Table, incremental, starting at character 1"
84739>>>                Set FontWeight to fw_Bold
84740>>>            End_Object
84741>>>            Object oSuggestionForm4 is a dbSuggestionForm
84743>>>                Set Location to 89 74
84744>>>                Entry_Item Customer.State
84745>>>                Set Size to 14 50
84746>>>                Set Label to "Customer State:"
84747>>>                Set peSuggestionMode to smValidationTable
84748>>>                Set piStartAtChar to 1
84749>>>            End_Object
84750>>>            Object oLabel2 is a TextBox
84752>>>                Set Auto_Size_State to False
84753>>>                Set Size to 10 199
84754>>>                Set Location to 120 16
84755>>>                Set Label to "Data bound, full text, starting at character 2"
84756>>>                Set FontWeight to fw_Bold
84757>>>            End_Object
84758>>>            
84758>>>            Object oSuggestionForm3 is a dbSuggestionForm
84760>>>                Set Location to 137 74
84761>>>                Entry_Item Vendor.Name
84762>>>                Set Server to oVendor_DD
84763>>>                Set Size to 14 100
84764>>>                Set pbFullText to True
84765>>>                Set Label to "Vendor name:"
84766>>>            End_Object
84767>>>
84767>>>            Object oLabel3 is a TextBox
84769>>>                Set Auto_Size_State to False
84770>>>                Set Size to 10 199
84771>>>                Set Location to 158 16
84772>>>                Set Label to "Custom Suggestion List"
84773>>>                Set FontWeight to fw_Bold
84774>>>            End_Object
84775>>>            
84775>>>            // this shows how to create you own custom suggestion list
84775>>>            Object oSuggestionForm5 is a dbSuggestionForm
84777>>>                Set Location to 175 74
84778>>>                Set Label to "Custom Id:"
84779>>>                Set Size to 14 100
84780>>>                Set peSuggestionMode to smCustom
84781>>>                Set piStartAtChar to 1
84782>>>
84782>>>                // even though we handle searching manually in OnFindSuggestions, pbFullText
84782>>>                // is still used to determine the display and bolding of matched text. Setting
84782>>>                // this true tells it we are matching anywhere within the string.
84782>>>                // Since this is a custom list, it is the developer's job to make sure that
84782>>>                // OnFindSuggestions follows these rules as well.
84782>>>                Set pbFullText to True
84783>>>                
84783>>>                // augment to create an arbitrary list of Ids to be used for our search
84783>>>                Property String[] pCustomIds
84785>>>                
84785>>>                // augment to create a list of Ids
84785>>>                Procedure Activating
84788>>>                    String[] sIds
84789>>>                    Forward Send Activating
84791>>>                    Move "JSON" to sIds[0]
84792>>>                    Move "XML" to sIds[1]
84793>>>                    Move "SQL" to sIds[2]
84794>>>                    Move "SQLExpress" to sIds[3]
84795>>>                    Move "SQLServer" to sIds[4]
84796>>>                    Move "DF" to sIds[5]
84797>>>                    Move "XQuery" to sIds[6]
84798>>>                    Move "JScript" to sIds[7]
84799>>>                    Move "Java" to sIds[8]
84800>>>                    Move "UTF-8" to sIds[9]
84801>>>                    Move "UTF-16" to sIds[10]
84802>>>                    Set pCustomIds to (SortArray(sIds,Desktop,RefFunc(DFSTRICMP)))
84803>>>                End_Procedure
84804>>>                
84804>>>                // custom code to find all matches for the search
84804>>>                // You can write whatever code you want here to find matched items
84804>>>                Procedure OnFindSuggestions String sSearch tSuggestion[] ByRef aSuggestions
84807>>>                    String[] sIds
84808>>>                    Integer i iLen iIds iCount
84808>>>                    Move (Lowercase(sSearch)) to sSearch
84809>>>                    Move (Length(sSearch)) to iLen
84810>>>                    Get pCustomIds to sIds
84811>>>                    Move (SizeOfArray(sIds)-1) to iIds
84812>>>                    For i from 0 to iIds
84818>>>>
84818>>>                        If (Lowercase(sIds[i]) contains sSearch) Begin
84820>>>                            Move sIds[i] to aSuggestions[iCount].sRowId
84821>>>                            Move sIds[i] to aSuggestions[iCount].aValues[0]
84822>>>                            Increment iCount
84823>>>                        End
84823>>>>
84823>>>                    Loop
84824>>>>
84824>>>                End_Procedure
84825>>>
84825>>>                Procedure OnSelectSuggestion String sSearch tSuggestion Suggestion
84828>>>                    Set Value to Suggestion.sRowId
84829>>>                    Set Item_Changed_State to True
84830>>>                End_Procedure
84831>>>
84831>>>            
84831>>>            End_Object
84832>>>        End_Object
84833>>>
84833>>>        Object oSuggestionGrid is a dbTabView
84835>>>
84835>>>            Set Label to "cDbCJGridColumnSuggestion"
84836>>>
84836>>>            Object oCustomer_DD is a Customer_DataDictionary
84838>>>            End_Object
84839>>>        
84839>>>            Set Main_DD to oCustomer_DD
84840>>>            Set Server to oCustomer_DD
84841>>>        
84841>>>            Object oDbCJGrid1 is a cDbCJGrid
84843>>>                Set Size to 177 268
84844>>>                Set Location to 7 7
84845>>>                Set Ordering to 1
84846>>>                Set Verify_Save_msg to (RefFunc(Save_Confirmation))
84847>>>                
84847>>>                Object oCustomer_Customer_Number is a cDbCJGridColumnSuggestion
84849>>>                    Entry_Item Customer.Customer_Number
84850>>>                    Set piWidth to 73
84851>>>                    Set psCaption to "Number"
84852>>>                    Set piStartAtChar to 1
84853>>>                End_Object
84854>>>        
84854>>>                // normally you would not use a suggestion list with a grid's main 
84854>>>                // file. It would be more useful when selecting a parent.
84854>>>                Object oCustomer_Name is a cDbCJGridColumnSuggestion
84856>>>                    Entry_Item Customer.Name
84857>>>                    Set piWidth to 358
84858>>>                    Set psCaption to "Customer Name"
84859>>>                    Set pbFullText to True
84860>>>                    Set piStartAtChar to 1
84861>>>                End_Object
84862>>>        
84862>>>                Object oCustomer_State is a cDbCJGridColumnSuggestion
84864>>>                    Entry_Item Customer.State
84865>>>                    Set piWidth to 105
84866>>>                    Set psCaption to "State"
84867>>>                    Set peSuggestionMode to smValidationTable
84868>>>                    Set piStartAtChar to 1
84869>>>                End_Object
84870>>>            End_Object
84871>>>
84871>>>        End_Object
84872>>>        
84872>>>    End_Object
84873>>>        
84873>>>        
84873>>>Cd_End_Object
84875>>>>
84875>        Use DemoButtonTest.vw
Including file: DemoButtonTest.vw    (C:\Test\Order Entry git\AppSrc\DemoButtonTest.vw)
84875>>>Use Windows.pkg
84875>>>Use DFClient.pkg
84875>>>Use cImageList32.pkg
84875>>>Use cSplitButton.pkg
84875>>>Use cCommandLinkButton.pkg
Including file: cCommandLinkButton.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cCommandLinkButton.pkg)
84875>>>>>// cCommandLinkButton class
84875>>>>>
84875>>>>>// This requires version 6 of common controls (vista or windows server 2008). If used with
84875>>>>>// older versions you will just get a regular great big button.
84875>>>>> 
84875>>>>>Use Windows.pkg
84875>>>>>Use CharTranslate.pkg
84875>>>>>
84875>>>>>Class cCommandLinkButton is a Button
84876>>>>>
84876>>>>>        Procedure Construct_Object
84878>>>>>            Forward Send Construct_Object
84880>>>>>            Property String psPrivateNote
84881>>>>>        End_Procedure
84882>>>>>        
84882>>>>>        Procedure Set psNote String sNote
84884>>>>>            Boolean bSupported
84884>>>>>            Set psPrivateNote to sNote
84885>>>>>            Get IsExControlSupported to bSupported
84886>>>>>            If bSupported Begin
84888>>>>>                Send SetWinNote
84889>>>>>            End
84889>>>>>>
84889>>>>>        End_Procedure
84890>>>>>        
84890>>>>>        Procedure SetWinNote
84892>>>>>            String sNote
84892>>>>>            Handle hWnd
84892>>>>>            Integer i
84892>>>>>            Address aVar
84892>>>>>            Get Form_Window_Handle 0 to hWnd
84893>>>>>            If hWnd Begin
84895>>>>>                Get psNote to sNote
84896>>>>>                Move (OemToUtf16Buffer(AddressOf(sNote),Length(sNote))) to aVar
84897>>>>>                Move (SendMessage(hwnd, BCM_SETNOTE, 0, aVar)) to i
84898>>>>>                Move (Free(aVar)) to i 
84899>>>>>            End
84899>>>>>>
84899>>>>>        End_Procedure
84900>>>>>        
84900>>>>>        
84900>>>>>        Function psNote Returns String
84902>>>>>            Function_Return (psPrivateNote(Self))
84903>>>>>        End_Function
84904>>>>>        
84904>>>>>
84904>>>>>        Procedure Page Integer iState
84906>>>>>            Integer i hWnd
84906>>>>>            Boolean bSupported
84906>>>>>            Get IsExControlSupported to bSupported
84907>>>>>            If (iState=1 and bSupported) Begin
84909>>>>>                Get form_style i to i
84910>>>>>                Set Form_Style 0 to (i ior (BS_COMMANDLINK + BS_FLAT))
84911>>>>>                Forward Send Page iState
84913>>>>>                Send SetWinNote
84914>>>>>            End
84914>>>>>>
84914>>>>>            Else Begin
84915>>>>>                Forward Send Page iState
84917>>>>>            End
84917>>>>>>
84917>>>>>        End_Procedure        
84918>>>>>
84918>>>>>End_Class
84919>>>Use cCJStandardMenuItemClasses.pkg
84919>>>
84919>>>
84919>>>Deferred_View Activate_oButtonTest for ;Object oButtonTest is a dbView
84944>>>
84944>>>    Set Border_Style to Border_Thick
84945>>>    Set Size to 212 300
84946>>>    Set Location to 2 3
84947>>>    Set Label to "Button Samples"
84948>>>
84948>>>    Object oTextBox1 is a TextBox
84950>>>        Set Size to 9 110
84951>>>        Set Location to 8 10
84952>>>        Set Label to 'Buttons that use Text and Images'
84953>>>    End_Object
84954>>>
84954>>>    Object oTextButton is a Button
84956>>>        Set Location to 20 11
84957>>>        Set Label to 'Save'
84958>>>    
84958>>>        Procedure OnClick
84961>>>        End_Procedure
84962>>>    
84962>>>    End_Object
84963>>>
84963>>>    Object oTextAndImageButton is a Button
84965>>>        Set Location to 20 71
84966>>>        Set Label to 'Save'
84967>>>        Set psImage to "ActionSave.ico"
84968>>>
84968>>>        Procedure OnClick
84971>>>        End_Procedure
84972>>>    
84972>>>    End_Object
84973>>>
84973>>>    Object oImageButton is a Button
84975>>>        Set Size to 14 27
84976>>>        Set Location to 20 131
84977>>>        Set psImage to "ActionSave.ico"
84978>>>        Set peImageAlign to Button_ImageList_Align_Center
84979>>>
84979>>>        Procedure OnClick
84982>>>        End_Procedure
84983>>>    
84983>>>    End_Object
84984>>>
84984>>>    Object oTextAndImageTopButton is a Button
84986>>>        Set Size to 26 50
84987>>>        Set Location to 20 168
84988>>>        Set Label to 'Save'
84989>>>        Set psImage to "ActionSave.ico"
84990>>>        Set peImageAlign to Button_ImageList_Align_Top
84991>>>        Set piImageMarginTop to 10
84992>>>
84992>>>        Procedure OnClick
84995>>>        End_Procedure
84996>>>    
84996>>>    End_Object
84997>>>
84997>>>    Object oTextAndImageBottomButton is a Button
84999>>>        Set Size to 26 50
85000>>>        Set Location to 20 226
85001>>>        Set Label to 'Save'
85002>>>        Set psImage to "ActionSave.ico"
85003>>>        Set peImageAlign to Button_ImageList_Align_Bottom
85004>>>        Set piImageMarginBottom to 10
85005>>>
85005>>>        Procedure OnClick
85008>>>        End_Procedure
85009>>>    
85009>>>    End_Object
85010>>>
85010>>>    Object oTextBox1 is a TextBox
85012>>>        Set Size to 9 110
85013>>>        Set Location to 51 10
85014>>>        Set Label to 'Buttons with drop down menus'
85015>>>    End_Object
85016>>>
85016>>>    // this is a button with down arrow button on the right that invokes
85016>>>    // a context menu inside of OnClick
85016>>>    Object oDropDownButton is a Button
85018>>>        Set Size to 14 58
85019>>>        Set Location to 65 10
85020>>>        Set Label to "Select"
85021>>>        Set psImage to "Down16.bmp"
85022>>>        Set peImageAlign to Button_ImageList_Align_Right
85023>>>
85023>>>        Procedure OnClick
85026>>>            // OnDropDown is defined to popup menu in phoButtonPopup
85026>>>            Send OnDropDown
85027>>>        End_Procedure
85028>>>        
85028>>>        Object oButtonMenu is a cCJContextMenu
85030>>>            
85030>>>            Object oMenuItem1 is a cCJMenuItem
85032>>>                Set psCaption to "Save"
85033>>>                Set psImage to "ActionSaveRecord.ico"
85034>>>                Procedure OnExecute Variant vCommandBarControl
85037>>>                End_Procedure
85038>>>            End_Object
85039>>>            
85039>>>            Object oMenuItem2 is a cCJMenuItem
85041>>>                Set psCaption to "Clear"
85042>>>                Set psImage to "ActionClear.ico"
85043>>>                Procedure OnExecute Variant vCommandBarControl
85046>>>                End_Procedure
85047>>>            End_Object
85048>>>            
85048>>>            Object oMenuItem3 is a cCJMenuItem
85050>>>                Set psCaption to "Delete"
85051>>>                Set psImage to "ActionDeleteRecord.ico"
85052>>>                Procedure OnExecute Variant vCommandBarControl
85055>>>                End_Procedure
85056>>>            End_Object
85057>>>
85057>>>        End_Object
85058>>>        // Binds OnDropDown to this menu
85058>>>        Set phoButtonPopup to oButtonMenu 
85059>>>
85059>>>    End_Object
85060>>>
85060>>>    // this is split button (Vista or greater required), where OnClick and
85060>>>    // OnDropDown are two events. OnDropDown automatically invokes phoButtonPopup
85060>>>    
85060>>>    Object oSplitButton is a cSplitButton
85062>>>        Set Size to 14 53
85063>>>        Set Location to 65 76
85064>>>        Set Label to 'Save'
85065>>>        Set psImage to "ActionSaveRecord.ico"
85066>>>    
85066>>>        Procedure OnClick
85069>>>        End_Procedure
85070>>>        
85070>>>        Object oButtonMenu is a cCJContextMenu
85072>>>            
85072>>>            Object oMenuItem1 is a cCJMenuItem
85074>>>                Set psCaption to "Set to Save"
85075>>>                Procedure OnExecute Variant vCommandBarControl
85078>>>                    Delegate Set label to "Save"
85080>>>                    Delegate Set psImage to "ActionSaveRecord.ico"
85082>>>                End_Procedure
85083>>>            End_Object
85084>>>            
85084>>>            Object oMenuItem2 is a cCJMenuItem
85086>>>                Set psCaption to "Set to Clear"
85087>>>                Procedure OnExecute Variant vCommandBarControl
85090>>>                    Delegate Set label  to "Clear"
85092>>>                    Delegate Set psImage to  "ActionClear.ico"
85094>>>                End_Procedure
85095>>>            End_Object
85096>>>            
85096>>>            Object oMenuItem3 is a cCJMenuItem
85098>>>                Set psCaption to "Set to Delete"
85099>>>                Procedure OnExecute Variant vCommandBarControl
85102>>>                    Delegate Set label  to "Delete"
85104>>>                    Delegate Set psImage to  "ActionDeleteRecord.ico"
85106>>>                End_Procedure
85107>>>            End_Object
85108>>>
85108>>>            Object oMenuItem4 is a cCJMenuItem
85110>>>                Set psCaption to "Set to Select"
85111>>>                Procedure OnExecute Variant vCommandBarControl
85114>>>                    Delegate Set label  to "Select"
85116>>>                    Delegate Set psImage to  ""
85118>>>                End_Procedure
85119>>>            End_Object
85120>>>
85120>>>        End_Object
85121>>>
85121>>>        Set phoButtonPopup to oButtonMenu 
85122>>>
85122>>>    End_Object
85123>>>
85123>>>    Object oTextBox2 is a TextBox
85125>>>        Set Size to 9 115
85126>>>        Set Location to 51 166
85127>>>        Set Label to "Button using an external image list"
85128>>>    End_Object
85129>>>    
85129>>>    // button have 6 image states. We will provide a different image
85129>>>    // for each of these states
85129>>>    Object oImageList is a cImageList32
85131>>>        Set piMaxImages to 6
85132>>>        Set piImageHeight to 16
85133>>>        Set piImageWidth to 16
85134>>>        Procedure OnCreate
85137>>>            Integer iIndex
85137>>>            // for buttons either create 1 image or 6
85137>>>            // if 6, they are normal, hot, pressed, disabled, defaulted, stylus-hot
85137>>>            Get AddImage "ClosFold.bmp" to iIndex
85138>>>            Get AddImage "OpenFold.bmp" to iIndex
85139>>>            Get AddImage "OpenFold.bmp" to iIndex
85140>>>            Get AddImage "ClosFold.bmp" to iIndex
85141>>>            Get AddImage "OpenFold.bmp" to iIndex
85142>>>            Get AddImage "ClosFold.bmp" to iIndex
85143>>>        End_Procedure
85144>>>    End_Object
85145>>>
85145>>>    // this attaches to an external imageist with 6 images. Because this
85145>>>    // uses an external imagelist you will not see the image modeled in the Studio
85145>>>    Object oMultiImageButton is a Button
85147>>>        Set Location to 65 194
85148>>>        Set phoExternalButtonImageList to oImageList
85149>>>        Set peImageAlign to Button_ImageList_Align_Center
85150>>>        
85150>>>        Procedure OnClick
85153>>>        End_Procedure
85154>>>
85154>>>    End_Object
85155>>>
85155>>>    // CommandLinkButtons work with Vista or greater required
85155>>>    Object oCommandLinkButtonGroup is a Group
85157>>>        Set Size to 115 258
85158>>>        Set Location to 90 10
85159>>>        Set Label to "CommandLink Buttons"
85160>>>
85160>>>        Object oCommandLinkStandard is a cCommandLinkButton
85162>>>            Set Location to 11 9
85163>>>            Set Size to 34 239
85164>>>            Set Label to 'CommandLink Choice 1'
85165>>>            Set psNote to "This is a normal command link button with the standard command link image"
85166>>>    
85166>>>            Procedure OnClick
85169>>>            End_Procedure
85170>>>            
85170>>>        End_Object
85171>>>
85171>>>        Object oCommandLinkShield is a cCommandLinkButton
85173>>>            Set Location to 44 9
85174>>>            Set Size to 34 239
85175>>>            Set Label to 'CommandLink Choice 2'
85176>>>            Set psNote to "This is a command link button using the Windows elevated shield image"
85177>>>            Set pbShield to True
85178>>>    
85178>>>            Procedure OnClick
85181>>>            End_Procedure
85182>>>            
85182>>>        End_Object
85183>>>
85183>>>        Object oCommandLinkCustom is a cCommandLinkButton
85185>>>            Set Location to 78 9
85186>>>            Set Size to 34 239
85187>>>            Set Label to 'CommandLink Choice 3'
85188>>>            Set psNote to "This is a command link with a custom image. This image just happens to be larger"
85189>>>            Set psImage to "DF32.bmp"
85190>>>            Set piImageSize to 48
85191>>>
85191>>>            Procedure OnClick
85194>>>            End_Procedure
85195>>>            
85195>>>        End_Object
85196>>>
85196>>>    End_Object
85197>>>
85197>>>
85197>>>Cd_End_Object
85199>>>>
85199>              Use DemoCalendarControl.vw
Including file: DemoCalendarControl.vw    (C:\Test\Order Entry git\AppSrc\DemoCalendarControl.vw)
85199>>>Use Windows.pkg
85199>>>Use DFClient.pkg
85199>>>
85199>>>Use MonthCalendarPrompt.dg
85199>>>Use cTextEdit.pkg
85199>>>
85199>>>Activate_View Activate_oDemoCalendarControl for oDemoCalendarControl
85209>>>>
85209>>>Object oDemoCalendarControl is a dbView
85211>>>
85211>>>    Set Border_Style to Border_Thick
85212>>>    Set Size to 148 196
85213>>>    Set Location to 2 2
85214>>>    Set Label to "Calendar Control Sample"
85215>>>
85215>>>    // Simplest case example, just set the prompt_object
85215>>>    Object oDateFormTest is a Form
85217>>>        Set Location to 16 89
85218>>>        Set Size to 13 66
85219>>>        Set Label to "Date Select Test:"
85220>>>
85220>>>        Set Prompt_Object to oMonthCalendarPrompt
85221>>>        Set Prompt_Button_Mode to PB_PromptOn
85222>>>
85222>>>    End_Object
85223>>>
85223>>>    Object oDateRangeGroup is a Group
85225>>>
85225>>>        Set Label to "Selecting Date Range"
85226>>>        Set Size to 74 165
85227>>>        Set Location to 39 23
85228>>>        
85228>>>        Object oFromDate is a Form
85230>>>            Set Label to "From:"
85231>>>            Set Location to 29 66
85232>>>            Set Size to 13 66
85233>>>            Set Prompt_Button_Mode to PB_PromptOn
85234>>>            Set Prompt_Object to oMonthCalendarPrompt
85235>>>            
85235>>>            Procedure Prompt_Callback Integer hoPrompt
85238>>>                Send DateRangeCallback hoPrompt
85239>>>            End_Procedure
85240>>>        End_Object
85241>>>        
85241>>>        Object oToDate is a Form
85243>>>            Set Label to "To:"
85244>>>            Set Location to 50 66
85245>>>            Set Size to 13 66
85246>>>            Set Prompt_Button_Mode to PB_PromptOn
85247>>>            
85247>>>            Procedure Prompt
85250>>>                Send Popup to oMonthCalendarPrompt
85251>>>            End_Procedure
85252>>>            
85252>>>            Procedure Prompt_Callback Integer hoPrompt
85255>>>                Send DateRangeCallback hoPrompt
85256>>>            End_Procedure
85257>>>        End_Object
85258>>>
85258>>>              Object oTextBox1 is a TextBox
85260>>>                        Set Size to 10 154
85261>>>                        Set Location to 11 3
85262>>>                        Set Label to "(select initial date and drag the mouse to end date)"
85263>>>              End_Object
85264>>>        
85264>>>        
85264>>>        // Since these two date forms are using the same logic, we delegate to here
85264>>>        // and let the group handle the inititalization and update
85264>>>        
85264>>>        // this is the callback set in DateRangeCallback
85264>>>        Procedure DoDateUpdate Integer hoSel Date dDate1 Date dDate2
85267>>>            Set Value of oFromDate to dDate1
85268>>>            Set Value of oToDate to dDate2
85269>>>        End_Procedure
85270>>>        
85270>>>        // This is the first callback. Make this multi-select, 
85270>>>        // no click select, show week numbers, don't show today stuff.   
85270>>>        // also set the callback to call DoDateUpdate (which will delegate to here)
85270>>>        Procedure DateRangeCallback Integer hoPrompt
85273>>>            Date dDate1 dDate2
85273>>>            
85273>>>            Set pbMultiSelect of hoPrompt to True
85274>>>            Set peMouseSelectOk of hoPrompt to msoNone
85275>>>            Set phmPromptUpdateCallback of hoPrompt to (RefProc(DoDateUpdate))
85276>>>            
85276>>>            Set pbWeekNumbers of hoPrompt to True
85277>>>            Set pbNoToday of hoPrompt to True
85278>>>            Set pbNoTodayCircle of hoPrompt to True
85279>>>            
85279>>>            Get Value of oFromDate to dDate1
85280>>>            Get Value of oToDate to dDate2
85281>>>            Set pdSeedValue of hoPrompt to dDate1 
85282>>>            Set pdSeedValue2 of hoPrompt to dDate2 
85283>>>        End_Procedure
85284>>>    End_Object
85285>>>
85285>>>    Object oDateTextBox is a TextBox
85287>>>        Set Size to 10 34
85288>>>        Set Location to 123 56
85289>>>        Set Label to '1/30/2016'
85290>>>        Procedure Activating 
85293>>>            Set Label to (Date(CurrentDateTime()))
85294>>>            Forward Send Activating
85296>>>        End_Procedure
85297>>>    End_Object
85298>>>
85298>>>    Object oButton1 is a Button
85300>>>        Set Location to 121 100
85301>>>        Set Label to 'Change'
85302>>>        
85302>>>        Procedure Prompt_Callback Integer hoPrompt
85305>>>            Date dDate
85305>>>            Get Value of oDateTextBox to dDate
85306>>>            Set peUpdateMode of hoPrompt to umPromptCustom
85307>>>            Set pdSeedValue of hoPrompt to dDate
85308>>>            Set phmPromptUpdateCallback of hoPrompt to (RefProc(DoDateUpdate))
85309>>>        End_Procedure
85310>>>
85310>>>        Procedure DoDateUpdate Integer hoSel Date dDate1 Date dDate2
85313>>>            Set Value of oDateTextBox to dDate1
85314>>>        End_Procedure
85315>>>    
85315>>>        Procedure OnClick
85318>>>            Send Popup of oMonthCalendarPrompt
85319>>>        End_Procedure
85320>>>    
85320>>>    End_Object
85321>>>    
85321>>>End_Object
85322>        Use DemoParentCombos.vw
Including file: DemoParentCombos.vw    (C:\Test\Order Entry git\AppSrc\DemoParentCombos.vw)
85322>>>Use dfClient.pkg
85322>>>Use DataDict.pkg
85322>>>Use dfEntry.pkg
85322>>>Use dfSpnEnt.pkg
85322>>>Use dfCEntry.pkg
85322>>>Use dfTable.pkg
85322>>>Use Windows.pkg
85322>>>Use Vendor.DD
85322>>>Use Invt.DD
85322>>>Use Customer.DD
85322>>>Use SalesP.DD
85322>>>Use OrderHea.DD
85322>>>Use OrderDtl.DD
85322>>>Use cDbCJGrid.pkg
85322>>>Use cCJGridColumnRowIndicator.pkg
85322>>>Use DbParentCombo.pkg
Including file: dbParentCombo.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\dbParentCombo.pkg)
85322>>>>>Use Dfcentry.pkg
85322>>>>>
85322>>>>>// Combo for parents. 
85322>>>>>Class dbParentCombo is a dbComboForm
85323>>>>>    Procedure Construct_Object
85325>>>>>        Forward Send Construct_Object
85327>>>>>        
85327>>>>>        // Show a psEmptyItemDescription. If Entry_State is false, you probably
85327>>>>>        // want this false as well
85327>>>>>        Property Boolean pbAddEmptyItem True        
85328>>>>>        Property String psEmptyItemDescription DD_BLANK_CODE_DESCRIPTION
85329>>>>>        
85329>>>>>        // if true, the list is refilled each time the combo takes the focus
85329>>>>>        // making it more dynamic. You can manually refill a list sending ComboRefill
85329>>>>>        Property Boolean pbRefillOnFocus False
85330>>>>>        
85330>>>>>        // object maintained. If it detects that the list does not contain a parent it
85330>>>>>        // will set this true to force a refill on the next focus 
85330>>>>>        Property Boolean pbNeedsRefill False
85331>>>>>        
85331>>>>>        // make sure these properties are what we want
85331>>>>>        Set Code_Display_Mode to CB_Code_Display_Description
85332>>>>>        Set Undefined_Display_Mode to CB_ERR_UPDATE_WINDOW_VALUE // don't change
85333>>>>>        Set Undefined_Save_Mode    to CB_ERR_UPDATE_WINDOW_VALUE // don't change
85334>>>>>        
85334>>>>>        // in general this will work best with a non-editable combo
85334>>>>>        // but the other style works as well
85334>>>>>        Set Entry_State 0 to False
85335>>>>>        // its ok to change this - when default it displays in Combo_Index order
85335>>>>>        Set Combo_Sort_State to True
85336>>>>>    End_Procedure
85337>>>>>    
85337>>>>>    // augment to fill list when paged (instead of doing earlier)
85337>>>>>    Procedure Page_Object Boolean bPage
85339>>>>>        If bPage Begin
85341>>>>>            Send ComboRefill
85342>>>>>        End
85342>>>>>>
85342>>>>>        Forward Send Page_Object bPage
85344>>>>>    End_Procedure
85345>>>>>
85345>>>>>    
85345>>>>>    // Augmentation to handle optional combo refill on set focus
85345>>>>>    Procedure Notify_Focus_Change Integer Fg
85347>>>>>        Boolean bReFillOnFocus bNeedsRefill
85347>>>>>        Forward Send Notify_Focus_Change Fg
85349>>>>>        If Fg Begin
85351>>>>>            Get pbNeedsRefill to bNeedsRefill
85352>>>>>            Get pbRefillOnFocus to bReFillOnFocus
85353>>>>>            If (bRefillOnFocus or bNeedsRefill) Begin
85355>>>>>                Send ComboRefill
85356>>>>>            End
85356>>>>>>
85356>>>>>        End
85356>>>>>>
85356>>>>>    End_Procedure
85357>>>>>    
85357>>>>>    // Refill combo list, while maintaining current value
85357>>>>>    Procedure ComboRefill
85359>>>>>        String sValue
85359>>>>>        Set Deferred_State to True
85360>>>>>        Get Value 0 to sValue
85361>>>>>        Send Combo_Fill_List
85362>>>>>        Set Deferred_State to False
85363>>>>>        Set Combo_data_object to (Combo_Data_Object(Self))
85364>>>>>        Set Local_Value 0 to sValue
85365>>>>>    End_Procedure
85366>>>>>    
85366>>>>>    // Augment to  init and fill the list with all parents.
85366>>>>>    Procedure Combo_Fill_List
85368>>>>>        Handle hoServer hoDD
85368>>>>>        Integer iFile iField iIndex
85368>>>>>        String sDescription sData
85368>>>>>        Boolean bAddEmptyItem
85368>>>>>        Boolean bOldRelate bNeedsRelate
85368>>>>>        RowID riID
85368>>>>>        
85368>>>>>        Get Server to hoServer
85369>>>>>        Get Data_File to iFile
85370>>>>>        Get Data_Field to iField
85371>>>>>        Get Combo_Index to iIndex
85372>>>>>        Get pbAddEmptyItem to bAddEmptyItem
85373>>>>>        Send Combo_Delete_Data
85374>>>>>        
85374>>>>>        If (hoServer and iFile) Begin
85376>>>>>    
85376>>>>>            Get Data_Set of hoServer iFile to hoDD
85377>>>>>            
85377>>>>>            If (hoDD) Begin
85379>>>>>                Set Relational_State to True
85380>>>>>                If (bAddEmptyItem) Begin
85382>>>>>                    Get psEmptyItemDescription to sDescription
85383>>>>>                    Send Combo_Add_Blank_Item sDescription
85384>>>>>                    Set Data_Only_State to True // this got cleared - we don't care about dummy item
85385>>>>>                End
85385>>>>>>
85385>>>>>                
85385>>>>>                If (iIndex <= 0) Begin
85387>>>>>                    Get_Attribute DF_FIELD_INDEX of iFile iField to iIndex
85390>>>>>                End
85390>>>>>>
85390>>>>>                // optimize relates. Only do it if needed
85390>>>>>                Get No_Relate_State of hoDD to bOldRelate
85391>>>>>                Get DDOConstraintNeedsRelate of hoDD iIndex to bNeedsRelate
85392>>>>>                Set No_Relate_State of hoDD to (not(bNeedsRelate))
85393>>>>>                Send Request_Read of hoDD FIRST_RECORD iFile iIndex
85394>>>>>                While (Found)
85398>>>>>                    Send AddParentItemFromRecord  
85399>>>>>                    Send Locate_Next of hoDD
85400>>>>>                 Loop
85401>>>>>>
85401>>>>>                Set No_Relate_State of hoDD to bOldRelate
85402>>>>>            End
85402>>>>>>
85402>>>>>        End
85402>>>>>>
85402>>>>>        If (not(hoDD)) Begin
85404>>>>>            Error DFERR_PROGRAM "Invalid use of DbParentCombo"            
85405>>>>>>
85405>>>>>        End
85405>>>>>>
85405>>>>>        Set pbNeedsRefill to False
85406>>>>>    End_Procedure
85407>>>>>    
85407>>>>>    Procedure AddParentItemFromRecord
85409>>>>>        Integer iFile iField iItems
85409>>>>>        String sData sDescription
85409>>>>>        RowID riID
85409>>>>>        
85409>>>>>        Get Data_File to iFile
85410>>>>>        Get Data_Field to iField
85411>>>>>        Move (GetRowID(iFile)) to riID
85412>>>>>        Get_Field_Value iFile iField to sData
85415>>>>>        Move (Trim(sData)) to sData 
85416>>>>>        Move sData to sDescription
85417>>>>>        // user hook to customize the combo description
85417>>>>>        Send OnDefineDescription (&sDescription)
85418>>>>>        Get Combo_Item_Count to iItems
85419>>>>>        Send ComboFillItem iItems sData sDescription iFile riID
85420>>>>>        Increment iItems
85421>>>>>    End_Procedure
85422>>>>>    
85422>>>>>    // Hook to customize a combo item's description.
85422>>>>>    Procedure OnDefineDescription String ByRef sDescription
85424>>>>>    End_Procedure
85425>>>>>    
85425>>>>>    // augment to test that we found a match and if not add it to the list
85425>>>>>    Procedure Display_Description String DataVal
85427>>>>>        String sValue
85427>>>>>        Integer iItem
85427>>>>>        Move (Trim(DataVal)) to DataVal // must be trimmed for Combo_Item_Matching below
85428>>>>>        Get Data_to_Description DataVal to sValue
85429>>>>>        // Test that the combo item exists. We assume that a missing combo item means the list is out of date.
85429>>>>>        // If so, add the missing item and mark that we probably need to do a refill next chance we get.
85429>>>>>        If (DataVal<>"") Begin
85431>>>>>            Get Combo_Item_Matching sValue to iItem
85432>>>>>            If (iItem=-1) Begin
85434>>>>>                Send AddParentItemFromRecord
85435>>>>>                Set pbNeedsRefill to True
85436>>>>>                // now it should work
85436>>>>>                Get Data_to_Description DataVal to sValue
85437>>>>>            End
85437>>>>>>
85437>>>>>        End
85437>>>>>>
85437>>>>>        Set Value item 0 to sValue
85438>>>>>    End_Procedure
85439>>>>>    
85439>>>>>    // cancel so the list is not built upon attach to DDO. Attach upon activation
85439>>>>>    Procedure combo_initialize_list
85441>>>>>    End_Procedure
85442>>>>>    
85442>>>>>    
85442>>>>>End_Class
85443>>>Use MonthCalendarPrompt.dg
85443>>>
85443>>>Activate_View Activate_oDemoParentCombos for oDemoParentCombos
85453>>>>
85453>>>Object oDemoParentCombos is a dbView
85455>>>    Set Border_Style to Border_Thick
85456>>>    Set Maximize_Icon to True
85457>>>    Set Label to "Parent Combo Demo"
85458>>>    Set Location to 2 3
85459>>>    Set Size to 174 383
85460>>>    Set piMinSize to 174 383
85461>>>    
85461>>>
85461>>>    Object Vendor_DD is a Vendor_DataDictionary
85463>>>    End_Object    // Vendor_DD
85464>>>
85464>>>    Object Invt_DD is a Invt_DataDictionary
85466>>>        Set DDO_Server to Vendor_DD
85467>>>    End_Object    // Invt_DD
85468>>>
85468>>>    Object Customer_DD is a Customer_DataDictionary
85470>>>    End_Object    // Customer_DD
85471>>>
85471>>>    Object SalesP_DD is a Salesp_DataDictionary
85473>>>    End_Object    // SalesP_DD
85474>>>
85474>>>    Object OrderHea_DD is a OrderHea_DataDictionary
85476>>>        Set DDO_Server to Customer_DD
85477>>>        Set DDO_Server to SalesP_DD
85478>>>        
85478>>>        // this lets you save a new OrderHea from within OrderDtl.
85478>>>        Set Allow_Foreign_New_Save_State to True
85479>>>        
85479>>>    End_Object    // OrderHea_DD
85480>>>    
85480>>>    Object OrderDtl_DD is a OrderDtl_DataDictionary
85482>>>        Set DDO_Server to OrderHea_DD
85483>>>        Set DDO_Server to Invt_DD
85484>>>        Set Constrain_File to OrderHea.File_Number
85485>>>    End_Object    // OrderDtl_DD
85486>>>
85486>>>    Set Main_DD to OrderHea_DD
85487>>>    Set Server to OrderHea_DD
85488>>>    
85488>>>    Object oDbContainer3d1 is a dbContainer3d
85490>>>        Set Size to 85 377
85491>>>        Set Location to 2 3
85492>>>        Set peAnchors to anTopLeftRight
85493>>>        
85493>>>        
85493>>>        Object oOrderHea_Order_Number is a dbForm
85495>>>            Entry_Item OrderHea.Order_Number
85496>>>            Set Label to "Order Number:"
85497>>>            Set Size to 13 42
85498>>>            Set Location to 4 63
85499>>>            Set peAnchors to anTopLeft
85500>>>            Set Label_Col_Offset to 2
85501>>>            Set Label_Justification_Mode to jMode_Right
85502>>>            
85502>>>        End_Object    // oOrderHea_Order_Number
85503>>>
85503>>>        Object oOrderHea_Customer_Number is a DbParentCombo
85505>>>            Entry_Item Customer.Customer_Number
85506>>>            Set Label to "Customer Number:"
85507>>>            Set Size to 13 42
85508>>>            Set Location to 4 201
85509>>>            Set peAnchors to anTopRight
85510>>>            Set Label_Col_Offset to 2
85511>>>            Set Label_Justification_Mode to jMode_Right
85512>>>            Set psEmptyItemDescription to "???"
85513>>>            // with numbers, not sorting may be preferred
85513>>>            Set Combo_Sort_State to False
85514>>>            // anytime this takes the focus, refill the combo. If the list is very
85514>>>            // large you may not want this. However, if the list is very large you
85514>>>            // may not want parent combos.
85514>>>            Set pbRefillOnFocus to True
85515>>>        End_Object
85516>>>
85516>>>        Object oOrderHea_Order_Date is a dbForm
85518>>>            Entry_Item OrderHea.Order_Date
85519>>>            Set Label to "Order Date:"
85520>>>            Set Size to 13 67
85521>>>            Set Location to 4 299
85522>>>            Set peAnchors to anTopRight
85523>>>            Set Label_Col_Offset to 2
85524>>>            Set Label_Justification_Mode to jMode_Right
85525>>>            
85525>>>            Set Prompt_Object to oMonthCalendarPrompt
85526>>>            Set Prompt_Button_Mode to PB_PromptOn
85527>>>        End_Object    // oOrderHea_Order_Date
85528>>>
85528>>>        Object oCustomer_Name is a dbForm
85530>>>            Entry_Item Customer.Name
85531>>>            Set Label to "Customer Name:"
85532>>>            Set Size to 13 180
85533>>>            Set Location to 18 63
85534>>>            Set peAnchors to anTopLeftRight
85535>>>            Set Label_Col_Offset to 2
85536>>>            Set Label_Justification_Mode to jMode_Right
85537>>>        End_Object    // oCustomer_Name
85538>>>
85538>>>        Object oCustomer_Address is a dbForm
85540>>>            Entry_Item Customer.Address
85541>>>            Set Label to "Street Address:"
85542>>>            Set Size to 13 180
85543>>>            Set Location to 34 63
85544>>>            Set peAnchors to anTopLeftRight
85545>>>            Set Label_Col_Offset to 2
85546>>>            Set Label_Justification_Mode to jMode_Right
85547>>>        End_Object    // oCustomer_Address
85548>>>
85548>>>        Object oCustomer_City is a dbForm
85550>>>            Entry_Item Customer.City
85551>>>            Set Label to "City/State/Zip:"
85552>>>            Set Size to 13 84
85553>>>            Set Location to 49 63
85554>>>            Set peAnchors to anTopLeftRight
85555>>>            Set Label_Col_Offset to 2
85556>>>            Set Label_Justification_Mode to jMode_Right
85557>>>        End_Object    // oCustomer_City
85558>>>
85558>>>        Object oCustomer_State is a dbForm
85560>>>            Entry_Item Customer.State
85561>>>            Set Size to 13 20
85562>>>            Set Location to 49 155
85563>>>            Set peAnchors to anTopRight
85564>>>        End_Object    // oCustomer_State
85565>>>
85565>>>        Object oCustomer_Zip is a dbForm
85567>>>            Entry_Item Customer.Zip
85568>>>            Set Size to 13 60
85569>>>            Set Location to 49 183
85570>>>            Set peAnchors to anTopRight
85571>>>        End_Object    // oCustomer_Zip
85572>>>
85572>>>        Object oOrderHea_Ordered_By is a dbForm
85574>>>            Entry_Item OrderHea.Ordered_By
85575>>>            Set Label to "Ordered By:"
85576>>>            Set Size to 13 67
85577>>>            Set Location to 34 299
85578>>>            Set peAnchors to anTopRight
85579>>>            Set Label_Col_Offset to 2
85580>>>            Set Label_Justification_Mode to jMode_Right
85581>>>        End_Object    // oOrderHea_Ordered_By
85582>>>
85582>>>        Object oOrderHea_Salesperson_ID is a DbParentCombo
85584>>>            Entry_Item Salesp.Id
85585>>>            Set Label to "Sold by:"
85586>>>            Set Size to 11 90
85587>>>            Set Location to 49 276
85588>>>            Set peAnchors to anTopRight
85589>>>            Set Label_Col_Offset to 2
85590>>>            Set Label_Justification_Mode to jMode_Right
85591>>>            Set psEmptyItemDescription to "<none>"
85592>>>            
85592>>>            Procedure OnDefineDescription String ByRef sDescription
85595>>>                Move (trim(Salesp.ID) + " - " * SalesP.Name) to sDescription
85596>>>            End_Procedure
85597>>>        End_Object    // oOrderHea_Salesperson_ID
85598>>>
85598>>>        Object oOrderHea_Terms is a dbComboForm
85600>>>            Entry_Item OrderHea.Terms
85601>>>            Set Label to "Terms:"
85602>>>            Set Size to 13 85
85603>>>            Set Location to 64 63
85604>>>            Set peAnchors to anTopLeft
85605>>>            Set Form_Border to 0
85606>>>            Set Label_Col_Offset to 2
85607>>>            Set Label_Justification_Mode to jMode_Right
85608>>>            Set Entry_State to False
85609>>>
85609>>>        End_Object    // oOrderHea_Terms
85610>>>
85610>>>        Object oOrderHea_Ship_Via is a dbComboForm
85612>>>            Entry_Item OrderHea.Ship_Via
85613>>>            Set Label to "Ship Via:"
85614>>>            Set Size to 13 103
85615>>>            Set Location to 64 183
85616>>>            Set peAnchors to anTopRight
85617>>>            Set Form_Border to 0
85618>>>            Set Label_Col_Offset to 2
85619>>>            Set Label_Justification_Mode to jMode_Right
85620>>>            Set Entry_State to False
85621>>>            
85621>>>
85621>>>        End_Object    // oOrderHea_Ship_Via
85622>>>
85622>>>    End_Object    // oDbContainer3d1
85623>>>
85623>>>    Object oOrderDtl_Grid is a cDbCJGrid
85625>>>        Set Server to OrderDtl_DD
85626>>>        Set Ordering to 1
85627>>>        Set Size to 63 377
85628>>>        Set Location to 90 3
85629>>>        Set peAnchors to anAll
85630>>>        Set pbAllowInsertRow to False
85631>>>        Set pbRestoreLayout to False
85632>>>        Set psLayoutSection to "OrderView_oOrderDtl_Grid2"
85633>>>        Set piLayoutBuild to 6
85634>>>        Set pbHeaderPrompts to True
85635>>>
85635>>>        On_Key Key_F11 Send Request_InsertRow
85636>>>
85636>>>        Object oMark is a cCJGridColumnRowIndicator
85638>>>        End_Object
85639>>>        
85639>>>        Object oInvt_Item_ID is a cDbCJGridColumn
85641>>>            Entry_Item Invt.Item_ID
85642>>>            Set piWidth to 91
85643>>>            Set psCaption to "Item ID"
85644>>>            Set psImage to "ActionPrompt.ico"
85645>>>        End_Object
85646>>>
85646>>>        Object oInvt_Description is a cDbCJGridColumn
85648>>>            Entry_Item Invt.Description
85649>>>            Set piWidth to 213
85650>>>            Set psCaption to "Description"
85651>>>        End_Object
85652>>>
85652>>>        Object oInvt_Unit_Price is a cDbCJGridColumn
85654>>>            Entry_Item Invt.Unit_Price
85655>>>            Set piWidth to 53
85656>>>            Set psCaption to "Unit Price"
85657>>>        End_Object
85658>>>
85658>>>        Object oOrderDtl_Qty_Ordered is a cDbCJGridColumn
85660>>>            Entry_Item OrderDtl.Qty_Ordered
85661>>>            Set piWidth to 50
85662>>>            Set psCaption to "Quantity"
85663>>>        End_Object
85664>>>
85664>>>        Object oOrderDtl_Price is a cDbCJGridColumn
85666>>>            Entry_Item OrderDtl.Price
85667>>>            Set piWidth to 62
85668>>>            Set psCaption to "Price"
85669>>>        End_Object
85670>>>
85670>>>        Object oOrderDtl_Extended_Price is a cDbCJGridColumn
85672>>>            Entry_Item OrderDtl.Extended_Price
85673>>>            Set piWidth to 81
85674>>>            Set psCaption to "Total"
85675>>>        End_Object
85676>>>        
85676>>>    End_Object    // oOrderDtl_Grid
85677>>>
85677>>>    Object oOrderHea_Order_Total is a dbForm
85679>>>        Entry_Item OrderHea.Order_Total
85680>>>        Set Label to "Order Total:"
85681>>>        Set Size to 13 60
85682>>>        Set Location to 156 307
85683>>>        Set peAnchors to anBottomRight
85684>>>        Set Label_Col_Offset to 3
85685>>>        Set Label_Justification_Mode to jMode_Right
85686>>>    End_Object    // oOrderHea_Order_Total
85687>>>
85687>>>    Object oPrintBtn is a Button
85689>>>        Set Label to "Print Order"
85690>>>        Set Location to 156 3
85691>>>        Set peAnchors to anBottomLeft
85692>>>        Set psToolTip to "Print preview of current order"
85693>>>
85693>>>        Procedure OnClick
85696>>>            Delegate Send PrintCurrentOrder // defined in view object
85698>>>        End_Procedure  // OnClick
85699>>>        
85699>>>    End_Object    // oPrintBtn
85700>>>
85700>>>
85700>>>    // Change:   Create custom confirmation messages for save and delete
85700>>>    //           We must create the new functions and assign verify messages
85700>>>    //           to them.
85700>>>    Function Confirm_Delete_Order Returns Integer
85703>>>        Integer iRetVal
85703>>>        Get Confirm "Delete Entire Order?" to iRetVal
85704>>>        Function_Return iRetVal
85705>>>    End_Function
85706>>>    
85706>>>    // Only confirm on the saving of new records
85706>>>    Function Confirm_Save_Order Returns Integer
85709>>>        Integer iNoSave iSrvr
85709>>>        Boolean bOld
85709>>>        Get Server to iSrvr
85710>>>        Get HasRecord of iSrvr to bOld
85711>>>        If not bOld Begin
85713>>>            Get Confirm "Save this NEW order header?" to iNoSave
85714>>>        End
85714>>>>
85714>>>        Function_Return iNoSave
85715>>>    End_Function
85716>>>    
85716>>>    // Define alternate confirmation Messages
85716>>>    Set Verify_Save_MSG       to (RefFunc(Confirm_Save_Order))
85717>>>    Set Verify_Delete_MSG     to (RefFunc(Confirm_Delete_Order))
85718>>>    Set Auto_Clear_DEO_State  to False // don't clear Header on save
85719>>>    
85719>>>    
85719>>>    // print the current order. This message will be sent
85719>>>    // by the print button
85719>>>    Procedure PrintCurrentOrder
85722>>>        Integer hDD iNum
85722>>>        Get Server to hDD // this will be the OrderHea DD
85723>>>        If (HasRecord(hDD)) Begin // only do this if record exists
85725>>>            Get Field_Current_Value of hDD Field OrderHea.Order_Number to iNum
85726>>>//            Send PrintOrder of oOrder_Report iNum
85726>>>            Send Info_Box "This is just a stub and this invoice is not actually being printed" ("Print Order " + String(iNum))
85727>>>        End
85727>>>>
85727>>>    End_Procedure
85728>>>    
85728>>>    // refresh is sent to containers. We will use that to control the print button and only
85728>>>    // enable it when an order exists
85728>>>    Procedure Refresh Integer eMode
85731>>>        Boolean bRec
85731>>>        Handle hoServer
85731>>>        Get Server to hoServer
85732>>>        Get HasRecord of hoServer to bRec
85733>>>        Set Enabled_State of oPrintBtn to bRec
85734>>>    End_Procedure
85735>>>
85735>>>End_Object
85736>    
85736>        Procedure Activate_About
85739>            Send DoAbout "Order Entry Sample Application" "18.2.1.0" "Copyright (c) 2016 Data Access Corporation" "Data Access Worldwide" ""
85740>        End_Procedure
85741>    
85741>    End_Object
85742>
85742>
85742>End_Object
85743>
85743>// open Order Entry view on application startup
85743>Send Activate_oOrderEntryView of (oClientArea(oMain))
85744>Start_UI
85745>
Summary
Memory Available: 2147483646
Total Warnings : 0
Total Errors   : 0
Total Symbols  : 47275
Total Resources: 0
Total Commands : 85744
Total Windows  : 5
Total Pages    : 4
Static Data    : 536765
Message area   : 609579
Total Blocks   : 30622
