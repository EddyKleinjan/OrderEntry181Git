Compiling Program: C:\Test\Order Entry git\AppSrc\Order.src
Memory Available: 2147483646
1>Use OrderPrecompile.pkg
Using pre-compiled package ORDERPRECOMPILE.PKG
Including file: OrderPrecompile.pkd    (C:\Test\Order Entry git\AppSrc\OrderPrecompile.pkd)
75734>
75734>Use DfAllent.pkg
75734>Use cCJStandardCommandBarSystem.pkg
75734>Use cToolTipController.pkg
75734>Use cCJCommandBarSystem.pkg
75734>
75734>Object oHtmlHelp is a cHtmlHelp
75736>End_Object
75737>
75737>Object oApplication is a cApplication
75739>    Set psCompany to "Data Access Worldwide"
75740>    Set psProduct to "DataFlex Examples"
75741>    Set psVersion to "18.2"
75742>    Set psProgram to "Order"
75743>    Set psHelpFile to "Examples.chm"
75744>    Set peHelpType to htHtmlHelp
75745>End_Object
75746>
75746>Object oToolTipController is a cToolTipController
75748>    Move Self to ghoToolTipController
75749>End_Object
75750>
75750>Use oEditContextMenu.pkg
Including file: oEditContextMenu.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\oEditContextMenu.pkg)
75750>>>Use cCJStandardMenuItemClasses.pkg
75750>>>
75750>>>Object oEditContextMenu is a cCJContextMenu
75752>>>    
75752>>>    Move Self to Default_Form_Floating_Menu_ID
75753>>>    
75753>>>    Object oUndoMenuItem is a cCJUndoMenuItem
75755>>>    End_Object
75756>>>    
75756>>>    Object oCutMenuItem is a cCJCutMenuItem
75758>>>        Set pbControlBeginGroup to True
75759>>>    End_Object
75760>>>    
75760>>>    Object oCopyMenuItem is a cCJCopyMenuItem
75762>>>    End_Object
75763>>>
75763>>>    Object oPasteMenuItem is a cCJPasteMenuItem
75765>>>    End_Object
75766>>>
75766>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
75768>>>    End_Object
75769>>>
75769>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
75771>>>        Set pbControlBeginGroup to True
75772>>>    End_Object
75773>>>
75773>>>End_Object
75774>>>
75774>Use oDEOEditContextMenu17.pkg
Including file: oDEOEditContextMenu17.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\oDEOEditContextMenu17.pkg)
75774>>>Use Windows.pkg
75774>>>Use cCJStandardMenuItemClasses.pkg
75774>>>Use cCJDeoMenuItemClasses.pkg
75774>>>
75774>>>
75774>>>Object oDEOEditContextMenu17 is a cCJContextMenu
75776>>>    
75776>>>    Move Self to Default_dbFloating_Menu_ID
75777>>>    
75777>>>    Object oUndoMenuItem is a cCJUndoMenuItem
75779>>>    End_Object
75780>>>    
75780>>>    Object oCutMenuItem is a cCJCutMenuItem
75782>>>        Set pbControlBeginGroup to True
75783>>>    End_Object
75784>>>    
75784>>>    Object oCopyMenuItem is a cCJCopyMenuItem
75786>>>    End_Object
75787>>>
75787>>>    Object oPasteMenuItem is a cCJPasteMenuItem
75789>>>    End_Object
75790>>>
75790>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
75792>>>    End_Object
75793>>>
75793>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
75795>>>        Set pbControlBeginGroup to True
75796>>>    End_Object
75797>>>
75797>>>    Object oPromptMenuItem is a cCJPromptMenuItem
75799>>>        Set pbControlBeginGroup to True
75800>>>    End_Object
75801>>>
75801>>>    Object oFindNextMenu is a cCJFindNextMenuItem
75803>>>        Set pbControlBeginGroup to True
75804>>>    End_Object
75805>>>
75805>>>    Object oFindPreviousMenu is a cCJFindPreviousMenuItem
75807>>>    End_Object
75808>>>
75808>>>    Object oClearMenuItem is a cCJClearMenuItem
75810>>>        Set pbControlBeginGroup to True
75811>>>    End_Object
75812>>>
75812>>>    Object oClearAllMenu is a cCJClearAllMenuItem
75814>>>    End_Object
75815>>>
75815>>>    Object oSaveMenu is a cCJSaveMenuItem
75817>>>    End_Object
75818>>>    
75818>>>    Object oDeleteMenu is a cCJDeleteMenuItem
75820>>>    End_Object
75821>>>
75821>>>    Object oRememberitem is a cCJRememberFieldMenuItem
75823>>>        Set pbControlBeginGroup to True
75824>>>    End_Object
75825>>>
75825>>>    Object oRetainItem is a cCJRememberLastFieldMenuItem
75827>>>    End_Object
75828>>>
75828>>>    Object oUnRememberitem is a cCJUnRememberFieldMenuItem
75830>>>    End_Object
75831>>>
75831>>>    Object oCJClearAllDynamicDefaults is a cCJUnRememberFieldAllMenuItem
75833>>>    End_Object
75834>>>
75834>>>End_Object
75835>
75835>Object oMain is a Panel
75837>    Set Label to "Order Entry Sample Application In Git"
75838>    Set Location to 4 3
75839>    Set Size to 300 450
75840>
75840>    Object oCommandBarSystem is a cCJCommandBarSystem
75842>    
75842>        Set pbTimerUpdate to True
75843>    
75843>        Procedure OnCreateCommandBars
75846>            Handle hoOptions
75846>            Get OptionsObject to hoOptions
75847>            Forward Send OnCreateCommandBars
75849>        End_Procedure
75850>    
75850>        Object oMenuBar is a cCJMenuBar
75852>            
75852>            Object oFileMenu is a cCJMenuItem
75854>                
75854>                Set peControlType to xtpControlPopup          
75855>                Set psCaption   to "&File"
75856>                Set psDescription to "Find, Save, Delete, Clear information or quit this application."
75857>                Set psCategory to "Menus"
75858>    
75858>                Object oClearMenuItem is a cCJClearMenuItem
75860>                    Set pbAddToDesignerMenu to True
75861>                End_Object
75862>    
75862>                Object oClearAllMenu is a cCJClearAllMenuItem
75864>                    Set pbAddToDesignerMenu to True
75865>                End_Object
75866>    
75866>                Object oPromptMenuItem is a cCJPromptMenuItem
75868>                    Set pbAddToDesignerMenu to True
75869>                    Set pbControlBeginGroup to True
75870>                End_Object
75871>    
75871>                Object oFindMenuItem is a cCJFindMenuItem
75873>                    Set pbAddToDesignerMenu to True
75874>                    Set pbControlBeginGroup to True
75875>                End_Object
75876>    
75876>                Object oFindNextMenu is a cCJFindNextMenuItem
75878>                    Set pbAddToDesignerMenu to True
75879>                End_Object
75880>    
75880>                Object oFindPreviousMenu is a cCJFindPreviousMenuItem
75882>                    Set pbAddToDesignerMenu to True
75883>                End_Object
75884>    
75884>                Object oFindFirstMenu is a cCJFindFirstMenuItem
75886>                    Set pbAddToDesignerMenu to True
75887>                End_Object
75888>    
75888>                Object oFindLastMenu is a cCJFindLastMenuItem
75890>                    Set pbAddToDesignerMenu to True
75891>                End_Object
75892>    
75892>                Object oSaveMenuItem is a cCJSaveMenuItem
75894>                    Set pbAddToDesignerMenu to True
75895>                    Set pbControlBeginGroup to True
75896>                End_Object
75897>    
75897>                Object oDeleteMenuItem is a cCJDeleteMenuItem
75899>                    Set pbAddToDesignerMenu to True
75900>                End_Object
75901>    
75901>                Object oExitMenu is a cCJExitMenuItem
75903>                    Set pbControlBeginGroup to True
75904>                End_Object
75905>    
75905>            End_Object
75906>            
75906>            Object oViewMenu is a cCJMenuItem
75908>                
75908>                Set peControlType to xtpControlPopup
75909>                Set psCaption to "&View"
75910>                Set psToolTip to "View"
75911>                Set psDescription to "Available Views"
75912>    
75912>                Object oCustomerEntryViewMenuItem is a cCJMenuItem
75914>                    Set psCaption to "Customer Entry View"
75915>                    Set psShortcut to "Ctrl+1"
75916>                    Set psDescription to "Add, edit and delete Customer data."
75917>                    Set psToolTip to "Customer Entry View"
75918>                
75918>                    Procedure OnExecute Variant vCommandBarControl
75921>                        Handle hoClient
75921>                        Get Client_Id to hoClient
75922>                        Send Activate_oCustomerView of hoClient
75923>                    End_Procedure
75924>                End_Object
75925>    
75925>                Object oInventoryItemViewMenuItem is a cCJMenuItem
75927>                    Set psCaption to "Inventory Item View"
75928>                    Set psShortcut to "Ctrl+2"
75929>                    Set psDescription to "Add, edit and delete Inventory data."
75930>                    Set psToolTip to "Inventory Item View"
75931>                
75931>                    Procedure OnExecute Variant vCommandBarControl
75934>                        Handle hoClient
75934>                        Get Client_Id to hoClient
75935>                        Send Activate_oInventoryView of hoClient
75936>                    End_Procedure
75937>                End_Object
75938>    
75938>                Object oOrderEntryMenuItem is a cCJMenuItem
75940>                    Set psCaption to "Order Entry"
75941>                    Set psShortcut to "Ctrl+3"
75942>                    Set psDescription to "Add, edit and delete Order data."
75943>                    Set psToolTip to "Order Entry"
75944>                
75944>                    Procedure OnExecute Variant vCommandBarControl
75947>                        Handle hoClient
75947>                        Get Client_Id to hoClient
75948>                        Send Activate_oOrderEntryView of hoClient
75949>                    End_Procedure
75950>                End_Object
75951>    
75951>                Object oSalesPersonEntryViewMenuItem is a cCJMenuItem
75953>                    Set psCaption to "Sales Person Entry View"
75954>                    Set psShortcut to "Ctrl+4"
75955>                    Set psDescription to "Add, edit and delete Sales Person data."
75956>                    Set psToolTip to "Sales Person Entry View"
75957>                
75957>                    Procedure OnExecute Variant vCommandBarControl
75960>                        Handle hoClient
75960>                        Get Client_Id to hoClient
75961>                        Send Activate_oSalesPersonView of hoClient
75962>                    End_Procedure
75963>                End_Object
75964>    
75964>                Object oVendorEntryViewMenuItem is a cCJMenuItem
75966>                    Set psCaption to "Vendor Entry View"
75967>                    Set psShortcut to "Ctrl+5"
75968>                    Set psDescription to "Add, edit and delete Vendor data."
75969>                    Set psToolTip to "Vendor Entry View"
75970>                
75970>                    Procedure OnExecute Variant vCommandBarControl
75973>                        Handle hoClient
75973>                        Get Client_Id to hoClient
75974>                        Send Activate_oVendorView of hoClient
75975>                    End_Procedure
75976>                End_Object
75977>    
75977>            End_Object
75978>            
75978>            Object oReportMenu is a cCJMenuItem
75980>                
75980>                Set peControlType to xtpControlPopup          
75981>                Set psCaption to "&Report"
75982>                Set psToolTip to "Report"
75983>                Set psDescription to "Available Reports"
75984>    
75984>                Object oBasicReportsMenuItem is a cCJMenuItem
75986>                    Set psCaption to "Basic Reports"
75987>                    Set peControlType to xtpControlPopup
75988>                    Set psToolTip to "Basic Reports"
75989>                    Set psDescription to "Reports based on the Basic Report class."
75990>    
75990>                    Object oCustomerListMenuItem is a cCJMenuItem
75992>                        Set psCaption to "Customer List"
75993>                        Set psToolTip to "Customer List (Basic)"
75994>                    
75994>                        Procedure OnExecute Variant vCommandBarControl
75997>                            Handle hoClient
75997>                            Get Client_Id to hoClient
75998>                            Send Activate_oCustomerListBR of hoClient
75999>                        End_Procedure
76000>                    End_Object
76001>                End_Object
76002>    
76002>                Object oWinPrintReportsMenuItem is a cCJMenuItem
76004>                    Set psCaption to "WinPrint Reports"
76005>                    Set peControlType to xtpControlPopup
76006>                    Set psToolTip to "WinPrint Reports"
76007>                    Set psDescription to "Reports based on the WinPrint class."
76008>    
76008>                    Object oCustomerListMenuItem2 is a cCJMenuItem
76010>                        Set psCaption to "Customer List"
76011>                        Set psShortcut to "Ctrl+6"
76012>                        Set psToolTip to "Customer List (WinPrint)"
76013>                        Set psDescription to "Print Customer data."
76014>                    
76014>                        Procedure OnExecute Variant vCommandBarControl
76017>                            Handle hoClient
76017>                            Get Client_Id to hoClient
76018>                            Send Activate_oCustomerListWP of hoClient
76019>                        End_Procedure
76020>                    End_Object
76021>    
76021>                    Object oItemsperOrderMenuItem is a cCJMenuItem
76023>                        Set psCaption to "Items per Order"
76024>                        Set psShortcut to "Ctrl+7"
76025>                        Set psToolTip to "Items per Order (WinPrint)"
76026>                        Set psDescription to "Print line items for all Orders."
76027>                    
76027>                        Procedure OnExecute Variant vCommandBarControl
76030>                            Handle hoClient
76030>                            Get Client_Id to hoClient
76031>                            Send Activate_oItemsPerOrderWP of hoClient
76032>                        End_Procedure
76033>                    End_Object
76034>    
76034>                    Object oOrdersbyCustomerMenuItem1 is a cCJMenuItem
76036>                        Set psCaption to "Orders by Customer"
76037>                        Set psShortcut to "Ctrl+8"
76038>                        Set psToolTip to "Orders by Customer (WinPrint)"
76039>                        Set psDescription to "Print Order data sorted by Customer."
76040>                    
76040>                        Procedure OnExecute Variant vCommandBarControl
76043>                            Handle hoClient
76043>                            Get Client_Id to hoClient
76044>                            Send Activate_oOrdersByCustomerWP of hoClient
76045>                        End_Procedure
76046>                    End_Object
76047>    
76047>                    Object oOrdersbyOrderNumberMenuItem is a cCJMenuItem
76049>                        Set psCaption to "Orders by Order Number"
76050>                        Set psShortcut to "Ctrl+9"
76051>                        Set psToolTip to "Orders by Order Number (WinPrint)"
76052>                        Set psDescription to "Print Order data."
76053>                    
76053>                        Procedure OnExecute Variant vCommandBarControl
76056>                            Handle hoClient
76056>                            Get Client_Id to hoClient
76057>                            Send Activate_oOrdersWP of hoClient
76058>                        End_Procedure
76059>                    End_Object
76060>                End_Object
76061>    
76061>            End_Object
76062>                        
76062>            Object oNavigateMenu is a cCJMenuItem
76064>                Set peControlType to xtpControlPopup      
76065>                Set psCaption to "&Navigate"    
76066>                Set psTooltip to "Navigate"    
76067>                Set psDescription to "Move to different areas of the application"
76068>                
76068>                Object oNextAreaMenu is a cCJNextAreaMenu
76070>                End_Object
76071>                
76071>                Object oPriorAreaMenu is a cCJPriorAreaMenu
76073>                End_Object
76074>                
76074>                Object oNextViewMenu is a cCJNextViewMenu
76076>                End_Object
76077>                
76077>                Object oPriorViewMenu is a cCJPriorViewMenu
76079>                End_Object
76080>                
76080>                Object oPromptMenu is a cCJPromptMenuItem
76082>                    Set pbControlBeginGroup to True
76083>                End_Object
76084>    
76084>                Object oZoomMenu is a cCJZoomMenuItem
76086>                End_Object
76087>    
76087>            End_Object
76088>    
76088>            Object oWindowMenu is a cCJMDIWindowsMenuItem
76090>                Set peControlType to xtpControlPopup      
76091>                Set psCaption to "&Window"
76092>                Set psToolTip to "Window"
76093>                Set psDescription to "Display Current Views and set other display options."    
76094>                
76094>                // These are the static windows items. More will be created in onInitPopup 
76094>                Object oDisplayOptionsMenu is a cCJMenuItem
76096>                    Set peControlType to xtpControlPopup          
76097>                    Set psCaption to "&Display Options"
76098>                    Set psToolTip to "Display Options"
76099>                    Set psDescription to "Set display options"
76100>    
76100>                    Object oStatusbarMenu is a cCJStatusbarMenuItem
76102>                    End_Object
76103>    
76103>                    Object oAutoArrangeIconsMenu is a cCJAutoArrangeIconsMenuItem
76105>                    End_Object
76106>    
76106>                    Object oRestoreMenusMenu is a cCJRestoreMenusMenuItem
76108>                        Set pbControlBeginGroup to True
76109>                    End_Object
76110>                    
76110>                End_Object
76111>        
76111>                Object oCascadeMenu is a cCJCascadeMenuItem
76113>                    Set pbControlBeginGroup to True
76114>                End_Object
76115>    
76115>                Object oHorizTile is a cCJTileHorizontally
76117>                End_Object
76118>    
76118>                Object oVertTile is a cCJTileVertically
76120>                End_Object
76121>    
76121>                Object oMinimizeMenuItem is a cCJMinimizeWindowsMenuItem
76123>                    Set pbControlBeginGroup to True
76124>                End_Object
76125>    
76125>                Object oRestoreMenuItem is a cCJRestoreWindowsMenuItem
76127>                End_Object
76128>    
76128>                Object oArrangeIconsMenuItem is a cCJAutoArrangeIconsMenuItem
76130>                    Set pbControlBeginGroup to True
76131>                End_Object
76132>    
76132>            End_Object
76133>
76133>            Object oDemoMenuItem is a cCJMenuItem
76135>                Set psCaption to "&Demo"
76136>                Set psTooltip to "&Demo"
76137>                Set peControlType to xtpControlPopup
76138>                
76138>                Object oParentComboDemoMenuItem is a cCJMenuItem
76140>                    Set psCaption to "Parent Combo Demo"
76141>                    Set psTooltip to "Parent Combo Demo"
76142>                
76142>                    Procedure OnExecute Variant vCommandBarControl
76145>                        Handle hoClient
76145>                        Get Client_Id to hoClient
76146>                        Send Activate_oDemoParentCombos of hoClient
76147>                    End_Procedure
76148>                End_Object
76149>
76149>                Object oSuggestionFormMenuItem is a cCJMenuItem
76151>                    Set psCaption to "Suggestion Form"
76152>                    Set psTooltip to "Suggestion Form"
76153>                
76153>                    Procedure OnExecute Variant vCommandBarControl
76156>                        Handle hoClient
76156>                        Get Client_Id to hoClient
76157>                        Send Activate_oDemoSuggestionForm of hoClient
76158>                    End_Procedure
76159>                End_Object
76160>
76160>                Object oButtonSamplesMenuItem is a cCJMenuItem
76162>                    Set psCaption to "Button Samples"
76163>                    Set psTooltip to "Button Samples"
76164>                
76164>                    Procedure OnExecute Variant vCommandBarControl
76167>                        Handle hoClient
76167>                        Get Client_Id to hoClient
76168>                        Send Activate_oButtonTest of hoClient
76169>                    End_Procedure
76170>                End_Object
76171>
76171>                Object oCalendarControlSampleMenuItem is a cCJMenuItem
76173>                          Set psCaption to "Calendar Control Sample"
76174>                          Set psTooltip to "Calendar Control Sample"
76175>                
76175>                          Procedure OnExecute Variant vCommandBarControl
76178>                                    Handle hoClient
76178>                                    Get Client_Id to hoClient
76179>                                    Send Activate_oDemoCalendarControl of hoClient
76180>                          End_Procedure
76181>                End_Object
76182>            End_Object
76183>            
76183>            Object oHelpMenu is a cCJMenuItem
76185>                Set peControlType to xtpControlPopup    
76186>                Set psCaption to "&Help"
76187>                Set psDescription to "Access Information for learning and using this DataFlex application."
76188>                Set psToolTip to "Help"
76189>                
76189>                Object oHelpMenuItem is a cCJHelpMenuItem 
76191>                End_Object
76192>    
76192>                Object oAboutMenuItem is a cCJAboutMenuItem
76194>                End_Object
76195>           
76195>            End_Object
76196>    
76196>        End_Object
76197>    
76197>        Object oFindToolBar is a cCJToolbar
76199>            Set psTitle to "Finding Toolbar"
76200>    
76200>            Object oFindFirstTool is a cCJFindFirstMenuItem
76202>            End_Object
76203>    
76203>            Object oFindPreviousTool is a cCJFindPreviousMenuItem
76205>            End_Object
76206>    
76206>            Object oFindMenuTool is a cCJFindMenuItem
76208>            End_Object
76209>    
76209>            Object oFindNextTool is a cCJFindNextMenuItem
76211>            End_Object
76212>    
76212>            Object oFindLastTool is a cCJFindLastMenuItem
76214>            End_Object
76215>    
76215>            Object oPromptToolItem is a cCJPromptMenuItem
76217>                Set pbControlBeginGroup to True
76218>            End_Object
76219>    
76219>        End_Object
76220>            
76220>        Object oFileToolBar is a cCJToolbar
76222>            Set psTitle to "Data Entry Toolbar"
76223>    
76223>            Object oClearToolItem is a cCJClearMenuItem
76225>                Set peControlStyle to xtpButtonIconAndCaption
76226>            End_Object
76227>            
76227>            Object oClearAllToolItem2 is a cCJClearAllMenuItem
76229>                Set peControlStyle to xtpButtonIconAndCaption
76230>            End_Object
76231>                
76231>            Object oSaveToolItem is a cCJSaveMenuItem
76233>                Set peControlStyle to xtpButtonIconAndCaption
76234>                Set pbControlBeginGroup to True
76235>            End_Object
76236>    
76236>            Object oDeleteToolItem is a cCJDeleteMenuItem
76238>                Set peControlStyle to xtpButtonIconAndCaption
76239>            End_Object
76240>    
76240>        End_Object
76241>    
76241>        Object oEditToolBar is a cCJToolbar
76243>            Set psTitle to "Edit Toolbar"
76244>            
76244>            Object oCutToolbarItem is a cCJCutMenuItem
76246>            End_Object
76247>    
76247>            Object oCopyToolbarItem is a cCJCopyMenuItem
76249>            End_Object
76250>    
76250>            Object oPasteToolbarItem is a cCJPasteMenuItem
76252>            End_Object
76253>    
76253>            Object oDeleteEditToolbarItem is a cCJDeleteEditMenuItem
76255>                Set pbControlBeginGroup to True
76256>            End_Object
76257>    
76257>        End_Object
76258>                
76258>        Object oRememberToolbar is a cCJToolbar
76260>            Set psTitle to "Remember Toolbar"
76261>
76261>            Object oRememberItems is a cCJMenuItem
76263>
76263>                Set peControlType to xtpControlPopup
76264>                Set peControlStyle to xtpButtonCaption
76265>                Set psCaption to C_$Remember
76266>                
76266>                Object oMenuItem is a cCJRememberFieldMenuItem
76268>                    Set peControlStyle to xtpButtonIconAndCaption
76269>                End_Object
76270>                
76270>                Object oMenuItem is a cCJRememberLastFieldMenuItem
76272>                    Set peControlStyle to xtpButtonIconAndCaption
76273>                End_Object
76274>                
76274>                Object oMenuItem is a cCJUnRememberFieldMenuItem
76276>                    Set peControlStyle to xtpButtonIconAndCaption
76277>                End_Object
76278>                
76278>                Object oMenuItem is a cCJUnRememberFieldAllMenuItem
76280>                    Set peControlStyle to xtpButtonIconAndCaption
76281>                End_Object
76282>
76282>            End_Object
76283>
76283>        End_Object
76284>
76284>
76284>        Object oStatusBar is a cCJStatusBar
76286>            
76286>            Object oStatusPane1 is a cCJStatusBarPane
76288>                Set piID to sbpIDIdlePane
76289>                Set pbStyleStretch to True
76290>            End_Object
76291>    
76291>            Object oStatusPane2 is a cCJStatusBarPane
76293>                Set phoViewPane to Self
76294>                Set pbStyleStretch to True
76295>            End_Object
76296>    
76296>        End_Object
76297>    
76297>    End_Object
76298>
76298>    Object oClientArea is a ClientArea
76300>        Use Customer.vw
Including file: Customer.vw    (C:\Test\Order Entry git\AppSrc\Customer.vw)
76300>>>Use dfClient.pkg
76300>>>Use DataDict.pkg
76300>>>Use dfEntry.pkg
76300>>>Use dfTabDlg.pkg
76300>>>Use dfCEntry.pkg
76300>>>Use cDbTextEdit.Pkg
76300>>>Use Customer.DD
Including file: Customer.dd    (C:\Test\Order Entry git\DDSrc\Customer.dd)
76300>>>>>Use Windows.pkg           // Basic Definitions
76300>>>>>Use DataDict.pkg          // DataDictionary Class Definition
76300>>>>>Use DDvalTbl.pkg          // Validation Table Class Definitions
76300>>>>>
76300>>>>>Open Customer
Including file: Customer.fd    (C:\Test\Order Entry git\DDSrc\Customer.fd)
76302>>>>>Open OrderHea
Including file: OrderHea.fd    (C:\Test\Order Entry git\DDSrc\OrderHea.fd)
76304>>>>>Open Ordsys
Including file: OrdSys.fd    (C:\Test\Order Entry git\DDSrc\OrdSys.fd)
76306>>>>>
76306>>>>>
76306>>>>>Register_Object Customer_State_VT
76306>>>>>Register_Object Customer_sl
76306>>>>>
76306>>>>>Object Customer_State_VT  is a CodeValidationTable
76308>>>>>    Set Type_Value        To "STATES"
76309>>>>>    Set Table_Title       To "States"
76310>>>>>End_Object   // Customer_State_VT
76311>>>>>
76311>>>>>Register_Function ValidateEmail Integer iColumn String sValue Returns Boolean
76311>>>>>
76311>>>>>Class Customer_DataDictionary Is A DataDictionary
76312>>>>>
76312>>>>>    Procedure Construct_Object
76314>>>>>        Forward Send Construct_Object
76316>>>>>
76316>>>>>        Set Main_File To Customer.File_Number
76317>>>>>        Set Cascade_Delete_State To False
76318>>>>>
76318>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_FINDREQ to True
76319>>>>>        Set Foreign_Field_Option DD_INDEXFIELD DD_NOPUT to True
76320>>>>>        Set Foreign_Field_Option DD_DEFAULT DD_DISPLAYONLY to True
76321>>>>>
76321>>>>>        Set Add_Client_File to OrderHea.File_Number
76322>>>>>
76322>>>>>        Set Add_System_File to Ordsys.File_Number DD_LOCK_ON_NEW_SAVE
76323>>>>>
76323>>>>>        Set Field_Auto_Increment Field Customer.Customer_Number to File_Field Ordsys.Cust_Number
76324>>>>>        Set Field_Label_Long Field Customer.Customer_Number To "Customer Number"
76325>>>>>        Set Field_Label_Short Field Customer.Customer_Number To "Number"
76326>>>>>        Set Field_Option Field Customer.Customer_Number DD_AUTOFIND to True
76327>>>>>        Set Field_Option Field Customer.Customer_Number DD_NOPUT to True
76328>>>>>        Set Field_Prompt_Object Field Customer.Customer_Number to Customer_sl
76329>>>>>        Set Key_Field_State Field Customer.Customer_Number To True
76330>>>>>        Set Status_Help Field Customer.Customer_Number To "Customer Id Number (system assigned)."
76331>>>>>
76331>>>>>        Set Field_Label_Long Field Customer.Name To "Customer Name"
76332>>>>>        Set Field_Label_Short Field Customer.Name To "Customer Name"
76333>>>>>        Set Field_Option Field Customer.Name DD_REQUIRED to True
76334>>>>>        Set Field_Prompt_Object Field Customer.Name to Customer_sl
76335>>>>>        Set Status_Help Field Customer.Name To "Customer/Company Name."
76336>>>>>
76336>>>>>        Set Field_Label_Long Field Customer.Address To "Street Address"
76337>>>>>        Set Field_Label_Short Field Customer.Address To "Address"
76338>>>>>        Set Status_Help Field Customer.Address To "Street Address."
76339>>>>>
76339>>>>>        Set Status_Help Field Customer.City To "City Name."
76340>>>>>
76340>>>>>        Set Field_Class_Name Field Customer.State To "dbComboForm"
76341>>>>>        Set Field_Label_Long Field Customer.State To "State"
76342>>>>>        Set Field_Label_Short Field Customer.State To "St."
76343>>>>>        Set Field_Option Field Customer.State DD_CAPSLOCK to True
76344>>>>>        Set Field_Value_Table Field Customer.State to Customer_State_VT
76345>>>>>        Set Status_Help Field Customer.State To "Two letter state ID."
76346>>>>>
76346>>>>>        Set Field_Label_Long Field Customer.Zip To "Zip/Postal Code"
76347>>>>>        Set Field_Label_Short Field Customer.Zip To "Zip"
76348>>>>>        Set Field_Mask Field Customer.Zip To "#####-####"
76349>>>>>        Set Field_Mask_Type Field Customer.Zip To MASK_WINDOW
76350>>>>>        Set Status_Help Field Customer.Zip To "Zip or Postal Code."
76351>>>>>
76351>>>>>        Set Field_Label_Long Field Customer.Phone_Number To "Phone Number"
76352>>>>>        Set Field_Label_Short Field Customer.Phone_Number To "Phone"
76353>>>>>        Set Status_Help Field Customer.Phone_Number To "Phone Number."
76354>>>>>
76354>>>>>        Set Field_Label_Long Field Customer.Fax_Number To "Fax Number"
76355>>>>>        Set Field_Label_Short Field Customer.Fax_Number To "Fax"
76356>>>>>        Set Status_Help Field Customer.Fax_Number To "Fax Phone Number."
76357>>>>>
76357>>>>>        Set Field_Label_Long Field Customer.Email_Address To "E-Mail Address"
76358>>>>>        Set Field_Label_Short Field Customer.Email_Address To "E-Mail"
76359>>>>>        Set Status_Help Field Customer.Email_Address To "E-mail Address (internet)."
76360>>>>>        Set Field_Validate_msg Field Customer.EMail_Address to (RefFunc(ValidateEmail))
76361>>>>>        Set Field_Option Field Customer.EMail_Address DD_REQUIRED to True
76362>>>>>
76362>>>>>        Set Field_Class_Name Field Customer.Credit_Limit To "dbSpinForm"
76363>>>>>        Set Field_Mask_Type Field Customer.Credit_Limit To MASK_CURRENCY_WINDOW
76364>>>>>
76364>>>>>        Set Field_Label_Long Field Customer.Purchases To "Total Purchases"
76365>>>>>        Set Field_Label_Short Field Customer.Purchases To "Purchases"
76366>>>>>        Set Field_Mask_Type Field Customer.Purchases To MASK_CURRENCY_WINDOW
76367>>>>>        Set Field_Option Field Customer.Purchases DD_DISPLAYONLY to True
76368>>>>>
76368>>>>>        Set Field_Label_Long Field Customer.Balance To "Balance Due"
76369>>>>>        Set Field_Label_Short Field Customer.Balance To "Balance"
76370>>>>>        Set Field_Mask_Type Field Customer.Balance To MASK_CURRENCY_WINDOW
76371>>>>>        Set Field_Option Field Customer.Balance DD_DISPLAYONLY to True
76372>>>>>
76372>>>>>        Set Status_Help Field Customer.Comments To "Additional Comments and Notes."
76373>>>>>
76373>>>>>        Set Field_Checkbox_Values Field Customer.Status To "Y" "N"
76374>>>>>        Set Field_Label_Long Field Customer.Status To "Active Status"
76375>>>>>        Set Field_Label_Short Field Customer.Status To "Status"
76376>>>>>        Set Status_Help Field Customer.Status To "Active Inactive Status of customer"
76377>>>>>
76377>>>>>    End_Procedure  //  Construct_Object
76378>>>>>
76378>>>>>    Procedure Field_defaults
76380>>>>>        Forward Send Field_Defaults
76382>>>>>        Set Field_Changed_Value   Field Customer.State To "FL"
76383>>>>>        Set Field_Changed_Value   Field Customer.Credit_Limit To 1000
76384>>>>>        Set Field_Changed_Value   Field Customer.Status To "Y"
76385>>>>>    End_Procedure
76386>>>>>
76386>>>>>    //
76386>>>>>    //  Validates if the field contains a valid email address (it allows empty values to).
76386>>>>>    //
76386>>>>>    Function ValidateEmail Integer iColumn String sValue Returns Boolean
76388>>>>>        Integer iAt iDot
76388>>>>>        Boolean bResult
76388>>>>>        
76388>>>>>        If (Trim(sValue) <> "") Begin
76390>>>>>            Move (Pos("@", sValue)) to iAt
76391>>>>>            Move (RightPos(".", sValue)) to iDot
76392>>>>>            
76392>>>>>            If (not(iAt > 1 and iDot > 0 and iDot > iAt + 1 and iDot < Length(sValue))) Begin
76394>>>>>                Send Data_set_error iColumn DFERR_OPERATOR "Please enter a valid email address"
76395>>>>>                Move True to bResult
76396>>>>>            End
76396>>>>>>
76396>>>>>        End
76396>>>>>>
76396>>>>>        
76396>>>>>        Function_Return bResult
76397>>>>>    End_Function
76398>>>>>
76398>>>>>End_Class    //  Customer_DataDictionary
76399>>>>>
76399>>>>>
76399>>>>>Use Customer.sl      // Customer_sl
Including file: Customer.sl    (C:\Test\Order Entry git\AppSrc\Customer.sl)
76399>>>>>>>Use DFClient.pkg
76399>>>>>>>Use DFSelLst.pkg
76399>>>>>>>Use Windows.pkg
76399>>>>>>>Use cDbCJGridPromptList.pkg
76399>>>>>>>
76399>>>>>>>Use Customer.DD
76399>>>>>>>
76399>>>>>>>CD_Popup_Object Customer_sl is a dbModalPanel
76417>>>>>>>>
76417>>>>>>>
76417>>>>>>>    Set Border_Style to Border_Thick
76418>>>>>>>    Set Minimize_Icon to False
76419>>>>>>>    Set Label to "Customer List"
76420>>>>>>>    Set Size to 134 238
76421>>>>>>>    Set Location to 4 5
76422>>>>>>>    Set piMinSize to 134 238
76423>>>>>>>
76423>>>>>>>    Object Customer_DD is a Customer_DataDictionary
76425>>>>>>>    End_Object    // Customer_DD
76426>>>>>>>
76426>>>>>>>    Set Main_DD to Customer_DD
76427>>>>>>>    Set Server to Customer_DD
76428>>>>>>>
76428>>>>>>>    Object oSelList is a cDbCJGridPromptList
76430>>>>>>>        Set Size to 100 224
76431>>>>>>>        Set Location to 9 8
76432>>>>>>>        Set peAnchors to anAll
76433>>>>>>>        Set pbAllowColumnRemove to False
76434>>>>>>>
76434>>>>>>>        Object oNumber is a cDbCJGridColumn
76436>>>>>>>            Entry_Item Customer.Customer_Number
76437>>>>>>>            Set piWidth to 93
76438>>>>>>>            Set psCaption to "Number"
76439>>>>>>>        End_Object
76440>>>>>>>
76440>>>>>>>        Object oCustomerName is a cDbCJGridColumn
76442>>>>>>>            Entry_Item Customer.Name
76443>>>>>>>            Set piWidth to 243
76444>>>>>>>            Set psCaption to "Customer Name"
76445>>>>>>>        End_Object
76446>>>>>>>    End_Object  // oSelList
76447>>>>>>>
76447>>>>>>>    Object oOK_bn is a Button
76449>>>>>>>        Set Label to "&Ok"
76450>>>>>>>        Set Location to 116 77
76451>>>>>>>        Set peAnchors to anBottomRight
76452>>>>>>>
76452>>>>>>>        Procedure OnClick
76455>>>>>>>            Send OK of oSelList
76456>>>>>>>        End_Procedure
76457>>>>>>>
76457>>>>>>>    End_Object    // oOK_bn
76458>>>>>>>
76458>>>>>>>    Object oCancel_bn is a Button
76460>>>>>>>        Set Label to "&Cancel"
76461>>>>>>>        Set Location to 116 130
76462>>>>>>>        Set peAnchors to anBottomRight
76463>>>>>>>
76463>>>>>>>        Procedure OnClick
76466>>>>>>>            Send Cancel of oSelList
76467>>>>>>>        End_Procedure
76468>>>>>>>
76468>>>>>>>    End_Object    // oCancel_bn
76469>>>>>>>
76469>>>>>>>    Object oSearch_bn is a Button
76471>>>>>>>        Set Label to "&Search..."
76472>>>>>>>        Set Location to 116 183
76473>>>>>>>        Set peAnchors to anBottomRight
76474>>>>>>>
76474>>>>>>>        Procedure OnClick
76477>>>>>>>            Send Search of oSelList
76478>>>>>>>        End_Procedure
76479>>>>>>>
76479>>>>>>>    End_Object    // oSearch_bn
76480>>>>>>>
76480>>>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOk_bn
76481>>>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_bn
76482>>>>>>>    On_Key Key_Alt+Key_S Send KeyAction of oSearch_bn
76483>>>>>>>
76483>>>>>>>CD_End_Object    // Customer_sl
76485>>>>>>>>
76485>>>>>
76485>>>>>
76485>>>
76485>>>DEFERRED_VIEW Activate_oCustomerView FOR ;;Object oCustomerView is a dbView
76510>>>    Set Border_Style to Border_Thick
76511>>>    Set Label to "Customer Entry View"
76512>>>    Set Location to 7 23
76513>>>    Set Size to 146 277
76514>>>    Set piMaxSize to 300 350
76515>>>    Set piMinSize to 146 277
76516>>>
76516>>>    Object Customer_DD is a Customer_DataDictionary
76518>>>    End_Object    // Customer_DD
76519>>>
76519>>>    Set Main_DD to Customer_DD
76520>>>    Set Server to Customer_DD
76521>>>
76521>>>    Object oCustomer_Number is a dbForm
76523>>>        Entry_Item Customer.Customer_Number
76524>>>        Set Label to "Customer Number:"
76525>>>        Set Size to 13 42
76526>>>        Set Location to 5 72
76527>>>        Set peAnchors to anTopLeft
76528>>>        Set Label_Col_Offset to 2
76529>>>        Set Label_Justification_Mode to jMode_Right
76530>>>    End_Object    // oCustomer_Number
76531>>>
76531>>>    Object oCustomer_Name is a dbForm
76533>>>        Entry_Item Customer.Name
76534>>>        Set Label to "Name:"
76535>>>        Set Size to 13 186
76536>>>        Set Location to 20 72
76537>>>        Set peAnchors to anTopLeftRight
76538>>>        Set Label_Col_Offset to 2
76539>>>        Set Label_Justification_Mode to jMode_Right
76540>>>    End_Object    // oCustomer_Name
76541>>>
76541>>>    Object oCustTD is a dbTabDialog
76543>>>        Set Size to 105 265
76544>>>        Set Location to 36 7
76545>>>        Set Rotate_Mode to RM_Rotate
76546>>>        Set peAnchors to anAll
76547>>>        Object oAddress_TP is a dbTabPage
76549>>>            Set Label to "Address"
76550>>>            Set Tab_ToolTip_Value to "Customer contact information"
76551>>>            Object oCustomer_Address is a dbForm
76553>>>                Entry_Item Customer.Address
76554>>>                Set Label to "Street Address:"
76555>>>                Set Size to 13 180
76556>>>                Set Location to 8 62
76557>>>                Set peAnchors to anTopLeftRight
76558>>>                Set Label_Col_Offset to 2
76559>>>                Set Label_Justification_Mode to jMode_Right
76560>>>            End_Object    // oCustomer_Address
76561>>>
76561>>>            Object oCustomer_City is a dbForm
76563>>>                Entry_Item Customer.City
76564>>>                Set Label to "City/State/Zip:"
76565>>>                Set Size to 13 84
76566>>>                Set Location to 24 62
76567>>>                Set peAnchors to anTopLeftRight
76568>>>                Set Label_Col_Offset to 2
76569>>>                Set Label_Justification_Mode to jMode_Right
76570>>>            End_Object    // oCustomer_City
76571>>>
76571>>>            Object oCustomer_State is a dbComboForm
76573>>>                Entry_Item Customer.State
76574>>>                Set Size to 13 32
76575>>>                Set Location to 24 152
76576>>>                Set peAnchors to anTopRight
76577>>>                Set Form_Border to 0
76578>>>                Set Code_Display_Mode to cb_code_display_code
76579>>>            End_Object    // oCustomer_State
76580>>>
76580>>>            Object oCustomer_Zip is a dbForm
76582>>>                Entry_Item Customer.Zip
76583>>>                Set Size to 13 51
76584>>>                Set Location to 24 191
76585>>>                Set peAnchors to anTopRight
76586>>>            End_Object    // oCustomer_Zip
76587>>>
76587>>>            Object oCustomer_Phone_number is a dbForm
76589>>>                Entry_Item Customer.Phone_Number
76590>>>                Set Label to "Phone Number:"
76591>>>                Set Size to 13 120
76592>>>                Set Location to 39 62
76593>>>                Set peAnchors to anTopLeft
76594>>>                Set Label_Col_Offset to 2
76595>>>                Set Label_Justification_Mode to jMode_Right
76596>>>            End_Object    // oCustomer_Phone_number
76597>>>
76597>>>            Object oCustomer_Fax_number is a dbForm
76599>>>                Entry_Item Customer.Fax_Number
76600>>>                Set Label to "Fax Number:"
76601>>>                Set Size to 13 120
76602>>>                Set Location to 54 62
76603>>>                Set peAnchors to anTopLeft
76604>>>                Set Label_Col_Offset to 2
76605>>>                Set Label_Justification_Mode to jMode_Right
76606>>>            End_Object    // oCustomer_Fax_number
76607>>>
76607>>>            Object oCustomer_Email_address is a dbForm
76609>>>                Entry_Item Customer.EMail_Address
76610>>>                Set Label to "E-Mail Address:"
76611>>>                Set Size to 13 180
76612>>>                Set Location to 69 62
76613>>>                Set peAnchors to anTopLeftRight
76614>>>                Set Label_Col_Offset to 2
76615>>>                Set Label_Justification_Mode to jMode_Right
76616>>>            End_Object    // oCustomer_Email_address
76617>>>
76617>>>        End_Object    // oAddress_TP
76618>>>
76618>>>        Object oBalances_TP is a dbTabPage
76620>>>            Set Label to "Balances"
76621>>>            Set Tab_ToolTip_Value to "Current account balances"
76622>>>            Object oCustomer_Credit_Limit is a dbForm
76624>>>                Entry_Item Customer.Credit_limit
76625>>>                Set Label to "Credit Limit:"
76626>>>                Set Size to 13 48
76627>>>                Set Location to 9 72
76628>>>                Set Label_Col_Offset to 2
76629>>>                Set Label_Justification_Mode to jMode_Right
76630>>>            End_Object    // oCustomer_Credit_Limit
76631>>>
76631>>>            Object oCustomer_Purchases is a dbForm
76633>>>                Entry_Item Customer.Purchases
76634>>>                Set Label to "Total Purchases:"
76635>>>                Set Size to 13 48
76636>>>                Set Location to 24 72
76637>>>                Set Label_Col_Offset to 2
76638>>>                Set Label_Justification_Mode to jMode_Right
76639>>>            End_Object    // oCustomer_Purchases
76640>>>
76640>>>            Object oCustomer_Balance is a dbForm
76642>>>                Entry_Item Customer.Balance
76643>>>                Set Label to "Balance Due:"
76644>>>                Set Size to 13 48
76645>>>                Set Location to 39 72
76646>>>                Set Label_Col_Offset to 2
76647>>>                Set Label_Justification_Mode to jMode_Right
76648>>>            End_Object    // oCustomer_Balance
76649>>>
76649>>>        End_Object    // oBalances_TP
76650>>>
76650>>>        Object oComments_TP is a dbTabPage
76652>>>            Set Label to "Comments"
76653>>>            Set Tab_ToolTip_Value to "Notes about this customer"
76654>>>            Object oCustomer_Comments is a cDbTextEdit
76656>>>                Entry_Item Customer.Comments
76657>>>                Set Size to 71 242
76658>>>                Set Location to 9 9
76659>>>                Set peAnchors to anAll
76660>>>            End_Object    // oCustomer_Comments
76661>>>
76661>>>        End_Object    // oComments_TP
76662>>>
76662>>>    End_Object    // oCustTD
76663>>>
76663>>>CD_End_Object    // oCustomerView
76665>>>>
76665>        Use Invt.vw
Including file: Invt.vw    (C:\Test\Order Entry git\AppSrc\Invt.vw)
76665>>>Use dfClient.pkg
76665>>>Use DataDict.pkg
76665>>>Use dfEntry.pkg
76665>>>Use Vendor.DD
Including file: Vendor.dd    (C:\Test\Order Entry git\DDSrc\Vendor.dd)
76665>>>>>Use  Windows.pkg           // Basic Definitions
76665>>>>>Use  DataDict.pkg          // DataDictionary Class Definition
76665>>>>>Use  DDvalTbl.pkg          // Validation Table Class Definitions
76665>>>>>
76665>>>>>Open Vendor
Including file: Vendor.fd    (C:\Test\Order Entry git\DDSrc\Vendor.fd)
76667>>>>>Open Invt
Including file: Invt.fd    (C:\Test\Order Entry git\DDSrc\Invt.fd)
76669>>>>>Open OrdSys
76671>>>>>
76671>>>>>
76671>>>>>Register_Object Vendor_State_VT
76671>>>>>
76671>>>>>Object Vendor_State_VT  is a CodeValidationTable
76673>>>>>    Set Type_Value        To "STATES"
76674>>>>>End_Object   // Vendor_State_VT
76675>>>>>Register_Object Vendor_sl
76675>>>>>
76675>>>>>Class Vendor_DataDictionary Is A DataDictionary
76676>>>>>
76676>>>>>    Procedure Construct_Object
76678>>>>>        Forward Send Construct_Object
76680>>>>>
76680>>>>>        Set Main_File To Vendor.File_Number
76681>>>>>        Set Cascade_Delete_State To False
76682>>>>>
76682>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_FINDREQ to True
76683>>>>>        Set Foreign_Field_Option DD_INDEXFIELD DD_NOPUT to True
76684>>>>>        Set Foreign_Field_Option DD_DEFAULT DD_DISPLAYONLY to True
76685>>>>>
76685>>>>>        Set Add_Client_File to Invt.File_Number
76686>>>>>
76686>>>>>        Set Add_System_File to Ordsys.File_Number DD_LOCK_ON_NEW_SAVE
76687>>>>>
76687>>>>>        Set Field_Auto_Increment Field Vendor.Id to File_Field Ordsys.Vendor_Number
76688>>>>>
76688>>>>>
76688>>>>>        Set Field_Label_Long Field Vendor.ID To "Vendor ID"
76689>>>>>        Set Field_Label_Short Field Vendor.ID To "Vndr ID"
76690>>>>>        Set Field_Option Field Vendor.ID DD_AUTOFIND to True
76691>>>>>        Set Field_Option Field Vendor.ID DD_NOPUT to True
76692>>>>>        Set Field_Prompt_Object Field Vendor.ID to Vendor_sl
76693>>>>>        Set Key_Field_State Field Vendor.ID To True
76694>>>>>        Set Status_Help Field Vendor.ID To "Vendor Id Number (system assigned)."
76695>>>>>
76695>>>>>        Set Field_Label_Long Field Vendor.Name To "Vendor Name"
76696>>>>>        Set Field_Label_Short Field Vendor.Name To "Name"
76697>>>>>        Set Field_Option Field Vendor.Name DD_REQUIRED to True
76698>>>>>        Set Field_Prompt_Object Field Vendor.Name to Vendor_sl
76699>>>>>        Set Status_Help Field Vendor.Name To "Vendor Name."
76700>>>>>
76700>>>>>        Set Field_Label_Long Field Vendor.Address To "Street Address"
76701>>>>>        Set Field_Label_Short Field Vendor.Address To "Address"
76702>>>>>        Set Status_Help Field Vendor.Address To "Street Address."
76703>>>>>
76703>>>>>        Set Status_Help Field Vendor.City To "City Name."
76704>>>>>
76704>>>>>        Set Field_Class_Name Field Vendor.State To "dbComboForm"
76705>>>>>        Set Field_Label_Long Field Vendor.State To "State"
76706>>>>>        Set Field_Label_Short Field Vendor.State To "St."
76707>>>>>        Set Field_Option Field Vendor.State DD_CAPSLOCK to True
76708>>>>>        Set Field_Value_Table Field Vendor.State to Vendor_State_VT
76709>>>>>        Set Status_Help Field Vendor.State To "Two letter state ID."
76710>>>>>
76710>>>>>        Set Field_Label_Long Field Vendor.Zip To "Zip/Postal Code"
76711>>>>>        Set Field_Label_Short Field Vendor.Zip To "Zip"
76712>>>>>        Set Field_Mask Field Vendor.Zip To "#####-####"
76713>>>>>        Set Field_Mask_Type Field Vendor.Zip To MASK_WINDOW
76714>>>>>        Set Status_Help Field Vendor.Zip To "Zip or Postal Code."
76715>>>>>
76715>>>>>        Set Field_Label_Long Field Vendor.Phone_Number To "Phone Number"
76716>>>>>        Set Field_Label_Short Field Vendor.Phone_Number To "Phone"
76717>>>>>        Set Status_Help Field Vendor.Phone_Number To "Phone Number."
76718>>>>>
76718>>>>>        Set Field_Label_Long Field Vendor.Fax_Number To "Fax Number"
76719>>>>>        Set Field_Label_Short Field Vendor.Fax_Number To "Fax"
76720>>>>>        Set Status_Help Field Vendor.Fax_Number To "Fax Phone Number."
76721>>>>>
76721>>>>>
76721>>>>>    End_Procedure  //  Construct_Object
76722>>>>>
76722>>>>>
76722>>>>>
76722>>>>>    Procedure Field_Defaults
76724>>>>>        Forward Send Field_Defaults
76726>>>>>    End_Procedure    // Field_Defaults
76727>>>>>    
76727>>>>>End_Class    //  Vendor_DataDictionary
76728>>>>>
76728>>>>>Use Vendor.sl        // Vendor_sl
Including file: Vendor.sl    (C:\Test\Order Entry git\AppSrc\Vendor.sl)
76728>>>>>>>Use DFClient.pkg
76728>>>>>>>Use DFSelLst.pkg
76728>>>>>>>Use Windows.pkg
76728>>>>>>>Use cDbCJGridPromptList.pkg
76728>>>>>>>
76728>>>>>>>Use Vendor.DD
76728>>>>>>>
76728>>>>>>>CD_Popup_Object Vendor_sl is a dbModalPanel
76746>>>>>>>>
76746>>>>>>>    Set Label to "Vendor List"
76747>>>>>>>    Set Size to 132 238
76748>>>>>>>    Set Location to 4 5
76749>>>>>>>    Set piMinSize to 132 238
76750>>>>>>>
76750>>>>>>>    Object Vendor_DD is a Vendor_DataDictionary
76752>>>>>>>    End_Object    // Vendor_DD
76753>>>>>>>
76753>>>>>>>    Set Main_DD to Vendor_DD
76754>>>>>>>    Set Server to Vendor_DD
76755>>>>>>>
76755>>>>>>>    Object oSelList is a cDbCJGridPromptList
76757>>>>>>>        Set Size to 95 229
76758>>>>>>>        Set Location to 12 4
76759>>>>>>>        Set pbAllowColumnRemove to False
76760>>>>>>>        Set peAnchors to anAll
76761>>>>>>>
76761>>>>>>>        Object oVendor_ID is a cDbCJGridColumn
76763>>>>>>>            Entry_Item Vendor.ID
76764>>>>>>>            Set piWidth to 63
76765>>>>>>>            Set psCaption to "ID"
76766>>>>>>>        End_Object
76767>>>>>>>
76767>>>>>>>        Object oVendor_Name is a cDbCJGridColumn
76769>>>>>>>            Entry_Item Vendor.Name
76770>>>>>>>            Set piWidth to 280
76771>>>>>>>            Set psCaption to "Vendor Name"
76772>>>>>>>        End_Object
76773>>>>>>>    End_Object
76774>>>>>>>
76774>>>>>>>    Object oOK_bn is a Button
76776>>>>>>>        Set Label to "&Ok"
76777>>>>>>>        Set Location to 114 77
76778>>>>>>>        Set peAnchors to anBottomRight
76779>>>>>>>
76779>>>>>>>        Procedure OnClick
76782>>>>>>>            Send OK of oSelList
76783>>>>>>>        End_Procedure
76784>>>>>>>
76784>>>>>>>    End_Object    // oOK_bn
76785>>>>>>>
76785>>>>>>>    Object oCancel_bn is a Button
76787>>>>>>>        Set Label to "&Cancel"
76788>>>>>>>        Set Location to 114 130
76789>>>>>>>        Set peAnchors to anBottomRight
76790>>>>>>>
76790>>>>>>>        Procedure OnClick
76793>>>>>>>            Send Cancel of oSelList
76794>>>>>>>        End_Procedure
76795>>>>>>>
76795>>>>>>>    End_Object    // oCancel_bn
76796>>>>>>>
76796>>>>>>>    Object oSearch_bn is a Button
76798>>>>>>>        Set Label to "&Search..."
76799>>>>>>>        Set Location to 114 183
76800>>>>>>>        Set peAnchors to anBottomRight
76801>>>>>>>
76801>>>>>>>        Procedure OnClick
76804>>>>>>>            Send Search of oSelList
76805>>>>>>>        End_Procedure
76806>>>>>>>
76806>>>>>>>    End_Object    // oSearch_bn
76807>>>>>>>
76807>>>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOk_bn
76808>>>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_bn
76809>>>>>>>    On_Key Key_Alt+Key_S Send KeyAction of oSearch_bn
76810>>>>>>>
76810>>>>>>>CD_End_Object    // Vendor_sl
76812>>>>>>>>
76812>>>>>
76812>>>>>
76812>>>Use Invt.DD
Including file: Invt.dd    (C:\Test\Order Entry git\DDSrc\Invt.dd)
76812>>>>>Use  Windows.pkg           // Basic Definitions
76812>>>>>Use  DataDict.pkg          // DataDictionary Class Definition
76812>>>>>Use  DDvalTbl.pkg          // Validation Table Class Definitions
76812>>>>>
76812>>>>>Open Invt
76814>>>>>Open OrderDtl
Including file: OrderDtl.fd    (C:\Test\Order Entry git\DDSrc\OrderDtl.fd)
76816>>>>>Open Vendor
76818>>>>>
76818>>>>>Register_Object Invt_sl
76818>>>>>
76818>>>>>Class Invt_DataDictionary Is A DataDictionary
76819>>>>>
76819>>>>>    Procedure Construct_Object
76821>>>>>        Forward Send Construct_Object
76823>>>>>
76823>>>>>        Set Main_File To Invt.File_Number
76824>>>>>        Set Cascade_Delete_State To False
76825>>>>>
76825>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_FINDREQ to True
76826>>>>>        Set Foreign_Field_Option DD_INDEXFIELD DD_NOPUT to True
76827>>>>>        Set Foreign_Field_Option DD_DEFAULT DD_DISPLAYONLY to True
76828>>>>>
76828>>>>>        Set Add_Client_File to OrderDtl.File_Number
76829>>>>>
76829>>>>>        Set Add_Server_File to Vendor.File_Number
76830>>>>>
76830>>>>>
76830>>>>>        Set Field_Label_Long Field Invt.Item_ID To "Invt. Item ID"
76831>>>>>        Set Field_Label_Short Field Invt.Item_ID To "Item ID"
76832>>>>>        Set Field_Option Field Invt.Item_ID DD_AUTOFIND to True
76833>>>>>        Set Field_Option Field Invt.Item_ID DD_REQUIRED to True
76834>>>>>        Set Field_Option Field Invt.Item_ID DD_CAPSLOCK to True
76835>>>>>        Set Field_Prompt_Object Field Invt.Item_ID to Invt_sl
76836>>>>>        Set Key_Field_State Field Invt.Item_ID To True
76837>>>>>        Set Status_Help Field Invt.Item_ID To "Inventory Item Id - user defined identification"
76838>>>>>
76838>>>>>        Set Field_Label_Long Field Invt.Description To "Invt. Description"
76839>>>>>        Set Field_Label_Short Field Invt.Description To "Description"
76840>>>>>        Set Field_Option Field Invt.Description DD_REQUIRED to True
76841>>>>>        Set Status_Help Field Invt.Description To "Inventory Part Description"
76842>>>>>
76842>>>>>        Set Field_Option Field Invt.Vendor_ID DD_CAPSLOCK to True
76843>>>>>        Set Status_Help Field Invt.Vendor_ID To "Vendor Number"
76844>>>>>
76844>>>>>        Set Field_Option Field Invt.Vendor_Part_ID DD_REQUIRED to True
76845>>>>>        Set Status_Help Field Invt.Vendor_Part_ID To "Vendor ID name for this item"
76846>>>>>
76846>>>>>        Set Field_Mask_Type Field Invt.Unit_Price To MASK_CURRENCY_WINDOW
76847>>>>>        Set Field_Value_Range Field Invt.Unit_Price To 0 999999.99
76848>>>>>        Set Status_Help Field Invt.Unit_Price To "Retail unit price"
76849>>>>>
76849>>>>>        Set Field_Value_Range Field Invt.On_Hand To -999999 999999
76850>>>>>        Set Status_Help Field Invt.On_Hand To "Units currently available"
76851>>>>>
76851>>>>>    End_Procedure  //  Construct_Object
76852>>>>>  
76852>>>>>    Function Validate_Save Returns Integer
76854>>>>>        Integer iRetVal
76854>>>>>    
76854>>>>>        Forward Get Validate_Save to iRetVal
76856>>>>>        
76856>>>>>        If iRetVal Function_Return iRetVal
76859>>>>>    
76859>>>>>        If Invt.On_Hand Lt 0 Begin
76861>>>>>           Send UserError "Insufficient Inventory Stock" ""
76862>>>>>           Function_Return 1
76863>>>>>        End   
76863>>>>>>
76863>>>>>    End_Function  // Validate_Save
76864>>>>>
76864>>>>>
76864>>>>>    Procedure Field_Defaults
76866>>>>>        Forward Send Field_Defaults
76868>>>>>    End_Procedure    // Field_Defaults
76869>>>>>    
76869>>>>>End_Class    //  Invt_DataDictionary
76870>>>>>
76870>>>>>Use Invt.sl          // Invt_sl
Including file: Invt.sl    (C:\Test\Order Entry git\AppSrc\Invt.sl)
76870>>>>>>>Use DFClient.pkg
76870>>>>>>>Use DFSelLst.pkg
76870>>>>>>>Use Windows.pkg
76870>>>>>>>
76870>>>>>>>Use Vendor.DD
76870>>>>>>>Use Invt.DD
76870>>>>>>>
76870>>>>>>>CD_Popup_Object Invt_sl is a dbModalPanel
76888>>>>>>>>
76888>>>>>>>
76888>>>>>>>    Set Minimize_Icon to False
76889>>>>>>>    Set Label to "Inventory List"
76890>>>>>>>    Set Size to 133 284
76891>>>>>>>    Set Location to 4 4
76892>>>>>>>    Set piMinSize to 133 284
76893>>>>>>>
76893>>>>>>>    Object Vendor_DD is a Vendor_DataDictionary
76895>>>>>>>    End_Object    // Vendor_DD
76896>>>>>>>
76896>>>>>>>    Object Invt_DD is a Invt_DataDictionary
76898>>>>>>>        Set DDO_Server to Vendor_DD
76899>>>>>>>    End_Object    // Invt_DD
76900>>>>>>>
76900>>>>>>>    Set Main_DD to Invt_DD
76901>>>>>>>    Set Server to Invt_DD
76902>>>>>>>
76902>>>>>>>    Object oSelList is a cDbCJGridPromptList
76904>>>>>>>        Set Size to 105 273
76905>>>>>>>        Set Location to 6 6
76906>>>>>>>        Set peAnchors to anAll
76907>>>>>>>        Set pbAllowColumnRemove to False
76908>>>>>>>
76908>>>>>>>        Object oItemID is a cDbCJGridColumn
76910>>>>>>>            Entry_Item Invt.Item_iD
76911>>>>>>>            Set psCaption to "Item ID"
76912>>>>>>>            Set piWidth to 74
76913>>>>>>>        End_Object
76914>>>>>>>        
76914>>>>>>>        Object oDescription is a cDbCJGridColumn
76916>>>>>>>            Entry_Item Invt.Description
76917>>>>>>>            Set psCaption to "Description"
76918>>>>>>>            Set piWidth to 205
76919>>>>>>>        End_Object
76920>>>>>>>        
76920>>>>>>>        Object oUnitPrice is a cDbCJGridColumn
76922>>>>>>>            Entry_Item Invt.Unit_Price
76923>>>>>>>            Set psCaption to "Unit Price"
76924>>>>>>>            Set piWidth to 69
76925>>>>>>>        End_Object
76926>>>>>>>        
76926>>>>>>>        Object oOnHand is a cDbCJGridColumn
76928>>>>>>>            Entry_Item Invt.On_Hand
76929>>>>>>>            Set psCaption to "On Hand"
76930>>>>>>>            Set piWidth to 61
76931>>>>>>>        End_Object
76932>>>>>>>
76932>>>>>>>    End_Object    // oSelList
76933>>>>>>>
76933>>>>>>>    Object oOK_bn is a Button
76935>>>>>>>        Set Label to "&Ok"
76936>>>>>>>        Set Location to 115 123
76937>>>>>>>        Set peAnchors to anBottomRight
76938>>>>>>>
76938>>>>>>>        Procedure OnClick
76941>>>>>>>            Send OK of oSelList
76942>>>>>>>        End_Procedure
76943>>>>>>>
76943>>>>>>>    End_Object    // oOK_bn
76944>>>>>>>
76944>>>>>>>    Object oCancel_bn is a Button
76946>>>>>>>        Set Label to "&Cancel"
76947>>>>>>>        Set Location to 115 176
76948>>>>>>>        Set peAnchors to anBottomRight
76949>>>>>>>
76949>>>>>>>        Procedure OnClick
76952>>>>>>>            Send Cancel of oSelList
76953>>>>>>>        End_Procedure
76954>>>>>>>
76954>>>>>>>    End_Object    // oCancel_bn
76955>>>>>>>
76955>>>>>>>    Object oSearch_bn is a Button
76957>>>>>>>        Set Label to "&Search..."
76958>>>>>>>        Set Location to 115 229
76959>>>>>>>        Set peAnchors to anBottomRight
76960>>>>>>>
76960>>>>>>>        Procedure OnClick
76963>>>>>>>            Send Search of oSelList
76964>>>>>>>        End_Procedure
76965>>>>>>>
76965>>>>>>>    End_Object    // oSearch_bn
76966>>>>>>>
76966>>>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOk_bn
76967>>>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_bn
76968>>>>>>>    On_Key Key_Alt+Key_S Send KeyAction of oSearch_bn
76969>>>>>>>
76969>>>>>>>CD_End_Object    // Invt_sl
76971>>>>>>>>
76971>>>>>
76971>>>>>
76971>>>
76971>>>DEFERRED_VIEW Activate_oInventoryView FOR ;;Object oInventoryView is a dbView
76996>>>    Set Border_Style to Border_Thick
76997>>>    Set Label to "Inventory Item View"
76998>>>    Set Location to 5 8
76999>>>    Set Size to 151 305
77000>>>    Set piMaxSize to 115 350
77001>>>    Set piMinSize to 151 270
77002>>>
77002>>>    Object Vendor_DD is a Vendor_DataDictionary
77004>>>    End_Object    // Vendor_DD
77005>>>
77005>>>    Object Invt_DD is a Invt_DataDictionary
77007>>>        Set DDO_Server to Vendor_DD
77008>>>    End_Object    // Invt_DD
77009>>>
77009>>>    Set Main_DD to Invt_DD
77010>>>    Set Server to Invt_DD
77011>>>
77011>>>    Object oDbCont is a dbContainer3d
77013>>>        Set Size to 140 295
77014>>>        Set Location to 5 4
77015>>>        Set peAnchors to anAll
77016>>>        Object oInvt_Item_ID is a dbForm
77018>>>            Entry_Item Invt.Item_ID
77019>>>            Set Label to "Invt. Item ID:"
77020>>>            Set Size to 13 60
77021>>>            Set Location to 10 70
77022>>>            Set peAnchors to anTopLeft
77023>>>            Set Label_Col_Offset to 2
77024>>>            Set Label_Justification_Mode to jMode_Right
77025>>>        End_Object    // oInvt_Item_Id
77026>>>
77026>>>        Object oInvt_Description is a dbForm
77028>>>            Entry_Item Invt.Description
77029>>>            Set Label to "Invt. Description:"
77030>>>            Set Size to 13 210
77031>>>            Set Location to 25 70
77032>>>            Set peAnchors to anTopLeftRight
77033>>>            Set Label_Col_Offset to 2
77034>>>            Set Label_Justification_Mode to jMode_Right
77035>>>        End_Object    // oInvt_Description
77036>>>
77036>>>        Object oVendorGroup is a dbGroup
77038>>>            Set Size to 58 271
77039>>>            Set Location to 41 9
77040>>>            Set peAnchors to anAll
77041>>>            Set Label to "Vendor"
77042>>>            Object oInvt_Vendor_ID is a dbForm
77044>>>                Entry_Item Vendor.ID
77045>>>                Set Label to "Vendor ID:"
77046>>>                Set Size to 13 42
77047>>>                Set Location to 9 61
77048>>>                Set peAnchors to anTopLeft
77049>>>                Set Label_Col_Offset to 2
77050>>>                Set Label_Justification_Mode to jMode_Right
77051>>>            End_Object    // oInvt_Vendor_Id
77052>>>
77052>>>            Object oVendor_Name is a dbForm
77054>>>                Entry_Item Vendor.Name
77055>>>                Set Label to "Vendor Name:"
77056>>>                Set Size to 13 180
77057>>>                Set Location to 24 61
77058>>>                Set peAnchors to anTopLeftRight
77059>>>                Set Label_Col_Offset to 2
77060>>>                Set Label_Justification_Mode to jMode_Right
77061>>>            End_Object    // oVendor_Name
77062>>>
77062>>>            Object oInvt_Vendor_Part_ID is a dbForm
77064>>>                Entry_Item Invt.Vendor_Part_ID
77065>>>                Set Label to "Vendor Part ID:"
77066>>>                Set Size to 13 90
77067>>>                Set Location to 39 61
77068>>>                Set peAnchors to anTopLeft
77069>>>                Set Label_Col_Offset to 2
77070>>>                Set Label_Justification_Mode to jMode_Right
77071>>>            End_Object    // oInvt_Vendor_Part_ID
77072>>>
77072>>>        End_Object    // oVendorGroup
77073>>>
77073>>>        Object oUnitGroup is a dbGroup
77075>>>            Set Size to 28 271
77076>>>            Set Location to 101 9
77077>>>            Set peAnchors to anAll
77078>>>            Object oInvt_Unit_Price is a dbForm
77080>>>                Entry_Item Invt.Unit_Price
77081>>>                Set Label to "Unit Price:"
77082>>>                Set Size to 13 48
77083>>>                Set Location to 10 61
77084>>>                Set peAnchors to anTopLeft
77085>>>                Set Label_Col_Offset to 2
77086>>>                Set Label_Justification_Mode to jMode_Right
77087>>>            End_Object    // oInvt_Unit_Price
77088>>>
77088>>>            Object oInvt_On_Hand is a dbForm
77090>>>                Entry_Item Invt.On_Hand
77091>>>                Set Label to "On Hand:"
77092>>>                Set Size to 13 36
77093>>>                Set Location to 10 205
77094>>>                Set peAnchors to anTopRight
77095>>>                Set Label_Col_Offset to 2
77096>>>                Set Label_Justification_Mode to jMode_Right
77097>>>            End_Object    // oInvt_On_Hand
77098>>>
77098>>>        End_Object    // oUnitGroup
77099>>>
77099>>>    End_Object    // oDbCont
77100>>>
77100>>>CD_End_Object    // oInventoryView
77102>>>>
77102>        Use Order.vw
Including file: Order.vw    (C:\Test\Order Entry git\AppSrc\Order.vw)
77102>>>Use dfClient.pkg
77102>>>Use DataDict.pkg
77102>>>Use dfEntry.pkg
77102>>>Use dfSpnEnt.pkg
77102>>>Use dfCEntry.pkg
77102>>>Use dfTable.pkg
77102>>>Use Windows.pkg
77102>>>Use Vendor.DD
77102>>>Use Invt.DD
77102>>>Use Customer.DD
77102>>>Use SalesP.DD
Including file: SalesP.dd    (C:\Test\Order Entry git\DDSrc\SalesP.dd)
77102>>>>>Use  Windows.pkg           // Basic Definitions
77102>>>>>Use  DataDict.pkg          // DataDictionary Class Definition
77102>>>>>Use  DDvalTbl.pkg          // Validation Table Class Definitions
77102>>>>>
77102>>>>>Open Salesp
Including file: SalesP.fd    (C:\Test\Order Entry git\DDSrc\SalesP.fd)
77104>>>>>Open Orderhea
77106>>>>>
77106>>>>>Register_Object SalesP_sl
77106>>>>>
77106>>>>>Class SalesP_DataDictionary Is A DataDictionary
77107>>>>>
77107>>>>>    Procedure Construct_Object
77109>>>>>        Forward Send Construct_Object
77111>>>>>
77111>>>>>        Set Main_File To Salesp.File_Number
77112>>>>>        Set Cascade_Delete_State To FALSE
77113>>>>>
77113>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_NOPUT to True
77114>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_FINDREQ to True
77115>>>>>        Set Foreign_Field_Option DD_INDEXFIELD DD_NOPUT to True
77116>>>>>        Set Foreign_Field_Option DD_DEFAULT DD_DISPLAYONLY to True
77117>>>>>
77117>>>>>        Set Add_Client_File to Orderhea.File_Number
77118>>>>>
77118>>>>>
77118>>>>>        Set Field_Label_Long Field Salesp.Id To "Sales Person ID"
77119>>>>>        Set Field_Label_Short Field Salesp.Id To "ID"
77120>>>>>        Set Field_Option Field Salesp.Id DD_AUTOFIND to True
77121>>>>>        Set Field_Option Field Salesp.Id DD_REQUIRED to True
77122>>>>>        Set Field_Option Field Salesp.Id DD_CAPSLOCK to True
77123>>>>>        Set Field_Prompt_Object Field Salesp.Id to SalesP_sl
77124>>>>>        Set Key_Field_State Field Salesp.Id To TRUE
77125>>>>>        Set Status_Help Field Salesp.Id To "Sales person ID code - Upper case alpha"
77126>>>>>
77126>>>>>        Set Field_Label_Long Field Salesp.Name To "Sales Person Name"
77127>>>>>        Set Field_Label_Short Field Salesp.Name To "Sales Person Name"
77128>>>>>        Set Field_Prompt_Object Field Salesp.Name to SalesP_sl
77129>>>>>        Set Status_Help Field Salesp.Name To "Sales person name - first and last"
77130>>>>>
77130>>>>>    End_Procedure  //  Construct_Object
77131>>>>>
77131>>>>>
77131>>>>>    Procedure Field_Defaults
77133>>>>>        Forward Send Field_Defaults
77135>>>>>    End_Procedure    // Field_Defaults
77136>>>>>    
77136>>>>>End_Class    //  Salesp_DataDictionary
77137>>>>>
77137>>>>>Use SalesP.sl        // SalesP_sl
Including file: Salesp.sl    (C:\Test\Order Entry git\AppSrc\Salesp.sl)
77137>>>>>>>Use DFClient.pkg
77137>>>>>>>Use DFSelLst.pkg
77137>>>>>>>Use Windows.pkg
77137>>>>>>>Use cDbCJGridPromptList.pkg
77137>>>>>>>
77137>>>>>>>Use SalesP.DD
77137>>>>>>>
77137>>>>>>>CD_Popup_Object SalesP_sl is a dbModalPanel
77155>>>>>>>>
77155>>>>>>>
77155>>>>>>>    Set Minimize_Icon to False
77156>>>>>>>    Set Label to "Sales Person List"
77157>>>>>>>    Set Size to 99 260
77158>>>>>>>    Set Location to 4 5
77159>>>>>>>    Set piMinSize to 99 180
77160>>>>>>>
77160>>>>>>>    Object SalesP_DD is a SalesP_DataDictionary
77162>>>>>>>    End_Object    // Salesp_DD
77163>>>>>>>
77163>>>>>>>    Set Main_DD to SalesP_DD
77164>>>>>>>    Set Server to SalesP_DD
77165>>>>>>>
77165>>>>>>>    Object oSelList is a cDbCJGridPromptList
77167>>>>>>>        Set Size to 70 249
77168>>>>>>>        Set Location to 6 5
77169>>>>>>>        Set pbAllowColumnRemove to False
77170>>>>>>>        Set peAnchors to anAll
77171>>>>>>>
77171>>>>>>>        Object oSalesP_ID is a cDbCJGridColumn
77173>>>>>>>            Entry_Item SalesP.ID
77174>>>>>>>            Set piWidth to 60
77175>>>>>>>            Set psCaption to "ID"
77176>>>>>>>        End_Object
77177>>>>>>>
77177>>>>>>>        Object oSalesP_Name is a cDbCJGridColumn
77179>>>>>>>            Entry_Item SalesP.Name
77180>>>>>>>            Set piWidth to 313
77181>>>>>>>            Set psCaption to "Sales Person Name"
77182>>>>>>>        End_Object
77183>>>>>>>    End_Object
77184>>>>>>>
77184>>>>>>>    Object oOK_bn is a Button
77186>>>>>>>        Set Label to "&Ok"
77187>>>>>>>        Set Location to 81 99
77188>>>>>>>        Set peAnchors to anBottomRight
77189>>>>>>>        Set Default_State to True
77190>>>>>>>
77190>>>>>>>        Procedure OnClick
77193>>>>>>>            Send OK of oSelList
77194>>>>>>>        End_Procedure
77195>>>>>>>
77195>>>>>>>    End_Object    // oOK_bn
77196>>>>>>>
77196>>>>>>>    Object oCancel_bn is a Button
77198>>>>>>>        Set Label to "&Cancel"
77199>>>>>>>        Set Location to 81 152
77200>>>>>>>        Set peAnchors to anBottomRight
77201>>>>>>>
77201>>>>>>>        Procedure OnClick
77204>>>>>>>            Send Cancel of oSelList
77205>>>>>>>        End_Procedure
77206>>>>>>>
77206>>>>>>>    End_Object    // oCancel_bn
77207>>>>>>>
77207>>>>>>>    Object oSearch_bn is a Button
77209>>>>>>>        Set Label to "&Search..."
77210>>>>>>>        Set Location to 81 205
77211>>>>>>>        Set peAnchors to anBottomRight
77212>>>>>>>
77212>>>>>>>        Procedure OnClick
77215>>>>>>>            Send Search of oSelList
77216>>>>>>>        End_Procedure
77217>>>>>>>
77217>>>>>>>    End_Object    // oSearch_bn
77218>>>>>>>
77218>>>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOk_bn
77219>>>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_bn
77220>>>>>>>    On_Key Key_Alt+Key_S Send KeyAction of oSearch_bn
77221>>>>>>>
77221>>>>>>>CD_End_Object    // SalesP_sl
77223>>>>>>>>
77223>>>>>
77223>>>>>
77223>>>Use OrderHea.DD
Including file: OrderHea.dd    (C:\Test\Order Entry git\DDSrc\OrderHea.dd)
77223>>>>>Use  Windows.pkg           // Basic Definitions
77223>>>>>Use  DataDict.pkg          // DataDictionary Class Definition
77223>>>>>Use  DDvalTbl.pkg          // Validation Table Class Definitions
77223>>>>>
77223>>>>>Open OrderHea
77225>>>>>Open OrderDtl
77227>>>>>Open Customer
77229>>>>>Open SalesP
77231>>>>>Open OrdSys
77233>>>>>
77233>>>>>
77233>>>>>Register_Object Terms_table
77233>>>>>Register_Object Ship_Table
77233>>>>>
77233>>>>>Object Terms_table  is a DescriptionValidationTable
77235>>>>>
77235>>>>>    Procedure Fill_List
77238>>>>>        Forward Send Fill_List
77240>>>>>        Send Add_Table_Value  "NONE"  "None established"
77241>>>>>        Send Add_Table_Value  "COD"  "COD"
77242>>>>>        Send Add_Table_Value  "NET30"  "Net 30"
77243>>>>>        Send Add_Table_Value  "NET60"  "Net 60"
77244>>>>>        Send Add_Table_Value  "NET90"  "Net 90"
77245>>>>>        Send Add_Table_Value  "PREPAY"  "Pre-payment required"
77246>>>>>    End_Procedure    // Fill_List
77247>>>>>End_Object   // Terms_table
77248>>>>>
77248>>>>>Object Ship_Table  is a CodeValidationTable
77250>>>>>    Set Type_Value        To "SHIPPING"
77251>>>>>    Set Allow_Blank_State To True
77252>>>>>End_Object   // Ship_Table
77253>>>>>
77253>>>>>Register_Object OrderHea_sl
77253>>>>>
77253>>>>>Class OrderHea_DataDictionary Is A DataDictionary
77254>>>>>
77254>>>>>    Procedure Construct_Object
77256>>>>>        Forward Send Construct_Object
77258>>>>>
77258>>>>>        Set Main_File To OrderHea.File_Number
77259>>>>>
77259>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_FINDREQ to True
77260>>>>>        Set Foreign_Field_Option DD_INDEXFIELD DD_NOPUT to True
77261>>>>>        Set Foreign_Field_Option DD_DEFAULT DD_DISPLAYONLY to True
77262>>>>>
77262>>>>>        Set Add_Client_File to OrderDtl.File_Number
77263>>>>>
77263>>>>>        Set Add_Server_File to Customer.File_Number
77264>>>>>        Set Add_Server_File to SalesP.File_Number
77265>>>>>
77265>>>>>        Set ParentNullAllowed SalesP.File_Number to True
77266>>>>>        Set ParentNoSwitchIfCommitted Customer.File_Number to True
77267>>>>>
77267>>>>>        Set Add_System_File to OrdSys.File_Number DD_LOCK_ON_NEW_SAVE_DELETE
77268>>>>>
77268>>>>>        Set Field_Auto_Increment Field OrderHea.Order_Number to File_Field OrdSys.Order_Number
77269>>>>>
77269>>>>>
77269>>>>>        Set Field_Option Field OrderHea.Order_Number DD_AUTOFIND to True
77270>>>>>        Set Field_Prompt_Object Field OrderHea.Order_Number to OrderHea_SL
77271>>>>>        Set Key_Field_State Field OrderHea.Order_Number To True
77272>>>>>        Set Status_Help Field OrderHea.Order_Number To "Order Number - New orders are assigned numbers automatically"
77273>>>>>
77273>>>>>
77273>>>>>        Set Field_Class_Name Field OrderHea.Order_Date To "dbSpinForm"
77274>>>>>        Set Field_Entry_msg Field OrderHea.Order_Date To Entry_Order_Date
77275>>>>>        Set Field_Mask_Type Field OrderHea.Order_Date To MASK_DATE_WINDOW
77276>>>>>        Set Field_Prompt_Object Field OrderHea.Order_Date to OrderHea_SL
77277>>>>>        Set Status_Help Field OrderHea.Order_Date To "Date on which the order was placed"
77278>>>>>        Set Field_Option Field OrderHea.Order_Date DD_COMMIT to True
77279>>>>>
77279>>>>>        Set Field_Class_Name Field OrderHea.Terms To "dbComboForm"
77280>>>>>        Set Field_Value_Table Field OrderHea.Terms to Terms_table
77281>>>>>        Set Status_Help Field OrderHea.Terms To "Payment terms"
77282>>>>>
77282>>>>>        Set Field_Class_Name Field OrderHea.Ship_Via To "dbComboForm"
77283>>>>>        Set Field_Value_Table Field OrderHea.Ship_Via to Ship_Table
77284>>>>>        Set Status_Help Field OrderHea.Ship_Via To "Shipping method"
77285>>>>>
77285>>>>>        Set Status_Help Field OrderHea.Ordered_By To "Order placed by"
77286>>>>>        Set Field_Option Field OrderHea.Ordered_By DD_COMMIT to True
77287>>>>>
77287>>>>>        Set Field_Label_Long Field OrderHea.Salesperson_ID To "Sales Person ID"
77288>>>>>        Set Field_Label_Short Field OrderHea.Salesperson_ID To "Sales ID"
77289>>>>>        Set Status_Help Field OrderHea.Salesperson_ID To "Sales Person who initiated the order"
77290>>>>>
77290>>>>>        Set Field_Mask_Type Field OrderHea.Order_Total To MASK_CURRENCY_WINDOW
77291>>>>>        Set Field_Option Field OrderHea.Order_Total DD_DISPLAYONLY to True
77292>>>>>
77292>>>>>
77292>>>>>    End_Procedure  // Construct_Object
77293>>>>>
77293>>>>>    Procedure Field_Defaults
77295>>>>>        Forward Send Field_Defaults
77297>>>>>    End_Procedure
77298>>>>>
77298>>>>>    // Add a default date if the field is blank
77298>>>>>    Procedure Entry_Order_Date Integer iField Date dDate
77300>>>>>         Integer iChanged
77300>>>>>         
77300>>>>>         Get Field_Changed_State iField To iChanged
77301>>>>>         If (iChanged=0 And dDate=0) Begin
77303>>>>>            SysDate dDate
77304>>>>>            Set Field_Default_Value iField To dDate
77305>>>>>         End
77305>>>>>>
77305>>>>>    End_Procedure
77306>>>>>
77306>>>>>    Procedure Update
77308>>>>>        Forward Send Update
77310>>>>>        Send Adjust_Balances OrderHea.Order_Total
77311>>>>>    End_Procedure
77312>>>>>
77312>>>>>    Procedure Backout
77314>>>>>        Forward Send Backout
77316>>>>>        Send Adjust_Balances (-OrderHea.Order_Total)
77317>>>>>    End_Procedure
77318>>>>>
77318>>>>>    Procedure Adjust_Balances Number Amt
77320>>>>>        Add Amt To Customer.Purchases
77321>>>>>        Add Amt To Customer.Balance
77322>>>>>    End_Procedure
77323>>>>>
77323>>>>>    Procedure Deleting
77325>>>>>        Forward Send Deleting
77327>>>>>        // see if we can decrement the order number in sys file...can only do
77327>>>>>        // this if this is the newest order.
77327>>>>>        If (OrderHea.Order_Number=OrdSys.Order_Number) Begin // if this is
77329>>>>>           Decrement OrdSys.Order_Number          // the last number,
77330>>>>>           Saverecord OrdSys                      // decrement and save.
77331>>>>>        End
77331>>>>>>
77331>>>>>    End_Procedure
77332>>>>>
77332>>>>>End_Class    //  OrderHea_DataDictionary
77333>>>>>
77333>>>>>Use OrderHea.sl      // OrderHea_sl
Including file: Orderhea.sl    (C:\Test\Order Entry git\AppSrc\Orderhea.sl)
77333>>>>>>>Use DFClient.pkg
77333>>>>>>>Use DFSelLst.pkg
77333>>>>>>>Use Windows.pkg
77333>>>>>>>Use cDbCJGridPromptList.pkg
77333>>>>>>>
77333>>>>>>>Use Customer.DD
77333>>>>>>>Use OrderHea.DD
77333>>>>>>>
77333>>>>>>>
77333>>>>>>>CD_Popup_Object OrderHea_sl is a dbModalPanel
77351>>>>>>>>
77351>>>>>>>
77351>>>>>>>    Set Minimize_Icon to False
77352>>>>>>>    Set Label to "Order List"
77353>>>>>>>    Set Size to 134 392
77354>>>>>>>    Set Location to 4 5
77355>>>>>>>    Set piMinSize to 134 392
77356>>>>>>>
77356>>>>>>>    Object Customer_DD is a Customer_DataDictionary
77358>>>>>>>    End_Object    // Customer_DD
77359>>>>>>>
77359>>>>>>>    Object OrderHea_DD is a OrderHea_DataDictionary
77361>>>>>>>        Set DDO_Server to Customer_DD
77362>>>>>>>    End_Object    // OrderHea_DD
77363>>>>>>>
77363>>>>>>>    Set Main_DD to OrderHea_DD
77364>>>>>>>    Set Server to OrderHea_DD
77365>>>>>>>
77365>>>>>>>    Object oSelList is a cDbCJGridPromptList
77367>>>>>>>        Set Size to 100 377
77368>>>>>>>        Set Location to 9 7
77369>>>>>>>        Set pbAllowColumnRemove to False
77370>>>>>>>        Set peAnchors to anAll
77371>>>>>>>
77371>>>>>>>        Object oOrderHea_Order_Number is a cDbCJGridColumn
77373>>>>>>>            Entry_Item OrderHea.Order_Number
77374>>>>>>>            Set piWidth to 87
77375>>>>>>>            Set psCaption to "Order Number"
77376>>>>>>>        End_Object
77377>>>>>>>
77377>>>>>>>        Object oCustomer_Customer_Number is a cDbCJGridColumn
77379>>>>>>>            Entry_Item Customer.Customer_Number
77380>>>>>>>            Set piWidth to 84
77381>>>>>>>            Set psCaption to "Cust. Number"
77382>>>>>>>        End_Object
77383>>>>>>>
77383>>>>>>>        Object oCustomer_Name is a cDbCJGridColumn
77385>>>>>>>            Entry_Item Customer.Name
77386>>>>>>>            Set piWidth to 231
77387>>>>>>>            Set psCaption to "Customer Name"
77388>>>>>>>        End_Object
77389>>>>>>>
77389>>>>>>>        Object oOrderHea_Order_Date is a cDbCJGridColumn
77391>>>>>>>            Entry_Item OrderHea.Order_Date
77392>>>>>>>            Set piWidth to 75
77393>>>>>>>            Set psCaption to "Order Date"
77394>>>>>>>            Set peTextAlignment to xtpAlignmentRight
77395>>>>>>>        End_Object
77396>>>>>>>
77396>>>>>>>        Object oOrderHea_Order_Total is a cDbCJGridColumn
77398>>>>>>>            Entry_Item OrderHea.Order_Total
77399>>>>>>>            Set piWidth to 88
77400>>>>>>>            Set psCaption to "Order Total"
77401>>>>>>>        End_Object
77402>>>>>>>    End_Object
77403>>>>>>>
77403>>>>>>>    Object oOK_bn is a Button
77405>>>>>>>        Set Label to "&Ok"
77406>>>>>>>        Set Location to 116 231
77407>>>>>>>        Set peAnchors to anBottomRight
77408>>>>>>>
77408>>>>>>>        Procedure OnClick
77411>>>>>>>            Send OK of oSelList
77412>>>>>>>        End_Procedure
77413>>>>>>>
77413>>>>>>>    End_Object    // oOK_bn
77414>>>>>>>
77414>>>>>>>    Object oCancel_bn is a Button
77416>>>>>>>        Set Label to "&Cancel"
77417>>>>>>>        Set Location to 116 284
77418>>>>>>>        Set peAnchors to anBottomRight
77419>>>>>>>
77419>>>>>>>        Procedure OnClick
77422>>>>>>>            Send Cancel of oSelList
77423>>>>>>>        End_Procedure
77424>>>>>>>
77424>>>>>>>    End_Object    // oCancel_bn
77425>>>>>>>
77425>>>>>>>    Object oSearch_bn is a Button
77427>>>>>>>        Set Label to "&Search..."
77428>>>>>>>        Set Location to 116 337
77429>>>>>>>        Set peAnchors to anBottomRight
77430>>>>>>>
77430>>>>>>>        Procedure OnClick
77433>>>>>>>            Send Search of oSelList
77434>>>>>>>        End_Procedure
77435>>>>>>>
77435>>>>>>>    End_Object    // oSearch_bn
77436>>>>>>>
77436>>>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOk_bn
77437>>>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_bn
77438>>>>>>>    On_Key Key_Alt+Key_S Send KeyAction of oSearch_bn
77439>>>>>>>
77439>>>>>>>CD_End_Object    // OrderHea_sl
77441>>>>>>>>
77441>>>>>
77441>>>>>
77441>>>Use OrderDtl.DD
Including file: OrderDtl.dd    (C:\Test\Order Entry git\DDSrc\OrderDtl.dd)
77441>>>>>Use  Windows.pkg           // Basic Definitions
77441>>>>>Use  DataDict.pkg          // DataDictionary Class Definition
77441>>>>>Use  DDvalTbl.pkg          // Validation Table Class Definitions
77441>>>>>
77441>>>>>Open OrderDtl
77443>>>>>Open OrderHea
77445>>>>>Open Invt
77447>>>>>
77447>>>>>
77447>>>>>Class OrderDtl_DataDictionary Is A DataDictionary
77448>>>>>
77448>>>>>    Procedure Construct_Object
77450>>>>>        Forward Send Construct_Object
77452>>>>>
77452>>>>>        Set Main_File To OrderDtl.File_Number
77453>>>>>        Set Cascade_Delete_State To False
77454>>>>>
77454>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_FINDREQ to True
77455>>>>>        Set Foreign_Field_Option DD_INDEXFIELD DD_NOPUT to True
77456>>>>>        Set Foreign_Field_Option DD_DEFAULT DD_DISPLAYONLY to True
77457>>>>>
77457>>>>>        Set Add_Server_File to OrderHea.File_Number
77458>>>>>        Set Add_Server_File to Invt.File_Number
77459>>>>>
77459>>>>>        Set Field_Auto_Increment Field OrderDtl.Detail_Number to File_Field OrderHea.Last_Detail_Num
77460>>>>>
77460>>>>>
77460>>>>>        Set Field_Option Field OrderDtl.Order_Number DD_NOPUT to True
77461>>>>>
77461>>>>>        Set Field_Option Field OrderDtl.Detail_Number DD_NOPUT to True
77462>>>>>
77462>>>>>
77462>>>>>        Set Field_Exit_msg Field OrderDtl.Qty_Ordered To Adjust_Display_Total
77463>>>>>        Set Field_Label_Long Field OrderDtl.Qty_Ordered To "Quantity Ordered"
77464>>>>>        Set Field_Label_Short Field OrderDtl.Qty_Ordered To "Quantity"
77465>>>>>        Set Field_Mask_Type Field OrderDtl.Qty_Ordered To MASK_NUMERIC_WINDOW
77466>>>>>        Set Status_Help Field OrderDtl.Qty_Ordered To "Number of items ordered"
77467>>>>>
77467>>>>>        Set Field_Entry_msg Field OrderDtl.Price To Entering_Price
77468>>>>>        Set Field_Exit_msg Field OrderDtl.Price To Adjust_Display_Total
77469>>>>>        Set Field_Label_Long Field OrderDtl.Price To "Price per Unit"
77470>>>>>        Set Field_Label_Short Field OrderDtl.Price To "Price"
77471>>>>>        Set Field_Mask_Type Field OrderDtl.Price To MASK_CURRENCY_WINDOW
77472>>>>>        Set Status_Help Field OrderDtl.Price To "Price per Unit"
77473>>>>>
77473>>>>>        Set Field_Label_Long Field OrderDtl.Extended_Price To "Extended Price"
77474>>>>>        Set Field_Label_Short Field OrderDtl.Extended_Price To "Total"
77475>>>>>        Set Field_Mask_Type Field OrderDtl.Extended_Price To MASK_CURRENCY_WINDOW
77476>>>>>        Set Field_Option Field OrderDtl.Extended_Price DD_DISPLAYONLY to True
77477>>>>>        Set Status_Help Field OrderDtl.Extended_Price To "Total extended price"
77478>>>>>
77478>>>>>    End_Procedure  //  Construct_Object
77479>>>>>
77479>>>>>    // Update and Backout need to adjust the Invt.On_Hand quantity,
77479>>>>>    // the dtl line's extended price and the OrderHea total. We will call
77479>>>>>    // the same procedure (Adjust_Balances) to insure that backout and
77479>>>>>    // update are inverses of each other.
77479>>>>>    // Note that Backout does not need to change the extended_price. This
77479>>>>>    // only gets changed as part of update.
77479>>>>>    Procedure Update
77481>>>>>        Forward Send Update
77483>>>>>        Move (OrderDtl.Price * OrderDtl.Qty_Ordered) To OrderDtl.Extended_Price
77484>>>>>        Send Adjust_Balances OrderDtl.Qty_Ordered OrderDtl.Extended_Price
77485>>>>>    End_Procedure
77486>>>>>    
77486>>>>>    Procedure Backout
77488>>>>>        Forward Send Backout
77490>>>>>        Send Adjust_Balances (-OrderDtl.Qty_Ordered) (-OrderDtl.Extended_Price)
77491>>>>>    End_Procedure
77492>>>>>
77492>>>>>    // Called by Backout and Update passing the quantity
77492>>>>>    // and the extended price. 
77492>>>>>    // Subtract quantity from Invt on-hand and
77492>>>>>    // add extended amnt to order total.
77492>>>>>    Procedure Adjust_Balances Number Qty Number Amt
77494>>>>>        Subtract Qty From Invt.On_Hand
77495>>>>>        Add      Amt To   OrderHea.Order_Total
77496>>>>>    End_Procedure
77497>>>>>
77497>>>>>    // when entering the price field we may wish to update the
77497>>>>>    // current field value with the standard unit price from the
77497>>>>>    // Invt file. Only do this if the current amount is zero and an item was actually picked. If non-
77497>>>>>    // zero or no item picked, we assume the field is being edited (and we make no assumptions). 
77497>>>>>    Procedure Entering_Price Integer Field# Number nAmnt
77499>>>>>        Handle hoInvtDD
77499>>>>>        Boolean bHasRecord
77499>>>>>
77499>>>>>        Get Data_Set Invt.File_Number to hoInvtDD
77500>>>>>
77500>>>>>        If (hoInvtDD) Begin
77502>>>>>            Get HasRecord of hoInvtDD to bHasRecord
77503>>>>>        
77503>>>>>            If (nAmnt=0 and bHasRecord) Begin
77505>>>>>               Get File_Field_Current_Value File_Field Invt.Unit_Price to nAmnt
77506>>>>>               Set Field_Changed_Value Field# to nAmnt
77507>>>>>               Send Adjust_Display_Total
77508>>>>>            End
77508>>>>>>
77508>>>>>        End
77508>>>>>>
77508>>>>>        
77508>>>>>    End_Procedure
77509>>>>>
77509>>>>>    // This updates the extended price field, which will update any 
77509>>>>>    // display balances. This is only done for display purposes. The actual
77509>>>>>    // amount is updated to the field during the save.
77509>>>>>    Procedure Adjust_Display_total Integer iField String sValue
77511>>>>>        Integer iQty
77511>>>>>        Number  nAmnt
77511>>>>>        
77511>>>>>        Get Field_Current_Value Field OrderDtl.Qty_Ordered    To iQty
77512>>>>>        Get Field_Current_Value Field OrderDtl.Price          To nAmnt
77513>>>>>        Set Field_Current_Value Field OrderDtl.Extended_Price To (nAmnt * iQty)
77514>>>>>        // note we set value, but not changed state!
77514>>>>>    End_Procedure
77515>>>>>
77515>>>>>
77515>>>>>    Procedure Field_Defaults
77517>>>>>        Forward Send Field_Defaults
77519>>>>>    End_Procedure    // Field_Defaults
77520>>>>>    
77520>>>>>End_Class    //  OrderDtl_DataDictionary
77521>>>>>
77521>>>Use cDbCJGrid.pkg
77521>>>Use cCJGridColumnRowIndicator.pkg
Including file: cCJGridColumnRowIndicator.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cCJGridColumnRowIndicator.pkg)
77521>>>>>Use cCJGridColumn.pkg
77521>>>>>
77521>>>>>Class cCJGridColumnRowIndicator is a cCJGridColumn
77522>>>>>    
77522>>>>>    Procedure Construct_Object
77524>>>>>        Forward Send Construct_Object
77526>>>>>    
77526>>>>>        Property Integer piImage 0
77527>>>>>        
77527>>>>>        Set psCaption to ""
77528>>>>>        Set piWidth to 20
77529>>>>>        Set pbResizable to False
77530>>>>>        Set pbEditable to False
77531>>>>>        Set pbFocusable to False
77532>>>>>        Set pbAllowDrag to False
77533>>>>>        Set psToolTip to "Row Indicator"
77534>>>>>//        Set Color to (RGB(217,222,243))   //JVH
77534>>>>>    End_Procedure
77535>>>>>    
77535>>>>>    Procedure OnCreateColumn
77537>>>>>        Integer iImage
77537>>>>>        Delegate Get AddImage "GridColumnRowIndicator.bmp" 0 to iImage
77539>>>>>        Set piImage to iImage
77540>>>>>    End_Procedure
77541>>>>>            
77541>>>>>    Procedure OnSetDisplayMetrics Handle hoGridItemMetrics Integer iRow String ByRef sValue
77543>>>>>        Integer iImage iFocusedRow
77543>>>>>        Handle hoDataSource
77543>>>>>        
77543>>>>>        Get phoDataSource to hoDataSource
77544>>>>>        Get SelectedRow of hoDataSource to iFocusedRow
77545>>>>>        Move -1 to iImage
77546>>>>>        If (iRow = iFocusedRow) Begin
77548>>>>>            Get piImage to iImage
77549>>>>>            Set ComItemIcon of hoGridItemMetrics to iImage
77550>>>>>        End
77550>>>>>>
77550>>>>>    End_Procedure
77551>>>>>
77551>>>>>End_Class
77552>>>
77552>>>Use MonthCalendarPrompt.dg
Including file: MonthCalendarPrompt.dg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\MonthCalendarPrompt.dg)
77552>>>>>// Month Calendar Prompt dialog
77552>>>>>
77552>>>>>
77552>>>>>Use cMonthCalendarPrompt.pkg
Including file: cMonthCalendarPrompt.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cMonthCalendarPrompt.pkg)
77552>>>>>>>Use cMonthCalendar.pkg
Including file: cMonthCalendar.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cMonthCalendar.pkg)
77552>>>>>>>>>Use Windows.pkg
77552>>>>>>>>>Use Commctrl.pkg
77552>>>>>>>>>Use tWinStructs.pkg
77552>>>>>>>>>Use cWinControlEx.pkg
Including file: cWinControlEx.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cWinControlEx.pkg)
77552>>>>>>>>>>>Use cWinControl.pkg
77552>>>>>>>>>>>// This adds proper navigation and default button support for
77552>>>>>>>>>>>// external classes
77552>>>>>>>>>>>
77552>>>>>>>>>>>Class cWinControlEx is a cWinControl
77553>>>>>>>>>>>    Import_Class_Protocol Standard_Form_Mixin
77554>>>>>>>>>>>    Procedure Construct_Object
77556>>>>>>>>>>>        Forward Send Construct_Object
77558>>>>>>>>>>>        Send define_standard_Form_Mixin
77559>>>>>>>>>>>    End_Procedure
77560>>>>>>>>>>>    
77560>>>>>>>>>>>    Function item_count Integer iItem Returns Integer
77562>>>>>>>>>>>        Function_Return 1
77563>>>>>>>>>>>    End_Function
77564>>>>>>>>>>>    
77564>>>>>>>>>>>    Procedure External_SetFocus
77566>>>>>>>>>>>        Send notify_focus_change 1
77567>>>>>>>>>>>    End_Procedure
77568>>>>>>>>>>>
77568>>>>>>>>>>>    Procedure External_KillFocus
77570>>>>>>>>>>>        Send notify_focus_change 0
77571>>>>>>>>>>>    End_Procedure
77572>>>>>>>>>>>
77572>>>>>>>>>>>    Procedure End_Construct_Object
77574>>>>>>>>>>>        Forward Send End_Construct_Object
77576>>>>>>>>>>>        Set External_Message WM_SETFOCUS  to External_SetFocus
77577>>>>>>>>>>>        Set External_Message WM_KILLFOCUS to External_KillFocus
77578>>>>>>>>>>>    End_Procedure
77579>>>>>>>>>>>        
77579>>>>>>>>>>>End_Class
77580>>>>>>>>>>>
77580>>>>>>>>>
77580>>>>>>>>>Class cMonthCalendar is a cWinControlEx
77581>>>>>>>>>    Procedure Construct_Object
77583>>>>>>>>>        Integer iResult
77583>>>>>>>>>        tWinInitCommonControlsEX InitCC
77583>>>>>>>>>        tWinInitCommonControlsEX InitCC
77583>>>>>>>>>
77583>>>>>>>>>        Forward Send Construct_Object
77585>>>>>>>>>
77585>>>>>>>>>        Move (SizeOfType (tWinInitCommonControlsEX)) to InitCC.dwSize
77586>>>>>>>>>        Move ICC_DATE_CLASSES to InitCC.dwICC
77587>>>>>>>>>        Move (InitCommonControlsEx(AddressOf(InitCC))) to iResult
77588>>>>>>>>>        
77588>>>>>>>>>        Set External_Class_Name 'cMonthCalendar' to 'SysMonthCal32'
77589>>>>>>>>>        Set External_Message WM_LBUTTONDBLCLK to msg_OnLButtonDblClick
77590>>>>>>>>>        
77590>>>>>>>>>        Set Border_Style to Border_Normal
77591>>>>>>>>>        
77591>>>>>>>>>        Property Boolean pbNoToday False
77592>>>>>>>>>        Property Boolean pbNoTodayCircle False
77593>>>>>>>>>        Property Boolean pbMultiSelect False
77594>>>>>>>>>        Property Boolean pbWeekNumbers False
77595>>>>>>>>>        Property Integer piMaxSelectedCount 90
77596>>>>>>>>>        
77596>>>>>>>>>        // this is minimum Dialog units required for a single picker rectangle
77596>>>>>>>>>        Property Integer piMinWidth 0
77597>>>>>>>>>        Property Integer piMinHeight 0
77598>>>>>>>>>
77598>>>>>>>>>        // stores initial date before control is activated
77598>>>>>>>>>        Property Date pdPrivateDate 
77599>>>>>>>>>        // if multi-select, this is the end range
77599>>>>>>>>>        Property Date pdPrivateDate2 
77600>>>>>>>>>        
77600>>>>>>>>>    End_Procedure
77601>>>>>>>>>    
77601>>>>>>>>>    // returns control's value when single select
77601>>>>>>>>>    Function SelectedDate Returns Date
77603>>>>>>>>>        tWinSystemTime CurrentSystemTime
77603>>>>>>>>>        tWinSystemTime CurrentSystemTime
77603>>>>>>>>>        Integer iRetval
77603>>>>>>>>>        DateTime dtSel
77603>>>>>>>>>        Handle hWnd
77603>>>>>>>>>        Get Window_Handle to hWnd
77604>>>>>>>>>        If (hWnd) Begin
77606>>>>>>>>>            Move (Windows_Message (MCM_GETCURSEL, 0, AddressOf (CurrentSystemTime))) to iRetval
77607>>>>>>>>>            Move (DateSetDay(dtSel,CurrentSystemTime.wDay)) to dtSel
77608>>>>>>>>>            Move (DateSetMonth(dtSel,CurrentSystemTime.wMonth)) to dtSel
77609>>>>>>>>>            Move (DateSetYear(dtSel,CurrentSystemTime.wYear)) to dtSel
77610>>>>>>>>>        End
77610>>>>>>>>>>
77610>>>>>>>>>        Else Begin
77611>>>>>>>>>            Get pdPrivateDate to dtSel
77612>>>>>>>>>        End
77612>>>>>>>>>>
77612>>>>>>>>>        Function_Return (Date(dtSel))
77613>>>>>>>>>    End_Function
77614>>>>>>>>>
77614>>>>>>>>>    // returns control's values when multi select
77614>>>>>>>>>    Function SelectedDateRange Returns Date[]
77616>>>>>>>>>        tWinSystemTime[2] CurrentSystemTime
77616>>>>>>>>>        tWinSystemTime[2] CurrentSystemTime
77617>>>>>>>>>        Integer iRetval
77617>>>>>>>>>        DateTime dtSel1 dtsel2
77617>>>>>>>>>        Date[] dtSel
77618>>>>>>>>>        Handle hWnd
77618>>>>>>>>>        Get Window_Handle to hWnd
77619>>>>>>>>>        If (hWnd) Begin
77621>>>>>>>>>            Move (Windows_Message (MCM_GETSELRANGE, 0, AddressOf (CurrentSystemTime))) to iRetval
77622>>>>>>>>>            
77622>>>>>>>>>            Move (DateSetDay(dtSel1,CurrentSystemTime[0].wDay)) to dtSel1
77623>>>>>>>>>            Move (DateSetMonth(dtSel1,CurrentSystemTime[0].wMonth)) to dtSel1
77624>>>>>>>>>            Move (DateSetYear(dtSel1,CurrentSystemTime[0].wYear)) to dtSel1
77625>>>>>>>>>            
77625>>>>>>>>>            Move (DateSetDay(dtSel2,CurrentSystemTime[1].wDay)) to dtSel2
77626>>>>>>>>>            Move (DateSetMonth(dtSel2,CurrentSystemTime[1].wMonth)) to dtSel2
77627>>>>>>>>>            Move (DateSetYear(dtSel2,CurrentSystemTime[1].wYear)) to dtSel2
77628>>>>>>>>>            
77628>>>>>>>>>            Move dtSel1 to dtSel[0]
77629>>>>>>>>>            Move dtsel2 to dtSel[1]
77630>>>>>>>>>        End
77630>>>>>>>>>>
77630>>>>>>>>>        Else Begin
77631>>>>>>>>>            Get pdPrivateDate to dtSel[0]
77632>>>>>>>>>            Get pdPrivateDate2 to dtSel[1]
77633>>>>>>>>>        End
77633>>>>>>>>>>
77633>>>>>>>>>        Function_Return dtSel
77634>>>>>>>>>    End_Function
77635>>>>>>>>>
77635>>>>>>>>>    // Set control's value when single select
77635>>>>>>>>>    Procedure SetSelectedDate Date dDate
77637>>>>>>>>>        tWinSystemTime CurrentSystemTime
77637>>>>>>>>>        tWinSystemTime CurrentSystemTime
77637>>>>>>>>>        Integer iRetval
77637>>>>>>>>>        Handle hWnd
77637>>>>>>>>>        
77637>>>>>>>>>        Get Window_Handle to hWnd
77638>>>>>>>>>        Set pdPrivateDate to dDate
77639>>>>>>>>>        If (hWnd) Begin
77641>>>>>>>>>            Move (DateGetDay(dDate)) to CurrentSystemTime.wDay
77642>>>>>>>>>            Move (DateGetMonth(dDate)) to CurrentSystemTime.wMonth
77643>>>>>>>>>            Move (DateGetYear(dDate)) to CurrentSystemTime.wYear
77644>>>>>>>>>    
77644>>>>>>>>>           Move (Windows_Message (MCM_SETCURSEL, 0, AddressOf (CurrentSystemTime))) to iRetval        
77645>>>>>>>>>        End
77645>>>>>>>>>>
77645>>>>>>>>>    End_Procedure
77646>>>>>>>>>
77646>>>>>>>>>    // Set control's values when multi select
77646>>>>>>>>>    Procedure SetSelectedDateRange Date dDate Date dDate2
77648>>>>>>>>>        tWinSystemTime[] CurrentSystemTime
77648>>>>>>>>>        tWinSystemTime[] CurrentSystemTime
77649>>>>>>>>>        Integer iRetval
77649>>>>>>>>>        Handle hWnd
77649>>>>>>>>>
77649>>>>>>>>>        Get Window_Handle to hWnd
77650>>>>>>>>>        Set pdPrivateDate to dDate
77651>>>>>>>>>        Set pdPrivateDate2 to dDate2
77652>>>>>>>>>        If (hWnd) Begin
77654>>>>>>>>>            Move (DateGetDay(dDate)) to CurrentSystemTime[0].wDay
77655>>>>>>>>>            Move (DateGetMonth(dDate)) to CurrentSystemTime[0].wMonth
77656>>>>>>>>>            Move (DateGetYear(dDate)) to CurrentSystemTime[0].wYear
77657>>>>>>>>>
77657>>>>>>>>>            Move (DateGetDay(dDate2)) to CurrentSystemTime[1].wDay
77658>>>>>>>>>            Move (DateGetMonth(dDate2)) to CurrentSystemTime[1].wMonth
77659>>>>>>>>>            Move (DateGetYear(dDate2)) to CurrentSystemTime[1].wYear
77660>>>>>>>>>    
77660>>>>>>>>>            Move (Windows_Message (MCM_SETSELRANGE, 0, AddressOf (CurrentSystemTime))) to iRetval        
77661>>>>>>>>>        End
77661>>>>>>>>>>
77661>>>>>>>>>    End_Procedure
77662>>>>>>>>>    
77662>>>>>>>>>    // augment to set dates from control, so they can be accessed after the control is closed
77662>>>>>>>>>    Procedure Remove_Object
77664>>>>>>>>>        Date[] SelDate 
77665>>>>>>>>>        If (pbMultiSelect(Self)) Begin
77667>>>>>>>>>            Get SelectedDateRange to SelDate
77668>>>>>>>>>            Set pdPrivateDate2 to SelDate[1]
77669>>>>>>>>>        End
77669>>>>>>>>>>
77669>>>>>>>>>        Else Begin
77670>>>>>>>>>            Get SelectedDate to SelDate[0]
77671>>>>>>>>>        End
77671>>>>>>>>>>
77671>>>>>>>>>        Set pdPrivateDate to SelDate[0]
77672>>>>>>>>>        Forward Send Remove_Object
77674>>>>>>>>>    End_Procedure
77675>>>>>>>>>
77675>>>>>>>>>    Procedure Page Integer iState
77677>>>>>>>>>        Integer iRetval iSize iHeight iWidth
77677>>>>>>>>>        tWinRect WindowRect
77677>>>>>>>>>        tWinRect WindowRect
77677>>>>>>>>>        Date dDate dDate2
77677>>>>>>>>>        Handle hWnd
77677>>>>>>>>>        Integer  iMaxSelectedCount
77677>>>>>>>>>        Boolean bNoToday bWeekNumbers bMultiSelect bNoTodayCircle
77677>>>>>>>>>        
77677>>>>>>>>>        If (iState<>1) Begin
77679>>>>>>>>>            Forward Send Page iState
77681>>>>>>>>>            Procedure_Return
77682>>>>>>>>>        End
77682>>>>>>>>>>
77682>>>>>>>>>        
77682>>>>>>>>>        Set Icon to 'ActionCalendar.ico'
77683>>>>>>>>>
77683>>>>>>>>>        Get pbNoToday to bNoToday
77684>>>>>>>>>        Get pbNoTodayCircle to bNoTodayCircle
77685>>>>>>>>>        Get pbMultiSelect to bMultiSelect
77686>>>>>>>>>        Get pbWeekNumbers to bWeekNumbers
77687>>>>>>>>>        Get piMaxSelectedCount to iMaxSelectedCount
77688>>>>>>>>>
77688>>>>>>>>>        Set Window_Style MCS_MULTISELECT to bMultiSelect
77689>>>>>>>>>        Set Window_Style MCS_NOTODAY to bNoToday
77690>>>>>>>>>        Set Window_Style MCS_NOTODAYCIRCLE to bNoTodayCircle
77691>>>>>>>>>        Set Window_Style MCS_WEEKNUMBERS to bWeekNumbers
77692>>>>>>>>>        Forward Send Page iState
77694>>>>>>>>>
77694>>>>>>>>>        Get Window_Handle to hWnd
77695>>>>>>>>>        // support double click
77695>>>>>>>>>        Move (SetClassLong(hWnd,GCL_STYLE,CS_DBLCLKS ior CS_GLOBALCLASS)) to iRetval
77696>>>>>>>>>        // set range when multi select
77696>>>>>>>>>        Move (Windows_Message(MCM_SETMAXSELCOUNT,iMaxSelectedCount,0)) to iRetval
77697>>>>>>>>>        
77697>>>>>>>>>        // store minimum size for calendar control and set the size to this by default
77697>>>>>>>>>        Move (Windows_Message (MCM_GETMINREQRECT, 0, AddressOf(WindowRect))) to iRetval
77698>>>>>>>>>        Get GuiToDialog WindowRect.bottom WindowRect.right to iSize
77699>>>>>>>>>        Move (Hi(iSize)) to iHeight
77700>>>>>>>>>        Move (Low(iSize)) to iWidth
77701>>>>>>>>>        Set piMinWidth to iWidth
77702>>>>>>>>>        Set piMinHeight to iHeight
77703>>>>>>>>>        Set Size to iHeight iWidth
77704>>>>>>>>>        
77704>>>>>>>>>        // now that we are activated set starting date or date range
77704>>>>>>>>>        Get pdPrivateDate to dDate
77705>>>>>>>>>        If (pbMultiSelect(Self)) Begin
77707>>>>>>>>>            Get pdPrivateDate2 to dDate2
77708>>>>>>>>>            Send SetSelectedDateRange dDate dDate2
77709>>>>>>>>>        End
77709>>>>>>>>>>
77709>>>>>>>>>        Else Begin
77710>>>>>>>>>            Send SetSelectedDate dDate
77711>>>>>>>>>        End
77711>>>>>>>>>>
77711>>>>>>>>>    End_Procedure
77712>>>>>>>>>
77712>>>>>>>>>    Procedure Notify Integer wParam Integer lParam
77714>>>>>>>>>        Integer iRetval
77714>>>>>>>>>        DateTime dtSel dtSel2
77714>>>>>>>>>        tWintagNMSelChange CalenderInfo
77714>>>>>>>>>        tWintagNMSelChange CalenderInfo
77714>>>>>>>>>        Boolean bMulti
77714>>>>>>>>>        
77714>>>>>>>>>        Move (MemCopy (AddressOf (CalenderInfo), lParam, SizeOfType (tWintagNMSelChange))) to iRetval
77715>>>>>>>>>        If (CalenderInfo.nmHdr.code = MCN_SELCHANGE) Begin
77717>>>>>>>>>            Get pbMultiSelect to bMulti
77718>>>>>>>>>            Move (DateSetDay(dtSel,CalenderInfo.stSelStart.wDay)) to dtSel
77719>>>>>>>>>            Move (DateSetMonth(dtSel,CalenderInfo.stSelStart.wMonth)) to dtSel
77720>>>>>>>>>            Move (DateSetYear(dtSel,CalenderInfo.stSelStart.wYear)) to dtSel
77721>>>>>>>>>            If bMulti Begin
77723>>>>>>>>>                Move (DateSetDay(dtSel,CalenderInfo.stSelEnd.wDay)) to dtSel2
77724>>>>>>>>>                Move (DateSetMonth(dtSel,CalenderInfo.stSelEnd.wMonth)) to dtSel2
77725>>>>>>>>>                Move (DateSetYear(dtSel,CalenderInfo.stSelEnd.wYear)) to dtSel2
77726>>>>>>>>>            End
77726>>>>>>>>>>
77726>>>>>>>>>            Send OnChange (Date(dtSel)) (Date(dtSel2))
77727>>>>>>>>>        End
77727>>>>>>>>>>
77727>>>>>>>>>    End_Procedure
77728>>>>>>>>>
77728>>>>>>>>>    // sent whenever there is a selection change within the calendar
77728>>>>>>>>>    Procedure OnChangeDate Date dDate Date dDate2
77730>>>>>>>>>    End_Procedure
77731>>>>>>>>>
77731>>>>>>>>>    // sent when a click occurs in the calendar 
77731>>>>>>>>>    Procedure OnClick
77733>>>>>>>>>    End_Procedure
77734>>>>>>>>>    
77734>>>>>>>>>    // sent when a double click occurs in the calendar 
77734>>>>>>>>>    Procedure OnDoubleClick
77736>>>>>>>>>    End_Procedure
77737>>>>>>>>>    
77737>>>>>>>>>    // sends OnClick if the double click is on a calendar day
77737>>>>>>>>>    Procedure OnLButtonDblClick Integer wParam Integer lParam
77739>>>>>>>>>        Boolean bDayHit
77739>>>>>>>>>        Get MonthDayHit to bDayHit
77740>>>>>>>>>        If bDayHit Begin
77742>>>>>>>>>            Send OnDoubleClick
77743>>>>>>>>>        End
77743>>>>>>>>>>
77743>>>>>>>>>    End_Procedure
77744>>>>>>>>>
77744>>>>>>>>>    // sends OnClick if the click is on a calendar day
77744>>>>>>>>>    Procedure OnWmLButtonUp Integer wParam Integer lParam
77746>>>>>>>>>        Boolean bDayHit
77746>>>>>>>>>        Get MonthDayHit to bDayHit
77747>>>>>>>>>        If bDayHit Begin
77749>>>>>>>>>            Send OnClick
77750>>>>>>>>>        End
77750>>>>>>>>>>
77750>>>>>>>>>    End_Procedure
77751>>>>>>>>>    
77751>>>>>>>>>    // returns true if the month calander is up and the mouse is over a day
77751>>>>>>>>>    Function MonthDayHit Returns Boolean
77753>>>>>>>>>        Integer iRet
77753>>>>>>>>>        Get Windows_Message MCM_GETCURRENTVIEW 0 0 to iRet
77754>>>>>>>>>        If (iRet=MCMV_MONTH) Begin
77756>>>>>>>>>            Get HitTest to iRet
77757>>>>>>>>>            Function_Return (iRet=MCHT_CALENDARDATE)
77758>>>>>>>>>        End
77758>>>>>>>>>>
77758>>>>>>>>>        Function_Return False
77759>>>>>>>>>    End_Function
77760>>>>>>>>>    
77760>>>>>>>>>    // return what was hit in the control
77760>>>>>>>>>    Function HitTest Returns Integer
77762>>>>>>>>>        tWinMCHitTestInfo HitInfo
77762>>>>>>>>>        tWinMCHitTestInfo HitInfo
77762>>>>>>>>>        Handle hWnd iRet
77762>>>>>>>>>        Integer iVoid
77762>>>>>>>>>        Pointer lpPt
77762>>>>>>>>>        tWinPoint Pt
77762>>>>>>>>>        tWinPoint Pt
77762>>>>>>>>>        Get Window_Handle to hWnd
77763>>>>>>>>>        Move (AddressOf(Pt)) to lpPt
77764>>>>>>>>>        Move (GetCursorPos(lpPt)) to iVoid
77765>>>>>>>>>        Move (ScreenToClient(hWnd, lpPt)) to iVoid
77766>>>>>>>>>        Move Pt to HitInfo.Pt
77767>>>>>>>>>        Move (SizeOfType(tWinMCHitTestInfo)) to HitInfo.cbSize
77768>>>>>>>>>        Get WindowsMessage MCM_HITTEST 0 (AddressOf(HitInfo)) to iRet
77769>>>>>>>>>        Function_Return HitInfo.uHit
77770>>>>>>>>>    End_Function
77771>>>>>>>>>    
77771>>>>>>>>>End_Class
77772>>>>>>>
77772>>>>>>>// peMouseSelectOk choices
77772>>>>>>>Enum_List
77772>>>>>>>    Define msoClick
77772>>>>>>>    Define msoDblClick
77772>>>>>>>    Define msoNone
77772>>>>>>>End_Enum_List
77772>>>>>>>
77772>>>>>>>// It is expected that this class will only be used inside of ModalPanel and
77772>>>>>>>// will be used as a prompt object component in a framework style application.
77772>>>>>>>// If you wish to Use a month calendar in some other non prompt situation, 
77772>>>>>>>// use cMonthCalendar
77772>>>>>>>
77772>>>>>>>Class cMonthCalendarPrompt is a cMonthCalendar
77773>>>>>>>
77773>>>>>>>    Procedure Construct_Object
77775>>>>>>>
77775>>>>>>>        Forward Send Construct_Object
77777>>>>>>>
77777>>>>>>>        Property Integer peUpdateMode umPromptValue
77778>>>>>>>
77778>>>>>>>        Property Integer peMouseSelectOk msoClick
77779>>>>>>>        
77779>>>>>>>        Property Date pdSeedValue
77780>>>>>>>
77780>>>>>>>        // if multi-select, this is the end range
77780>>>>>>>        Property Date pdSeedValue2
77781>>>>>>>
77781>>>>>>>        Property Handle phmPromptUpdateCallback 0
77782>>>>>>>
77782>>>>>>>        Property Integer phoInvokingObject
77783>>>>>>>        
77783>>>>>>>        Property Integer peStoredUpdateMode
77784>>>>>>>        Property Handle  phmStoredPromptUpdateCallback
77785>>>>>>>        Property Boolean pbStoredWeekNumbers
77786>>>>>>>        Property Boolean pbStoredNoToday
77787>>>>>>>        Property Boolean pbStoredNoTodayCircle
77788>>>>>>>        Property Boolean pbStoredMultiSelect
77789>>>>>>>        Property Integer piStoredMaxSelectedCount
77790>>>>>>>        Property Integer peStoredpeMouseSelectOk
77791>>>>>>>
77791>>>>>>>        // internally set by list
77791>>>>>>>        // these must be set upon closing the list and can be used for manual list updates
77791>>>>>>>        Property Boolean pbCanceled
77792>>>>>>>
77792>>>>>>>    End_Procedure
77793>>>>>>>        
77793>>>>>>>    Procedure OnStoreDefaults
77795>>>>>>>        Integer iVal
77795>>>>>>>        Boolean bVal
77795>>>>>>>
77795>>>>>>>        Get peUpdateMode to iVal
77796>>>>>>>        Set peStoredUpdateMode to iVal
77797>>>>>>>        
77797>>>>>>>        Get phmPromptUpdateCallback to iVal       
77798>>>>>>>        Set phmStoredPromptUpdateCallback to iVal       
77799>>>>>>>
77799>>>>>>>        Get pbMultiSelect to bVal       
77800>>>>>>>        Set pbStoredMultiSelect to bVal       
77801>>>>>>>
77801>>>>>>>        Get pbNoToday to bVal       
77802>>>>>>>        Set pbStoredNoToday to bVal       
77803>>>>>>>
77803>>>>>>>        Get pbNoTodayCircle to bVal       
77804>>>>>>>        Set pbStoredNoTodayCircle to bVal       
77805>>>>>>>
77805>>>>>>>        Get pbWeekNumbers to bVal       
77806>>>>>>>        Set pbStoredWeekNumbers to bVal       
77807>>>>>>>
77807>>>>>>>        Get piMaxSelectedCount to iVal       
77808>>>>>>>        Set piStoredMaxSelectedCount to iVal  
77809>>>>>>>        
77809>>>>>>>        Get peMouseSelectOk to iVal       
77810>>>>>>>        Set peStoredpeMouseSelectOk to iVal       
77811>>>>>>>        
77811>>>>>>>    End_Procedure
77812>>>>>>>
77812>>>>>>>    Procedure OnRestoreDefaults
77814>>>>>>>        Integer iVal
77814>>>>>>>        Boolean bVal
77814>>>>>>>
77814>>>>>>>        Get peStoredUpdateMode to iVal
77815>>>>>>>        Set peUpdateMode to iVal
77816>>>>>>>        
77816>>>>>>>        Get phmStoredPromptUpdateCallback to iVal       
77817>>>>>>>        Set phmPromptUpdateCallback to iVal       
77818>>>>>>>
77818>>>>>>>        Get pbStoredMultiSelect to bVal       
77819>>>>>>>        Set pbMultiSelect to bVal       
77820>>>>>>>
77820>>>>>>>        Get pbStoredNoToday to bVal       
77821>>>>>>>        Set pbNoToday to bVal       
77822>>>>>>>
77822>>>>>>>        Get pbStoredNoTodayCircle to bVal       
77823>>>>>>>        Set pbNoTodayCircle to bVal       
77824>>>>>>>
77824>>>>>>>        Get pbStoredWeekNumbers to bVal       
77825>>>>>>>        Set pbWeekNumbers to bVal       
77826>>>>>>>
77826>>>>>>>        Get piStoredMaxSelectedCount to iVal       
77827>>>>>>>        Set piMaxSelectedCount to iVal       
77828>>>>>>>
77828>>>>>>>        Get peStoredpeMouseSelectOk to iVal       
77829>>>>>>>        Set peMouseSelectOk to iVal       
77830>>>>>>>
77830>>>>>>>    End_Procedure
77831>>>>>>>
77831>>>>>>>    Procedure Add_Focus Handle hoParent Returns Integer
77833>>>>>>>        Integer eMode
77833>>>>>>>        Set pbCanceled to True // assume cancel unless changed
77834>>>>>>>        Get peUpdateMode to eMode
77835>>>>>>>        If (eMode<>umPromptNonInvoking) Begin
77837>>>>>>>            Send OnStoreDefaults
77838>>>>>>>        End
77838>>>>>>>>
77838>>>>>>>        Send InitializePrompt
77839>>>>>>>        Forward Send Add_Focus hoParent
77841>>>>>>>    End_Procedure
77842>>>>>>>        
77842>>>>>>>    // augment to send OnRestoreDefaults.
77842>>>>>>>    Procedure Release_Focus
77844>>>>>>>        Integer eUpdateMode
77844>>>>>>>        Get peUpdateMode to eUpdateMode
77845>>>>>>>        Forward Send Release_Focus
77847>>>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
77849>>>>>>>            Send OnRestoreDefaults
77850>>>>>>>        End
77850>>>>>>>>
77850>>>>>>>    End_Procedure
77851>>>>>>>
77851>>>>>>>    // This is only called in a successful close
77851>>>>>>>    Procedure ClosePrompt
77853>>>>>>>        Handle hoInvokingObject
77853>>>>>>>        Handle hmCallBack
77853>>>>>>>        Integer eUpdateMode
77853>>>>>>>        Date[] dDates
77854>>>>>>>        
77854>>>>>>>        Set pbCanceled to False
77855>>>>>>>        
77855>>>>>>>        Get peUpdateMode to eUpdateMode
77856>>>>>>>        // if non-invoking there is by definition, no move value out
77856>>>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
77858>>>>>>>            
77858>>>>>>>            If (eUpdateMode=umPromptValue) Begin
77860>>>>>>>                Send OnMoveValueOutByValue
77861>>>>>>>            End
77861>>>>>>>>
77861>>>>>>>            Else If (eUpdateMode=umPromptCustom) Begin
77864>>>>>>>                Send OnMoveValueOutByCustom
77865>>>>>>>            End
77865>>>>>>>>
77865>>>>>>>            Get phmPromptUpdateCallback to hmCallBack
77866>>>>>>>            If hmCallBack Begin
77868>>>>>>>                Get phoInvokingObject to hoInvokingObject
77869>>>>>>>                If (pbMultiSelect(Self)) Begin
77871>>>>>>>                    Get SelectedDateRange to dDates
77872>>>>>>>                    Send hmCallBack of hoInvokingObject Self dDates[0] dDates[1]
77873>>>>>>>                    
77873>>>>>>>                End
77873>>>>>>>>
77873>>>>>>>                Else Begin
77874>>>>>>>                    Get SelectedDate to dDates[0]
77875>>>>>>>                    Send hmCallBack of hoInvokingObject Self dDates[0]
77876>>>>>>>                End
77876>>>>>>>>
77876>>>>>>>            End
77876>>>>>>>>
77876>>>>>>>        End
77876>>>>>>>>
77876>>>>>>>
77876>>>>>>>        Send Close_Panel
77877>>>>>>>    End_Procedure
77878>>>>>>>
77878>>>>>>>    Procedure OnMoveValueOutByValue
77880>>>>>>>        Handle hoInvokingObject
77880>>>>>>>        Date dSelDate
77880>>>>>>>        Boolean bMulti
77880>>>>>>>        // we can only do an automatic move value out with
77880>>>>>>>        // single select. If multi-select you will probably want to
77880>>>>>>>        // use a callback method (hmCallBack) to update the values. 
77880>>>>>>>        Get pbMultiSelect to bMulti
77881>>>>>>>        If (not(bMulti)) Begin
77883>>>>>>>            Get SelectedDate to dSelDate
77884>>>>>>>            Get phoInvokingObject to hoInvokingObject
77885>>>>>>>            Set Value of hoInvokingObject to dSelDate
77886>>>>>>>            Set Item_Changed_State of hoInvokingObject to True
77887>>>>>>>        End
77887>>>>>>>>
77887>>>>>>>    End_Procedure
77888>>>>>>>
77888>>>>>>>    Procedure OnMoveValueOutByCustom
77890>>>>>>>    End_Procedure
77891>>>>>>>        
77891>>>>>>>    // called before the list is activated. 
77891>>>>>>>    Procedure InitializePrompt
77893>>>>>>>        Handle hoInvokingObject
77893>>>>>>>        Integer eUpdateMode
77893>>>>>>>        Boolean bMulti 
77893>>>>>>>        Date dValue
77893>>>>>>>
77893>>>>>>>        Get peUpdateMode to eUpdateMode
77894>>>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
77896>>>>>>>
77896>>>>>>>            Get Focus of Desktop to hoInvokingObject
77897>>>>>>>            If (hoInvokingObject<=Desktop) Begin
77899>>>>>>>                Error DFERR_PROGRAM "Calendar Prompt has no invoking object"
77900>>>>>>>>
77900>>>>>>>                Procedure_Return
77901>>>>>>>            End
77901>>>>>>>>
77901>>>>>>>
77901>>>>>>>            Set phoInvokingObject to hoInvokingObject
77902>>>>>>>            Send Prompt_Callback to hoInvokingObject Self
77903>>>>>>>            Get peUpdateMode to eUpdateMode
77904>>>>>>>        End
77904>>>>>>>>
77904>>>>>>>
77904>>>>>>>        Get pdSeedValue to dValue
77905>>>>>>>        Get pbMultiSelect to bMulti
77906>>>>>>>        If (not(bMulti) and eUpdateMode=umPromptValue and dValue=0) Begin
77908>>>>>>>            Get Value of hoInvokingObject to dValue
77909>>>>>>>            Set pdSeedValue to dValue
77910>>>>>>>        End
77910>>>>>>>>
77910>>>>>>>        Send OnSeedData
77911>>>>>>>        Set pdSeedValue to 0
77912>>>>>>>        Set pdSeedValue2 to 0
77913>>>>>>>    End_Procedure
77914>>>>>>>    
77914>>>>>>>    Procedure OnSeedData 
77916>>>>>>>        Boolean bMulti
77916>>>>>>>        Date dValue dValue2
77916>>>>>>>        Integer iMax iRange
77916>>>>>>>        DateTime dt1 dt2
77916>>>>>>>        Get pbMultiSelect to bMulti
77917>>>>>>>        Get pdSeedValue to dValue
77918>>>>>>>        If (not(bMulti)) Begin
77920>>>>>>>            // if no date, use current date
77920>>>>>>>            If (dValue=0) Begin
77922>>>>>>>                Move (CurrentDateTime()) to dValue
77923>>>>>>>            End
77923>>>>>>>>
77923>>>>>>>            Send SetSelectedDate dValue    
77924>>>>>>>        End
77924>>>>>>>>
77924>>>>>>>        Else Begin
77925>>>>>>>            Get pdSeedValue2 to dValue2 
77926>>>>>>>            // if no dates, use current date
77926>>>>>>>            If (dValue=0 and dValue2=0) Begin
77928>>>>>>>                Move (CurrentDateTime()) to dValue
77929>>>>>>>            End
77929>>>>>>>>
77929>>>>>>>            // if only one date, make that the range
77929>>>>>>>            If (dValue=0) Begin
77931>>>>>>>                Move dValue2 to dValue
77932>>>>>>>            End
77932>>>>>>>>
77932>>>>>>>            Else If (dValue2=0) Begin
77935>>>>>>>                Move dValue to dValue2
77936>>>>>>>            End
77936>>>>>>>>
77936>>>>>>>            
77936>>>>>>>            // test for valid range
77936>>>>>>>            Get piMaxSelectedCount to iMax
77937>>>>>>>            Move dValue to dt1
77938>>>>>>>            Move dValue2 to dt2
77939>>>>>>>            Move (SpanTotalDays(dt1 - dt2)) to iRange
77940>>>>>>>            If (iRange>iMax) Begin
77942>>>>>>>                Error DFERR_OPERATOR (SFormat(C_$DateRangeExceeded,iMax))
77943>>>>>>>>
77943>>>>>>>                Move dValue to dValue2
77944>>>>>>>            End
77944>>>>>>>>
77944>>>>>>>            
77944>>>>>>>            Send SetSelectedDateRange dValue dValue2
77945>>>>>>>        End
77945>>>>>>>>
77945>>>>>>>    End_Procedure
77946>>>>>>>
77946>>>>>>>    Procedure OnDoubleClick
77948>>>>>>>        Integer eSelectOn
77948>>>>>>>        Get peMouseSelectOk to eSelectOn
77949>>>>>>>        If (eSelectOn=msoDblClick) Begin
77951>>>>>>>            Send Ok
77952>>>>>>>        End
77952>>>>>>>>
77952>>>>>>>    End_Procedure
77953>>>>>>>    
77953>>>>>>>    Procedure OnClick
77955>>>>>>>        Integer eSelectOn
77955>>>>>>>        Get peMouseSelectOk to eSelectOn
77956>>>>>>>        If (eSelectOn=msoClick) Begin
77958>>>>>>>            Send Ok
77959>>>>>>>        End
77959>>>>>>>>
77959>>>>>>>    End_Procedure
77960>>>>>>>
77960>>>>>>>    Procedure Ok Returns Integer
77962>>>>>>>        Send ClosePrompt
77963>>>>>>>    End_Procedure
77964>>>>>>>
77964>>>>>>>    Procedure Cancel Returns Integer
77966>>>>>>>        Send Close_Panel
77967>>>>>>>    End_Procedure
77968>>>>>>>        
77968>>>>>>>End_Class
77969>>>>>>>
77969>>>>>>>
77969>>>>>Use Dfclient.pkg
77969>>>>>
77969>>>>>Cd_Popup_Object oMonthCalendarPrompt is a ModalPanel
77987>>>>>>
77987>>>>>    Set Location to 10 10
77988>>>>>    Set Size to 145 145
77989>>>>>    // resizable
77989>>>>>    Set Border_Style to Border_Thick
77990>>>>>
77990>>>>>    Set Label to C_$DateSelector
77991>>>>>
77991>>>>>    Set piMinSize to 0 0 // set this dynamically // 145 145
77992>>>>>    Set piMaxSize to 310 460
77993>>>>>
77993>>>>>    // tells us if this been activated and sized yet
77993>>>>>    Property Boolean pbSizeInited False
77995>>>>>        
77995>>>>>    Object oCalendar is a cMonthCalendarPrompt
77997>>>>>        Set Size to 120 135 // not real size, will be assigned
77998>>>>>        Set Location to 5 5
77999>>>>>        Set Border_Style to Border_None
78000>>>>>    End_Object
78001>>>>>
78001>>>>>    Object oOKButton is a Button
78003>>>>>        Set Label to C_$OK
78004>>>>>        Set Default_State to True
78005>>>>>        Set Location to 129 34
78006>>>>>        Set peAnchors to anBottomRight
78007>>>>>        
78007>>>>>        Procedure OnClick
78010>>>>>            Send Ok of oCalendar
78011>>>>>        End_Procedure
78012>>>>>    End_Object
78013>>>>>
78013>>>>>    Object oCancelButton is a Button
78015>>>>>        Set Label to C_$Cancel
78016>>>>>        Set Location to 129 89
78017>>>>>        Set peAnchors to anBottomRight
78018>>>>>        
78018>>>>>        Procedure OnClick
78021>>>>>            Send Cancel of oCalendar
78022>>>>>        End_Procedure
78023>>>>>    End_Object
78024>>>>>
78024>>>>>    Procedure OnResize 
78027>>>>>        Integer iSize iHeight iWidth iMinSize
78027>>>>>        Boolean bInited
78027>>>>>
78027>>>>>        Get piMinHeight of oCalendar to iHeight
78028>>>>>        // when 0, the control has not yet been created. Nothing to do.
78028>>>>>        If (iHeight=0) Begin
78030>>>>>            Procedure_Return
78031>>>>>        End
78031>>>>>>
78031>>>>>
78031>>>>>        Get pbSizeInited to bInited
78032>>>>>        
78032>>>>>        Get piMinWidth of oCalendar to iWidth
78033>>>>>        Get piMinSize to iMinSize
78034>>>>>        // Minumum size of panel - add 1 to each to each for wiggle room
78034>>>>>        Move (iHeight+25+1) to iHeight
78035>>>>>        Move (iWidth+10+1) to iWidth
78036>>>>>         
78036>>>>>        Set piMinSize to iHeight iWidth
78037>>>>>
78037>>>>>        If (not(bInited))  Begin
78039>>>>>            Set Size to iHeight iWidth
78040>>>>>            Set pbSizeInited to True
78041>>>>>        End
78041>>>>>>
78041>>>>>        Else Begin
78042>>>>>            Send Adjust_Logicals
78043>>>>>            Get Size to iSize
78044>>>>>            If (Hi(iSize)<iHeight or Low(iSize)<iWidth) Begin
78046>>>>>                Set Size to (iHeight max Hi(iSize)) (iWidth max Low(iSize))
78047>>>>>                Get Size to iSize
78048>>>>>            End
78048>>>>>>
78048>>>>>            Set Size of oCalendar to (Hi(iSize) - 25) (Low(iSize) - 10)
78049>>>>>        End
78049>>>>>>
78049>>>>>        
78049>>>>>    End_Procedure
78050>>>>>    
78050>>>>>    Procedure Add_Focus Handle hoParent Returns Integer
78053>>>>>        Forward Send Add_Focus hoParent
78055>>>>>        Send OnResize
78056>>>>>    End_Procedure
78057>>>>>
78057>>>>>    On_Key kCancel Send KeyAction to oCancelButton
78058>>>>>
78058>>>>>Cd_End_Object
78060>>>>>>
78060>>>
78060>>>Activate_View Activate_oOrderEntryView for oOrderEntryView
78070>>>>
78070>>>Object oOrderEntryView is a dbView
78072>>>    Set Border_Style to Border_Thick
78073>>>    Set Maximize_Icon to True
78074>>>    Set Label to "Order Entry"
78075>>>    Set Location to 2 3
78076>>>    Set Size to 174 383
78077>>>    Set piMinSize to 174 383
78078>>>    Set pbAutoActivate to True
78079>>>    
78079>>>
78079>>>    Object Vendor_DD is a Vendor_DataDictionary
78081>>>    End_Object    // Vendor_DD
78082>>>
78082>>>    Object Invt_DD is a Invt_DataDictionary
78084>>>        Set DDO_Server to Vendor_DD
78085>>>    End_Object    // Invt_DD
78086>>>
78086>>>    Object Customer_DD is a Customer_DataDictionary
78088>>>    End_Object    // Customer_DD
78089>>>
78089>>>    Object SalesP_DD is a Salesp_DataDictionary
78091>>>    End_Object    // SalesP_DD
78092>>>
78092>>>    Object OrderHea_DD is a OrderHea_DataDictionary
78094>>>        Set DDO_Server to Customer_DD
78095>>>        Set DDO_Server to SalesP_DD
78096>>>        
78096>>>        // this lets you save a new OrderHea from within OrderDtl.
78096>>>        Set Allow_Foreign_New_Save_State to True
78097>>>        
78097>>>    End_Object    // OrderHea_DD
78098>>>    
78098>>>    Object OrderDtl_DD is a OrderDtl_DataDictionary
78100>>>        Set DDO_Server to OrderHea_DD
78101>>>        Set DDO_Server to Invt_DD
78102>>>        Set Constrain_File to OrderHea.File_Number
78103>>>    End_Object    // OrderDtl_DD
78104>>>
78104>>>    Set Main_DD to OrderHea_DD
78105>>>    Set Server to OrderHea_DD
78106>>>    
78106>>>    Object oDbContainer3d1 is a dbContainer3d
78108>>>        Set Size to 85 377
78109>>>        Set Location to 2 3
78110>>>        Set peAnchors to anTopLeftRight
78111>>>        
78111>>>        
78111>>>        Object oOrderHea_Order_Number is a dbForm
78113>>>            Entry_Item OrderHea.Order_Number
78114>>>            Set Label to "Order Number:"
78115>>>            Set Size to 13 42
78116>>>            Set Location to 4 63
78117>>>            Set peAnchors to anTopLeft
78118>>>            Set Label_Col_Offset to 2
78119>>>            Set Label_Justification_Mode to jMode_Right
78120>>>            
78120>>>        End_Object    // oOrderHea_Order_Number
78121>>>
78121>>>        Object oOrderHea_Customer_Number is a dbForm
78123>>>            Entry_Item Customer.Customer_Number
78124>>>            Set Label to "Customer Number:"
78125>>>            Set Size to 13 42
78126>>>            Set Location to 4 201
78127>>>            Set peAnchors to anTopRight
78128>>>            Set Label_Col_Offset to 2
78129>>>            Set Label_Justification_Mode to jMode_Right
78130>>>        End_Object    // oOrderHea_Customer_Number
78131>>>
78131>>>        Object oOrderHea_Order_Date is a dbForm
78133>>>            Entry_Item OrderHea.Order_Date
78134>>>            Set Label to "Order Date:"
78135>>>            Set Size to 13 67
78136>>>            Set Location to 4 299
78137>>>            Set peAnchors to anTopRight
78138>>>            Set Label_Col_Offset to 2
78139>>>            Set Label_Justification_Mode to jMode_Right
78140>>>            
78140>>>            Set Prompt_Object to oMonthCalendarPrompt
78141>>>            Set Prompt_Button_Mode to PB_PromptOn
78142>>>        End_Object    // oOrderHea_Order_Date
78143>>>
78143>>>        Object oCustomer_Name is a dbForm
78145>>>            Entry_Item Customer.Name
78146>>>            Set Label to "Customer Name:"
78147>>>            Set Size to 13 180
78148>>>            Set Location to 18 63
78149>>>            Set peAnchors to anTopLeftRight
78150>>>            Set Label_Col_Offset to 2
78151>>>            Set Label_Justification_Mode to jMode_Right
78152>>>        End_Object    // oCustomer_Name
78153>>>
78153>>>        Object oCustomer_Address is a dbForm
78155>>>            Entry_Item Customer.Address
78156>>>            Set Label to "Street Address:"
78157>>>            Set Size to 13 180
78158>>>            Set Location to 34 63
78159>>>            Set peAnchors to anTopLeftRight
78160>>>            Set Label_Col_Offset to 2
78161>>>            Set Label_Justification_Mode to jMode_Right
78162>>>        End_Object    // oCustomer_Address
78163>>>
78163>>>        Object oCustomer_City is a dbForm
78165>>>            Entry_Item Customer.City
78166>>>            Set Label to "City/State/Zip:"
78167>>>            Set Size to 13 84
78168>>>            Set Location to 49 63
78169>>>            Set peAnchors to anTopLeftRight
78170>>>            Set Label_Col_Offset to 2
78171>>>            Set Label_Justification_Mode to jMode_Right
78172>>>        End_Object    // oCustomer_City
78173>>>
78173>>>        Object oCustomer_State is a dbForm
78175>>>            Entry_Item Customer.State
78176>>>            Set Size to 13 20
78177>>>            Set Location to 49 155
78178>>>            Set peAnchors to anTopRight
78179>>>        End_Object    // oCustomer_State
78180>>>
78180>>>        Object oCustomer_Zip is a dbForm
78182>>>            Entry_Item Customer.Zip
78183>>>            Set Size to 13 60
78184>>>            Set Location to 49 183
78185>>>            Set peAnchors to anTopRight
78186>>>        End_Object    // oCustomer_Zip
78187>>>
78187>>>        Object oOrderHea_Ordered_By is a dbForm
78189>>>            Entry_Item OrderHea.Ordered_By
78190>>>            Set Label to "Ordered By:"
78191>>>            Set Size to 13 67
78192>>>            Set Location to 34 299
78193>>>            Set peAnchors to anTopRight
78194>>>            Set Label_Col_Offset to 2
78195>>>            Set Label_Justification_Mode to jMode_Right
78196>>>        End_Object    // oOrderHea_Ordered_By
78197>>>
78197>>>        Object oOrderHea_Salesperson_ID is a dbForm
78199>>>            Entry_Item Salesp.Id
78200>>>            Set Label to "Salesperson ID:"
78201>>>            Set Size to 13 40
78202>>>            Set Location to 49 299
78203>>>            Set peAnchors to anTopRight
78204>>>            Set Label_Col_Offset to 2
78205>>>            Set Label_Justification_Mode to jMode_Right
78206>>>        End_Object    // oOrderHea_Salesperson_ID
78207>>>
78207>>>        Object oOrderHea_Terms is a dbComboForm
78209>>>            Entry_Item OrderHea.Terms
78210>>>            Set Label to "Terms:"
78211>>>            Set Size to 13 85
78212>>>            Set Location to 64 63
78213>>>            Set peAnchors to anTopLeft
78214>>>            Set Form_Border to 0
78215>>>            Set Label_Col_Offset to 2
78216>>>            Set Label_Justification_Mode to jMode_Right
78217>>>
78217>>>        End_Object    // oOrderHea_Terms
78218>>>
78218>>>        Object oOrderHea_Ship_Via is a dbComboForm
78220>>>            Entry_Item OrderHea.Ship_Via
78221>>>            Set Label to "Ship Via:"
78222>>>            Set Size to 13 103
78223>>>            Set Location to 64 183
78224>>>            Set peAnchors to anTopRight
78225>>>            Set Form_Border to 0
78226>>>            Set Label_Col_Offset to 2
78227>>>            Set Label_Justification_Mode to jMode_Right
78228>>>
78228>>>        End_Object    // oOrderHea_Ship_Via
78229>>>
78229>>>        Object oTextBox1 is a TextBox
78231>>>            Set Size to 10 31
78232>>>            Set Location to 4 4
78233>>>            Set Label to "Hallo!!"
78234>>>            Set Justification_Mode to JMode_Right
78235>>>            Set FontWeight to fw_Bold
78236>>>            Set FontPointHeight to 90
78237>>>        End_Object
78238>>>
78238>>>    End_Object    // oDbContainer3d1
78239>>>
78239>>>    Object oOrderDtl_Grid is a cDbCJGrid
78241>>>        Set Server to OrderDtl_DD
78242>>>        Set Ordering to 1
78243>>>        Set Size to 63 377
78244>>>        Set Location to 90 3
78245>>>        Set peAnchors to anAll
78246>>>        Set pbAllowInsertRow to False
78247>>>        Set pbRestoreLayout to False
78248>>>        Set psLayoutSection to "OrderView_oOrderDtl_Grid2"
78249>>>        Set piLayoutBuild to 6
78250>>>        Set pbHeaderPrompts to True
78251>>>
78251>>>        On_Key Key_F11 Send Request_InsertRow
78252>>>
78252>>>        Object oMark is a cCJGridColumnRowIndicator
78254>>>        End_Object
78255>>>        
78255>>>        Object oInvt_Item_ID is a cDbCJGridColumn
78257>>>            Entry_Item Invt.Item_ID
78258>>>            Set piWidth to 91
78259>>>            Set psCaption to "Item ID"
78260>>>            Set psImage to "ActionPrompt.ico"
78261>>>        End_Object
78262>>>
78262>>>        Object oInvt_Description is a cDbCJGridColumn
78264>>>            Entry_Item Invt.Description
78265>>>            Set piWidth to 213
78266>>>            Set psCaption to "Description"
78267>>>        End_Object
78268>>>
78268>>>        Object oInvt_Unit_Price is a cDbCJGridColumn
78270>>>            Entry_Item Invt.Unit_Price
78271>>>            Set piWidth to 53
78272>>>            Set psCaption to "Unit Price"
78273>>>        End_Object
78274>>>
78274>>>        Object oOrderDtl_Qty_Ordered is a cDbCJGridColumn
78276>>>            Entry_Item OrderDtl.Qty_Ordered
78277>>>            Set piWidth to 50
78278>>>            Set psCaption to "Quantity"
78279>>>        End_Object
78280>>>
78280>>>        Object oOrderDtl_Price is a cDbCJGridColumn
78282>>>            Entry_Item OrderDtl.Price
78283>>>            Set piWidth to 62
78284>>>            Set psCaption to "Price"
78285>>>        End_Object
78286>>>
78286>>>        Object oOrderDtl_Extended_Price is a cDbCJGridColumn
78288>>>            Entry_Item OrderDtl.Extended_Price
78289>>>            Set piWidth to 81
78290>>>            Set psCaption to "Total"
78291>>>        End_Object
78292>>>        
78292>>>    End_Object    // oOrderDtl_Grid
78293>>>
78293>>>    Object oOrderHea_Order_Total is a dbForm
78295>>>        Entry_Item OrderHea.Order_Total
78296>>>        Set Label to "Order Total:"
78297>>>        Set Size to 13 60
78298>>>        Set Location to 156 307
78299>>>        Set peAnchors to anBottomRight
78300>>>        Set Label_Col_Offset to 3
78301>>>        Set Label_Justification_Mode to jMode_Right
78302>>>    End_Object    // oOrderHea_Order_Total
78303>>>
78303>>>    Object oPrintBtn is a Button
78305>>>        Set Label to "Print Order"
78306>>>        Set Location to 156 3
78307>>>        Set peAnchors to anBottomLeft
78308>>>        Set psToolTip to "Print preview of current order"
78309>>>
78309>>>        Procedure OnClick
78312>>>            Delegate Send PrintCurrentOrder // defined in view object
78314>>>        End_Procedure  // OnClick
78315>>>        
78315>>>    End_Object    // oPrintBtn
78316>>>
78316>>>
78316>>>    // Change:   Create custom confirmation messages for save and delete
78316>>>    //           We must create the new functions and assign verify messages
78316>>>    //           to them.
78316>>>    Function Confirm_Delete_Order Returns Integer
78319>>>        Integer iRetVal
78319>>>        Get Confirm "Delete Entire Order?" to iRetVal
78320>>>        Function_Return iRetVal
78321>>>    End_Function
78322>>>    
78322>>>    // Only confirm on the saving of new records
78322>>>    Function Confirm_Save_Order Returns Integer
78325>>>        Integer iNoSave iSrvr
78325>>>        Boolean bOld
78325>>>        Get Server to iSrvr
78326>>>        Get HasRecord of iSrvr to bOld
78327>>>        If not bOld Begin
78329>>>            Get Confirm "Save this NEW order header?" to iNoSave
78330>>>        End
78330>>>>
78330>>>        Function_Return iNoSave
78331>>>    End_Function
78332>>>    
78332>>>    // Define alternate confirmation Messages
78332>>>    Set Verify_Save_MSG       to (RefFunc(Confirm_Save_Order))
78333>>>    Set Verify_Delete_MSG     to (RefFunc(Confirm_Delete_Order))
78334>>>    Set Auto_Clear_DEO_State  to False // don't clear Header on save
78335>>>    
78335>>>    
78335>>>    // print the current order. This message will be sent
78335>>>    // by the print button
78335>>>    Procedure PrintCurrentOrder
78338>>>        Integer hDD iNum
78338>>>        Get Server to hDD // this will be the OrderHea DD
78339>>>        If (HasRecord(hDD)) Begin // only do this if record exists
78341>>>            Get Field_Current_Value of hDD Field OrderHea.Order_Number to iNum
78342>>>//            Send PrintOrder of oOrder_Report iNum
78342>>>            Send Info_Box "This is just a stub and this invoice is not actually being printed" ("Print Order " + String(iNum))
78343>>>        End
78343>>>>
78343>>>    End_Procedure
78344>>>    
78344>>>    // refresh is sent to containers. We will use that to control the print button and only
78344>>>    // enable it when an order exists
78344>>>    Procedure Refresh Integer eMode
78347>>>        Boolean bRec
78347>>>        Handle hoServer
78347>>>        Get Server to hoServer
78348>>>        Get HasRecord of hoServer to bRec
78349>>>        Set Enabled_State of oPrintBtn to bRec
78350>>>    End_Procedure
78351>>>
78351>>>End_Object
78352>        Use SalesP.vw
Including file: Salesp.vw    (C:\Test\Order Entry git\AppSrc\Salesp.vw)
78352>>>Use dfClient.pkg
78352>>>Use DataDict.pkg
78352>>>Use dfEntry.pkg
78352>>>Use SalesP.DD
78352>>>
78352>>>DEFERRED_VIEW Activate_oSalesPersonView FOR ;;Object oSalesPersonView is a dbView
78377>>>    Set Border_Style to Border_None
78378>>>    Set Label to "Sales Person Entry View"
78379>>>    Set Location to 6 6
78380>>>    Set Size to 51 245
78381>>>
78381>>>    Object SalesP_DD is a Salesp_DataDictionary
78383>>>    End_Object    // Salesp_DD
78384>>>
78384>>>    Set Main_DD to SalesP_DD
78385>>>    Set Server to SalesP_DD
78386>>>
78386>>>    Object oContainer1 is a dbContainer3d
78388>>>        Set Size to 40 233
78389>>>        Set Location to 5 6
78390>>>        Object oSalesP_ID is a dbForm
78392>>>            Entry_Item SalesP.ID
78393>>>            Set Label to "Sales Person ID:"
78394>>>            Set Size to 13 46
78395>>>            Set Location to 4 70
78396>>>            Set Label_Col_Offset to 2
78397>>>            Set Label_Justification_Mode to jMode_Right
78398>>>        End_Object    // oSalesP_ID
78399>>>
78399>>>        Object oSalesP_Name is a dbForm
78401>>>            Entry_Item SalesP.Name
78402>>>            Set Label to "Sales Person Name:"
78403>>>            Set Size to 13 156
78404>>>            Set Location to 20 70
78405>>>            Set Label_Col_Offset to 2
78406>>>            Set Label_Justification_Mode to jMode_Right
78407>>>        End_Object    // oSalesP_Name
78408>>>
78408>>>    End_Object    // oContainer1
78409>>>
78409>>>CD_End_Object    // oSalesPersonView
78411>>>>
78411>        Use Vendor.vw
Including file: Vendor.vw    (C:\Test\Order Entry git\AppSrc\Vendor.vw)
78411>>>Use dfClient.pkg
78411>>>Use DataDict.pkg
78411>>>Use dfEntry.pkg
78411>>>Use dfCEntry.pkg
78411>>>Use Vendor.DD
78411>>>
78411>>>DEFERRED_VIEW Activate_oVendorView FOR ;;Object oVendorView is a dbView
78436>>>    Set Border_Style to Border_Thick
78437>>>    Set Label to "Vendor Entry View"
78438>>>    Set Location to 6 6
78439>>>    Set Size to 137 281
78440>>>    Set piMaxSize to 137 350
78441>>>    Set piMinSize to 137 215
78442>>>
78442>>>    Object Vendor_DD is a Vendor_DataDictionary
78444>>>    End_Object    // Vendor_DD
78445>>>
78445>>>    Set Main_DD to Vendor_DD
78446>>>    Set Server to Vendor_DD
78447>>>
78447>>>    Object oContainer1 is a dbContainer3d
78449>>>        Set Size to 129 273
78450>>>        Set Location to 4 4
78451>>>        Set peAnchors to anAll
78452>>>        Object oVendor_Id is a dbForm
78454>>>            Entry_Item Vendor.ID
78455>>>            Set Label to "Vendor ID:"
78456>>>            Set Size to 13 42
78457>>>            Set Location to 4 67
78458>>>            Set peAnchors to anTopLeft
78459>>>            Set Label_Col_Offset to 2
78460>>>            Set Label_Justification_Mode to jMode_Right
78461>>>        End_Object    // oVendor_ID
78462>>>
78462>>>        Object oVendor_Name is a dbForm
78464>>>            Entry_Item Vendor.Name
78465>>>            Set Label to "Vendor Name:"
78466>>>            Set Size to 13 186
78467>>>            Set Location to 18 67
78468>>>            Set peAnchors to anTopLeftRight
78469>>>            Set Label_Col_Offset to 2
78470>>>            Set Label_Justification_Mode to jMode_Right
78471>>>        End_Object    // oVendor_Name
78472>>>
78472>>>        Object oVendor_Address is a dbForm
78474>>>            Entry_Item Vendor.Address
78475>>>            Set Label to "Street Address:"
78476>>>            Set Size to 13 186
78477>>>            Set Location to 34 67
78478>>>            Set peAnchors to anTopLeftRight
78479>>>            Set Label_Col_Offset to 2
78480>>>            Set Label_Justification_Mode to jMode_Right
78481>>>        End_Object    // oVendor_Address
78482>>>
78482>>>        Object oVendor_City is a dbForm
78484>>>            Entry_Item Vendor.City
78485>>>            Set Label to "City:"
78486>>>            Set Size to 13 90
78487>>>            Set Location to 49 67
78488>>>            Set peAnchors to anTopLeft
78489>>>            Set Label_Col_Offset to 2
78490>>>            Set Label_Justification_Mode to jMode_Right
78491>>>        End_Object    // oVendor_City
78492>>>
78492>>>        Object oVendor_State is a dbComboForm
78494>>>            Entry_Item Vendor.State
78495>>>            Set Label to "State:"
78496>>>            Set Size to 13 32
78497>>>            Set Location to 64 67
78498>>>            Set peAnchors to anTopLeft
78499>>>            Set Form_Border to 0
78500>>>            Set Label_Col_Offset to 2
78501>>>            Set Label_Justification_Mode to jMode_Right
78502>>>            Set Entry_State to False
78503>>>            Set Code_Display_Mode to cb_code_display_code
78504>>>        End_Object    // oVendor_State
78505>>>
78505>>>        Object oVendor_Zip is a dbForm
78507>>>            Entry_Item Vendor.Zip
78508>>>            Set Label to "Zip/Postal Code:"
78509>>>            Set Size to 13 66
78510>>>            Set Location to 79 67
78511>>>            Set peAnchors to anTopLeft
78512>>>            Set Label_Col_Offset to 2
78513>>>            Set Label_Justification_Mode to jMode_Right
78514>>>        End_Object    // oVendor_Zip
78515>>>
78515>>>        Object oVendor_Phone_Number is a dbForm
78517>>>            Entry_Item Vendor.Phone_Number
78518>>>            Set Label to "Phone Number:"
78519>>>            Set Size to 13 126
78520>>>            Set Location to 94 67
78521>>>            Set peAnchors to anTopLeftRight
78522>>>            Set Label_Col_Offset to 2
78523>>>            Set Label_Justification_Mode to jMode_Right
78524>>>        End_Object    // oVendor_Phone_Number
78525>>>
78525>>>        Object oVendor_Fax_Number is a dbForm
78527>>>            Entry_Item Vendor.Fax_Number
78528>>>            Set Label to "Fax Number:"
78529>>>            Set Size to 13 126
78530>>>            Set Location to 108 67
78531>>>            Set peAnchors to anTopLeftRight
78532>>>            Set Label_Col_Offset to 2
78533>>>            Set Label_Justification_Mode to jMode_Right
78534>>>        End_Object    // oVendor_Fax_Number
78535>>>
78535>>>    End_Object    // oContainer1
78536>>>
78536>>>CD_End_Object    // oVendorView
78538>>>>
78538>        
78538>        Use Basic\CustomerListBR.rv
Including file: Basic\CustomerListBR.rv    (C:\Test\Order Entry git\AppSrc\Basic\CustomerListBR.rv)
78538>>>Use DFAllRpt.pkg
78538>>>Use Basic\CustBasicRptImages.inc  // contains the images for the report
Including file: Basic\CustBasicRptImages.inc    (C:\Test\Order Entry git\AppSrc\Basic\CustBasicRptImages.inc)
78538>>>>>// CustBasicRptImages.pkg - images for CustomerListBR.rv
78538>>>>>// Since report images, such as the one used here, are not fully supported by
78538>>>>>// the Studio, we have placed the images for this report in a separate package.
78538>>>>>
/CUSTHDR
Image 2, CUSTHDR
                             Customer Listing                      Page:___.
Number  Name
----------------------------------------------------------------------------
/CustBody
Image 3, CUSTBODY
_____.  ______________________________
/Footer
Image 4, FOOTER
Date printed:  __/__/____
/*
78538>>>
78538>>>Open Customer
78540>>>Use dfrptvw.pkg
78540>>>Use dfRadio.pkg
Including file: Dfradio.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\Dfradio.pkg)
78540>>>>>Use windows.pkg // this now lives here. (you don't need to ever use this). 
78540>>>>>
78540>>>Use Windows.pkg
78540>>>
78540>>>DEFERRED_VIEW Activate_oCustomerListBR FOR ;;Object oCustomerListBR is a ReportView
78565>>>
78565>>>    Property Integer piSortIndex Public 1
78567>>>
78567>>>    Set Label to "Customer List"
78568>>>    Set Location to 6 6
78569>>>    Set Size to 80 180
78570>>>
78570>>>    Object oDestination is a RadioGroup
78572>>>        Set Size to 50 80
78573>>>        Set Location to 5 5
78574>>>        Set Label to "Output Device:"
78575>>>        Object oScreen is a Radio
78577>>>            Set Label to "Screen"
78578>>>            Set Size to 10 39
78579>>>            Set Location to 15 10
78580>>>            Set Status_Help to "Preview the report to screen"
78581>>>        End_Object    // oScreen
78582>>>
78582>>>        Object oPrinter is a Radio
78584>>>            Set Label to "Printer"
78585>>>            Set Size to 10 37
78586>>>            Set Location to 30 10
78587>>>            Set Status_Help to "Send the report to the default printer"
78588>>>        End_Object    // oPrinter
78589>>>
78589>>>        // set the Output_Device_Mode each time the radio button changes
78589>>>        Procedure Notify_Select_State Integer iNewItem Integer iOldItem
78592>>>            Forward Send Notify_Select_State iNewItem iOldItem
78594>>>        
78594>>>            If (iNewItem=0) Set Output_Device_Mode To PRINT_TO_WINDOW
78597>>>            Else            Set Output_Device_Mode To PRINT_TO_PRINTER
78599>>>        End_Procedure
78600>>>
78600>>>    End_Object    // oDestination
78601>>>
78601>>>    Object oOrderRadio is a RadioGroup
78603>>>        Set Size to 50 80
78604>>>        Set Location to 5 95
78605>>>        Set Label to "Report Order:"
78606>>>        Object oNumber is a Radio
78608>>>            Set Label to "Number"
78609>>>            Set Size to 10 41
78610>>>            Set Location to 15 10
78611>>>            Set Status_Help to "Sort by customer number"
78612>>>        End_Object    // oNumber
78613>>>
78613>>>        Object oName is a Radio
78615>>>            Set Label to "Name"
78616>>>            Set Size to 10 35
78617>>>            Set Location to 30 10
78618>>>            Set Status_Help to "Sort by customer name"
78619>>>        End_Object    // oName
78620>>>
78620>>>        // set the piSortIndex each time the radio button changes
78620>>>        Procedure Notify_Select_State Integer iNewItem Integer iOldItem
78623>>>            Forward Send Notify_Select_State iNewItem iOldItem
78625>>>        
78625>>>            Set piSortIndex  To (iNewItem + 1)
78626>>>        End_Procedure
78627>>>
78627>>>    End_Object    // oOrderRadio
78628>>>
78628>>>    Object oOkButton is a Button
78630>>>        Set Label to "OK"
78631>>>        Set Size to 14 51
78632>>>        Set Location to 62 71
78633>>>        Set Default_State to True
78634>>>
78634>>>        Procedure OnClick
78637>>>            Send StartReport
78638>>>        End_Procedure
78639>>>
78639>>>    End_Object    // oOkButton
78640>>>
78640>>>    Object oCancelButton is a Button
78642>>>        Set Label to "Cancel"
78643>>>        Set Location to 62 125
78644>>>
78644>>>        Procedure OnClick
78647>>>            Send Request_Cancel
78648>>>        End_Procedure
78649>>>
78649>>>    End_Object    // oCancelButton
78650>>>
78650>>>    Procedure StartReport
78653>>>        Integer iOutputDevice
78653>>>        Handle hoThisWorkspace
78653>>>        String sCurDir sDataPath 
78653>>>        String sFileName
78653>>>                    
78653>>>        Get Output_Device_Mode to iOutputDevice
78654>>>
78654>>>        If (iOutputDevice=PRINT_TO_WINDOW) Begin
78656>>>            // save current location
78656>>>            Get_Current_Directory to sCurDir
78657>>>
78657>>>            // get workspace data path (all users must have r/w rights to it) to output the temp file there
78657>>>            Get phoWorkspace of ghoApplication to hoThisWorkspace
78658>>>            Get psDataPath of hoThisWorkspace to sDataPath
78659>>>            Get PathAtIndex of hoThisWorkspace sDataPath 1 to sDataPath
78660>>>            
78660>>>            // set current directory to DataPath
78660>>>            Set_Directory sDataPath
78661>>>        
78661>>>            Make_Temp_File "TXT" sFileName
78662>>>            Move (".\" - sFileName) to sFileName
78663>>>            Set Output_Device_Name to sFileName
78664>>>        End
78664>>>>
78664>>>        Else Begin
78665>>>           Set Output_Device_Name to "WinLST:"
78666>>>        End
78666>>>>
78666>>>    
78666>>>        Send Run_Report
78667>>>    
78667>>>        If (iOutputDevice=PRINT_TO_WINDOW) Begin
78669>>>           Runprogram background "NotePad" sFileName
78670>>>           EraseFile sFileName
78671>>>>
78671>>>        End
78671>>>>
78671>>>        
78671>>>        // restore previous location
78671>>>        Set_Directory sCurDir
78672>>>        
78672>>>    End_Procedure   // StartReport
78673>>>    
78673>>>    Object oCustomer_BasicReport is a BasicReport
78675>>>    
78675>>>        Report_Main_File Customer
78676>>>    
78676>>>        Set Report_Title to "Printing Customer Names"
78677>>>    
78677>>>        Function Starting_Main_Report Returns Integer
78680>>>            Integer iRetVal
78680>>>            Integer iIndex
78680>>>    
78680>>>            Forward Get Starting_Main_Report to iRetVal
78682>>>    
78682>>>            Get piSortIndex To iIndex
78683>>>            Report_Index BY iIndex    // set the sort order
78685>>>            Sysdate Footer.1         // set date for report
78686>>>            
78686>>>            Function_Return iRetVal
78687>>>        End_Function
78688>>>    
78688>>>        Procedure_Section Page_Top as CustHdr
78693>>>            Integer iPage
78693>>>            Get Page_Count To iPage
78694>>>            Print iPage
78695>>>            OutPut_PageCheck
78696>>>        End_Procedure
78697>>>    
78697>>>        Procedure_Section Body as CustBody
78702>>>            Send Update_Status (String(Customer.Customer_Number)- ":" * Customer.Name )
78703>>>            Print Customer.Customer_number
78704>>>            Print Customer.Name
78705>>>            OutPut_PageCheck
78706>>>        End_Procedure
78707>>>    
78707>>>        Procedure_Section Page_Bottom as Footer
78717>>>            OutPut_PageCheck
78718>>>        End_Procedure
78719>>>    
78719>>>    End_Object    // Customer_BasicReport
78720>>>
78720>>>CD_End_Object    // oCustomerListBR
78722>>>>
78722>        Use WinPrint\CustomerListWP.rv
Including file: WinPrint\CustomerListWP.rv    (C:\Test\Order Entry git\AppSrc\WinPrint\CustomerListWP.rv)
78722>>>Use dfrptvw.pkg
78722>>>Use DataDict.pkg
78722>>>Use dfRadio.pkg
78722>>>Use Windows.pkg
78722>>>Use cWinReport2.pkg
Including file: cWinReport2.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cWinReport2.pkg)
78722>>>>>// cWinReport2.pkg
78722>>>>>
78722>>>>>// defines support for new Winprint2 cWinReport2 class
78722>>>>>
78722>>>>>
78722>>>>>Use DFRpt.pkg              // BasicReport RO Class for VDF
78722>>>>>Use WinPrint2.pkg          // WinPrint2 engine
Including file: Winprint2.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\Winprint2.pkg)
78722>>>>>>>// WinPrint2.pkg
78722>>>>>>>//
78722>>>>>>>Use windows.pkg
78722>>>>>>>Use LanguageText.pkg
78722>>>>>>>Use DLL.pkg
78722>>>>>>>Use WinPrint2_Api.pkg
Including file: WinPrint2_API.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\WinPrint2_API.pkg)
78722>>>>>>>>>//WinPrint2_API.pkg
78722>>>>>>>>>
78722>>>>>>>>>Use DLL.pkg
78722>>>>>>>>>
78722>>>>>>>>>External_Function WP_IsPrinterValid "IsPrinterValid" WinPrint.dll ;Returns Boolean // True if the the current printer is a valid one. False, otherwise.
78723>>>>>>>>>
78723>>>>>>>>>External_Function WP_ArePrintersInstalled "ArePrintersInstalled" WinPrint.dll ; // determines whether at least one printer is installedReturns Boolean // True, if a printer is installed, False if it is not.
78724>>>>>>>>>
78724>>>>>>>>>External_Function WP_ExecutePrinterSetupDialog "ExecutePrinterSetupDialog" WinPrint.dll ; // displays the "printer setup" dialog   Handle hWndParent; // window handle of the parent windowReturns Boolean // True if the OK button pressed; False, otherwise.
78725>>>>>>>>>
78725>>>>>>>>>External_Function WP_ExecutePrintDialog "ExecutePrintDialog" WinPrint.dll ; // displays the "Print" dialog   Handle hWndParent; // window handle of the parent windowReturns Boolean // True if the OK button pressed; False, otherwise.
78726>>>>>>>>>
78726>>>>>>>>>External_Function WP_GetCurrentDevice "GetCurrentDevice" WinPrint.dll ; // retrieves the name of the current printer device    Address aDevice ; // address of the string (255 chars) that will hold the device name upon returnReturns Boolean // True, if success; False if error occurred
78727>>>>>>>>>
78727>>>>>>>>>External_Function WP_GetPrintDialogFlags "GetPrintDialogFlags" WinPrint.dll ; // retrieves the current print optionsReturns UInteger // array of flags representing print-related options that are currently set
78728>>>>>>>>>
78728>>>>>>>>>External_Function WP_GetUserDefinedPapersize "GetUserDefinedPapersize" WinPrint.dll ;  // gets the size of user-defined paperReturns UInteger // // hi-word=length; lo-word=width
78729>>>>>>>>>
78729>>>>>>>>>External_Function WP_IsPrintDialogFlagSet "IsPrintDialogFlagSet" WinPrint.dll ; // determines whether a specific print-flag is set    UInteger iFlag ; // the printer flagReturns Boolean // True, if the flag is set; False, if it isn't
78730>>>>>>>>>
78730>>>>>>>>>External_Function WP_SelectPrinter "SelectPrinter" WinPrint.dll ; // selects a printer programatically    String sDevice; // the name of the printerReturns Boolean // True, if success; False, if error (such as an invalid printer name)
78731>>>>>>>>>
78731>>>>>>>>>External_Function WP_SetFirstPagePaperSource "SetFirstPagePaperSource"  WinPrint.dll ;        Integer iBin ; // the bim constantReturns Boolean // True if success, false if error
78732>>>>>>>>>
78732>>>>>>>>>External_Function WP_SetNumberOfPrintCopies "SetNumberOfPrintCopies" WinPrint.dll ; // sets the number of copies to print    UInteger iNumCopies; // number of copies to makeReturns Boolean // Always True
78733>>>>>>>>>
78733>>>>>>>>>External_Function WP_SetSpecificPrintDialogFlag "SetSpecificPrintDialogFlag" WinPrint.dll; // Sets/unsets one printer flag    UInteger fFlag; // printer flagReturns Boolean // True, if success; False if error occurred
78734>>>>>>>>>
78734>>>>>>>>>External_Function WP_SetPrintDialogFlags "SetPrintDialogFlags" WinPrint.dll; // Sets/unsets all printer flags in one call    UInteger fFlags; // printer flagsReturns Boolean // True, if success; False if error occurred
78735>>>>>>>>>
78735>>>>>>>>>External_Function WP_SetUserDefinedPapersize "SetUserDefinedPapersize" WinPrint.dll ;  // sets the size of user-defined paper    UInteger iPaperSize ; // hi-word=length; lo-word=widthReturns Boolean; // True, if success; False if error occurred
78736>>>>>>>>>External_Function WP_SetFontStyle "SetFontStyle" WinPrint.dll ; // sets multiple font attributes    Integer iStyles ; // series of flagsReturns Boolean // always True
78737>>>>>>>>>
78737>>>>>>>>>External_Function WP_SetFontBold "SetFontBold" WinPrint.dll ; // toggles the bold attribute of the current font    Boolean bBold ; // True to switch bold attribute on; False to switch it offReturns Boolean // always True
78738>>>>>>>>>
78738>>>>>>>>>External_Function WP_SetFontItalic "SetFontItalic" WinPrint.dll ; // toggles the italic attribute of the current font    Boolean bItalic ; // True to switch italic attribute on; False to switch it offReturns Boolean  // always True
78739>>>>>>>>>
78739>>>>>>>>>External_Function WP_SetFontUnderline "SetFontUnderline" WinPrint.dll ; // toggles the underline attribute of the current font    Boolean bUnderline ; // True to switch underline attribute on; False to switch it offReturns Boolean  // always True
78740>>>>>>>>>
78740>>>>>>>>>External_Function WP_SetFontStrikeout "SetFontStrikeout" WinPrint.dll ; // toggles the strikeout attribute of the current font    Boolean bStrikeout ; // True to switch strikeout attribute on; False to switch it offReturns Boolean  // always True
78741>>>>>>>>>
78741>>>>>>>>>External_Function WP_SetFontColor "SetFontColor" WinPrint.dll ; // sets the color of the current font    Integer iColor ; // color of the fontReturns Boolean  // always True
78742>>>>>>>>>
78742>>>>>>>>>External_Function WP_SetFontHeight "SetFontHeight" WinPrint.dll ; // sets the height of the font    UInteger iHeight ; // height of the font in points (multiplied by 100. Eg 12.5 point should be sent as 1250)Returns Boolean  // always True
78743>>>>>>>>>
78743>>>>>>>>>External_Function WP_SetFontName "SetFontName" WinPrint.dll ; // Sets the name of the font to use    String sFontName ; // name of the font to useReturns Boolean  // always True
78744>>>>>>>>>
78744>>>>>>>>>External_Function WP_DrawBitmap "DrawBitmap" WinPrint.dll ; // Draws a bitmap (BMP, JPG)    String  sBitmap;                 // Name of the bitmap    Integer iLeft;                   // distance from left edge to draw bitmap    Integer iTop;                    // distance from top edge to draw bitmap    Integer iWidth;                  // width of the bitmap    Integer iHeight;                 // height of the bitmap    Boolean bUpdateCurrentPosition;  // after drawing, should the current position be updated?Returns Boolean // True, if OK; False, if an error occurred.
78745>>>>>>>>>
78745>>>>>>>>>External_Function WP_DrawEllipse "DrawEllipse" WinPrint.dll ; // draws an elipse within a bounding rectangle    Integer iLeft;                   // distance from left edge to draw the ellipse    Integer iTop;                    // distance from top edge to draw the ellipse    Integer iWidth;                  // width of the bounding rectangle    Integer iHeight;                 // height of the bounding rectangle    Integer iBorderColor;            // color of the ellipse's edge    Integer iFillColor;              // internal color of the ellipse    Boolean  bFill;                  // should the ellipse be filled? (False=transparent)    UInteger iThickness;             // thickness of the elipse    Boolean  bUpdateCurrentPosition; // after drawing, should the current position be updated?    Boolean  bWrap;                  // Should the ellipse be drawn on future soft-page breaks?Returns Boolean // True, if OK; False, if an error occurred.
78746>>>>>>>>>
78746>>>>>>>>>External_Function WP_DrawLine "DrawLine" WinPrint.dll ; // draws a line from the current position    Integer iLeft;                   // distance from left edge to draw the line    Integer iTop;                    // distance from top edge to draw the line    Integer iLength;                 // length of the line    Boolean  bHorizontal;            // draw horizontal? (False=vertical)    Integer iColor;                  // color of the line    UInteger iThickness;             // thickness of the line    Boolean  bUpdateCurrentPosition; // after drawing, should the current position be updated?Returns Boolean // True, if OK; False, if an error occurred.
78747>>>>>>>>>
78747>>>>>>>>>External_Function WP_DrawRectangle "DrawRectangle" WinPrint.dll ; // draws a rectangle    Integer iLeft;                   // distance from left edge to draw the rectangle    Integer iTop;                    // distance from top edge to draw the rectangle    Integer iWidth;                  // width of the rectangle    Integer iHeight;                 // height of the rectangle    Integer iBorderColor;            // color of the rectangle's border    Integer iFillColor;              // internal color of the rectangle    Boolean  bFill;                  // should the rectangle be filled? (False=transparent)    UInteger iThickness;             // thickness of the rectangle's border    Boolean  bUpdateCurrentPosition; // after drawing, should the current position be updated?    Boolean  bWrap;                  // Should the rectangle be drawn on future soft-page breaks?Returns Boolean // True, if OK; False, if an error occurred.
78748>>>>>>>>>
78748>>>>>>>>>External_Function WP_DrawXYLine "DrawXYLine" WinPrint.dll ; // draws a line between two points    Integer iLeftStart;              // distance from left edge to draw from    Integer iTopStart;               // distance from top edge to draw from    Integer iLeftEnd;                // distance from left edge to draw to    Integer iTopEnd;                 // distance from top edge to draw to    Integer iColor;                  // color of the line    UInteger iThickness;             // thickness of the line    Boolean  bUpdateCurrentPosition; // after drawing, should the current position be updated?    Boolean  bWrap;                  // Should the line be drawn on future soft-page breaks?Returns Boolean // True, if OK; False, if an error occurred.
78749>>>>>>>>>
78749>>>>>>>>>External_Function WP_SetAbsoluteMargins "SetAbsoluteMargins" WinPrint.dll ; // modifies the top/bottom non-printable margin    UInteger iTop;      // the top margin offset    UInteger iBottom;   // the bottom margin offset    Boolean  bAllPages; // should all pages be affected? True=AllPages; False=first page onlyReturns Boolean // always True
78750>>>>>>>>>
78750>>>>>>>>>External_Function WP_SetMargins "SetMargins" WinPrint.dll ; // Sets the user-margins    UInteger iLeft;   // the left margin    UInteger iTop;    // the top margin    UInteger iRight;  // the right margin    UInteger iBottom; // the bottom marginReturns Boolean // always True
78751>>>>>>>>>
78751>>>>>>>>>External_Function WP_CreateDiagram "CreateDiagram" WinPrint.dll ; // Creates a new diagram    UInteger eType;       // type of diagram (Bar, Line, Pie)    UInteger eEffect;     // how it is drawn (2d or 3d, etc)    UInteger iWidth;      // width of the diagram    UInteger iHeight;     // height of the diagram    Boolean  bDrawXyAxis; // draw the xy-axis (for bar charts only)?Returns Handle // unique id for the diagram used in other diagram funtions
78752>>>>>>>>>
78752>>>>>>>>>External_Function WP_AddDiagramEntry "AddDiagramEntry" WinPrint.dll ; // Adds an item into a diagram    Handle   hDiagram;          // diagram handle returned by CreateDiagram()    String   sValueDescription; // description of the item    String   sValue;            // value of the item    Integer iBorderColor;       // color of the item's border    Integer iFillColor;         // color of the item's interior    Boolean  bFilled;           // should the item be drawn filled (with iFillColor), or transparent?    UInteger iNumDecimals;      // Number of decimals in the sValue argument    UInteger eValueOrPercent;   // How the value should be displayed (as value or percentage, etc)    Boolean  bExploded;         // should the value be "pulled out" (pie charts only)Returns Boolean // True, if success; False, if error
78753>>>>>>>>>
78753>>>>>>>>>External_Function WP_DrawDiagram "DrawDiagram" WinPrint.dll ; // draws a diagram    Handle   hDiagram;               // diagram handle returned by CreateDiagram()    UInteger iLeft;                  // x-coordinate to draw the diagram    UInteger iTop;                   // y-coordinate to draw the diagram    Boolean  bUpdateCurrentPosition; // after drawing, should the current position be updated?Returns Boolean // True, if success; False, if error
78754>>>>>>>>>
78754>>>>>>>>>External_Function WP_LockDiagram "LockDiagram" WinPrint.dll ; // Locks a diagram so that no more entries can be added    Handle hDiagram; // diagram handle returned by CreateDiagram()Returns Boolean // True, if success; False, if error
78755>>>>>>>>>
78755>>>>>>>>>External_Function WP_SetDiagramCaption "SetDiagramCaption" WinPrint.dll ; // Sets the caption of a diagram    Handle hDiagram; // diagram handle returned by CreateDiagram()    String sCaption; // the diagram's captionReturns Boolean // True, if success; False, if error
78756>>>>>>>>>
78756>>>>>>>>>External_Function WP_SetDiagramXText "SetDiagramXText" WinPrint.dll ; // Sets the horizontal label of a diagram    Handle hDiagram; // diagram handle returned by CreateDiagram()    String sText;    // the diagram's horizonal labelReturns Boolean // True, if success; False, if error
78757>>>>>>>>>
78757>>>>>>>>>External_Function WP_SetDiagramYText "SetDiagramYText" WinPrint.dll ; // Sets the vertical label of a diagram    Handle  hDiagram;      // diagram handle returned by CreateDiagram()    String  sText;         // the diagram's vertical label    Boolean bVerticalText; // should the text be drawn vertically (False=horizontally)Returns Boolean // True, if success; False, if error
78758>>>>>>>>>
78758>>>>>>>>>External_Function WP_BeginHeader "BeginHeader" WinPrint.dll ; // creates a new header    UInteger iHeaderType; // the type of header    UInteger iSubHeaderNum; // for subheaders, then number (1-0)Returns Boolean // always True
78759>>>>>>>>>
78759>>>>>>>>>External_Function WP_EndHeader "EndHeader" WinPrint.dll ; // declares the end of the current headerReturns Boolean // always True
78760>>>>>>>>>
78760>>>>>>>>>External_Function WP_SetExtraLineCheck "SetExtraLineCheck" WinPrint.dll ; // forces a soft page break if header plus number of lines don't fit on page    UInteger iNumLines; // number of lines in addition to header required before forcing a soft page-breakReturns Boolean; // always True
78761>>>>>>>>>External_Function WP_SetHeaderFrame "SetHeaderFrame" WinPrint.dll ; // sets the style, color and frame of a header    UInteger eFrame;     // style of frame (margin-to-margin, etc)    Integer iColor;      // color of the frame's edge    UInteger iThickness; // thickness of the frame    Integer iFillCol;    // the internal color of the frame (only used if bBilled=True)    Boolean  bFilled;    // True, if the frame should be filled with the iFillColor (False=Transparent)Returns Boolean // Always True
78762>>>>>>>>>
78762>>>>>>>>>External_Function WP_SetHeaderMargin "SetHeaderMargin" WinPrint.dll ; // Sets a margin of space on the inside and outside of the current header    UInteger eType;      // Specifies which margin areas is being set.    Integer  iSize;      // Size of the margin setting in the current report metricsReturns Boolean  // False if document is not started
78763>>>>>>>>>
78763>>>>>>>>>External_Function WP_SetHeaderPlacement "SetHeaderPlacement" WinPrint.dll ; // placement (left, center or right) of the header    UInteger ePlacement; // placed left, center or rightReturns Boolean //always True
78764>>>>>>>>>
78764>>>>>>>>>External_Function WP_SetHeaderWrap "SetHeaderWrap" WinPrint.dll ; // determines whether the current header is drawn on soft page-breaks    Boolean bWrap; // True, to wrap onto following pages; False, for current page onlyReturns Boolean // always True
78765>>>>>>>>>
78765>>>>>>>>>External_Function WP_WriteHeader "WriteHeader" WinPrint.dll ; // writes a header to the current page    UInteger eHeaderType;   // type of header    UInteger iSubHeaderNum; // for subheaders, the number (1-9)Returns Boolean // True, if success; False, if error
78766>>>>>>>>>
78766>>>>>>>>>External_Function WP_RGBToDFPrintColor "RGBToDFPrintColor" WinPrint.dll ; // converts R, G, and B values into a composite color that WinPrint expects    UInteger iRed;   // red component (1-255)    UInteger iGreen; // green component (1-255)    UInteger iBlue;  // blue component (1-255)Returns Integer // composite color
78767>>>>>>>>>
78767>>>>>>>>>External_Function WP_GetMetrics "GetMetrics" WinPrint.dll ; // gets the current unit of measurementReturns UInteger // unit of measurement (Inch or CM)
78768>>>>>>>>>
78768>>>>>>>>>External_Function WP_SetMetrics "SetMetrics" WinPrint.dll ; // sets the unit of measurement   UInteger eMetrics; // Inch or CMReturns Boolean // always True
78769>>>>>>>>>
78769>>>>>>>>>External_Function WP_ClearDocument "ClearDocument" WinPrint.dll ; // clears the resources of the document from memoryReturns Boolean // always True
78770>>>>>>>>>
78770>>>>>>>>>External_Function WP_NewDocument "NewDocument" WinPrint.dll ; // starts a new document, but preserves the printer settings   Boolean bAutoPreview ; // Should the Previewer be displayed immediatelyReturns Boolean // True, if success; False, if an error occurred
78771>>>>>>>>>
78771>>>>>>>>>External_Function WP_EndDocument "EndDocument" WinPrint.dll ; // Indicates that the document is finishedReturns Boolean // always True
78772>>>>>>>>>
78772>>>>>>>>>External_Function WP_ClearPrinter "ClearPrinter" WinPrint.dll ; // clears all printer and document resourcesReturns Boolean // True, if success; False, if an error occurred
78773>>>>>>>>>
78773>>>>>>>>>External_Function WP_ConfirmLines "ConfirmLines" WinPrint.dll ; // ensures that a specified number of lines will fit on the page; if not, a soft page-break is performed automatically    UInteger iNumLines; // number of lines that must fit on the pageReturns Boolean // True, if success; False, if an error occurred
78774>>>>>>>>>
78774>>>>>>>>>External_Function WP_CreatePage "CreatePage" WinPrint.dll ; // creates a new page of specified columns   UInteger iNumColumns; // number of columns (zero= no columns)Returns UInteger; // page number that was created
78775>>>>>>>>>External_Function WP_PreviewDocument "PreviewDocument" WinPrint.dll ; // previews the current document    Boolean bPrintDialog; // Determines whether the Print Dialog (range, etc) is displayed when the "print" button is clicked in the preview window.    Boolean bPrintSetup;  // Determines whether the Print Setup button is enabled (allows to change orientation, etc)    Boolean bPrint;       // Determines whether the Print button is enabledReturns Handle // non-zero = hViewerProcess; zero= error
78776>>>>>>>>>
78776>>>>>>>>>External_Function WP_ClosePreview "ClosePreview" WinPrint.dll ; // closes the preview windowReturns Boolean // True, if closed; False, if an error occurred (such as it not being already open)
78777>>>>>>>>>
78777>>>>>>>>>External_Function WP_PrintDocument "PrintDocument" WinPrint.dll ; // prints the current document    Handle hWndParent; // window handle of object to use for any modal outputReturns Boolean // True, if success; False, if an error occurred
78778>>>>>>>>>
78778>>>>>>>>>External_Function WP_SetAlign "SetAlign" WinPrint.dll ; // align future text    UInteger eAlign; // left, center or rightReturns Boolean // always True
78779>>>>>>>>>
78779>>>>>>>>>External_Function WP_WriteText "WriteText" WinPrint.dll ; // write text to the current position or column    String sText;               // the text to write    Boolean bNewLineAfterPrint; // should a "CR" be written after the text    UInteger iColumnNum;        // number of the column to write to (zero=no column, use current position)    Integer iNumDecimals;       // number of decimals in the text (-1 means sText is a string)    UInteger iWidth;            // width of text before truncatingReturns Boolean // True, if success; False, if an error occurred
78780>>>>>>>>>
78780>>>>>>>>>External_Function WP_WriteTextAtPosition "WriteTextAtPosition" WinPrint.dll ; // writes text to a specific position    String sText;               // the text to write    Boolean bNewLineAfterPrint; // should a "CR" be written after the text    UInteger iPosition;         // horizontal position to write the text    Integer iNumDecimals;       // number of decimals in the text (-1 means sText is a string)    UInteger iWidth;            // width of text before truncatingReturns Boolean // True, if success; False, if an error occurred
78781>>>>>>>>>
78781>>>>>>>>>External_Function WP_SetProgressCaption "SetProgressCaption" WinPrint.dll ;    String sProgressCaption ;Returns Boolean
78782>>>>>>>>>
78782>>>>>>>>>External_Function WP_SetReportTitle     "SetReportTitle"     WinPrint.dll ;    String sCaption ;Returns Boolean
78783>>>>>>>>>
78783>>>>>>>>>External_Function WP_ViewerWantsToClose "ViewerWantsToClose" WinPrint.dll ;Returns Integer
78784>>>>>>>>>
78784>>>>>>>>>External_Function WP_DisplayMessageBox  "DisplayMessageBox"  WinPrint.dll ;    String sCaption String sText ;Returns Integer
78785>>>>>>>>>
78785>>>>>>>>>External_Function WP_GetViewerWindow "GetViewerWindow" Winprint.dll ;Returns Handle
78786>>>>>>>>>
78786>>>>>>>>>External_Function WP_GetDocumentStatus "GetDocumentStatus" Winprint.dll ;Returns Integer // returns dsNotStarted, dsStarted, or dsFinished
78787>>>>>>>>>
78787>>>>>>>Use WinPrint_Constants.pkg
78787>>>>>>>Use Rgb.pkg
78787>>>>>>>Use GlobalFunctionsProcedures.pkg
78787>>>>>>>
78787>>>>>>>DEFINE INFINITE for -1
78787>>>>>>>DEFINE WAIT_TIMEOUT for |CI$00000102
78787>>>>>>>
78787>>>>>>>
78787>>>>>>>DEFINE QS_KEY            for |CI$0001
78787>>>>>>>DEFINE QS_MOUSEMOVE      for |CI$0002
78787>>>>>>>DEFINE QS_MOUSEBUTTON    for |CI$0004
78787>>>>>>>DEFINE QS_POSTMESSAGE    for |CI$0008
78787>>>>>>>DEFINE QS_TIMER          for |CI$0010
78787>>>>>>>DEFINE QS_PAINT          for |CI$0020
78787>>>>>>>DEFINE QS_SENDMESSAGE    for |CI$0040
78787>>>>>>>DEFINE QS_HOTKEY         for |CI$0080
78787>>>>>>>DEFINE QS_ALLPOSTMESSAGE for |CI$0100
78787>>>>>>>DEFINE QS_MOUSE          for (QS_MOUSEMOVE ior QS_MOUSEBUTTON)
78787>>>>>>>DEFINE QS_INPUT          for (QS_MOUSE ior QS_KEY)
78787>>>>>>>DEFINE QS_ALLEVENTS      for (QS_INPUT ior QS_POSTMESSAGE ior QS_TIMER ior QS_PAINT ior QS_HOTKEY)
78787>>>>>>>DEFINE QS_ALLINPUT       for (QS_INPUT ior QS_POSTMESSAGE ior QS_TIMER ior QS_PAINT ior QS_HOTKEY ior QS_SENDMESSAGE)
78787>>>>>>>
78787>>>>>>>External_Function WaitForSingleObject "WaitForSingleObject" Kernel32.dll Handle hHandle Dword dwMilliseconds Returns DWord
78788>>>>>>>External_Function GetCurrentProcessId "GetCurrentProcessId" Kernel32.dll Returns DWord
78789>>>>>>>External_Function GetCurrentProcess "GetCurrentProcess" Kernel32.dll Returns DWord
78790>>>>>>>
78790>>>>>>>External_Function MsgWaitForMultipleObjects "MsgWaitForMultipleObjects" User32.dll ;    DWORD nCount;             // number of handles in the object handle array    Address pHandles;     // pointer to the object-handle array    Boolean fWaitAll;     // wait for all or wait for one    DWORD dwMilliseconds; // time-out interval in milliseconds    DWORD dwWakeMask;     // type of input events to wait forReturns Dword
78791>>>>>>>
78791>>>>>>>Use GlobalFunctionsProcedures.pkg
78791>>>>>>>
78791>>>>>>>Class cWinPrint2 is a cObject // JJT: Will we need a windows handle for this like old one
78792>>>>>>>    Procedure Construct_Object
78794>>>>>>>        forward send construct_object
78796>>>>>>>
78796>>>>>>>        //*** internal properties
78796>>>>>>>        Property Integer DFCurrent_Color       0
78797>>>>>>>        Property String  DFCurrent_OutPut      "WinPrint"
78798>>>>>>>        Property Integer DFCurrent_Diagram     0
78799>>>>>>>        Property Integer DFCurrent_HeaderType  0
78800>>>>>>>        Property Integer DFCurrent_HeaderNr    0
78801>>>>>>>        Property Number  DFCurrent_FontSize    10
78802>>>>>>>        Property String  DFCurrent_Font        "Arial"
78803>>>>>>>
78803>>>>>>>        //*** Default values for margins 2.53 CM = 1 inch
78803>>>>>>>        Property Number  DFLeft_Margin    2.53
78804>>>>>>>        Property Number  DFTop_Margin     2.53
78805>>>>>>>        Property Number  DFright_Margin   2.53
78806>>>>>>>        Property Number  DFBottom_Margin  2.53
78807>>>>>>>
78807>>>>>>>        // If WP1 this defaults to false. In 2, it is true which means that the print job
78807>>>>>>>        // dialog appears when you hitprint in previewer.
78807>>>>>>>        Property Integer PrintDlgInPreview   1
78808>>>>>>>         // This does nothing in Wp2 (because you can't to this anyway)
78808>>>>>>>        Property Integer EnablePrintSetupFromPreview  True
78809>>>>>>>        Property Integer EnablePrintFromPreview  1
78810>>>>>>>
78810>>>>>>>        // is the GUI Suspended. This is privately maintained and is used
78810>>>>>>>        // to figure out if a preview panel is up or not
78810>>>>>>>        Property Integer pbIsSuspended False
78811>>>>>>>
78811>>>>>>>        Object oDFColorArray is an Array
78813>>>>>>>           //Moved into array
78813>>>>>>>           Set Value  0  To RGB_WHITE
78814>>>>>>>           Set Value  1  To RGB_RED
78815>>>>>>>           Set Value  2  To RGB_BLUE
78816>>>>>>>           Set Value  3  To RGB_GREEN
78817>>>>>>>           Set Value  4  To RGB_YELLOW
78818>>>>>>>           Set Value  5  To RGB_GREY
78819>>>>>>>           Set Value  6  To RGB_CYAN
78820>>>>>>>           Set Value  7  To RGB_MAGENTA
78821>>>>>>>           Set Value  8  To RGB_DRED
78822>>>>>>>           Set Value  9  To RGB_DBLUE
78823>>>>>>>           Set Value  10 To RGB_DGREEN
78824>>>>>>>           Set Value  11 To RGB_DYELLOW
78825>>>>>>>           Set Value  12 To RGB_DGREY
78826>>>>>>>           Set Value  13 To RGB_DCYAN
78827>>>>>>>           Set Value  14 To RGB_DMAGENTA
78828>>>>>>>           Set Value  15 To RGB_BLACK
78829>>>>>>>        End_Object
78830>>>>>>>
78830>>>>>>>        Object oDiagramArray is an Array
78832>>>>>>>        End_Object
78833>>>>>>>
78833>>>>>>>    End_Procedure
78834>>>>>>>
78834>>>>>>>    Function ViewerWantsToClose returns Boolean
78836>>>>>>>        Function_return (WP_ViewerWantsToClose())
78837>>>>>>>    end_Function
78838>>>>>>>
78838>>>>>>>    Function IsViewerActive returns boolean
78840>>>>>>>        Function_Return (WP_GetViewerWindow()<>0)
78841>>>>>>>    end_function
78842>>>>>>>
78842>>>>>>>    Function IsPrinterValid Returns Boolean
78844>>>>>>>        Function_Return (WP_IsPrinterValid()<>0)
78845>>>>>>>    End_Function
78846>>>>>>>
78846>>>>>>>    Function ArePrintersInstalled returns boolean
78848>>>>>>>        Function_Return (WP_ArePrintersInstalled()<>0)
78849>>>>>>>    End_Function
78850>>>>>>>
78850>>>>>>>
78850>>>>>>>    // returns docucument state: dsNotStarted, dsStarted, dsFinished
78850>>>>>>>    Function DocumentStatus returns Integer
78852>>>>>>>        Function_Return (WP_GetDocumentStatus())
78853>>>>>>>    end_function
78854>>>>>>>
78854>>>>>>>    // Might still be called from report class. Leave dummy stub
78854>>>>>>>    Procedure DFZeroCounters
78856>>>>>>>    End_Procedure
78857>>>>>>>
78857>>>>>>>    //***
78857>>>>>>>    Function DFNewPage Integer Columns Returns Integer
78859>>>>>>>        Integer iPageNum
78859>>>>>>>        // This returns a page number used in report object....(this may change)
78859>>>>>>>        Move (WP_CreatePage(Columns)) To iPageNum
78860>>>>>>>        If (iPageNum=0) Begin
78862>>>>>>>            Error DFERR_WINPRINT DFPrintError900
78863>>>>>>>>
78863>>>>>>>        End
78863>>>>>>>>
78863>>>>>>>        Function_Return iPageNum
78864>>>>>>>    End_Function
78865>>>>>>>
78865>>>>>>>    //***Return handle to use for winprint dialog. If main_window
78865>>>>>>>    //   exists, use it. Else, get object's handle
78865>>>>>>>    Function Report_Window_Handle returns handle
78867>>>>>>>        Handle hWnd
78867>>>>>>>        Handle hoObj
78867>>>>>>>        Get Focus of desktop to hoObj // start with the focus
78868>>>>>>>        Move (gOwnerWindowHandle(hoObj)) to hWnd // global function finds the right handle for us
78869>>>>>>>        function_return hWnd
78870>>>>>>>    End_Function
78871>>>>>>>
78871>>>>>>>
78871>>>>>>>    //***
78871>>>>>>>    Function DFPrintDialog Returns Boolean
78873>>>>>>>        Handle hwnd
78873>>>>>>>        Boolean bOk
78873>>>>>>>
78873>>>>>>>        Get Report_Window_Handle to hWnd
78874>>>>>>>        Move (WP_ExecutePrintDialog(hwnd)) To bOk
78875>>>>>>>
78875>>>>>>>        Function_Return bOk
78876>>>>>>>    End_Function
78877>>>>>>>
78877>>>>>>>
78877>>>>>>>    //*** You can only invoke the print setup if the report is cleared. If you try to to do this in
78877>>>>>>>    //    the wrong state you will get an error.
78877>>>>>>>    Function DFPrintSetupDialog Returns Boolean
78879>>>>>>>        Handle hwnd
78879>>>>>>>        Boolean bOk
78879>>>>>>>        Integer iStatus
78879>>>>>>>        Get ArePrintersInstalled to bOk
78880>>>>>>>        If not bOk Begin
78882>>>>>>>            Error DFERR_WINPRINT C_$NoInstalledPrinters
78883>>>>>>>>
78883>>>>>>>        End
78883>>>>>>>>
78883>>>>>>>        Else Begin
78884>>>>>>>            Get DocumentStatus to iStatus
78885>>>>>>>            
78885>>>>>>>            If (iStatus=dsNotStarted) Begin
78887>>>>>>>                Get Report_Window_Handle to hWnd
78888>>>>>>>                Move (WP_ExecutePrinterSetupDialog(hwnd)) to bOk
78889>>>>>>>                
78889>>>>>>>                // test that the selected printer is valid....
78889>>>>>>>                If bOK Begin
78891>>>>>>>                    Get IsPrinterValid to bOk // if printer not valid, it's not ok
78892>>>>>>>                    If not bOk Begin
78894>>>>>>>                        Error DFERR_WINPRINT DFPrintError936  // could not select a valid printer
78895>>>>>>>>
78895>>>>>>>                    End
78895>>>>>>>>
78895>>>>>>>                End
78895>>>>>>>>
78895>>>>>>>            End
78895>>>>>>>>
78895>>>>>>>            Else Begin
78896>>>>>>>               Error DFERR_WINPRINT DFPrintError966      // cannot change printer when report is active
78897>>>>>>>>
78897>>>>>>>            End
78897>>>>>>>>
78897>>>>>>>        End
78897>>>>>>>>
78897>>>>>>>        Function_Return bOk
78898>>>>>>>    End_Function
78899>>>>>>>
78899>>>>>>>
78899>>>>>>>    //*** Provided for backwards compatibility. DFPrintSetupDialog is more flexible because it returns a
78899>>>>>>>    //    false if cancel was selected.
78899>>>>>>>    Procedure DFPrintSetup
78901>>>>>>>        Boolean bOk
78901>>>>>>>        Get DFPrintSetupDialog to bOk
78902>>>>>>>    End_Procedure
78903>>>>>>>
78903>>>>>>>    //*** This invokes the print job dialog, prints the report, then clears the report document.
78903>>>>>>>    //    This should be called after the report is complete.
78903>>>>>>>    Procedure DFPrint
78905>>>>>>>        Integer bOk
78905>>>>>>>        Get DFPrintDialog To bOk
78906>>>>>>>        If bOk Begin
78908>>>>>>>            Send DFPrintDoc
78909>>>>>>>            Send DFClearDoc
78910>>>>>>>        End
78910>>>>>>>>
78910>>>>>>>    End_Procedure
78911>>>>>>>
78911>>>>>>>    Procedure DFSuspendGui boolean bSuspend
78913>>>>>>>        If (bSuspend<>pbIsSuspended(self)) begin
78915>>>>>>>            Send SuspendGui of Desktop bSuspend
78916>>>>>>>            Set pbIsSuspended to bSuspend
78917>>>>>>>        end
78917>>>>>>>>
78917>>>>>>>    end_procedure
78918>>>>>>>
78918>>>>>>>    // this is protected so that the queue is only pumped if the
78918>>>>>>>    // gui is suspended.
78918>>>>>>>    Procedure PumpMsgQueue
78920>>>>>>>        If (pbIsSuspended(self)) begin
78922>>>>>>>            Send PumpMsgQueue of desktop // permit painting
78923>>>>>>>        end
78923>>>>>>>>
78923>>>>>>>    end_procedure
78924>>>>>>>
78924>>>>>>>
78924>>>>>>>    //*** This does a modeless preview. This is what you'd want during
78924>>>>>>>    //    report generation and it may be what you want for report viewing.
78924>>>>>>>    Procedure DFPreviewNoWait
78926>>>>>>>        Boolean bOk
78926>>>>>>>        Boolean bPrntDlg bPrintSetup bPrint
78926>>>>>>>        integer iStatus
78926>>>>>>>        Get PrintDlgInPreview to bPrntDlg
78927>>>>>>>        Get EnablePrintSetupFromPreview to bPrintSetup
78928>>>>>>>        Get EnablePrintFromPreview to bPrint
78929>>>>>>>        Get DocumentStatus to iStatus
78930>>>>>>>        If (iStatus=dsStarted) begin
78932>>>>>>>            Send DfSuspendGui True
78933>>>>>>>        end
78933>>>>>>>>
78933>>>>>>>        Move (WP_PreviewDocument(bPrntDlg,bPrintSetup,bPrint)) To bOk
78934>>>>>>>        If not bOk Begin
78936>>>>>>>            Error DFERR_WINPRINT DFPrintError901
78937>>>>>>>>
78937>>>>>>>            Send DfSuspendGui False
78938>>>>>>>        End
78938>>>>>>>>
78938>>>>>>>    End_Procedure
78939>>>>>>>
78939>>>>>>>
78939>>>>>>>    //*** This does a modal preview. You might want this for report
78939>>>>>>>    //    viewing as the program knows when the viewer is closed
78939>>>>>>>    // Note that this is a private message and it was never intended that this
78939>>>>>>>    // should be used. We expect winprint reports to use modeless viewers.
78939>>>>>>>    Procedure DFPreviewWait
78941>>>>>>>        Handle hViewerProcess
78941>>>>>>>        Boolean bPrntDlg bPrintSetup bPrint
78941>>>>>>>        Integer iRetVal
78941>>>>>>>        Integer hwMain hMain
78941>>>>>>>
78941>>>>>>>        Get PrintDlgInPreview to bPrntDlg
78942>>>>>>>        Get EnablePrintSetupFromPreview to bPrintSetup
78943>>>>>>>        Get EnablePrintFromPreview to bPrint
78944>>>>>>>
78944>>>>>>>        Send DfSuspendGui True
78945>>>>>>>        Move (WP_PreviewDocument(bPrntDlg,bPrintSetup,bPrint)) To hViewerProcess
78946>>>>>>>
78946>>>>>>>        If (hViewerProcess = 0) Begin
78948>>>>>>>            Error DFERR_WINPRINT DFPrintError901
78949>>>>>>>>
78949>>>>>>>        End
78949>>>>>>>>
78949>>>>>>>        Else Begin
78950>>>>>>>            // We need to wait for either the Viewer to close, or a WM_PAINT message in the thread's queue...
78950>>>>>>>            Repeat
78950>>>>>>>>
78950>>>>>>>               Move (MsgWaitForMultipleObjects(1, AddressOf(hViewerProcess), False, INFINITE, QS_PAINT)) To iRetVal
78951>>>>>>>               Send PumpMsgQueue // permit painting
78952>>>>>>>            Until (iRetVal = 0) // 0 means that the viewer process terminated
78954>>>>>>>        end
78954>>>>>>>>
78954>>>>>>>        Send DfSuspendGui False
78955>>>>>>>
78955>>>>>>>       // Do what we can to force VDF application to the top.
78955>>>>>>>       // As 12.0 dfSuspendGUI actually properly disables the underlying windows. When the viewer
78955>>>>>>>       // is closed it cannot give the focus back to this so it goes elsewhere. This will force it
78955>>>>>>>       // back. 
78955>>>>>>>
78955>>>>>>>       Get main_window of desktop to hMain
78956>>>>>>>       If hMain Begin
78958>>>>>>>          Get window_handle of hMain to hwMain
78959>>>>>>>          If hwMain Begin
78961>>>>>>>              If (GetForegroundWindow()<>hwMain) Begin
78963>>>>>>>                  Move (SetForegroundWindow(hwMain)) to hwMain
78964>>>>>>>              End
78964>>>>>>>>
78964>>>>>>>          End
78964>>>>>>>>
78964>>>>>>>       End
78964>>>>>>>>
78964>>>>>>>
78964>>>>>>>    End_Procedure
78965>>>>>>>
78965>>>>>>>    Procedure DfPreview
78967>>>>>>>        send DfPreviewNoWait
78968>>>>>>>    end_procedure
78969>>>>>>>
78969>>>>>>>
78969>>>>>>>    //***
78969>>>>>>>    Procedure DFPrintDoc
78971>>>>>>>        Handle hwnd
78971>>>>>>>        Boolean bOk
78971>>>>>>>        Get Report_Window_Handle to hWnd
78972>>>>>>>        Move (WP_PrintDocument(hwnd)) To bOk
78973>>>>>>>
78973>>>>>>>        If not bOk Begin
78975>>>>>>>            Error DFERR_WINPRINT DFPrintError902
78976>>>>>>>>
78976>>>>>>>        End
78976>>>>>>>>
78976>>>>>>>    End_Procedure
78977>>>>>>>
78977>>>>>>>
78977>>>>>>>    //***
78977>>>>>>>    Procedure DFClearDoc
78979>>>>>>>        Boolean bOk
78979>>>>>>>        Get ArePrintersInstalled to bOk
78980>>>>>>>        If bOk begin
78982>>>>>>>            Move (WP_ClearDocument()) To bOk
78983>>>>>>>            Send DFSuspendGUI False
78984>>>>>>>            If not bOk Begin
78986>>>>>>>               Error DFERR_WINPRINT DFPrintError903 // error number right?
78987>>>>>>>>
78987>>>>>>>            End
78987>>>>>>>>
78987>>>>>>>        End
78987>>>>>>>>
78987>>>>>>>    End_Procedure
78988>>>>>>>
78988>>>>>>>    Procedure DFNewDoc Boolean bAutoPreview
78990>>>>>>>        Boolean bOk
78990>>>>>>>        // this is the most likely place we will encounter when we start a report. Check for
78990>>>>>>>        // printers and return an explicit error to make it easy to identify the error
78990>>>>>>>        Get ArePrintersInstalled to bOk
78991>>>>>>>        If not bOk begin
78993>>>>>>>            Error DFERR_WINPRINT C_$NoInstalledPrinters
78994>>>>>>>>
78994>>>>>>>        end
78994>>>>>>>>
78994>>>>>>>        else begin
78995>>>>>>>            Send DfClearDoc //JJT - a new doc should always start with a clear
78996>>>>>>>            If bAutoPreview Send DFSuspendGUI True
78999>>>>>>>            Move (WP_NewDocument(bAutoPreview)) To bOk
79000>>>>>>>
79000>>>>>>>            If not bOk Begin
79002>>>>>>>               Error DFERR_WINPRINT DFPrintError902  // could not print document
79003>>>>>>>>
79003>>>>>>>               Send DFSuspendGUI False
79004>>>>>>>            End
79004>>>>>>>>
79004>>>>>>>        end
79004>>>>>>>>
79004>>>>>>>    End_Procedure
79005>>>>>>>
79005>>>>>>>    //***
79005>>>>>>>    Procedure DFSetFont String sFontName
79007>>>>>>>        boolean bOk
79007>>>>>>>        Move (WP_SetFontName(sFontName)) To bOk
79008>>>>>>>
79008>>>>>>>        If not bOK Begin
79010>>>>>>>            Error DFERR_WINPRINT DFPrintError904
79011>>>>>>>>
79011>>>>>>>        End
79011>>>>>>>>
79011>>>>>>>    End_Procedure
79012>>>>>>>
79012>>>>>>>
79012>>>>>>>    //***
79012>>>>>>>    Procedure DFSetFontSize Integer iHeight Integer iWidth
79014>>>>>>>        boolean bOk
79014>>>>>>>        // note that width is ignored in new implementation
79014>>>>>>>        Move (WP_SetFontHeight(iHeight)) To bOk
79015>>>>>>>
79015>>>>>>>        If not bOK Begin
79017>>>>>>>            Error DFERR_WINPRINT  DFPrintError905
79018>>>>>>>>
79018>>>>>>>        End
79018>>>>>>>>
79018>>>>>>>    End_Procedure
79019>>>>>>>
79019>>>>>>>
79019>>>>>>>    //***
79019>>>>>>>    Procedure DFSetFontStyle DWORD dwStyle
79021>>>>>>>        boolean bOk
79021>>>>>>>        Move (WP_SetFontStyle(dwStyle)) To bOk
79022>>>>>>>
79022>>>>>>>        If not bOK Begin
79024>>>>>>>            Error DFERR_WINPRINT DFPrintError906
79025>>>>>>>>
79025>>>>>>>        End
79025>>>>>>>>
79025>>>>>>>    End_Procedure
79026>>>>>>>
79026>>>>>>>
79026>>>>>>>    //***
79026>>>>>>>    Procedure DFSetUnderline boolean bUnderline
79028>>>>>>>        boolean bOk
79028>>>>>>>
79028>>>>>>>        Move (WP_SetFontUnderline(bUnderline)) To bOk
79029>>>>>>>
79029>>>>>>>        If not bOK Begin
79031>>>>>>>            Error DFERR_WINPRINT DFPrintError907
79032>>>>>>>>
79032>>>>>>>        End
79032>>>>>>>>
79032>>>>>>>    End_Procedure
79033>>>>>>>
79033>>>>>>>
79033>>>>>>>    //***
79033>>>>>>>    Procedure DFSetBold Boolean bBold
79035>>>>>>>        Boolean bOk
79035>>>>>>>
79035>>>>>>>        Move (WP_SetFontBold(bBold)) To bOk
79036>>>>>>>
79036>>>>>>>        If not bOK Begin
79038>>>>>>>            Error DFERR_WINPRINT DFPrintError908
79039>>>>>>>>
79039>>>>>>>        End
79039>>>>>>>>
79039>>>>>>>    End_Procedure
79040>>>>>>>
79040>>>>>>>
79040>>>>>>>    //***
79040>>>>>>>    Procedure DFSetItalic Boolean bItalic
79042>>>>>>>        Boolean bOk
79042>>>>>>>
79042>>>>>>>        Move (WP_SetFontItalic(bItalic)) To bOk
79043>>>>>>>
79043>>>>>>>        If not bOK Begin
79045>>>>>>>            Error DFERR_WINPRINT DFPrintError909
79046>>>>>>>>
79046>>>>>>>        End
79046>>>>>>>>
79046>>>>>>>    End_Procedure
79047>>>>>>>
79047>>>>>>>
79047>>>>>>>    //***
79047>>>>>>>    Procedure DFSetStrikeout Boolean bStrikeout
79049>>>>>>>        Boolean bOk
79049>>>>>>>
79049>>>>>>>        Move (WP_SetFontStrikeout(bStrikeout)) To bOk
79050>>>>>>>
79050>>>>>>>        If not bOK Begin
79052>>>>>>>            Error DFERR_WINPRINT DFPrintError910
79053>>>>>>>>
79053>>>>>>>        End
79053>>>>>>>>
79053>>>>>>>    End_Procedure
79054>>>>>>>
79054>>>>>>>
79054>>>>>>>    //***
79054>>>>>>>    Procedure DFSetMargins Number nLeft Number nTop Number nRight Number nBottom
79056>>>>>>>        Boolean bOk
79056>>>>>>>        integer iLeft iRight iTop iBottom
79056>>>>>>>
79056>>>>>>>        Move (nLeft   * 100) to iLeft
79057>>>>>>>        Move (nRight  * 100) to iRight
79058>>>>>>>        Move (nTop    * 100) to iTop
79059>>>>>>>        Move (nBottom * 100) to iBottom
79060>>>>>>>
79060>>>>>>>        Move (WP_SetMargins(iLeft,iTop,iRight,iBottom)) To bOk
79061>>>>>>>
79061>>>>>>>        If bOk Begin
79063>>>>>>>            Set DFLeft_Margin   To nLeft
79064>>>>>>>            Set DFTop_Margin    To nTop
79065>>>>>>>            Set DFRight_Margin  To nRight
79066>>>>>>>            Set DFBottom_Margin To nBottom
79067>>>>>>>        End
79067>>>>>>>>
79067>>>>>>>        Else Begin
79068>>>>>>>            Error DFERR_WINPRINT DFPrintError911
79069>>>>>>>>
79069>>>>>>>        End
79069>>>>>>>>
79069>>>>>>>    End_Procedure
79070>>>>>>>
79070>>>>>>>
79070>>>>>>>    //***
79070>>>>>>>    Procedure DFSetLeftMargin Number nLeft
79072>>>>>>>        number  nTop nRight nBottom
79072>>>>>>>        Get DFTop_Margin    To nTop
79073>>>>>>>        Get DFRight_Margin  To nRight
79074>>>>>>>        Get DFBottom_Margin To nBottom
79075>>>>>>>        Send DFSetMargins nLeft nTop nRight nBottom
79076>>>>>>>    End_Procedure
79077>>>>>>>
79077>>>>>>>
79077>>>>>>>    //***
79077>>>>>>>    Procedure DFSetRightMargin Number nRight
79079>>>>>>>        number  nLeft nTop nBottom
79079>>>>>>>        Get DFLeft_Margin   To nLeft
79080>>>>>>>        Get DFTop_Margin    To nTop
79081>>>>>>>        Get DFBottom_Margin To nBottom
79082>>>>>>>        Send DFSetMargins nLeft nTop nRight nBottom
79083>>>>>>>    End_Procedure
79084>>>>>>>
79084>>>>>>>
79084>>>>>>>    //***
79084>>>>>>>    Procedure DFSetTopMargin Number nTop
79086>>>>>>>        number  nLeft nRight nBottom
79086>>>>>>>        Get DFLeft_Margin   To nLeft
79087>>>>>>>        Get DFRight_Margin  To nRight
79088>>>>>>>        Get DFBottom_Margin To nBottom
79089>>>>>>>        Send DFSetMargins nLeft nTop nRight nBottom
79090>>>>>>>    End_Procedure
79091>>>>>>>
79091>>>>>>>
79091>>>>>>>    //***
79091>>>>>>>    Procedure DFSetBottomMargin Number nBottom
79093>>>>>>>        number  nLeft nTop nRight
79093>>>>>>>        Get DFLeft_Margin   To nLeft
79094>>>>>>>        Get DFTop_Margin    To nTop
79095>>>>>>>        Get DFRight_Margin  To nRight
79096>>>>>>>        Send DFSetMargins nLeft nTop nRight nBottom
79097>>>>>>>    End_Procedure
79098>>>>>>>
79098>>>>>>>
79098>>>>>>>    //***
79098>>>>>>>    Procedure DFWriteText String sText Integer iStyle Integer iColumn Integer iDecimal Boolean bNewLineAfterPrint
79100>>>>>>>        Boolean bOk
79100>>>>>>>
79100>>>>>>>        Send DFSetFontStyle iStyle
79101>>>>>>>        Get ToAnsi sText To sText
79102>>>>>>>        Move (WP_WriteText(sText,bNewLineAfterPrint,iColumn,iDecimal,0)) To bOk
79103>>>>>>>        If not bOk Begin
79105>>>>>>>            Error DFERR_WINPRINT DFPrintError918
79106>>>>>>>>
79106>>>>>>>        End
79106>>>>>>>>
79106>>>>>>>        Send PumpMsgQueue // permit painting //JJT!!!!!!!!!!!
79107>>>>>>>    End_Procedure
79108>>>>>>>
79108>>>>>>>    //***
79108>>>>>>>    Procedure DFWrite String sText DWORD iStyle Integer iColumn Integer iDecimal Boolean bTrim
79110>>>>>>>        If (Num_Arguments>=5 and bTrim) Begin
79112>>>>>>>            Move (Rtrim(sText)) to sText
79113>>>>>>>        end
79113>>>>>>>>
79113>>>>>>>        Send DFWriteText sText iStyle iColumn iDecimal False
79114>>>>>>>    End_Procedure
79115>>>>>>>
79115>>>>>>>    //***
79115>>>>>>>    Procedure DFWriteLn String sText DWORD iStyle Integer iColumn Integer iDecimal Boolean bTrim
79117>>>>>>>        If (Num_Arguments>=5 and bTrim) Begin
79119>>>>>>>            Move (Rtrim(sText)) to sText
79120>>>>>>>        end
79120>>>>>>>>
79120>>>>>>>        Send DFWriteText sText iStyle iColumn iDecimal True
79121>>>>>>>    End_Procedure
79122>>>>>>>
79122>>>>>>>
79122>>>>>>>    //***
79122>>>>>>>    Procedure DFWriteTextAtPosition String sText integer iStyle Number nPosition Integer iDecimal ;                                    Number nMaxLength Boolean bNewLineAfterPrint
79124>>>>>>>        Boolean bOk
79124>>>>>>>        Integer iPosition iMaxLength
79124>>>>>>>        Send DFSetFontStyle iStyle
79125>>>>>>>        Get ToAnsi sText To sText
79126>>>>>>>        Move (nPosition * 100) to iPosition
79127>>>>>>>        Move (nMaxLength * 100) to iMaxLength
79128>>>>>>>        Move (WP_WriteTextAtPosition(sText,bNewLineAfterPrint,iPosition,iDecimal,iMaxLength)) To bOk
79129>>>>>>>        If not bOk Begin
79131>>>>>>>            Error DFERR_WINPRINT DFPrintError922
79132>>>>>>>>
79132>>>>>>>        End
79132>>>>>>>>
79132>>>>>>>         Send PumpMsgQueue // permit painting //JJT!!!!!!!!!!!
79133>>>>>>>    End_Procedure
79134>>>>>>>
79134>>>>>>>    //***
79134>>>>>>>    Procedure DFWritePos String sText integer iStyle Number nPosition Integer iDecimal Number nMaxLength boolean bTrim
79136>>>>>>>        Number nMax
79136>>>>>>>        If (Num_Arguments>=6 and bTrim) Begin
79138>>>>>>>            Move (Rtrim(sText)) to sText
79139>>>>>>>        end
79139>>>>>>>>
79139>>>>>>>
79139>>>>>>>        If (Num_Arguments<5) ;            Move 0 to nMax
79142>>>>>>>        Else ;            Move nMaxLength to nMax
79144>>>>>>>        Send DFWriteTextAtPosition sText iStyle nPosition iDecimal nMax False
79145>>>>>>>    End_Procedure
79146>>>>>>>
79146>>>>>>>    //***
79146>>>>>>>    Procedure DFWriteLnPos String sText integer iStyle Number nPosition Integer iDecimal Number nMaxLength boolean bTrim
79148>>>>>>>        Number nMax
79148>>>>>>>        If (Num_Arguments>=6 and bTrim) Begin
79150>>>>>>>            Move (Rtrim(sText)) to sText
79151>>>>>>>        end
79151>>>>>>>>
79151>>>>>>>
79151>>>>>>>        If (Num_Arguments<5) ;            Move 0 to nMax
79154>>>>>>>        Else ;            Move nMaxLength to nMax
79156>>>>>>>        Send DFWriteTextAtPosition sText iStyle nPosition iDecimal nMax True
79157>>>>>>>    End_Procedure
79158>>>>>>>
79158>>>>>>>    Procedure DFSetMetrics String sMetrics
79160>>>>>>>        integer eMetrics
79160>>>>>>>        // for backwards compatibility support both string names and integer enumerations
79160>>>>>>>        // it is better to use the enumeration value
79160>>>>>>>        If (sMetrics="INCH" or sMetrics="CM") Begin
79162>>>>>>>            Set DFCurrent_Metrics to sMetrics
79163>>>>>>>        end
79163>>>>>>>>
79163>>>>>>>        else Begin
79164>>>>>>>            Move sMetrics to eMetrics
79165>>>>>>>            Move (WP_SetMetrics(eMetrics)) To eMetrics
79166>>>>>>>        End
79166>>>>>>>>
79166>>>>>>>    End_Procedure
79167>>>>>>>
79167>>>>>>>    Function DFGetMetrics Returns Integer
79169>>>>>>>        Integer eMetrics
79169>>>>>>>        Move (WP_GetMetrics()) To eMetrics
79170>>>>>>>        Function_return eMetrics
79171>>>>>>>    End_Function
79172>>>>>>>
79172>>>>>>>
79172>>>>>>>    //**** Properties Maintained for compatibility with old Winprint (obsolete)
79172>>>>>>>    Function DFCurrent_Metrics returns string
79174>>>>>>>        Integer eMetrics
79174>>>>>>>        Get DFGetMetrics to eMetrics
79175>>>>>>>        Function_return (if(eMetrics=WPM_INCH,"INCH","CM"))
79176>>>>>>>    end_function
79177>>>>>>>
79177>>>>>>>    Procedure Set DFCurrent_Metrics string sCMorINCH
79179>>>>>>>        Send DFSetMetrics (if(sCMorINCH="INCH", WPM_INCH, WPM_CM))
79180>>>>>>>    End_Procedure
79181>>>>>>>
79181>>>>>>>
79181>>>>>>>
79181>>>>>>>
79181>>>>>>>
79181>>>>>>>    //***
79181>>>>>>>    Procedure DFBeginHeaderType Integer iHeaderNr Integer eHeaderType
79183>>>>>>>        Boolean bOk
79183>>>>>>>
79183>>>>>>>        If (eHeaderType=DFSubHeader or eHeaderType=DFSubTotal) Begin
79185>>>>>>>            //*** Do nothing for the moment
79185>>>>>>>        End
79185>>>>>>>>
79185>>>>>>>        Else ;            Move 0 to iHeaderNr // If the user made a mistake
79187>>>>>>>
79187>>>>>>>        Set DFCurrent_HeaderType To eHeaderType
79188>>>>>>>        Set DFCurrent_HeaderNr   To iHeaderNr
79189>>>>>>>
79189>>>>>>>        Move (WP_BeginHeader(eHeaderType, iHeaderNr)) To bOk
79190>>>>>>>
79190>>>>>>>        If not bOk Begin
79192>>>>>>>            Error DFERR_WINPRINT DFPrintError925
79193>>>>>>>>
79193>>>>>>>        End
79193>>>>>>>>
79193>>>>>>>    End_Procedure
79194>>>>>>>
79194>>>>>>>
79194>>>>>>>    //***
79194>>>>>>>    Procedure DFEndHeaderType
79196>>>>>>>        Boolean bOk
79196>>>>>>>
79196>>>>>>>        Move (WP_EndHeader()) To bOk
79197>>>>>>>
79197>>>>>>>        if not bOk begin
79199>>>>>>>            Error DFERR_WINPRINT DFPrintError926
79200>>>>>>>>
79200>>>>>>>        End
79200>>>>>>>>
79200>>>>>>>    End_Procedure
79201>>>>>>>
79201>>>>>>>
79201>>>>>>>    //***
79201>>>>>>>    Procedure DFWriteHeaderType Integer iHeaderNr Integer eHeaderType
79203>>>>>>>        Boolean bOk
79203>>>>>>>        Move (WP_WriteHeader(eHeaderType, iHeaderNr)) To bOk
79204>>>>>>>        if not bOk begin
79206>>>>>>>            Error DFERR_WINPRINT DFPrintError927
79207>>>>>>>>
79207>>>>>>>        End
79207>>>>>>>>
79207>>>>>>>    End_Procedure
79208>>>>>>>
79208>>>>>>>
79208>>>>>>>    //***
79208>>>>>>>    Procedure DFHeaderPosition Integer ePlace
79210>>>>>>>        Boolean bOk
79210>>>>>>>
79210>>>>>>>         Move (WP_SetHeaderPlacement(ePlace)) To bOk
79211>>>>>>>
79211>>>>>>>         if not bOk begin
79213>>>>>>>            Error DFERR_WINPRINT DFPrintError929
79214>>>>>>>>
79214>>>>>>>        End
79214>>>>>>>>
79214>>>>>>>    End_Procedure
79215>>>>>>>
79215>>>>>>>
79215>>>>>>>    //***
79215>>>>>>>    Procedure DFHeaderFrameType Integer eFrame integer iColor Number nWeight;                                Integer iFillColor Boolean bFillFrame
79217>>>>>>>        Integer iWeight
79217>>>>>>>        Boolean bOk
79217>>>>>>>
79217>>>>>>>        move (nWeight*100) To iWeight
79218>>>>>>>
79218>>>>>>>        Move (WP_SetHeaderFrame(eFrame,iColor,iWeight,iFillColor,bFillFrame)) To bOk
79219>>>>>>>
79219>>>>>>>         if not bOk begin
79221>>>>>>>            Error DFERR_WINPRINT DFPrintError930
79222>>>>>>>>
79222>>>>>>>        End
79222>>>>>>>>
79222>>>>>>>    End_Procedure
79223>>>>>>>
79223>>>>>>>  Procedure DFHeaderMargin Integer eType Number nSize
79225>>>>>>>        Boolean bOk
79225>>>>>>>        Integer iSize
79225>>>>>>>
79225>>>>>>>        move (nSize * 100) to iSize
79226>>>>>>>
79226>>>>>>>        move (WP_SetHeaderMargin(eType, iSize)) To bOk
79227>>>>>>>
79227>>>>>>>        if not bOk begin
79229>>>>>>>            Error DFERR_WINPRINT DFPrintError930
79230>>>>>>>>
79230>>>>>>>        end
79230>>>>>>>>
79230>>>>>>>    End_Procedure
79231>>>>>>>
79231>>>>>>>
79231>>>>>>>    //***
79231>>>>>>>    Procedure DFHeaderWrap Integer eOnOff
79233>>>>>>>         Boolean bOk
79233>>>>>>>
79233>>>>>>>         Move (WP_SetHeaderWrap(eOnOff)) To bOk
79234>>>>>>>
79234>>>>>>>         if not bOk begin
79236>>>>>>>            Error DFERR_WINPRINT DFPrintError931
79237>>>>>>>>
79237>>>>>>>        End
79237>>>>>>>>
79237>>>>>>>    End_Procedure
79238>>>>>>>
79238>>>>>>>    //***
79238>>>>>>>    Procedure DFWriteBMP String sFileName Number nStartX Number nStartY Number nHeight Number nWidth Boolean bUCp
79240>>>>>>>        Boolean bOk
79240>>>>>>>        Integer iStartX iStartY iHeight iWidth
79240>>>>>>>
79240>>>>>>>        If ((nStartX = -998) or (nStartX = -999));            move nStartX to iStartX
79243>>>>>>>        else ;            move (nStartX*100) To iStartX
79245>>>>>>>
79245>>>>>>>        If ((nStartY = -998) or (nStartY = -999));            move nStartY to iStartY
79248>>>>>>>        else ;            move (nStartY*100) To iStartY
79250>>>>>>>
79250>>>>>>>        If ((nWidth = -998) or (nWidth = -999));            move nWidth To iWidth
79253>>>>>>>        else ;            move (nWidth*100) To iWidth
79255>>>>>>>
79255>>>>>>>        If ((nHeight = -998) or (nHeight = -999));            move nHeight To iHeight
79258>>>>>>>        else ;            move (nHeight*100) To iHeight
79260>>>>>>>
79260>>>>>>>        Get_File_Path sFileName To sFileName
79261>>>>>>>        Move (WP_DrawBitmap(sFileName,iStartX,iStartY,iWidth,iHeight,bUCp)) to bOk
79262>>>>>>>
79262>>>>>>>        If not bOk Begin
79264>>>>>>>            Error DFERR_WINPRINT DFPrintError932
79265>>>>>>>>
79265>>>>>>>        End
79265>>>>>>>>
79265>>>>>>>    End_Procedure
79266>>>>>>>
79266>>>>>>>
79266>>>>>>>    //***
79266>>>>>>>    Procedure DFHeaderLineCheck Integer iLines
79268>>>>>>>        Boolean bOk
79268>>>>>>>
79268>>>>>>>         Move (WP_SetExtraLineCheck(iLines)) To bOk
79269>>>>>>>
79269>>>>>>>        If not bOk begin
79271>>>>>>>            Error DFERR_WINPRINT DFPrintError934
79272>>>>>>>>
79272>>>>>>>        End
79272>>>>>>>>
79272>>>>>>>    End_Procedure
79273>>>>>>>
79273>>>>>>>
79273>>>>>>>    //***
79273>>>>>>>    Procedure DFPrintFlags Integer Flags
79275>>>>>>>        Boolean bOk
79275>>>>>>>
79275>>>>>>>         Move (WP_SetPrintDialogFlags(Flags)) To bOk
79276>>>>>>>
79276>>>>>>>        If not bOk begin
79278>>>>>>>            Error DFERR_WINPRINT DFPrintError935
79279>>>>>>>>
79279>>>>>>>        End
79279>>>>>>>>
79279>>>>>>>    End_Procedure
79280>>>>>>>
79280>>>>>>>
79280>>>>>>>    //*** obsolete and maintained for winprint-I backwards compatibility (maybe should be removed)
79280>>>>>>>    //
79280>>>>>>>    Procedure DFSelectPrinter String sDriver String sDevice String sPort Boolean bUpdate
79282>>>>>>>        Send DFSetDevice sDevice
79283>>>>>>>    End_Procedure
79284>>>>>>>
79284>>>>>>>    //*** Preferred usage for WinprintII
79284>>>>>>>    Procedure DFSetDevice String sDevice
79286>>>>>>>        Boolean bOk
79286>>>>>>>
79286>>>>>>>        Move (WP_SelectPrinter(sDevice)) To bOk
79287>>>>>>>
79287>>>>>>>        If not bOk Begin
79289>>>>>>>            Error DFERR_WINPRINT DFPrintError936
79290>>>>>>>>
79290>>>>>>>        End
79290>>>>>>>>
79290>>>>>>>    End_Procedure
79291>>>>>>>
79291>>>>>>>    Procedure DFPrinterBinFirstPage Integer eBin
79293>>>>>>>        Boolean bOk
79293>>>>>>>
79293>>>>>>>         Move (WP_SetFirstPagePaperSource(eBin)) To bOk
79294>>>>>>>
79294>>>>>>>        If not bOk Begin
79296>>>>>>>            Error DFERR_WINPRINT DFPrintError937
79297>>>>>>>>
79297>>>>>>>        End
79297>>>>>>>>
79297>>>>>>>    End_Procedure
79298>>>>>>>
79298>>>>>>>
79298>>>>>>>    //***
79298>>>>>>>    Function DFGetDFColor Integer iRed Integer iGreen Integer iBlue Returns Integer
79300>>>>>>>        Integer iColor
79300>>>>>>>
79300>>>>>>>         Move (WP_RGBToDFPrintColor(iRed,iGreen,iBlue)) To iColor
79301>>>>>>>
79301>>>>>>>        If (iColor=0) Begin
79303>>>>>>>            Error DFERR_WINPRINT DFPrintError938
79304>>>>>>>>
79304>>>>>>>        End
79304>>>>>>>>
79304>>>>>>>        Function_Return iColor
79305>>>>>>>    End_Function
79306>>>>>>>
79306>>>>>>>
79306>>>>>>>    //***
79306>>>>>>>    Procedure DFSetDFColor Dword dwColor
79308>>>>>>>        Integer bOk
79308>>>>>>>
79308>>>>>>>         Move (WP_SetFontColor(dwColor)) To bOk
79309>>>>>>>
79309>>>>>>>        If not bOk Begin
79311>>>>>>>            Error DFERR_WINPRINT DFPrintError939
79312>>>>>>>>
79312>>>>>>>        End
79312>>>>>>>>
79312>>>>>>>    End_Procedure
79313>>>>>>>
79313>>>>>>>
79313>>>>>>>    //***
79313>>>>>>>    Procedure DFSetTopBottom Number nTop Number nBottom Boolean bAllPages
79315>>>>>>>        Boolean bOk
79315>>>>>>>        Integer iTop iBottom
79315>>>>>>>
79315>>>>>>>        move (nTop*100)    To iTop
79316>>>>>>>        move (nBottom*100) To iBottom
79317>>>>>>>
79317>>>>>>>        Move (WP_SetAbsoluteMargins(iTop,iBottom,bAllPages)) To bOk
79318>>>>>>>
79318>>>>>>>        If Not bOk Begin
79320>>>>>>>            Error DFERR_WINPRINT DFPrintError940
79321>>>>>>>>
79321>>>>>>>        End
79321>>>>>>>>
79321>>>>>>>    End_Procedure
79322>>>>>>>
79322>>>>>>>
79322>>>>>>>    //***
79322>>>>>>>    Procedure DFSetJMode Integer eAlign
79324>>>>>>>        Boolean bOk
79324>>>>>>>
79324>>>>>>>        Move (WP_SetAlign(eAlign)) To bOk
79325>>>>>>>
79325>>>>>>>        If Not bOk Begin
79327>>>>>>>            Error DFERR_WINPRINT DFPrintError941
79328>>>>>>>>
79328>>>>>>>        End
79328>>>>>>>>
79328>>>>>>>    End_Procedure
79329>>>>>>>
79329>>>>>>>
79329>>>>>>>    //***
79329>>>>>>>    Procedure DFWriteEllip Number nStartX Number nStartY Number nHeight Number nWidth ;              Dword dwBColor Dword dwFColor Boolean bFill Number nWeight Boolean bWrap Boolean bUCp
79331>>>>>>>
79331>>>>>>>        Boolean bOk
79331>>>>>>>        Integer iWeight
79331>>>>>>>        Integer iStartX iStartY iHeight iWidth
79331>>>>>>>
79331>>>>>>>        If ((nStartX = -998) or (nStartX = -999));            move nStartX To iStartX
79334>>>>>>>        else ;            move (nStartX*100) To iStartX
79336>>>>>>>
79336>>>>>>>        If ((nStartY = -998) or (nStartY = -999));            move nStartY To iStartY
79339>>>>>>>        else ;            move (nStartY*100) To iStartY
79341>>>>>>>
79341>>>>>>>        If ((nWidth = -998) or (nWidth = -999));            move nWidth To iWidth
79344>>>>>>>        else ;            move (nWidth*100) To iWidth
79346>>>>>>>
79346>>>>>>>        If ((nHeight = -998) or (nHeight = -999));            move nHeight To iHeight
79349>>>>>>>        else ;            move (nHeight*100) To iHeight
79351>>>>>>>
79351>>>>>>>        move (nWeight*100) To iWeight
79352>>>>>>>
79352>>>>>>>
79352>>>>>>>        Move (WP_DrawEllipse(iStartX,iStartY,iWidth,iHeight,;                        dwBColor,dwFColor,bFill,iWeight,bUCp,bWrap)) To bOk
79353>>>>>>>
79353>>>>>>>        If Not bOk Begin
79355>>>>>>>            Error DFERR_WINPRINT DFPrintError942
79356>>>>>>>>
79356>>>>>>>        End
79356>>>>>>>>
79356>>>>>>>    End_Procedure
79357>>>>>>>
79357>>>>>>>
79357>>>>>>>
79357>>>>>>>
79357>>>>>>>    //***
79357>>>>>>>    Procedure DFWriteRect Number nStartX Number nStartY Number nHeight Number nWidth;              Dword dwBColor Dword dwFColor Boolean bFill Number nWeight Boolean bWrap Boolean bUCp
79359>>>>>>>
79359>>>>>>>        Boolean bOk
79359>>>>>>>        Integer iWeight
79359>>>>>>>        Integer iStartX iStartY iHeight iWidth
79359>>>>>>>
79359>>>>>>>        If ((nStartX = -998) or (nStartX = -999));            move nStartX To iStartX
79362>>>>>>>        else ;            move (nStartX*100) To iStartX
79364>>>>>>>
79364>>>>>>>        If ((nStartY = -998) or (nStartY = -999));            move nStartY To iStartY
79367>>>>>>>        else ;            move (nStartY*100) To iStartY
79369>>>>>>>
79369>>>>>>>        If ((nWidth = -998) or (nWidth = -999));            move nWidth To iWidth
79372>>>>>>>        else ;            move (nWidth*100) To iWidth
79374>>>>>>>
79374>>>>>>>        If ((nHeight = -998) or (nHeight = -999));            move nHeight To iHeight
79377>>>>>>>        else ;            move (nHeight*100) To iHeight
79379>>>>>>>
79379>>>>>>>        move (nWeight*100) To iWeight
79380>>>>>>>
79380>>>>>>>        Move (WP_DrawRectangle(iStartX,iStartY,iWidth,iHeight,;                            dwBColor,dwFColor,bFill,iWeight,bUCp,bWrap)) To bOk
79381>>>>>>>
79381>>>>>>>        If Not bOk Begin
79383>>>>>>>            Error DFERR_WINPRINT DFPrintError944
79384>>>>>>>>
79384>>>>>>>        End
79384>>>>>>>>
79384>>>>>>>    End_Procedure
79385>>>>>>>
79385>>>>>>>
79385>>>>>>>
79385>>>>>>>
79385>>>>>>>    //***
79385>>>>>>>    Procedure DFLineCheck Integer iLines
79387>>>>>>>        Boolean bOk
79387>>>>>>>
79387>>>>>>>        Move (WP_ConfirmLines(iLines)) To bOk
79388>>>>>>>
79388>>>>>>>        If Not bOk Begin
79390>>>>>>>            Error DFERR_WINPRINT DFPrintError946
79391>>>>>>>>
79391>>>>>>>        End
79391>>>>>>>>
79391>>>>>>>    End_Procedure
79392>>>>>>>
79392>>>>>>>
79392>>>>>>>    //***
79392>>>>>>>    Procedure DFCreateDiagram Integer eType Integer eFx Number nHeight Number nWidth Integer bXyAxis
79394>>>>>>>        Handle hDiagram
79394>>>>>>>        Integer iWidth iHeight
79394>>>>>>>
79394>>>>>>>        move (nHeight*100) To iHeight
79395>>>>>>>        move (nWidth*100)  To iWidth
79396>>>>>>>
79396>>>>>>>        Set DFCurrent_Color To 0
79397>>>>>>>
79397>>>>>>>        Move (WP_CreateDiagram(eType,eFx,iWidth,iHeight,bXyAxis)) To hDiagram
79398>>>>>>>
79398>>>>>>>        If (hDiagram) Begin
79400>>>>>>>            Error DFERR_WINPRINT DFPrintError947
79401>>>>>>>>
79401>>>>>>>        End
79401>>>>>>>>
79401>>>>>>>        Else Begin
79402>>>>>>>            Set DFCurrent_Diagram To hDiagram
79403>>>>>>>        end
79403>>>>>>>>
79403>>>>>>>    End_Procedure
79404>>>>>>>
79404>>>>>>>
79404>>>>>>>    //***
79404>>>>>>>    Procedure DFDiagram_Item handle hDiagram String sLabel Number nValue;                             Dword dwBColor Dword dwFColor Integer eFill;                             Integer iDec Integer eValueOrPercent Integer eExt
79406>>>>>>>
79406>>>>>>>        Boolean bOk
79406>>>>>>>        Integer iCurrColor iValue
79406>>>>>>>
79406>>>>>>>        If (dwFColor = -1) Begin
79408>>>>>>>            Get DFCurrent_Color To iCurrColor
79409>>>>>>>            Increment iCurrColor
79410>>>>>>>            If (iCurrColor>15) Move 1 To iCurrColor
79413>>>>>>>            Set DFCurrent_Color To iCurrColor
79414>>>>>>>            Get DFGetColor iCurrColor To dwFColor
79415>>>>>>>        End
79415>>>>>>>>
79415>>>>>>>
79415>>>>>>>        Move (nValue *100) to iValue
79416>>>>>>>
79416>>>>>>>        Get ToAnsi sLabel To sLabel
79417>>>>>>>
79417>>>>>>>        Move (WP_AddDiagramEntry(hDiagram,sLabel,iValue,dwBColor,dwFColor,eFill,iDec,eValueorPercent,eExt)) To bOk
79418>>>>>>>
79418>>>>>>>        If not bOk Begin
79420>>>>>>>            Error DFERR_WINPRINT DFPrintError948
79421>>>>>>>>
79421>>>>>>>        End
79421>>>>>>>>
79421>>>>>>>    End_Procedure
79422>>>>>>>
79422>>>>>>>
79422>>>>>>>    //***
79422>>>>>>>    Procedure DFLockDiagram Handle hDiagram
79424>>>>>>>        Boolean bOk
79424>>>>>>>
79424>>>>>>>        Move (WP_LockDiagram(hDiagram)) To bOk
79425>>>>>>>
79425>>>>>>>        If not bOk Begin
79427>>>>>>>            Error DFERR_WINPRINT DFPrintError949
79428>>>>>>>>
79428>>>>>>>        End
79428>>>>>>>>
79428>>>>>>>    End_Procedure
79429>>>>>>>
79429>>>>>>>
79429>>>>>>>
79429>>>>>>>    //***
79429>>>>>>>    Procedure DFDrawDiagram Handle hDiagram Number nYPos Number nXPos Boolean bUCp
79431>>>>>>>        Boolean bOk
79431>>>>>>>        Integer iXPos
79431>>>>>>>        Integer iYPos
79431>>>>>>>
79431>>>>>>>        move (nXPos*100) To iXPos
79432>>>>>>>        move (nYPos*100) To iYPos
79433>>>>>>>
79433>>>>>>>        If nYPos Eq -999 Move -999 To iYPos
79436>>>>>>>
79436>>>>>>>        Move (WP_DrawDiagram(hDiagram,iXPos,iYPos,bUCp)) To bOk
79437>>>>>>>
79437>>>>>>>        If not bOk Begin
79439>>>>>>>            Error DFERR_WINPRINT DFPrintError950
79440>>>>>>>>
79440>>>>>>>        End
79440>>>>>>>>
79440>>>>>>>    End_Procedure
79441>>>>>>>
79441>>>>>>>
79441>>>>>>>
79441>>>>>>>    //***
79441>>>>>>>    Procedure DFDiagramLabel handle hDiagram String sLabel
79443>>>>>>>        Boolean bOk
79443>>>>>>>        Integer iLabelLen
79443>>>>>>>
79443>>>>>>>        Get ToAnsi sLabel To sLabel
79444>>>>>>>
79444>>>>>>>        Move (WP_SetDiagramCaption(hDiagram,sLabel)) To bOk
79445>>>>>>>
79445>>>>>>>        if not bOk Begin
79447>>>>>>>            Error DFERR_WINPRINT DFPrintError952
79448>>>>>>>>
79448>>>>>>>        End
79448>>>>>>>>
79448>>>>>>>    End_Procedure
79449>>>>>>>
79449>>>>>>>
79449>>>>>>>    //***
79449>>>>>>>    Procedure DFDiagramXLabel handle hDiagram String sLabel
79451>>>>>>>        Boolean bOk
79451>>>>>>>        Get ToAnsi sLabel To sLabel
79452>>>>>>>
79452>>>>>>>        Move (WP_SetDiagramXText(hDiagram,sLabel)) To bOk
79453>>>>>>>
79453>>>>>>>        if not bOk Begin
79455>>>>>>>            Error DFERR_WINPRINT DFPrintError953
79456>>>>>>>>
79456>>>>>>>        End
79456>>>>>>>>
79456>>>>>>>    End_Procedure
79457>>>>>>>
79457>>>>>>>
79457>>>>>>>    //***
79457>>>>>>>    Procedure DFDiagramYLabel handle hDiagram String sLabel Boolean bVertical
79459>>>>>>>        Boolean bOk
79459>>>>>>>        Get ToAnsi sLabel To sLabel
79460>>>>>>>
79460>>>>>>>        Move (WP_SetDiagramYText(hDiagram,sLabel,bVertical)) To bOk
79461>>>>>>>
79461>>>>>>>        if not bOk Begin
79463>>>>>>>            Error DFERR_WINPRINT DFPrintError954
79464>>>>>>>>
79464>>>>>>>        End
79464>>>>>>>>
79464>>>>>>>    End_Procedure
79465>>>>>>>
79465>>>>>>>
79465>>>>>>>    //***
79465>>>>>>>    Procedure DFWriteXYLine Number nStartX Number nStartY Number nStopX Number nStopY;              Dword dwColor Number nWeight Boolean bWrap Boolean bUCp
79467>>>>>>>
79467>>>>>>>        Boolean bOk
79467>>>>>>>        Integer iStartX iStartY iStopX iStopY
79467>>>>>>>        Integer iWeight
79467>>>>>>>
79467>>>>>>>        move (nStartX*100)  To iStartX
79468>>>>>>>        move (nStartY*100)  To iStartY
79469>>>>>>>        move (nStopX*100)   To iStopX
79470>>>>>>>        move (nStopY*100)   To iStopY
79471>>>>>>>
79471>>>>>>>        move (nWeight*100) To iWeight
79472>>>>>>>
79472>>>>>>>        If (nStopY  = -998) Move -998 To iStopY
79475>>>>>>>        If (nStopX  = -998) Move -998 To iStopX
79478>>>>>>>
79478>>>>>>>        If (nStartY  = -999) Move -999 To iStartY
79481>>>>>>>        If (nStartX  = -999) Move -999 To iStartX
79484>>>>>>>
79484>>>>>>>        Move (WP_DrawXYLine(iStartX,iStartY,iStopX,iStopY,dwColor,iWeight,bUCp,bWrap)) To bOk
79485>>>>>>>
79485>>>>>>>        if not bOk Begin
79487>>>>>>>            Error DFERR_WINPRINT DFPrintError955
79488>>>>>>>>
79488>>>>>>>        End
79488>>>>>>>>
79488>>>>>>>    End_Procedure
79489>>>>>>>
79489>>>>>>>
79489>>>>>>>    //***
79489>>>>>>>    Procedure DFWriteLine Number nStartX Number nStartY Number nLength;                          Boolean bHorizontal Dword dwColor Number nWeight Boolean bUCp
79491>>>>>>>
79491>>>>>>>        Boolean bOk
79491>>>>>>>        Integer iStartX iStartY iLength
79491>>>>>>>        Integer iWeight
79491>>>>>>>
79491>>>>>>>        move (nStartX*100)  To iStartX
79492>>>>>>>        move (nStartY*100)  To iStartY
79493>>>>>>>        move (nLength*100)  To iLength
79494>>>>>>>        move (nWeight*100)  To iWeight
79495>>>>>>>
79495>>>>>>>        If (nStartY = -999) Move -999 To iStartY
79498>>>>>>>        If (nStartX = -999) Move -999 To iStartX
79501>>>>>>>        If (nLength = -998) Move -998 To iLength
79504>>>>>>>
79504>>>>>>>        Move (WP_DrawLine(iSTartX,iStartY,iLength,bHorizontal,dwColor,iWeight,bUCp)) To bOk
79505>>>>>>>
79505>>>>>>>        if not bOk Begin
79507>>>>>>>            Error DFERR_WINPRINT DFPrintError956
79508>>>>>>>>
79508>>>>>>>        End
79508>>>>>>>>
79508>>>>>>>    End_Procedure
79509>>>>>>>
79509>>>>>>>
79509>>>>>>>    //***
79509>>>>>>>    Procedure DFClearPrinter
79511>>>>>>>        Boolean bOk
79511>>>>>>>
79511>>>>>>>        Move (WP_ClearPrinter()) To bOk
79512>>>>>>>
79512>>>>>>>        If not bOk Begin
79514>>>>>>>            Error DFERR_WINPRINT DFPrintError957
79515>>>>>>>>
79515>>>>>>>        End
79515>>>>>>>>
79515>>>>>>>    End_Procedure
79516>>>>>>>
79516>>>>>>>
79516>>>>>>>
79516>>>>>>>    //***
79516>>>>>>>     Function DFGetCurrentDevice Returns String
79518>>>>>>>        Boolean bOk
79518>>>>>>>        String  sDFStr
79518>>>>>>>        Address pDFStr
79518>>>>>>>
79518>>>>>>>        Move (Repeat( Character(0), 255 )) to sDFStr
79519>>>>>>>        GetAddress of sDFStr to pDFStr
79520>>>>>>>
79520>>>>>>>        Move (WP_GetCurrentDevice(pDFStr)) To bOk
79521>>>>>>>
79521>>>>>>>        If not bOk Begin
79523>>>>>>>            Error DFERR_WINPRINT DFPrintError959
79524>>>>>>>>
79524>>>>>>>        End
79524>>>>>>>>
79524>>>>>>>
79524>>>>>>>        Move (CString(sDFStr)) To sDFStr
79525>>>>>>>        Function_Return sDFStr
79526>>>>>>>     End_Function
79527>>>>>>>
79527>>>>>>>
79527>>>>>>>    // Note: DfGetCurrentPort and DFGetCurrentDriver do not exist in winprint2. Trying to
79527>>>>>>>    //       use these will result in a runtime error (which is good - don't use them)
79527>>>>>>>
79527>>>>>>>
79527>>>>>>>    //***
79527>>>>>>>     Function DFGetPrintDialogFlags Returns Dword
79529>>>>>>>        Dword dwRetVal
79529>>>>>>>
79529>>>>>>>        Move (WP_GetPrintDialogFlags()) To dwRetVal
79530>>>>>>>
79530>>>>>>>        Function_Return dwRetVal
79531>>>>>>>     End_Function
79532>>>>>>>
79532>>>>>>>
79532>>>>>>>    //***
79532>>>>>>>    //*** Returns PRN_TRUE=  if the flag is set     (1)
79532>>>>>>>    //*** Returns PRN_FALSE= If the flag not is set (0)
79532>>>>>>>    //***
79532>>>>>>>     Function DFCheckPrintDialogFlag Dword dwPDFlag Returns Boolean
79534>>>>>>>        Boolean bIsSet
79534>>>>>>>
79534>>>>>>>        Move (WP_IsPrintDialogFlagSet(dwPDFlag)) To bIsSet
79535>>>>>>>
79535>>>>>>>        Function_Return bIsSet
79536>>>>>>>     End_Function
79537>>>>>>>
79537>>>>>>>
79537>>>>>>>    //***
79537>>>>>>>     Procedure DFSetSpecPrintFlag Dword dwPDFlag
79539>>>>>>>        Boolean bOk
79539>>>>>>>
79539>>>>>>>        Move (WP_SetSpecificPrintDialogFlag(dwPDFlag)) To bOk
79540>>>>>>>
79540>>>>>>>        If not bOk Begin
79542>>>>>>>            Error DFERR_WINPRINT DFPrintError961
79543>>>>>>>>
79543>>>>>>>        End
79543>>>>>>>>
79543>>>>>>>     End_Procedure
79544>>>>>>>
79544>>>>>>>
79544>>>>>>>    //***
79544>>>>>>>     Function DFGetUserDefinedLength Returns Number
79546>>>>>>>        Integer iRetVal
79546>>>>>>>        Number  nRetVal
79546>>>>>>>
79546>>>>>>>        Move (WP_GetUserDefinedPapersize()) To iRetVal
79547>>>>>>>
79547>>>>>>>        If (iRetVal=0) Begin
79549>>>>>>>            Error DFERR_WINPRINT DFPrintError962
79550>>>>>>>>
79550>>>>>>>            Function_Return 0
79551>>>>>>>        End
79551>>>>>>>>
79551>>>>>>>
79551>>>>>>>        Move (Hi(iRetVal)) To nRetVal
79552>>>>>>>        move (nRetVal/100) To nRetVal //Returns CM
79553>>>>>>>
79553>>>>>>>        Function_Return nRetVal
79554>>>>>>>     End_Function
79555>>>>>>>
79555>>>>>>>
79555>>>>>>>    //***
79555>>>>>>>     Function DFGetUserDefinedWidth Returns Number
79557>>>>>>>        Integer iRetVal
79557>>>>>>>        Number  nRetVal
79557>>>>>>>
79557>>>>>>>        Move (WP_GetUserDefinedPapersize()) To iRetVal
79558>>>>>>>
79558>>>>>>>        If (iRetVal=0) Begin
79560>>>>>>>            Error DFERR_WINPRINT DFPrintError963
79561>>>>>>>>
79561>>>>>>>            Function_Return 0
79562>>>>>>>        End
79562>>>>>>>>
79562>>>>>>>
79562>>>>>>>        Move (Low(iRetVal)) To nRetVal
79563>>>>>>>        Move (nRetVal/100) To nRetVal //Returns CM
79564>>>>>>>
79564>>>>>>>        Function_Return nRetVal
79565>>>>>>>     End_Function
79566>>>>>>>
79566>>>>>>>
79566>>>>>>>    //*** To be set in CM
79566>>>>>>>     Procedure DFSetUserDefinedPapersize Number nLength Number nWidth
79568>>>>>>>        Integer bOk
79568>>>>>>>        Integer iLength iWidth iSize
79568>>>>>>>
79568>>>>>>>        move (nLength*100) To iLength
79569>>>>>>>        move (nWidth*100)  To iWidth
79570>>>>>>>        move ((iLength*65536)+iWidth) To iSize
79571>>>>>>>
79571>>>>>>>        Move (WP_SetUserDefinedPapersize(iSize)) To bOk
79572>>>>>>>
79572>>>>>>>        If not bOk Begin
79574>>>>>>>            Error DFERR_WINPRINT DFPrintError964
79575>>>>>>>>
79575>>>>>>>        End
79575>>>>>>>>
79575>>>>>>>     End_Procedure
79576>>>>>>>
79576>>>>>>>     Procedure DFSetNumberOfCopies Integer iNrOfCopies
79578>>>>>>>        Boolean bOk
79578>>>>>>>
79578>>>>>>>        Move (WP_SetNumberOfPrintCopies(iNrOfCopies)) to bOk
79579>>>>>>>
79579>>>>>>>        If not bOk Begin
79581>>>>>>>            Error DFERR_WINPRINT DFPrintError965
79582>>>>>>>>
79582>>>>>>>        end
79582>>>>>>>>
79582>>>>>>>     End_Procedure
79583>>>>>>>
79583>>>>>>>
79583>>>>>>>
79583>>>>>>>
79583>>>>>>>    //*************************************************************
79583>>>>>>>    //*** This procedures and functions are used when building  ***
79583>>>>>>>    //*** complex graphics when you need to change value of the ***
79583>>>>>>>    //*** current diagram, so you can mix diagrams within each  ***
79583>>>>>>>    //*** other.                                                ***
79583>>>>>>>    //*************************************************************
79583>>>>>>>
79583>>>>>>>
79583>>>>>>>    Function DFGetCurrentDiagram Returns Integer
79585>>>>>>>        Integer iRetVal
79585>>>>>>>        Get DFCurrent_Diagram To iRetVal
79586>>>>>>>        Function_Return iRetVal
79587>>>>>>>    End_Function
79588>>>>>>>
79588>>>>>>>    Procedure DFSetCurrentDiagram Integer iDiagram
79590>>>>>>>        Set DFCurrent_Diagram To iDiagram
79591>>>>>>>    End_Procedure
79592>>>>>>>
79592>>>>>>>    Procedure DFSetDiagramList Integer iItem Integer iDiagram
79594>>>>>>>        Set Value of oDiagramArray iItem To iDiagram
79595>>>>>>>    End_Procedure
79596>>>>>>>
79596>>>>>>>    Function DFGetDiagramList Integer iItem Returns Integer
79598>>>>>>>        Integer iRetVal
79598>>>>>>>        Get Value of oDiagramArray iItem To iRetVal
79599>>>>>>>        Function_Return iRetVal
79600>>>>>>>    End_Function
79601>>>>>>>
79601>>>>>>>    Procedure DFClearDiagramList
79603>>>>>>>        Send Delete_Data To oDiagramArray
79604>>>>>>>    End_Procedure
79605>>>>>>>
79605>>>>>>>
79605>>>>>>>    Function DFGetColor Integer iColor Returns Dword
79607>>>>>>>        Dword   dwRetVal
79607>>>>>>>        Get Value of oDFColorArray iColor To dwRetVal
79608>>>>>>>        Function_Return dwRetVal
79609>>>>>>>    End_Function
79610>>>>>>>
79610>>>>>>>    Function DFGetCurrentColor Returns Dword
79612>>>>>>>        Dword   dwRetVal
79612>>>>>>>        Integer iCurrColor
79612>>>>>>>
79612>>>>>>>        Get DFCurrent_Color To iCurrColor
79613>>>>>>>        Get DFGetColor iCurrColor To dwRetVal
79614>>>>>>>
79614>>>>>>>        Function_Return dwRetVal
79615>>>>>>>    End_Function
79616>>>>>>>
79616>>>>>>>    Procedure DFEndDocument
79618>>>>>>>        integer iVoid
79618>>>>>>>        Move (WP_EndDocument()) To iVoid
79619>>>>>>>        Send DfSuspendGui False
79620>>>>>>>    End_procedure
79621>>>>>>>
79621>>>>>>>    Procedure DFClosePreview
79623>>>>>>>        integer iVoid
79623>>>>>>>        Move (WP_ClosePreview()) To iVoid
79624>>>>>>>        Send DfSuspendGui False
79625>>>>>>>    End_procedure
79626>>>>>>>
79626>>>>>>>    Procedure SetProgressCaption string sCaption
79628>>>>>>>        integer iVoid
79628>>>>>>>        Move (ToAnsi(sCaption)) to sCaption
79629>>>>>>>        Move (WP_SetProgressCaption(sCaption)) To iVoid
79630>>>>>>>    End_procedure
79631>>>>>>>
79631>>>>>>>    Procedure SetReportTitle string sTitle
79633>>>>>>>        integer iVoid
79633>>>>>>>        Move (ToAnsi(sTitle)) to sTitle
79634>>>>>>>        Move (WP_SetReportTitle(sTitle)) To iVoid
79635>>>>>>>    End_procedure
79636>>>>>>>
79636>>>>>>>    Function PreviewYesNoBox string sCaption string sText returns integer
79638>>>>>>>        integer eResult
79638>>>>>>>        Move (ToAnsi(sCaption)) to sCaption
79639>>>>>>>        Move (ToAnsi(sText))    to sText
79640>>>>>>>        Move (WP_DisplayMessageBox(sCaption, sText)) To eResult
79641>>>>>>>        Function_return eResult
79642>>>>>>>    end_function
79643>>>>>>>
79643>>>>>>>    // internal function, used to extract different printer flags ranges based on
79643>>>>>>>    // the print flag integer. These flags use a decimal style of packing information
79643>>>>>>>    // where different printer options (paper, bin, etc) use different ranges and
79643>>>>>>>    // different steps. Everything above iTopVal is removed and everything that is not
79643>>>>>>>    // within the iStep range is removed.
79643>>>>>>>    Function PrintFlagRange integer iTopVal integer iStep returns integer
79645>>>>>>>        integer iFgs iFg
79645>>>>>>>        Get DFGetPrintDialogFlags to iFg
79646>>>>>>>        Move (mod(iFg,iTopVal) / iStep * iStep ) to iFg
79647>>>>>>>        function_return iFg
79648>>>>>>>    end_Function
79649>>>>>>>
79649>>>>>>>    Procedure DFSetPrinterPaper integer ePaperType
79651>>>>>>>        Send DFSetSpecPrintFlag ePaperType
79652>>>>>>>    End_Procedure
79653>>>>>>>
79653>>>>>>>    Function DFGetPrinterPaper returns integer //ePaperType
79655>>>>>>>        integer ePaperType
79655>>>>>>>        Get PrintFlagRange 500 10 to ePaperType // 10-490 in steps of 10
79656>>>>>>>        function_return ePaperType
79657>>>>>>>    End_Function
79658>>>>>>>
79658>>>>>>>
79658>>>>>>>    Procedure DFSetPrinterBin integer eBinType
79660>>>>>>>        Send DFSetSpecPrintFlag eBinType
79661>>>>>>>    End_Procedure
79662>>>>>>>
79662>>>>>>>    Function DFGetPrinterBin returns integer //eBinType
79664>>>>>>>        integer eBinType
79664>>>>>>>        Get PrintFlagRange 10000 500 to eBinType // 1000-9000 steps 500
79665>>>>>>>        function_return eBinType
79666>>>>>>>    End_Function
79667>>>>>>>
79667>>>>>>>
79667>>>>>>>    Procedure DFSetPrinterResolution integer eResType
79669>>>>>>>        Send DFSetSpecPrintFlag eResType
79670>>>>>>>    End_Procedure
79671>>>>>>>
79671>>>>>>>    Function DFGetPrinterResolution returns integer //eResType
79673>>>>>>>        integer eResType
79673>>>>>>>        Get PrintFlagRange 50000 10000 to eResType // 10000-500000 steps 10000
79674>>>>>>>        function_return eResType
79675>>>>>>>    End_Function
79676>>>>>>>
79676>>>>>>>
79676>>>>>>>    Procedure DFSetLandscape boolean bIsLandscape
79678>>>>>>>        Send DFSetSpecPrintFlag (If(bIsLandscape,DF_Landscape,DF_Portrait))
79679>>>>>>>    End_Procedure
79680>>>>>>>
79680>>>>>>>    Function DFGetLandscape returns boolean // bIsLandscape
79682>>>>>>>        boolean bIsLandscape
79682>>>>>>>        Get DFCheckPrintDialogFlag DF_Landscape to bIsLandscape
79683>>>>>>>        function_return bIsLandscape
79684>>>>>>>    End_Function
79685>>>>>>>
79685>>>>>>>    Function RGBToWPColor integer iRgb returns integer
79687>>>>>>>        integer iRed iGreen iBlue
79687>>>>>>>        integer iWPColor
79687>>>>>>>        Move (R_from_rgb(iRGB)) to iRed
79688>>>>>>>        Move (G_from_rgb(iRGB)) to iGreen
79689>>>>>>>        Move (B_from_rgb(iRGB)) to iBlue
79690>>>>>>>        Get DfGetDfColor iRed iGreen iBlue to iWPColor
79691>>>>>>>        function_Return iWPColor
79692>>>>>>>    end_function
79693>>>>>>>
79693>>>>>>>
79693>>>>>>>
79693>>>>>>>End_Class
79694>>>>>>>
79694>>>>>>>Global_Variable Integer ghoWinPrint2
79694>>>>>>>
79694>>>>>>>Get Create of desktop U_cWinPrint2 to ghoWinPrint2
79695>>>>>>>
79695>>>>>>>
79695>>>>>Use Winprint_Commands.pkg  // commands used by this class
79695>>>>>
79695>>>>>Class cWinReport2 is a BasicReport
79696>>>>>
79696>>>>>    Procedure Construct_Object
79698>>>>>        Forward send construct_object
79700>>>>>
79700>>>>>        Date Today
79700>>>>>        Sysdate Today
79701>>>>>
79701>>>>>        // should use built in DF function CurrentDateTime()
79701>>>>>        Property Date  RptToday    Today
79702>>>>>
79702>>>>>        Object RptTotal is an Array
79704>>>>>        End_Object
79705>>>>>
79705>>>>>        // If true, report is output upon completion. Either preview
79705>>>>>        // or printer depending on output_device_mode
79705>>>>>        Property Boolean AutoOutput_State True
79706>>>>>
79706>>>>>        // When a new page is created (DFNew_Page) and the number
79706>>>>>        // of columns is not passed, this is used.
79706>>>>>        Property Integer Print_Columns 0
79707>>>>>
79707>>>>>        // This determines if a DFNew_Page should be executed when the
79707>>>>>        // report starts. In some rare cases, you would not want this to
79707>>>>>        // occur until a subheader
79707>>>>>        Property Boolean AutoNew_Page_State True
79708>>>>>
79708>>>>>        // Output device (print or preview). Normally this is delegated to
79708>>>>>        // the report view.
79708>>>>>        //
79708>>>>>
79708>>>>>        Property Integer Private.Output_Device_Mode PRINT_TO_UNDEFINED
79709>>>>>
79709>>>>>        Property Handle phoWinPrint  ghoWinPrint2 // the report engine to use.
79710>>>>>
79710>>>>>        // JJT: For now this is for testing.
79710>>>>>        Property boolean pbModalViewer False
79711>>>>>
79711>>>>>        Property boolean pbMultiReports False
79712>>>>>
79712>>>>>        Property boolean pbFirstPagePrinted false
79713>>>>>
79713>>>>>    End_Procedure
79714>>>>>
79714>>>>>    // returns the current status of Winprint Document object. dsNotStarted, dsStarted, dsFinished
79714>>>>>    // note that the status can reflect a status from a different report. The winprint object is global.
79714>>>>>    Function DocumentStatus returns Boolean
79716>>>>>        integer iStatus
79716>>>>>        Get DocumentStatus of (phoWinprint(self)) to iStatus
79717>>>>>        function_return iStatus
79718>>>>>    End_function
79719>>>>>
79719>>>>>    Function IsViewerActive Returns Boolean
79721>>>>>        Boolean bIsActive
79721>>>>>        Get IsViewerActive of (phoWinPrint(Self)) to bIsActive
79722>>>>>        Function_Return bIsActive
79723>>>>>    End_Function
79724>>>>>
79724>>>>>    Function IsPrinterValid Returns Boolean
79726>>>>>        Function_Return (WP_IsPrinterValid()<>0)
79727>>>>>    End_Function
79728>>>>>
79728>>>>>    Function ArePrintersInstalled Returns Boolean
79730>>>>>        Function_Return (WP_ArePrintersInstalled()<>0)
79731>>>>>    End_Function
79732>>>>>
79732>>>>>
79732>>>>>    // All subtotal commands use the outer main report. This makes it easier to keep
79732>>>>>    // track of these numbers
79732>>>>>
79732>>>>>    Procedure Add_SubTotal Integer iCounter Number nData
79734>>>>>        Number nValue
79734>>>>>        Integer iObj
79734>>>>>        Move (RptTotal(Main_Report_Id(Self))) to iObj
79735>>>>>        Get Number_Value of iObj iCounter To nValue
79736>>>>>        Add nData To nValue
79737>>>>>        Set Array_Value of iObj iCounter To nValue
79738>>>>>    End_Procedure
79739>>>>>
79739>>>>>    Procedure Clr_SubTotal Integer iCounter
79741>>>>>        Set Array_Value of (RptTotal(Main_Report_Id(Self))) iCounter To 0
79742>>>>>    End_Procedure
79743>>>>>
79743>>>>>    Procedure Clr_AllSubTotals
79745>>>>>        Send Delete_Data of (RptTotal(Main_Report_Id(Self)))
79746>>>>>    End_Procedure
79747>>>>>
79747>>>>>    Function Sum_SubTotal Integer iTotal Returns Number
79749>>>>>        Number nRetVal
79749>>>>>        Get Number_Value of (RptTotal(Main_Report_Id(Self))) iTotal To nRetVal
79750>>>>>        Function_Return nRetVal
79751>>>>>    End_Function
79752>>>>>
79752>>>>>    //Return sub-total and clear accumulator
79752>>>>>    //
79752>>>>>    Function SubTotal Integer iTotal Returns Number
79754>>>>>        Number nRetVal
79754>>>>>        Get Sum_SubTotal  iTotal to nRetVal
79755>>>>>        Send Clr_SubTotal iTotal
79756>>>>>        Function_Return nRetVal
79757>>>>>    End_Function
79758>>>>>
79758>>>>>
79758>>>>>    // Note: Cols is optional. If no argument is passed it will use
79758>>>>>    //       the object's property Print_Columns (0 by default)
79758>>>>>    //
79758>>>>>    Procedure DFNew_Page Integer Cols
79760>>>>>        Integer PageNumber Columns
79760>>>>>        Boolean bFirstPagePrinted
79760>>>>>        // If no args passed used default setting
79760>>>>>        If (Num_Arguments=0) ;           Move (Print_Columns(Main_Report_id(Self))) to Columns
79763>>>>>        Else ;           Move Cols to Columns
79765>>>>>        Set Page_Feed   to -2   // No FormFeed
79766>>>>>        If (Child_Rpt_State(self)) ;            Send DFNew_Page of (Main_Report_Id(Self)) Columns
79769>>>>>        Else Begin
79770>>>>>            // we only want to print report_header once. When report starts
79770>>>>>            // this is set true, after the first print it is false. You can set
79770>>>>>            // this to true before and explicit dfNew_page to force a header
79770>>>>>            Get pbFirstPagePrinted to bFirstPagePrinted
79771>>>>>            Get  DFNewPage of (phoWinPrint(self)) Columns To PageNumber
79772>>>>>            If (PageNumber<>0) begin // if 0, it failed
79774>>>>>                Set No_PageCheck_State to True
79775>>>>>
79775>>>>>                //Top section
79775>>>>>                Send Page_Top
79776>>>>>                If Not bFirstPagePrinted Send Report_Header
79779>>>>>                Send Page_Header
79780>>>>>                Send Page_Title
79781>>>>>
79781>>>>>                Set New_Page_State to False
79782>>>>>                Set Page_End_State to False
79783>>>>>                Set No_PageCheck_State to False        // No longer Paging
79784>>>>>                Set pbFirstPagePrinted to True
79785>>>>>            End
79785>>>>>>
79785>>>>>        End
79785>>>>>>
79785>>>>>
79785>>>>>        // Footer section
79785>>>>>        //
79785>>>>>        // DO NOT CHANGE THE ORDER OF BOTTOM SECTIONS !!!!!
79785>>>>>        //
79785>>>>>
79785>>>>>        Send Page_Bottom
79786>>>>>
79786>>>>>        // in WinPrint it is not possible to replace Page_Footer
79786>>>>>        // with Report_Footer. If you use Report_Footer you will
79786>>>>>        // have both Page_Footer and Report_Footer
79786>>>>>        //
79786>>>>>        //If LastTime eq 0 Send Page_Footer
79786>>>>>        //else             Send Report_Footer
79786>>>>>
79786>>>>>        Send Page_Footer
79787>>>>>        Send Page_Total
79788>>>>>    End_Procedure
79789>>>>>
79789>>>>>    Procedure Ending_Main_Report
79791>>>>>        Boolean bCancel bMultiReports
79791>>>>>
79791>>>>>        Get Cancelled_state to bCancel
79792>>>>>        Get pbMultiReports to bMultiReports
79793>>>>>
79793>>>>>        Forward Send Ending_Main_Report
79795>>>>>
79795>>>>>        If bCancel Begin
79797>>>>>            Send DFEndDocument
79798>>>>>            Send DFClearDoc // this will also close the previewer
79799>>>>>        end
79799>>>>>>
79799>>>>>        Else Begin
79800>>>>>            Send Report_Footer
79801>>>>>
79801>>>>>            // if multi-reports, we don't do an end of report yet. The programmer must
79801>>>>>            // manually end the report by sending EndMultiReport
79801>>>>>            If (not(bMultiReports)) begin
79803>>>>>                Send EndWinPrintReport
79804>>>>>            end
79804>>>>>>
79804>>>>>
79804>>>>>        end
79804>>>>>>
79804>>>>>
79804>>>>>    End_Procedure
79805>>>>>
79805>>>>>    // This must get called when you are running multiple reports (pbMultiReport).
79805>>>>>    // Send this when the last report is complete.
79805>>>>>    Procedure EndMultiReport
79807>>>>>        Send EndWinPrintReport
79808>>>>>    End_procedure
79809>>>>>
79809>>>>>
79809>>>>>    Procedure EndWinPrintReport
79811>>>>>        Boolean bAutoOutput
79811>>>>>        integer iStatus eMode
79811>>>>>        Get DocumentStatus to iStatus
79812>>>>>        If (iStatus<>dsStarted) procedure_return
79815>>>>>
79815>>>>>        // this tells winprint that the report is complete
79815>>>>>        Send DFEndDocument
79816>>>>>        // if auto-output we print or display automatically.
79816>>>>>        // for winprint2, if in preview mode you must do this so the previewer can enter
79816>>>>>        // a modal state (which it may or may not need to do).
79816>>>>>        Get AutoOutput_state to bAutoOutput
79817>>>>>        Get Output_device_mode to eMode
79818>>>>>        If (bAutoOutput or eMode=PRINT_TO_WINDOW) begin
79820>>>>>            Send PrintReport
79821>>>>>            // if auto output, we assume that you are done when it is all over
79821>>>>>            // we only can do this with the modal viewer
79821>>>>>            If (bAutoOutput and pbModalViewer(self)) begin
79823>>>>>                Send DFClearDoc
79824>>>>>            end
79824>>>>>>
79824>>>>>        end
79824>>>>>>
79824>>>>>
79824>>>>>    End_Procedure
79825>>>>>
79825>>>>>
79825>>>>>    Function Setup_Report Returns Integer
79827>>>>>        Integer iErr iStatus eMode
79827>>>>>        Boolean bActiveViewer bChildReport bMultiReports bOk
79827>>>>>
79827>>>>>        Get Child_rpt_state to bChildReport
79828>>>>>
79828>>>>>        If not bChildReport Begin
79830>>>>>
79830>>>>>            // This makes sure that we are pointing to the new winprint2 engine object.
79830>>>>>            // normally this will be the new winprint, but it can be redirected
79830>>>>>            Get phoWinPrint to WinPrintID
79831>>>>>
79831>>>>>            // winprint must have installed printer. If not installed, generate error and stop the report
79831>>>>>            Get ArePrintersInstalled to bOk
79832>>>>>            If not bOk Begin
79834>>>>>                Error DFERR_WINPRINT C_$NoInstalledPrinters
79835>>>>>>
79835>>>>>                Function_Return 1
79836>>>>>            End
79836>>>>>>
79836>>>>>
79836>>>>>            // check if selected printer is valid. If not, generate error and stop the report
79836>>>>>            Get IsPrinterValid to bOk
79837>>>>>            If not bOk Begin
79839>>>>>                Error DFERR_WINPRINT DFPrintError936    // Could not select a valid printer
79840>>>>>>
79840>>>>>                Function_Return 1
79841>>>>>            End
79841>>>>>>
79841>>>>>
79841>>>>>            // make sure it is ok to start a new report but try to be smart about it.
79841>>>>>            // if a report is active (dsstarted or dsFinished) check to see if it is
79841>>>>>            // finished w/ no viewer. If so, assume the user closed the report and is done
79841>>>>>            // so just clear the report. If a viewer is present, declare an error.
79841>>>>>            Get DocumentStatus to iStatus
79842>>>>>            Get pbMultiReports to bMultiReports
79843>>>>>            // multi-report only in-progress is multi and it is started
79843>>>>>            Move (bMultiReports and iStatus=dsStarted) to bMultiReports
79844>>>>>            If not bMultiReports Begin
79846>>>>>                If (iStatus<>dsNotStarted) Begin
79848>>>>>                    Get IsViewerActive to bActiveViewer
79849>>>>>                    If (iStatus=dsFinished and not(bActiveViewer)) Begin
79851>>>>>                        Send DfClearDoc
79852>>>>>                    End
79852>>>>>>
79852>>>>>                    Else Begin
79853>>>>>                        Error DFERR_WINPRINT DFPrintError967
79854>>>>>>
79854>>>>>                        Function_Return 1
79855>>>>>                    End
79855>>>>>>
79855>>>>>                End
79855>>>>>>
79855>>>>>
79855>>>>>                // all new reports by default allow printing from viewer and they have the print job set up when you select print
79855>>>>>                // if you need to change these defaults, you can change these inside of Starting_main_report
79855>>>>>                // We only do this with non-multi-reports.
79855>>>>>                Send DFSetPrintDlgInPreview      True
79856>>>>>                Send DFSetEnablePrintFromPreview True
79857>>>>>
79857>>>>>            End
79857>>>>>>
79857>>>>>
79857>>>>>            // In the new winprint, this message is not needed and is a stub. For
79857>>>>>            // now it is in here for compatibility purposes
79857>>>>>            //You MUST always start a new report with this procedure
79857>>>>>            Send DFZeroCounters of (phoWinPrint(Self))
79858>>>>>            Send Clr_AllSubTotals
79859>>>>>
79859>>>>>        End
79859>>>>>>
79859>>>>>
79859>>>>>        Forward Get Setup_report to iErr
79861>>>>>
79861>>>>>        If (iErr=0) Begin
79863>>>>>            If not bChildReport Begin
79865>>>>>                // if part of a multi-report we don't do a new doc
79865>>>>>                If not bMultiReports Begin
79867>>>>>                    Get Output_Device_Mode to eMode
79868>>>>>                    Send DFNewDoc of (phoWinPrint(Self))  (eMode = PRINT_TO_WINDOW) // pass True of display while printing
79869>>>>>                End
79869>>>>>>
79869>>>>>                // Do new page if not part of a multi-report and we say don't do a new page
79869>>>>>                If (not(bMultiReports) or AutoNew_Page_State(Self)) Begin
79871>>>>>                    Set pbFirstPagePrinted to False // tells new page that this is the first time for this report
79872>>>>>                    Send DFNew_page
79873>>>>>                End
79873>>>>>>
79873>>>>>            End
79873>>>>>>
79873>>>>>        End
79873>>>>>>
79873>>>>>        Function_Return iErr
79874>>>>>    End_Function
79875>>>>>
79875>>>>>
79875>>>>>
79875>>>>>    // Cancel RO behavior - there is no device to close
79875>>>>>    //
79875>>>>>    Procedure Close_Output_Device
79877>>>>>    End_Procedure
79878>>>>>
79878>>>>>    // Cancel RO Behavior
79878>>>>>    //
79878>>>>>    Procedure Initialize_Output_Device
79880>>>>>    End_procedure
79881>>>>>
79881>>>>>
79881>>>>>    Function Output_Device_Mode Returns Integer
79883>>>>>        Integer hoId
79883>>>>>        String DevMode
79883>>>>>        Get Private.Output_Device_Mode to DevMode
79884>>>>>        If (DevMode=PRINT_TO_UNDEFINED) Begin
79886>>>>>            Get Report_View_Id to hoId
79887>>>>>            If hoID ;                Get OutPut_Device_Mode of hoID to DevMode
79890>>>>>            If (DevMode=PRINT_TO_UNDEFINED) ;                Move PRINT_TO_WINDOW to DevMode
79893>>>>>        End
79893>>>>>>
79893>>>>>        Function_Return DevMode
79894>>>>>    End_Function // Output_Destination
79895>>>>>
79895>>>>>    Procedure Set Output_Device_Mode Integer DevMode
79897>>>>>        Set Private.Output_Device_Mode to DevMode
79898>>>>>    End_Procedure // Set Output_Device
79899>>>>>
79899>>>>>    // displays a metric ruler in .5 increments. This can be
79899>>>>>    // sent to make it easy to see how fields and labels should
79899>>>>>    // be moved for alignment.
79899>>>>>    //
79899>>>>>    Procedure ShowRuler
79901>>>>>        integer i
79901>>>>>        number n
79901>>>>>        for i from 0 to 30
79907>>>>>>
79907>>>>>            Send DFWritePos of (phoWinPrint(self)) (String(i)) FONT_DEFAULT i -1 0
79908>>>>>            Move (i+.5) to n
79909>>>>>            Send DFWritePos of (phoWinPrint(self)) "." FONT_DEFAULT n -1 0
79910>>>>>        Loop
79911>>>>>>
79911>>>>>        Send DFWriteln of (phoWinPrint(self)) ''  FONT_DEFAULT FONT_DEFAULT -1
79912>>>>>    End_procedure
79913>>>>>
79913>>>>>      // status panel related agumentations to handle the auto-previewer
79913>>>>>
79913>>>>>      Procedure Update_Status string sVal
79915>>>>>         Integer eMode
79915>>>>>         Get Output_device_mode to eMode
79916>>>>>         If (eMode=PRINT_TO_WINDOW) Begin
79918>>>>>            Send SetProgressCaption  of (phoWinPrint(self)) sVal
79919>>>>>         End
79919>>>>>>
79919>>>>>         Else Begin
79920>>>>>            forward Send Update_Status sVal
79922>>>>>         end
79922>>>>>>
79922>>>>>      End_Procedure
79923>>>>>
79923>>>>>      Procedure Start_Status
79925>>>>>         Integer eMode
79925>>>>>         string sTitle sCaption
79925>>>>>         Get Output_device_mode to eMode
79926>>>>>         If (eMode=PRINT_TO_WINDOW) Begin
79928>>>>>            Get Report_Caption to sCaption
79929>>>>>            Get Report_Title to sTitle
79930>>>>>            If (sTitle<>"" and sCaption<>"") begin
79932>>>>>                Move ( sCaption- ":" * sTitle) to sTitle
79933>>>>>            end
79933>>>>>>
79933>>>>>            else begin
79934>>>>>                Move (sCaption - sTitle) to sTitle
79935>>>>>            end
79935>>>>>>
79935>>>>>            Send SetReportTitle of (phoWinPrint(self)) sTitle
79936>>>>>         End
79936>>>>>>
79936>>>>>         Else Begin
79937>>>>>            forward Send Start_status
79939>>>>>         end
79939>>>>>>
79939>>>>>      End_Procedure
79940>>>>>
79940>>>>>      Procedure Resume_Status
79942>>>>>         Integer eMode
79942>>>>>         Get Output_device_mode to eMode
79943>>>>>         If (eMode=PRINT_TO_WINDOW) Begin
79945>>>>>            Send DfPreviewNoWait of (phoWinPrint(self))
79946>>>>>         End
79946>>>>>>
79946>>>>>         Else Begin
79947>>>>>            forward Send Resume_Status
79949>>>>>         end
79949>>>>>>
79949>>>>>      End_Procedure
79950>>>>>
79950>>>>>      Procedure End_Status
79952>>>>>         Integer eMode
79952>>>>>         Get Output_device_mode to eMode
79953>>>>>         If (error_processing_state(self)) Begin
79955>>>>>            Send DFClosePreview
79956>>>>>         end
79956>>>>>>
79956>>>>>         If (eMode=PRINT_TO_WINDOW) Begin
79958>>>>>         End
79958>>>>>>
79958>>>>>         Else Begin
79959>>>>>            forward Send End_Status
79961>>>>>         end
79961>>>>>>
79961>>>>>      End_Procedure
79962>>>>>
79962>>>>>    Function Report_Interrupt Returns Integer
79964>>>>>         integer eStat
79964>>>>>         String sMess
79964>>>>>         Boolean bActiveViewer
79964>>>>>         Get IsViewerActive to bActiveViewer
79965>>>>>         If (Error_Check_State(self)) begin
79967>>>>>            Move C_$AnErrorWishToCancel to sMess
79968>>>>>         end
79968>>>>>>
79968>>>>>         Else begin
79969>>>>>            Move  C_$CancelThisReport to sMess
79970>>>>>         end
79970>>>>>>
79970>>>>>         If bActiveViewer Begin
79972>>>>>            Get PreviewYesNoBox of (phoWinPrint(self)) C_$ReportInterrupt sMess to eStat
79973>>>>>         end
79973>>>>>>
79973>>>>>         Else Begin
79974>>>>>            Get YesNo_Box sMess C_$ReportInterrupt to eStat
79975>>>>>         End
79975>>>>>>
79975>>>>>
79975>>>>>         Function_Return (eStat=MBR_YES)
79976>>>>>
79976>>>>>  End_Function
79977>>>>>
79977>>>>>  Function Test_KeyPressed Returns Integer
79979>>>>>     Boolean bStop bError bActiveViewer
79979>>>>>     integer eMode
79979>>>>>     // winreport will do this also, but this makes sure that this gets called
79979>>>>>     // for each body loop -- even if the body loop prints nothing
79979>>>>>     Send PumpMsgQueue of (phoWinPrint(self)) // permit painting
79980>>>>>     Get IsViewerActive to bActiveViewer
79981>>>>>     Get Output_device_mode to eMode
79982>>>>>     If bActiveViewer Begin
79984>>>>>        Get ViewerWantsToClose of (phoWinPrint(self)) to bStop
79985>>>>>        Get Error_Check_State to bError
79986>>>>>        if (bStop or bError) begin
79988>>>>>            Get Report_Interrupt to bStop
79989>>>>>        end
79989>>>>>>
79989>>>>>     end
79989>>>>>>
79989>>>>>     Else Begin
79990>>>>>        Forward Get Test_KeyPressed to bStop
79992>>>>>        If (eMode=PRINT_TO_WINDOW and not(bStop)) Begin
79994>>>>>            Send DfPreviewNoWait
79995>>>>>        end
79995>>>>>>
79995>>>>>     End
79995>>>>>>
79995>>>>>
79995>>>>>     Function_Return bStop
79996>>>>>  End_Function
79997>>>>>
79997>>>>>    Procedure OnClosingView
79999>>>>>        Send DFClearDoc
80000>>>>>    end_procedure
80001>>>>>
80001>>>>>
80001>>>>>    // Attempt to make this as intuitive as possible. You cannot invoke this when a
80001>>>>>    // report is active. If a report is not finished, you cannot do this.
80001>>>>>    // If a report is finsihed it may or may not have a viewer present.
80001>>>>>    // If a viewer is not present, we will clear the exising report (making the assumption
80001>>>>>    // that a modeless viewer was closed and the report will not be invoked again). If a viewer
80001>>>>>    // is active, we will pass this through to the winprint object which will show an error
80001>>>>>
80001>>>>>    Function DFPrintSetupDialog Returns Boolean// invoke printer setup dialog
80003>>>>>        Integer iStatus
80003>>>>>        Boolean bActiveViewer bOk
80003>>>>>        // we must have printers installed for this to work
80003>>>>>        Get ArePrintersInstalled to bOk
80004>>>>>        If not bOk Begin
80006>>>>>            Error DFERR_WINPRINT C_$NoInstalledPrinters
80007>>>>>>
80007>>>>>        End
80007>>>>>>
80007>>>>>        Else Begin
80008>>>>>            Get DocumentStatus to iStatus
80009>>>>>            If (iStatus=dsFinished) Begin
80011>>>>>                Get IsViewerActive to bActiveViewer
80012>>>>>                If not bActiveViewer Begin
80014>>>>>                    Send DfClearDoc
80015>>>>>                End
80015>>>>>>
80015>>>>>            End
80015>>>>>>
80015>>>>>            // the winprint object will generate an error if the status is not dsNotStarted.
80015>>>>>            // we want those errors
80015>>>>>            Get DFPrintSetupDialog of (phoWinPrint(Self)) to bOk
80016>>>>>        End
80016>>>>>>
80016>>>>>        Function_Return bOk
80017>>>>>    End_Procedure
80018>>>>>
80018>>>>>    // It is better to use DFPrintSetupDialog which tells you if the dialog was canceled
80018>>>>>    Procedure DFPrintSetup // invoke printer setup dialog
80020>>>>>        Boolean bOk
80020>>>>>        Get DFPrintSetupDialog to bOk
80021>>>>>    End_Procedure
80022>>>>>
80022>>>>>    Procedure DFClearDoc // clear document, remove viewer
80024>>>>>        Send DFClearDoc of (phoWinPrint(self))
80025>>>>>    end_procedure
80026>>>>>
80026>>>>>    Procedure DFEndDocument // tell winprint that the report is complete
80028>>>>>        Send DfEndDocument of (phoWinPrint(self))
80029>>>>>    end_procedure
80030>>>>>
80030>>>>>    Procedure DFClosePreview //close the previewer, does not clear the document
80032>>>>>        Send DfClosePreview of (phoWinPrint(self))
80033>>>>>    end_procedure
80034>>>>>
80034>>>>>    Procedure DFPrintDialog // popup print job dialog
80036>>>>>        Send DFPrintDialog of (phoWinPrint(self))
80037>>>>>    End_procedure
80038>>>>>
80038>>>>>    Procedure DFPrint // print with printer dialog
80040>>>>>        Send DFPrint of (phoWinPrint(self))
80041>>>>>    End_procedure
80042>>>>>
80042>>>>>    Procedure DFPrintDoc // print without printer dialog
80044>>>>>        Send DFPrintDoc of (phoWinPrint(self))
80045>>>>>    End_Procedure
80046>>>>>
80046>>>>>    Procedure DFPreviewWait // invoke previewer in modal mode
80048>>>>>       Send DFPreviewWait of (phoWinPrint(self))
80049>>>>>    End_Procedure
80050>>>>>
80050>>>>>    Procedure DFPreviewNoWait // invoke previwer in modeless mode
80052>>>>>       Send DFPreviewNoWait of (phoWinPrint(self))
80053>>>>>    End_Procedure
80054>>>>>
80054>>>>>    Procedure DFPreview // invokde previewer based on pbModalViewer property
80056>>>>>       Boolean bModalViewer
80056>>>>>       Get pbModalViewer to bModalViewer
80057>>>>>       If bModalViewer Begin
80059>>>>>           Send DFPreviewWait
80060>>>>>       end
80060>>>>>>
80060>>>>>       else Begin
80061>>>>>           Send DFPreviewNoWait
80062>>>>>       end
80062>>>>>>
80062>>>>>   End_Procedure
80063>>>>>
80063>>>>>    // Print report to appropriate device (printer, preview) based
80063>>>>>    // on output_device_mode
80063>>>>>    //
80063>>>>>    Procedure PrintReport
80065>>>>>        Integer eMode
80065>>>>>        Get OutPut_Device_Mode to eMode
80066>>>>>        If ((eMode=PRINT_TO_WINDOW) or (eMode=DEFERRED_PRINT_TO_WINDOW)) Begin
80068>>>>>           Send DFPreview
80069>>>>>        end
80069>>>>>>
80069>>>>>        Else If (eMode=PRINT_TO_PRINTER_NO_DIALOG) Begin
80072>>>>>           Send DFPrintDoc // print, no print job dialog
80073>>>>>        end
80073>>>>>>
80073>>>>>        Else Begin // (eMode=PRINT_TO_PRINTER)
80074>>>>>           Send DFPrint // print with print job dialog
80075>>>>>        end
80075>>>>>>
80075>>>>>    End_Procedure
80076>>>>>
80076>>>>>
80076>>>>>    Procedure DFSetPrinterPaper integer ePaperType
80078>>>>>        Send DFSetPrinterPaper of (phoWinPrint(self)) ePaperType
80079>>>>>    End_Procedure
80080>>>>>
80080>>>>>    Function DFGetPrinterPaper returns integer //ePaperType
80082>>>>>        integer ePaperType
80082>>>>>        Get DFGetPrinterPaper of (phoWinPrint(self)) to ePaperType
80083>>>>>        Function_return ePaperType
80084>>>>>    end_function
80085>>>>>
80085>>>>>
80085>>>>>    Procedure DFSetPrinterBin integer eBinType
80087>>>>>        Send DFSetPrinterBin of (phoWinPrint(self)) eBinType
80088>>>>>    End_Procedure
80089>>>>>
80089>>>>>    Function DFGetPrinterBin returns integer //eBinType
80091>>>>>        integer eBinType
80091>>>>>        Get DFGetPrinterBin of (phoWinPrint(self)) to eBinType
80092>>>>>        Function_return eBinType
80093>>>>>    end_function
80094>>>>>
80094>>>>>
80094>>>>>    Procedure DFSetPrinterResolution integer eResType
80096>>>>>        Send DFSetPrinterResolution of (phoWinPrint(self)) eResType
80097>>>>>    End_Procedure
80098>>>>>
80098>>>>>    Function DFGetPrinterResolution returns integer //eResType
80100>>>>>        Boolean eResType
80100>>>>>        Get DFGetPrinterResolution of (phoWinPrint(self)) to eResType
80101>>>>>        Function_return eResType
80102>>>>>    end_function
80103>>>>>
80103>>>>>
80103>>>>>    Procedure DFSetLandscape boolean bIsLandscape
80105>>>>>        Send DFSetLandscape of (phoWinPrint(self)) bIsLandscape
80106>>>>>    End_Procedure
80107>>>>>
80107>>>>>    Function DFGetLandscape returns boolean // bIsLandscape
80109>>>>>        Boolean bIsLandscape
80109>>>>>        Get DFGetLandscape of (phoWinPrint(self)) to bIsLandscape
80110>>>>>        Function_return bIsLandscape
80111>>>>>    end_function
80112>>>>>
80112>>>>>    Procedure DFSetMetrics integer eType
80114>>>>>        Send DFSetMetrics of (phoWinPrint(self)) eType
80115>>>>>    End_Procedure
80116>>>>>
80116>>>>>    Function DFGetMetrics returns integer
80118>>>>>        integer eType
80118>>>>>        Get DFGetMetrics of (phoWinPrint(self)) to eType
80119>>>>>        Function_return eType
80120>>>>>    end_function
80121>>>>>
80121>>>>>
80121>>>>>    Procedure DFSetPrintDlgInPreview boolean bShowDialog
80123>>>>>        Set PrintDlgInPreview of (phoWinPrint(self)) to bShowDialog
80124>>>>>    End_Procedure
80125>>>>>
80125>>>>>    Function DFGetPrintDlgInPreview returns boolean
80127>>>>>        boolean bShowDialog
80127>>>>>        Get PrintDlgInPreview of (phoWinPrint(self)) to bShowDialog
80128>>>>>        Function_return bShowDialog
80129>>>>>    end_function
80130>>>>>
80130>>>>>
80130>>>>>    Procedure DFSetEnablePrintFromPreview boolean bEnablePrint
80132>>>>>        Set EnablePrintFromPreview of (phoWinPrint(self)) to bEnablePrint
80133>>>>>    End_Procedure
80134>>>>>
80134>>>>>    Function DFGetEnablePrintFromPreview returns boolean
80136>>>>>        boolean bEnablePrint
80136>>>>>        Get EnablePrintFromPreview of (phoWinPrint(self)) to bEnablePrint
80137>>>>>        Function_return bEnablePrint
80138>>>>>    end_function
80139>>>>>
80139>>>>>
80139>>>>>
80139>>>>>    Procedure DFSetMargins number nLeft number nTop number nRight number nBottom
80141>>>>>        Send DFSetMargins of (phoWinPrint(self)) nLeft nTop nRight nBottom
80142>>>>>    End_Procedure
80143>>>>>
80143>>>>>    Procedure DFSetTopBottom number nTop number nBottom Boolean bAllPages
80145>>>>>        Send DFSetTopBottom of (phoWinPrint(self)) nTop nBottom bAllPages
80146>>>>>    End_Procedure
80147>>>>>
80147>>>>>
80147>>>>>    Procedure DFSetDevice string sPrinterName
80149>>>>>        Send DFSetDevice of (phoWinPrint(self)) sPrinterName
80150>>>>>    End_Procedure
80151>>>>>
80151>>>>>    Function DFGetCurrentDevice returns string // sPrinterName
80153>>>>>        String sPrinterName
80153>>>>>        Get DFGetCurrentDevice of (phoWinPrint(self)) to sPrinterName
80154>>>>>        Function_return sPrinterName
80155>>>>>    end_function
80156>>>>>
80156>>>>>
80156>>>>>    Procedure DFSetUserDefinedPapersize number nLength number nWidth
80158>>>>>        Send DFSetUserDefinedPapersize of (phoWinPrint(self)) nLength nWidth
80159>>>>>    End_Procedure
80160>>>>>
80160>>>>>    Function DFGetUserDefinedLength returns number
80162>>>>>        number nSize
80162>>>>>        Get DFGetUserDefinedLength of (phoWinPrint(self)) to nSize
80163>>>>>        Function_return nSize
80164>>>>>    end_function
80165>>>>>
80165>>>>>    Function DFGetUserDefinedWidth returns number
80167>>>>>        number nSize
80167>>>>>        Get DFGetUserDefinedWidth of (phoWinPrint(self)) to nSize
80168>>>>>        Function_return nSize
80169>>>>>    end_function
80170>>>>>
80170>>>>>
80170>>>>>    Procedure DFSetNumberOfCopies integer iCopies
80172>>>>>        Send DFSetNumberOfCopies of (phoWinPrint(self)) iCopies
80173>>>>>    End_Procedure
80174>>>>>
80174>>>>>    Procedure DFPrinterBinFirstPage integer eBinType
80176>>>>>        Send DFPrinterBinFirstPage of (phoWinPrint(self)) eBinType
80177>>>>>    End_Procedure
80178>>>>>
80178>>>>>    Procedure DFClearPrinter
80180>>>>>        Send DFClearPrinter of (phoWinPrint(self))
80181>>>>>    End_Procedure
80182>>>>>
80182>>>>>    Function DFGetDFColor integer iRed integer iGreen integer iBlue returns integer
80184>>>>>        integer iWPColor
80184>>>>>        Get DFGetDFColor of (phoWinPrint(self)) iRed iGreen iBlue to iWPColor
80185>>>>>        Function_return iWPColor
80186>>>>>    end_function
80187>>>>>
80187>>>>>    Function RGBToWPColor integer iRgb returns integer
80189>>>>>        integer iWPColor
80189>>>>>        Get RGBToWPColor of (phoWinPrint(self)) iRGB to iWPColor
80190>>>>>        Function_return iWPColor
80191>>>>>    end_function
80192>>>>>
80192>>>>>
80192>>>>>End_Class
80193>>>Use CUSTOMER.DD
80193>>>
80193>>>ACTIVATE_VIEW Activate_oCustomerListWP FOR oCustomerListWP
80203>>>>
80203>>>
80203>>>Object oCustomerListWP is a ReportView
80205>>>
80205>>>    Property Boolean pbComments False
80207>>>    
80207>>>    Set Label to "Customer List"
80208>>>    Set Location to 6 6
80209>>>    Set Size to 95 180
80210>>>
80210>>>    Object Customer_DD is a Customer_DataDictionary
80212>>>    End_Object    // Customer_DD
80213>>>
80213>>>    Set Main_DD to Customer_DD
80214>>>    Set Server to Customer_DD
80215>>>
80215>>>    Object oPrintTo is a RadioGroup
80217>>>        Set Size to 50 80
80218>>>        Set Location to 5 5
80219>>>        Set Label to "Send Report to"
80220>>>        Object oScreenRadio is a Radio
80222>>>            Set Label to "Report Viewer"
80223>>>            Set Size to 10 61
80224>>>            Set Location to 15 10
80225>>>            Set Status_Help to "Preview the report to screen"
80226>>>        End_Object    // oScreenRadio
80227>>>
80227>>>        Object oPrinterRadio is a Radio
80229>>>            Set Label to "Printer"
80230>>>            Set Size to 10 37
80231>>>            Set Location to 30 10
80232>>>            Set Status_Help to "Send the report to the default printer"
80233>>>        End_Object    // oPrinterRadio
80234>>>
80234>>>        Function IsToPrinter Returns boolean
80237>>>            integer iRadio
80237>>>            Get Current_radio to iRadio
80238>>>            Function_return (iRadio=1)
80239>>>        End_Function // IsToPrinter
80240>>>
80240>>>    End_Object    // oPrintTo
80241>>>
80241>>>    Object oOrder is a RadioGroup
80243>>>        Set Size to 50 80
80244>>>        Set Location to 5 95
80245>>>        Set Label to "Report Order"
80246>>>        Object oNumberRadio is a Radio
80248>>>            Set Label to "Number"
80249>>>            Set Size to 10 41
80250>>>            Set Location to 15 10
80251>>>            Set Status_Help to "Sort by customer number"
80252>>>        End_Object    // oNumberRadio
80253>>>
80253>>>        Object oNameRadio is a Radio
80255>>>            Set Label to "Name"
80256>>>            Set Size to 10 35
80257>>>            Set Location to 30 10
80258>>>            Set Status_Help to "Sort by customer name"
80259>>>        End_Object    // oNameRadio
80260>>>
80260>>>        Function IsSortedByNumber Returns boolean
80263>>>            integer iRadio
80263>>>            Get Current_radio to iRadio
80264>>>            Function_return (iRadio=1)
80265>>>        End_Function // IsSortedByNumber
80266>>>
80266>>>    End_Object    // oOrder
80267>>>
80267>>>    Object oCommentsCkBx is a CheckBox
80269>>>        Set Label to "Print Comments"
80270>>>        Set Size to 10 65
80271>>>        Set Location to 59 95
80272>>>
80272>>>    End_Object    // oCommentsCkBx
80273>>>
80273>>>    Object oBtnPrint is a Button
80275>>>        Set Label to "Print"
80276>>>        Set Location to 76 7
80277>>>
80277>>>        Procedure OnClick
80280>>>            Send StartReport
80281>>>        End_Procedure
80282>>>
80282>>>    End_Object    // oBtnPrint
80283>>>
80283>>>    Object oBtnCancel is a Button
80285>>>        Set Label to "Cancel"
80286>>>        Set Location to 76 65
80287>>>
80287>>>        Procedure OnClick
80290>>>            Send Close_Panel
80291>>>        End_Procedure
80292>>>
80292>>>    End_Object    // oBtnCancel
80293>>>
80293>>>    Object oBtnPrinterSetup is a Button
80295>>>        Set Label to "Printer Setup"
80296>>>        Set Location to 76 123
80297>>>
80297>>>        Procedure OnClick
80300>>>            Boolean bSetupOk
80300>>>            Get DFPrintSetupDialog of oReport to bSetupOk
80301>>>        End_Procedure
80302>>>
80302>>>    End_Object    // oBtnPrinterSetup
80303>>>
80303>>>    Object oReport is a cWinReport2
80305>>>        Set Report_Title to "Customer List"
80306>>>
80306>>>        // Set DDO, Index and breaks for the report
80306>>>        Set Server to Customer_DD
80307>>>        Set Ordering to 1
80308>>>
80308>>>        // Report_Breaks file.field // no breaks in this report
80308>>>        
80308>>>        Property Boolean pbLandscape false
80310>>>        
80310>>>        Function Starting_Main_Report Returns Integer
80313>>>            Integer iIndex
80313>>>            Boolean bOn bErr
80313>>>        
80313>>>            Send DFSetMetrics wpm_cm
80314>>>            Send DFSetmargins 1 1 1 1
80315>>>        
80315>>>            Get pbComments to bOn
80316>>>            Send DFSetLandscape (if(bOn,True,false))  // This can be used to force a page orientation
80317>>>            Get DFGetLandscape to bOn
80318>>>            Set pbLandscape to bOn
80319>>>        
80319>>>            Forward Get Starting_Main_Report To bErr
80321>>>        
80321>>>            Function_return bErr
80322>>>        End_Function
80323>>>        
80323>>>        // Page_Top is printed first at the top margin of each page
80323>>>        Procedure Page_Top
80326>>>            string sFont
80326>>>            integer iFontSize iStyle
80326>>>        
80326>>>            Move "arial" to sFont
80327>>>            Move 8 to iFontSize
80328>>>            Move (Font_Default) to iStyle
80329>>>        
80329>>>            DFFont sFont
80330>>>            DFFontSize iFontSize
80331>>>            DFBeginHeader DFPageTop
80332>>>                DFHeaderFrame Hdr_NoFrame
80333>>>                DFHeaderPos   Hdr_Left
80334>>>                DFWriteLn ("Page:" * "#pagecount#") iStyle
80335>>>            DFEndHeader
80337>>>        
80337>>>        End_Procedure
80338>>>        
80338>>>        Procedure Page_Header
80341>>>            integer iFill iBorder iStyle
80341>>>            string  sFont sReportTitle
80341>>>            integer iFontSize
80341>>>        
80341>>>            Move "arial" to sFont
80342>>>            Move 16 to iFontSize
80343>>>            Move (Font_bold + rgb_White) to iStyle
80344>>>            Move (rgb_dGrey) to iFill
80345>>>            Move (rgb_dGrey) to iBorder
80346>>>            Get Report_Title to sReportTitle
80347>>>        
80347>>>            DFFont sFont
80348>>>            DFFontSize iFontSize
80349>>>            DFBeginHeader DFPageHeader
80350>>>                DFHeaderPos   Hdr_Left
80351>>>                DFHeaderFrame Hdr_Margins 0.01 iBorder iFill
80352>>>                DFWritelnPos sReportTitle 0.1 iStyle
80353>>>                DFHeaderMargin HM_BottomOuter 0.08
80354>>>            DFEndHeader
80356>>>        
80356>>>        End_Procedure // Page_Header
80357>>>        
80357>>>        Procedure Page_Title
80360>>>            string  sFont
80360>>>            integer iFontSize iHeaderStyle iFill iBorder
80360>>>            Boolean bOn
80360>>>        
80360>>>            Get pbLandscape to bOn
80361>>>        
80361>>>            Move "arial" to sFont
80362>>>            Move 8 to iFontSize
80363>>>            Move (Font_Bold + rgb_dBlue) to iHeaderStyle
80364>>>            Move (rgb_Grey) to iFill
80365>>>            Move (rgb_Grey) to iBorder
80366>>>        
80366>>>            DFFont sFont
80367>>>            DFFontSize iFontSize
80368>>>            DFBeginHeader DFPageTitle
80369>>>                DFHeaderPos   Hdr_Left
80370>>>                DFHeaderFrame Hdr_Margins 0 iBorder iFill
80371>>>                DfHeaderMargin HM_TopInner    0.01
80372>>>                DfHeaderMargin HM_BottomInner 0.01
80373>>>                DFHeaderMargin HM_BottomOuter 0.16
80374>>>        
80374>>>                DfWritePos "Number"                        0.1 (iHeaderStyle)
80375>>>                DfWritePos "Customer Name"                   2 (iHeaderStyle)
80376>>>                DfWritePos "Address"                         7 (iHeaderStyle)
80377>>>                DfWritePos "City"                           12 (iHeaderStyle)
80378>>>                DfWritePos "St."                            15 (iHeaderStyle)
80379>>>                DfWritePos "Zip"                            17 (iHeaderStyle)
80380>>>        
80380>>>                If bOn begin
80382>>>                   DfWritePos "Comments"                    19 (iHeaderStyle)
80383>>>                end
80383>>>>
80383>>>                DfWriteln
80384>>>            DFEndHeader
80386>>>        
80386>>>        End_Procedure // Page_Title
80387>>>        
80387>>>        Procedure Body
80390>>>            string  sFont
80390>>>            integer iFontSize iStyle
80390>>>            Boolean bOn
80390>>>        
80390>>>            Send Update_Status (String(Customer.Customer_number))
80391>>>        
80391>>>            Get pbLandscape to bOn
80392>>>        
80392>>>            Move "arial" to sFont
80393>>>            Move 8 to iFontSize
80394>>>            Move (font_default) to iStyle
80395>>>        
80395>>>            DFFont sFont
80396>>>            DFFontSize iFontSize
80397>>>            DFLineCheck 5
80398>>>        
80398>>>            DfWritePos Customer.Customer_Number       0.8 (iStyle + Font_Right) 0
80399>>>            DfWritePos Customer.Name                    2 iStyle -1 4.98
80400>>>            DfWritePos Customer.Address                 7 iStyle -1 4.98
80401>>>            DfWritePos Customer.City                   12 iStyle -1 3.98
80402>>>            DfWritePos Customer.State                  15 iStyle -1 0.98
80403>>>            DfWritePos Customer.Zip                    17 iStyle -1 1.98
80404>>>        
80404>>>            If bOn begin
80406>>>                DfWritePos Customer.Comments           19 iStyle -1 0
80407>>>                dfWriteln
80408>>>            end
80408>>>>
80408>>>            dfWriteln
80409>>>        End_Procedure  // Body
80410>>>        
80410>>>        // Page_Bottom is printed last at the bottom margin of each page
80410>>>        Procedure Page_Bottom
80413>>>            string sFont
80413>>>            integer iFontSize iBorder iStyle iFill
80413>>>            DateTime dtDT
80413>>>        
80413>>>            Move (CurrentDateTime()) to dtDT
80414>>>        
80414>>>            Move "arial" to sFont
80415>>>            Move 8 to iFontSize
80416>>>            Move (font_default) to iStyle
80417>>>            Move (rgb_dGrey) to iBorder
80418>>>            Move (rgb_White) to iFill
80419>>>        
80419>>>            DFFont sFont
80420>>>            DFFontSize iFontSize
80421>>>            DFBeginHeader DFPageBottom
80422>>>                DFHeaderFrame Hdr_Margins 0 iBorder iFill
80423>>>                DFHeaderPos Hdr_Center  // Write data in center
80424>>>                DFWriteln ("Report Printed on" * string(dtDT)) (iStyle)
80425>>>            DFEndHeader
80427>>>        
80427>>>        End_Procedure // Page_Bottom
80428>>>        
80428>>>    End_Object    // oReport
80429>>>
80429>>>    Procedure StartReport
80432>>>        Boolean bToPrinter bComments bSortByNumber
80432>>>    
80432>>>        // determine if direct print
80432>>>        Get IsToPrinter of oPrintTo to bToPrinter
80433>>>        Set OutPut_Device_Mode of oReport to (If(bToPrinter, PRINT_TO_PRINTER, PRINT_TO_WINDOW))
80434>>>    
80434>>>        // determine if sort order is by number or name
80434>>>        Get IsSortedByNumber of oOrder to bSortByNumber
80435>>>        Set Ordering of oReport to (if(bSortByNumber, 2, 1))
80436>>>    
80436>>>        Get Checked_State of oCommentsCkBx to bComments
80437>>>        Set pbComments to bComments
80438>>>    
80438>>>        // run the report
80438>>>        Send Run_Report of oReport
80439>>>    
80439>>>    End_Procedure // StartReport
80440>>>
80440>>>End_Object    // oCustomerListWP
80441>        Use WinPrint\ItemsPerOrderWP.rv
Including file: WinPrint\ItemsPerOrderWP.rv    (C:\Test\Order Entry git\AppSrc\WinPrint\ItemsPerOrderWP.rv)
80441>>>Use dfrptvw.pkg
80441>>>Use DataDict.pkg
80441>>>Use dfRadio.pkg
80441>>>Use Windows.pkg
80441>>>Use cWinReport2.pkg
80441>>>Use VENDOR.DD
80441>>>Use INVT.DD
80441>>>Use CUSTOMER.DD
80441>>>Use SALESP.DD
80441>>>Use ORDERHEA.DD
80441>>>Use ORDERDTL.DD
80441>>>
80441>>>ACTIVATE_VIEW Activate_oItemsPerOrderWP FOR oItemsPerOrderWP
80451>>>>
80451>>>
80451>>>Object oItemsPerOrderWP is a ReportView
80453>>>    Set Label to "Items per Order"
80454>>>    Set Location to 6 6
80455>>>    Set Size to 84 140
80456>>>
80456>>>    Object Vendor_DD is a Vendor_DataDictionary
80458>>>    End_Object    // Vendor_DD
80459>>>
80459>>>    Object Invt_DD is a Invt_DataDictionary
80461>>>        Set DDO_Server to Vendor_DD
80462>>>    End_Object    // Invt_DD
80463>>>
80463>>>    Object Customer_DD is a Customer_DataDictionary
80465>>>    End_Object    // Customer_DD
80466>>>
80466>>>    Object SalesP_DD is a Salesp_DataDictionary
80468>>>    End_Object    // SalesP_DD
80469>>>
80469>>>    Object Orderhea_DD is a Orderhea_DataDictionary
80471>>>        Set DDO_Server to Customer_DD
80472>>>        Set DDO_Server to SalesP_DD
80473>>>    End_Object    // Orderhea_DD
80474>>>
80474>>>    Object Orderdtl_DD is a Orderdtl_DataDictionary
80476>>>        Set DDO_Server to Orderhea_DD
80477>>>        Set DDO_Server to Invt_DD
80478>>>    End_Object    // Orderdtl_DD
80479>>>
80479>>>    Object oPrintTo is a RadioGroup
80481>>>        Set Size to 38 131
80482>>>        Set Location to 5 5
80483>>>        Set Label to "Print to"
80484>>>        Object oRadio1 is a Radio
80486>>>            Set Label to "Preview"
80487>>>            Set Size to 10 42
80488>>>            Set Location to 12 6
80489>>>            Set Status_Help to "Prints the report to screen"
80490>>>        End_Object    // oRadio1
80491>>>
80491>>>        Object oRadio2 is a Radio
80493>>>            Set Label to "Printer"
80494>>>            Set Size to 10 42
80495>>>            Set Location to 24 6
80496>>>            Set Status_Help to "Prints the report to printer"
80497>>>        End_Object    // oRadio2
80498>>>
80498>>>    End_Object    // oPrintTo
80499>>>
80499>>>    Object oBtnPrint is a Button
80501>>>        Set Label to "Print"
80502>>>        Set Location to 48 85
80503>>>        Set Status_Help to "Print the Selected report"
80504>>>        Set Default_State to True
80505>>>
80505>>>        Procedure OnClick
80508>>>            Send StartReport
80509>>>        End_Procedure
80510>>>
80510>>>    End_Object    // oBtnPrint
80511>>>
80511>>>    Object oBtnCancel is a Button
80513>>>        Set Label to "Cancel"
80514>>>        Set Location to 66 85
80515>>>        Set Status_Help to "Close this Panel"
80516>>>
80516>>>        Procedure OnClick
80519>>>            Send Close_Panel
80520>>>        End_Procedure
80521>>>
80521>>>    End_Object    // oBtnCancel
80522>>>
80522>>>    Object oOrders is a cWinReport2
80524>>>        Set Report_Title to "Customer Report"
80525>>>
80525>>>        //Main File for the report
80525>>>        Set Server to Orderdtl_DD
80526>>>
80526>>>        //Breaks and Index for the report
80526>>>        Report_Breaks ORDERHEA.ORDER_NUMBER
80540>>>        Set Ordering to 1
80541>>>
80541>>>        Function Starting_Main_Report Returns Integer
80544>>>            Integer iRetVal
80544>>>            Send DFSetMetrics WPM_CM
80545>>>            Send DFSetmargins 1 1 1 1
80546>>>            Forward Get Starting_Main_Report To iRetVal
80548>>>            If iRetVal Function_return iRetVal
80551>>>        End_Function
80552>>>
80552>>>        Procedure Page_Top
80555>>>            DFFont "Arial" //  Use Arial
80556>>>            DFFontSize 8
80557>>>            DFBeginHeader DFPageTop
80558>>>                DFHeaderPos   HDR_RIGHT
80559>>>                DFHeaderFrame HDR_NOFRAME
80560>>>                DFWriteLn ("Page:" * "#pagecount#")
80561>>>            DFEndHeader
80563>>>        End_Procedure
80564>>>
80564>>>        Procedure Page_Header
80567>>>            DFFont "Arial"
80568>>>            DFFontSize 14
80569>>>            DFBeginHeader DFPageHeader
80570>>>                DFHeaderFrame HDR_MARGINs 0 RGB_DGREY RGB_DGREY
80571>>>                DFHEADERPOS HDR_LEFT
80572>>>                DFHeaderMargin HM_BottomOuter 0.08
80573>>>                DFWritelnPos "Orders by Order Number Report" 0.10 (FONT_BOLD+RGB_WHITE)
80574>>>            DFEndHeader
80576>>>        End_Procedure
80577>>>
80577>>>        Procedure Page_Title
80580>>>            DFFont "Arial"
80581>>>            DFFontSize 8
80582>>>            DFBeginHeader DFPageTitle
80583>>>                DFHeaderFrame HDR_MARGINs 0 RGB_GREY RGB_GREY
80584>>>                DFHEADERPOS HDR_LEFT
80585>>>                DFWritePos    "Item Id"                 0.1     (FONT_BOLD+RGB_DBLUE)            -1 1.36
80586>>>                DFWritePos    "Description"             4.00    (FONT_BOLD+RGB_DBLUE)            -1 4.77
80587>>>                DFWritePos    "Qty Ordered"             11.5     (FONT_BOLD+FONT_RIGHT+RGB_DBLUE) -1 1.87
80588>>>                DFWritePos    "Price"                   13.22   (FONT_BOLD+FONT_RIGHT+RGB_DBLUE) -1 1.22
80589>>>                DFWritePos    "Extended Price"          16.0    (FONT_BOLD+FONT_RIGHT+RGB_DBLUE) -1 2.38
80590>>>                DFWriteln
80591>>>            DFEndHeader
80593>>>        End_Procedure
80594>>>
80594>>>        Procedure SubHeader1
80597>>>
80597>>>            DFFont "Arial" //  Use Arial
80598>>>            DFFontSize 10
80599>>>
80599>>>            DFBeginHeader DFSubHeader 1    //Header of type DFSubHeader
80600>>>
80600>>>                Send Update_Status ("Order:" * String(OrderHea.Order_number))
80601>>>
80601>>>                DFHeaderWrap HDR_WRAP
80602>>>                DFHeaderLineCheck 5            //Check that the header + 5 lines fits on the page, if not wrap
80603>>>
80603>>>                DFHeaderPos   HDR_LEFT         //Write data from left margin in the header
80604>>>                DFHeaderFrame HDR_NoFrame      //Set the box from margin to margin using size 0.05
80605>>>
80605>>>                DFWriteLnPos    ("Order: "+string(Orderhea.ORDER_NUMBER)) 0.1 (FONT_BOLD)
80606>>>
80606>>>              DFEndHeader                     //End and print header
80608>>>
80608>>>        End_Procedure
80609>>>
80609>>>        Procedure Body
80612>>>
80612>>>            DFFont "Arial" //  Use Arial
80613>>>            DFFontSize 8
80614>>>
80614>>>            DFLineCheck 5
80615>>>
80615>>>            DFWritePos    Invt.ITEM_ID                0.1     (FONT_DEFAULT)            -1 2.28
80616>>>            DFWritePos    Invt.DESCRIPTION            4.00    (FONT_DEFAULT)            -1 4.77
80617>>>            DFWritePos    Orderdtl.QTY_ORDERED        11.5     (FONT_DEFAULT+FONT_RIGHT)  0 1.87
80618>>>            DFWritePos    Orderdtl.PRICE              13.22   (FONT_DEFAULT+FONT_RIGHT)  2 1.22
80619>>>            DFWritePos    Orderdtl.EXTENDED_PRICE     16.0    (FONT_DEFAULT+FONT_RIGHT)  2 2.38
80620>>>            DFWriteln ""
80621>>>
80621>>>            // Using SubTotal in WinPrint.
80621>>>            Send Add_SubTotal 1 (Orderdtl.EXTENDED_PRICE)
80622>>>
80622>>>        End_Procedure
80623>>>
80623>>>        Procedure SubTotal1
80626>>>            Number nAmount
80626>>>            Get SubTotal 1 to nAmount
80627>>>            Send Add_SubTotal 2 nAmount // subtotal 2 is total
80628>>>
80628>>>            DFFont "Arial" //  Use Arial
80629>>>            DFFontSize 8
80630>>>            DFBeginHeader DFSubTotal 1
80631>>>
80631>>>                DFHEADERPOS HDR_LEFT
80632>>>                DFHEADERFRAME HDR_NOFRAME
80633>>>
80633>>>                DFWritelnPos  nAmount         16.0      (FONT_BOLD+FONT_RIGHT) 2 0
80634>>>                DFWriteLine DFGR_CURRLINE DFGR_CURRLINE DFGR_RB_MARGIN DFGR_HORI Rgb_dGrey
80635>>>
80635>>>            DFEndHeader
80637>>>
80637>>>        End_Procedure
80638>>>
80638>>>        Procedure Total
80641>>>            Number nTotal
80641>>>            Get SubTotal 2 to nTotal
80642>>>
80642>>>            DFFont "Arial" //  Use Arial
80643>>>            DFFontSize 8
80644>>>            DFBeginHeader DFTotal           //Header of type DFTotal
80645>>>
80645>>>              DFHeaderPos   HDR_LEFT         //Write data from left margin in the header
80646>>>              DFHeaderFrame HDR_MARGINs 0 RGB_DGREY RGB_GREY //rgb_Cyan rgb_Cyan
80647>>>
80647>>>              DFWritelnPos   nTotal         16.0      (FONT_BOLD+FONT_RIGHT) 2
80648>>>
80648>>>            DFEndHeader                     //End and print header
80650>>>
80650>>>        End_Procedure
80651>>>
80651>>>        Procedure Page_Bottom
80654>>>            DateTime dtDT
80654>>>            Move (CurrentDateTime()) to dtDT
80655>>>
80655>>>            DFFont "Arial" //  Use Arial
80656>>>            DFFontSize 8
80657>>>            DFBeginHeader DFPageBottom
80658>>>                DFHeaderPos   HDR_CENTER       //Write data in center
80659>>>                DFHeaderFrame HDR_MARGINS 0.01 rgb_dGrey
80660>>>                DFWriteLn   ("Report Printed on: " +string(dtDT)) (rgb_dBlue)
80661>>>            DFEndHeader
80663>>>
80663>>>        End_Procedure
80664>>>
80664>>>    End_Object    // oOrders
80665>>>
80665>>>    // Procedures and functions used by the user interface
80665>>>
80665>>>    //This function is called by the procedure StartReport
80665>>>    Function Print_to_Screen_State Returns Integer
80668>>>        Integer iRad
80668>>>        Get Current_Radio of oPrintTo To iRad
80669>>>        Function_Return (iRad=1)
80670>>>    End_Function
80671>>>
80671>>>    // Use this procedure to do print setup
80671>>>    Procedure SetupReport
80674>>>        Boolean bSetupOk
80674>>>        Get DFPrintSetupDialog of (Report_Object_Id(Self)) to bSetupOk
80675>>>    End_Procedure
80676>>>
80676>>>    // Use this procedure to start the report
80676>>>    Procedure StartReport
80679>>>        Integer iToPrinter iRepObj
80679>>>        String sVal
80679>>>        Get Report_Object_Id To iRepObj
80680>>>
80680>>>        Get Print_to_Screen_State to iToPrinter
80681>>>        If iToPrinter Set OutPut_Device_Mode to PRINT_TO_PRINTER
80684>>>        Else Set OutPut_Device_Mode to PRINT_TO_WINDOW
80686>>>
80686>>>        Send Run_Report to iRepObj
80687>>>
80687>>>    End_Procedure
80688>>>
80688>>>End_Object    // oItemsPerOrderWP
80689>        Use WinPrint\OrdersWP.rv
Including file: WinPrint\OrdersWP.rv    (C:\Test\Order Entry git\AppSrc\WinPrint\OrdersWP.rv)
80689>>>Use dfrptvw.pkg
80689>>>Use DataDict.pkg
80689>>>Use dfRadio.pkg
80689>>>Use Windows.pkg
80689>>>Use cWinReport2.pkg
80689>>>Use VENDOR.DD
80689>>>Use INVT.DD
80689>>>Use CUSTOMER.DD
80689>>>Use SALESP.DD
80689>>>Use ORDERHEA.DD
80689>>>Use ORDERDTL.DD
80689>>>
80689>>>ACTIVATE_VIEW Activate_oOrdersWP FOR oOrdersWP
80699>>>>
80699>>>
80699>>>Object oOrdersWP is a ReportView
80701>>>    Set Label to "Orders by Order Number"
80702>>>    Set Location to 6 6
80703>>>    Set Size to 46 175
80704>>>
80704>>>    Object Vendor_DD is a Vendor_DataDictionary
80706>>>    End_Object    // Vendor_DD
80707>>>
80707>>>    Object Invt_DD is a Invt_DataDictionary
80709>>>        Set DDO_Server to Vendor_DD
80710>>>    End_Object    // Invt_DD
80711>>>
80711>>>    Object Customer_DD is a Customer_DataDictionary
80713>>>    End_Object    // Customer_DD
80714>>>
80714>>>    Object SalesP_DD is a Salesp_DataDictionary
80716>>>    End_Object    // SalesP_DD
80717>>>
80717>>>    Object Orderhea_DD is a Orderhea_DataDictionary
80719>>>        Set DDO_Server to Customer_DD
80720>>>        Set DDO_Server to SalesP_DD
80721>>>    End_Object    // Orderhea_DD
80722>>>
80722>>>    Object Orderdtl_DD is a Orderdtl_DataDictionary
80724>>>        Set DDO_Server to Orderhea_DD
80725>>>        Set DDO_Server to Invt_DD
80726>>>    End_Object    // Orderdtl_DD
80727>>>
80727>>>    Object oPrintTo is a RadioGroup
80729>>>        Set Size to 38 105
80730>>>        Set Location to 4 5
80731>>>        Set Label to "Print to"
80732>>>        Object oRadio1 is a Radio
80734>>>            Set Label to "Preview"
80735>>>            Set Size to 10 42
80736>>>            Set Location to 12 6
80737>>>            Set Status_Help to "Prints the report to screen"
80738>>>        End_Object    // oRadio1
80739>>>
80739>>>        Object oRadio2 is a Radio
80741>>>            Set Label to "Printer"
80742>>>            Set Size to 10 42
80743>>>            Set Location to 24 6
80744>>>            Set Status_Help to "Prints the report to printer"
80745>>>        End_Object    // oRadio2
80746>>>
80746>>>    End_Object    // oPrintTo
80747>>>
80747>>>    Object oBtnPrint is a Button
80749>>>        Set Label to "Print"
80750>>>        Set Location to 10 120
80751>>>        Set Status_Help to "Print the Selected report"
80752>>>        Set Default_State to True
80753>>>
80753>>>        Procedure OnClick
80756>>>            Send StartReport
80757>>>        End_Procedure
80758>>>
80758>>>    End_Object    // oBtnPrint
80759>>>
80759>>>    Object oBtnCancel is a Button
80761>>>        Set Label to "Cancel"
80762>>>        Set Location to 28 120
80763>>>        Set Status_Help to "Close this Panel"
80764>>>
80764>>>        Procedure OnClick
80767>>>            Send Close_Panel
80768>>>        End_Procedure
80769>>>
80769>>>    End_Object    // oBtnCancel
80770>>>
80770>>>    Object oOrders is a cWinReport2
80772>>>        Set Report_Title to "Customer Report"
80773>>>
80773>>>        //Main File for the report
80773>>>        Set Server to Orderdtl_DD
80774>>>
80774>>>        //Breaks and Index for the report
80774>>>        Report_Breaks ORDERHEA.ORDER_NUMBER
80788>>>        Report_Index By 1
80790>>>
80790>>>        Function Starting_Main_Report Returns Integer
80793>>>            Integer iRetVal
80793>>>            Set PrintDlgInPreview of WinprintId to True
80794>>>            Send DFSetMetrics To WinPrintId "CM"
80795>>>            Send DFSetmargins To WinPrintId 1 1 1 1
80796>>>            Forward Get Starting_Main_Report To iRetVal
80798>>>            If iRetVal Function_return iRetVal
80801>>>        End_Function
80802>>>
80802>>>        Procedure Page_Top
80805>>>            DFFont "Arial" //  Use Arial
80806>>>            DFFontSize 8
80807>>>            DFBeginHeader DFPageTop
80808>>>                DFHeaderPos   HDR_RIGHT
80809>>>                DFHeaderFrame HDR_NOFRAME
80810>>>                DFWriteLn ("Page:" * "#pagecount#")
80811>>>            DFEndHeader
80813>>>        End_Procedure
80814>>>
80814>>>        Procedure Page_Title
80817>>>            DFFont "Arial"
80818>>>            DFFontSize 14
80819>>>            DFBeginHeader DFPageTitle
80820>>>                DFHeaderFrame HDR_MARGINs 0 RGB_DGREY RGB_DGREY
80821>>>                DFHEADERPOS HDR_LEFT
80822>>>                DFWritelnPos "Orders by Order Number Report" 0.10 (FONT_BOLD+RGB_WHITE)
80823>>>            DFEndHeader
80825>>>        End_Procedure
80826>>>
80826>>>        Procedure SubHeader1
80829>>>
80829>>>            DFFont "Arial" //  Use Arial
80830>>>            DFFontSize 8
80831>>>
80831>>>            DFBeginHeader DFSubHeader 1    //Header of type DFSubHeader
80832>>>
80832>>>                Send Update_Status ("Order:" * String(OrderHea.Order_number))
80833>>>
80833>>>
80833>>>                DFHeaderWrap HDR_WRAP
80834>>>                DFHeaderLineCheck 5            //Check that the header + 5 lines fits on the page, if not wrap
80835>>>
80835>>>                DFHeaderPos   HDR_LEFT         //Write data from left margin in the header
80836>>>                DFHeaderFrame HDR_NoFrame      //Set the box from margin to margin using size 0.05
80837>>>                DFHeaderMargin hm_BottomOuter 0.04
80838>>>
80838>>>                DFWritePos    "Order Number"            0.10  (FONT_BOLD+RGB_DBLUE)
80839>>>                DFWritelnPos  Orderhea.ORDER_NUMBER       4.0   (FONT_DEFAULT)
80840>>>                DFWritePos    "Order Date"              0.10  (FONT_BOLD+RGB_DBLUE)
80841>>>                DFWritelnPos  Orderhea.ORDER_DATE         4.0   (FONT_DEFAULT)
80842>>>                DFWritePos    "Customer Number"         0.10  (FONT_BOLD+RGB_DBLUE)
80843>>>                DFWritelnPos  Customer.CUSTOMER_NUMBER    4.0
80844>>>                DFWritePos    "Name"                    0.10  (FONT_BOLD+RGB_DBLUE)
80845>>>                DFWritelnPos  Customer.NAME               4.0   (FONT_DEFAULT)
80846>>>                DFWritePos    "Address"                 0.10  (FONT_BOLD+RGB_DBLUE)
80847>>>                DFWritelnPos  Customer.ADDRESS            4.0   (FONT_DEFAULT)
80848>>>                DFWritePos    "City"                    0.10  (FONT_BOLD+RGB_DBLUE)
80849>>>                DFWritelnPos  Customer.CITY               4.0   (FONT_DEFAULT)
80850>>>                DFWritePos    "State"                   0.10  (FONT_BOLD+RGB_DBLUE)
80851>>>                DFWritelnPos  Customer.STATE              4.0   (FONT_DEFAULT)
80852>>>                DFWritePos    "Zip"                     0.10  (FONT_BOLD+RGB_DBLUE)
80853>>>                DFWritelnPos  Customer.ZIP                4.0   (FONT_DEFAULT)
80854>>>                DFWritePos    "Terms"                   0.10  (FONT_BOLD+RGB_DBLUE)
80855>>>                DFWritelnPos  Orderhea.TERMS              4.0   (FONT_DEFAULT)
80856>>>                DFWritePos    "Ship Via"                0.10  (FONT_BOLD+RGB_DBLUE)
80857>>>                DFWritelnPos  Orderhea.SHIP_VIA           4.0   (FONT_DEFAULT)
80858>>>                DFFontSize 2
80859>>>                DFWriteLn
80860>>>
80860>>>                DFFontSize 8
80861>>>                DfWriteRect DFGR_CURRLINE 0 0.34 DFGR_RB_MARGIN RGB_GREY 0.0 dfgr_noWrap RGB_GREY
80862>>>                DFWritePos    "Item Id"                 0.1     (FONT_BOLD+RGB_DBLUE)            -1 1.36
80863>>>                DFWritePos    "Description"             4.00    (FONT_BOLD+RGB_DBLUE)            -1 4.77
80864>>>                DFWritePos    "Qty Ordered"             11.5     (FONT_BOLD+FONT_RIGHT+RGB_DBLUE) -1 1.87
80865>>>                DFWritePos    "Price"                   13.22   (FONT_BOLD+FONT_RIGHT+RGB_DBLUE) -1 1.22
80866>>>                DFWritePos    "Extended Price"          16.0    (FONT_BOLD+FONT_RIGHT+RGB_DBLUE) -1 2.40
80867>>>                DFWriteln
80868>>>
80868>>>              DFEndHeader                     //End and print header
80870>>>
80870>>>        End_Procedure
80871>>>
80871>>>        Procedure Body
80874>>>
80874>>>            DFFont "Arial" //  Use Arial
80875>>>            DFFontSize 8
80876>>>
80876>>>            DFLineCheck 5
80877>>>
80877>>>            DFWritePos    Invt.ITEM_ID                0.1     (FONT_DEFAULT)            -1 2.28
80878>>>            DFWritePos    Invt.DESCRIPTION            4.00    (FONT_DEFAULT)            -1 4.77
80879>>>            DFWritePos    Orderdtl.QTY_ORDERED        11.5     (FONT_DEFAULT+FONT_RIGHT)  0 1.87
80880>>>            DFWritePos    Orderdtl.PRICE              13.22   (FONT_DEFAULT+FONT_RIGHT)  2 1.22
80881>>>            DFWritePos    Orderdtl.EXTENDED_PRICE     16.0    (FONT_DEFAULT+FONT_RIGHT)  2 2.40
80882>>>            DFWriteln
80883>>>
80883>>>            // Using SubTotal in WinPrint.
80883>>>            Send Add_SubTotal 1 (Orderdtl.EXTENDED_PRICE)
80884>>>
80884>>>        End_Procedure
80885>>>
80885>>>        Procedure SubTotal1
80888>>>            Number nAmount
80888>>>            Get SubTotal 1 to nAmount
80889>>>            Send Add_SubTotal 2 nAmount // subtotal 2 is total
80890>>>
80890>>>            DFFont "Arial" //  Use Arial
80891>>>            DFFontSize 8
80892>>>            DFBeginHeader DFSubTotal 1
80893>>>
80893>>>                DFHEADERPOS HDR_LEFT
80894>>>                  DFHeaderFrame hdr_margins 0.01 rgb_grey rgb_Grey
80895>>>                  dfHeaderMargin hm_bottomOuter 0.10
80896>>>                  dfHeaderMargin hm_bottomInner 0.01
80897>>>                  dfHeaderMargin hm_TopInner    0.01
80898>>>
80898>>>                DFWritelnPos  nAmount         16.0      (Font_BOLD+FONT_RIGHT) 2 0
80899>>>            DFEndHeader
80901>>>
80901>>>        End_Procedure
80902>>>
80902>>>        Procedure Total
80905>>>            Number nTotal
80905>>>            Get SubTotal 2 to nTotal
80906>>>
80906>>>            DFFont "Arial" //  Use Arial
80907>>>            DFFontSize 8
80908>>>            DFBeginHeader DFTotal           //Header of type DFTotal
80909>>>
80909>>>              DFHeaderPos   HDR_LEFT         //Write data from left margin in the header
80910>>>              DFHeaderFrame HDR_MARGINs 0 RGB_DGREY RGB_GREY //rgb_Cyan rgb_Cyan
80911>>>
80911>>>              DFWritelnPos   nTotal         16.0      (FONT_BOLD+FONT_RIGHT) 2
80912>>>
80912>>>            DFEndHeader                     //End and print header
80914>>>
80914>>>        End_Procedure
80915>>>
80915>>>        Procedure Page_Bottom
80918>>>            DateTime dtDT
80918>>>            Move (CurrentDateTime()) to dtDT
80919>>>
80919>>>            DFFont "Arial" //  Use Arial
80920>>>            DFFontSize 8
80921>>>            DFBeginHeader DFPageBottom
80922>>>                DFHeaderPos   HDR_CENTER       //Write data in center
80923>>>                DFHeaderFrame HDR_MARGINS 0.01 rgb_dGrey
80924>>>                DFWriteLn   ("Report Printed on: " +string(dtDT)) (rgb_dBlue)
80925>>>            DFEndHeader
80927>>>
80927>>>        End_Procedure
80928>>>
80928>>>    End_Object    // oOrders
80929>>>
80929>>>    // Procedures and functions used by the user interface
80929>>>
80929>>>    //This function is called by the procedure StartReport
80929>>>    Function Print_to_Screen_State Returns Integer
80932>>>        Integer iRad
80932>>>        Get Current_Radio of oPrintTo To iRad
80933>>>        Function_Return (iRad=1)
80934>>>    End_Function
80935>>>
80935>>>    // Use this procedure to do print setup
80935>>>    Procedure SetupReport
80938>>>        Boolean bSetupOk
80938>>>        Get DFPrintSetupDialog of (Report_Object_Id(Self)) to bSetupOk
80939>>>    End_Procedure
80940>>>
80940>>>    // Use this procedure to start the report
80940>>>    Procedure StartReport
80943>>>        Integer iToPrinter iRepObj
80943>>>        String sVal
80943>>>        Get Report_Object_Id To iRepObj
80944>>>
80944>>>        Get Print_to_Screen_State to iToPrinter
80945>>>        If iToPrinter Set OutPut_Device_Mode to PRINT_TO_PRINTER
80948>>>        Else Set OutPut_Device_Mode to PRINT_TO_WINDOW
80950>>>
80950>>>        Send Run_Report to iRepObj
80951>>>
80951>>>    End_Procedure
80952>>>
80952>>>End_Object    // oOrdersWP
80953>        Use WinPrint\OrdersByCustomerWP.rv
Including file: WinPrint\OrdersByCustomerWP.rv    (C:\Test\Order Entry git\AppSrc\WinPrint\OrdersByCustomerWP.rv)
80953>>>Use dfrptvw.pkg
80953>>>Use DataDict.pkg
80953>>>Use dfRadio.pkg
80953>>>Use Windows.pkg
80953>>>Use cWinReport2.pkg
80953>>>Use VENDOR.DD
80953>>>Use INVT.DD
80953>>>Use CUSTOMER.DD
80953>>>Use SALESP.DD
80953>>>Use ORDERHEA.DD
80953>>>Use ORDERDTL.DD
80953>>>
80953>>>ACTIVATE_VIEW Activate_oOrdersByCustomerWP FOR oOrdersByCustomerWP
80963>>>>
80963>>>
80963>>>Object oOrdersByCustomerWP is a ReportView
80965>>>
80965>>>    property integer main_dd
80967>>>    Property integer server
80969>>>
80969>>>    Set Label to "Orders by Customer"
80970>>>    Set Location to 6 6
80971>>>    Set Size to 110 174
80972>>>
80972>>>    Object Vendor_DD is a Vendor_DataDictionary
80974>>>    End_Object    // Vendor_DD
80975>>>
80975>>>    Object Invt_DD is a Invt_DataDictionary
80977>>>        Set DDO_Server to Vendor_DD
80978>>>    End_Object    // Invt_DD
80979>>>
80979>>>    Object Customer_DD is a Customer_DataDictionary
80981>>>    End_Object    // Customer_DD
80982>>>
80982>>>    Object SalesP_DD is a Salesp_DataDictionary
80984>>>    End_Object    // SalesP_DD
80985>>>
80985>>>    Object Orderhea_DD is a Orderhea_DataDictionary
80987>>>        Set DDO_Server to Customer_DD
80988>>>        Set DDO_Server to SalesP_DD
80989>>>        Set Constrain_File to Customer.File_Number
80990>>>    End_Object    // Orderhea_DD
80991>>>
80991>>>    Object Orderdtl_DD is a Orderdtl_DataDictionary
80993>>>        Set DDO_Server to Orderhea_DD
80994>>>        Set DDO_Server to Invt_DD
80995>>>        Set Constrain_File to Orderhea.File_Number
80996>>>    End_Object    // Orderdtl_DD
80997>>>
80997>>>    Set Main_DD to Customer_DD
80998>>>    Set Server to Customer_DD
80999>>>
80999>>>    Object oPrintTo is a RadioGroup
81001>>>        Set Size to 38 105
81002>>>        Set Location to 5 5
81003>>>        Set Label to "Print to"
81004>>>        Object oRadio1 is a Radio
81006>>>            Set Label to "Preview"
81007>>>            Set Size to 10 42
81008>>>            Set Location to 12 6
81009>>>            Set Status_Help to "Prints the report to screen"
81010>>>        End_Object    // oRadio1
81011>>>
81011>>>        Object oRadio2 is a Radio
81013>>>            Set Label to "Printer"
81014>>>            Set Size to 10 42
81015>>>            Set Location to 24 6
81016>>>            Set Status_Help to "Prints the report to printer"
81017>>>        End_Object    // oRadio2
81018>>>
81018>>>    End_Object    // oPrintTo
81019>>>
81019>>>    Object oReportOrder is a RadioGroup
81021>>>        Set Size to 38 105
81022>>>        Set Location to 45 5
81023>>>        Set Label to "Report Order"
81024>>>        Object oRadio3 is a Radio
81026>>>            Set Label to "Customer Number"
81027>>>            Set Size to 10 73
81028>>>            Set Location to 12 6
81029>>>            Set Status_Help to "Prints the report to screen"
81030>>>        End_Object    // oRadio3
81031>>>
81031>>>        Object oRadio4 is a Radio
81033>>>            Set Label to "Customer Name"
81034>>>            Set Size to 10 67
81035>>>            Set Location to 24 6
81036>>>            Set Status_Help to "Prints the report to printer"
81037>>>        End_Object    // oRadio4
81038>>>
81038>>>        Function OrderByNumber returns boolean
81041>>>            function_return (current_radio(self)=0)
81042>>>        end_function
81043>>>        
81043>>>    End_Object    // oReportOrder
81044>>>
81044>>>    Object oSetupButton is a Button
81046>>>        Set Label to "Printer Setup"
81047>>>        Set Location to 7 120
81048>>>
81048>>>        Procedure OnClick
81051>>>            Boolean bSetupOk
81051>>>            Get DFPrintSetupDialog of oOrders to bSetupOk
81052>>>        End_Procedure
81053>>>
81053>>>    End_Object    // oSetupButton
81054>>>
81054>>>    Object oBtnPrint is a Button
81056>>>        Set Label to "Print"
81057>>>        Set Location to 49 120
81058>>>        Set Status_Help to "Print the Selected report"
81059>>>        Set Default_State to True
81060>>>
81060>>>        Procedure OnClick
81063>>>            boolean bByNumber
81063>>>            Get OrderByNumber of oReportOrder  to bByNumber
81064>>>            Set Ordering of oOrders to (if(bByNumber,1,2))
81065>>>            Send StartReport
81066>>>        End_Procedure
81067>>>
81067>>>    End_Object    // oBtnPrint
81068>>>
81068>>>    Object oBtnCancel is a Button
81070>>>        Set Label to "Cancel"
81071>>>        Set Location to 67 120
81072>>>        Set Status_Help to "Close this Panel"
81073>>>
81073>>>        Procedure OnClick
81076>>>            Send Close_Panel
81077>>>        End_Procedure
81078>>>
81078>>>    End_Object    // oBtnCancel
81079>>>
81079>>>    Object oOnePageCkBx is a CheckBox
81081>>>        Set Label to "New Page for Each Customer"
81082>>>        Set Size to 10 110
81083>>>        Set Location to 92 6
81084>>>
81084>>>        Procedure OnChange
81087>>>            Boolean bChecked
81087>>>        
81087>>>            Get Checked_State To bChecked
81088>>>        End_Procedure // OnChange
81089>>>
81089>>>    End_Object    // oOnePageCkBx
81090>>>
81090>>>    Object oOrders is a cWinReport2
81092>>>
81092>>>        Property Boolean pbOnePagePerCust False
81094>>>        
81094>>>        Set Report_Title to "Printing all Orders by Customer"
81095>>>        
81095>>>        //Main File for the report
81095>>>        Set Server to Customer_DD
81096>>>        //Breaks and Index for the report
81096>>>        Report_Breaks Customer.Customer_number
81110>>>        
81110>>>        Set Ordering to 2
81111>>>        
81111>>>        Object oOrderHea is a cWinReport2
81113>>>
81113>>>            Set Server to Orderhea_DD
81114>>>            Report_Breaks ORDERHEA.Order_number
81128>>>            set Ordering to 2
81129>>>
81129>>>            Object oOrderDtl is a cWinReport2
81131>>>
81131>>>                Set Server to Orderdtl_DD
81132>>>                Report_Breaks Orderhea.Order_Number
81146>>>                Set Ordering to 1
81147>>>                
81147>>>                Procedure SubHeader1
81150>>>                      Send Update_Status (Customer.Name - '/' - string(Orderhea.Order_number))
81151>>>                
81151>>>                      DFFont "Arial"
81152>>>                      DFFontSize 8
81153>>>                
81153>>>                      DFBeginHeader DFSubHeader 2
81154>>>                        DFHeaderFrame hdr_NoFrame
81155>>>                        DFHeaderPos   hdr_Left
81156>>>                        DFHeaderWrap hdr_Wrap
81157>>>                        DfHeaderMargin hm_BottomOuter 0.04
81158>>>                        DFHeaderLineCheck 5            //Check that the header + 5 lines fits on the page, if not wrap
81159>>>                
81159>>>                        DFWritePos    "Order Number"            0.10  (FONT_BOLD+RGB_DBLUE)
81160>>>                        DFWritelnPos  Orderhea.Order_number       4.0   (FONT_DEFAULT)
81161>>>                        DFWritePos    "Order Date"              0.10  (FONT_BOLD+RGB_DBLUE)
81162>>>                        DFWritelnPos  Orderhea.Order_date         4.0   (FONT_DEFAULT)
81163>>>                        DFWritePos    "Terms"                   0.10  (FONT_BOLD+RGB_DBLUE)
81164>>>                        DFWritelnPos  Orderhea.Terms              4.0   (FONT_DEFAULT)
81165>>>                        DFWritePos    "Ship Via"                0.10  (FONT_BOLD+RGB_DBLUE)
81166>>>                        DFWritelnPos  Orderhea.Ship_via           4.0   (FONT_DEFAULT)
81167>>>                
81167>>>                        DfWriteRect dfgr_CurrLine 0 0.34 dfgr_rb_Margin rgb_Grey 0.0 dfgr_NoWrap rgb_Grey
81168>>>                        DFWritePos    "Item Id"                 0.1     (FONT_BOLD+RGB_DBLUE)            -1 1.36
81169>>>                        DFWritePos    "Description"             4.00    (FONT_BOLD+RGB_DBLUE)            -1 4.77
81170>>>                        DFWritePos    "Qty Ordered"             11.5     (FONT_BOLD+FONT_RIGHT+RGB_DBLUE) -1 1.87
81171>>>                        DFWritePos    "Price"                   13.22   (FONT_BOLD+FONT_RIGHT+RGB_DBLUE) -1 1.22
81172>>>                        DFWritePos    "Extended Price"          16.0    (FONT_BOLD+FONT_RIGHT+RGB_DBLUE) -1 2.50
81173>>>                        DFWriteln
81174>>>                
81174>>>                      DFEndHeader
81176>>>                
81176>>>                End_Procedure
81177>>>                
81177>>>                Procedure Body // order detail body
81180>>>                
81180>>>                    DFFont "Arial"
81181>>>                    DFFontSize 8
81182>>>                
81182>>>                    DFLineCheck 5
81183>>>                
81183>>>                    DFWritePos    Invt.Item_id                0.1     (FONT_DEFAULT)            -1 2.28
81184>>>                    DFWritePos    Invt.Description            4.00    (FONT_DEFAULT)            -1 4.77
81185>>>                    DFWritePos    Orderdtl.Qty_ordered        11.5     (FONT_DEFAULT+FONT_RIGHT)  0 1.87
81186>>>                    DFWritePos    Orderdtl.Price              13.22   (FONT_DEFAULT+FONT_RIGHT)  2 1.22
81187>>>                    DFWritePos    Orderdtl.Extended_price     16.0    (FONT_DEFAULT+FONT_RIGHT)  2 2.50
81188>>>                    DFWriteln
81189>>>                
81189>>>                    // Using rectotal in WinPrint.
81189>>>                    Send Add_SubTotal 1 (Orderdtl.Extended_price)
81190>>>                
81190>>>                End_Procedure
81191>>>                
81191>>>                Procedure SubTotal1 // order total
81194>>>                    Number nAmount
81194>>>                
81194>>>                    Get SubTotal 1 to nAmount
81195>>>                    Send Add_SubTotal 2 nAmount // subtotal 2 is customer total
81196>>>                
81196>>>                    DFFont "Arial"
81197>>>                    DFFontSize 8
81198>>>                    DFBeginHeader DFSubTotal 2
81199>>>                        DFHeaderPos hdr_Left
81200>>>                        DFHeaderFrame hdr_Margins 0.01 rgb_dGrey rgb_Grey
81201>>>                        DfHeaderMargin hm_TopInner 0.02
81202>>>                        DfHeaderMargin hm_BottomInner 0.02
81203>>>                        DfHeaderMargin hm_BottomOuter 0.08
81204>>>                        DfHeaderMargin hm_TopOuter 0.04
81205>>>                
81205>>>                        DFWritePos   "Order Total:"  14.0  (FONT_BOLD+RGB_DBLUE+FONT_RIGHT)
81206>>>                        DFWritelnPos nAmount         16.0   (FONT_RIGHT) 2
81207>>>                    DFEndHeader
81209>>>                
81209>>>                End_Procedure
81210>>>                
81210>>>            End_Object    // oOrderDtl
81211>>>
81211>>>        End_Object    // oOrderHea
81212>>>        
81212>>>        Function Starting_Main_Report Returns Integer
81215>>>            Integer iRetVal bBreak
81215>>>            Get OnePagePerCust to bBreak
81216>>>            Set pbOnePagePerCust to bBreak
81217>>>            Send DFSetMetrics to WinPrintId "CM"
81218>>>            Send DFSetmargins to WinPrintId 1 1 1 1
81219>>>            Forward Get Starting_Main_Report to iRetVal
81221>>>            If iRetVal Function_Return iRetVal
81224>>>        End_Function
81225>>>        
81225>>>        Procedure Page_Top
81228>>>            DFFont "Arial"
81229>>>            DFFontSize 8
81230>>>            DFBeginHeader DFPageTop
81231>>>                DFHeaderFrame hdr_NoFrame
81232>>>                DFHeaderPos   hdr_Right
81233>>>        
81233>>>                DFWriteLn ("Page:" * "#pagecount#")
81234>>>            DFEndHeader
81236>>>        End_Procedure
81237>>>        
81237>>>        Procedure Page_Title
81240>>>            DFFont "Arial"
81241>>>            DFFontSize 14
81242>>>            DFBeginHeader DFPageTitle
81243>>>                DFHeaderFrame hdr_Margins 0.01 rgb_dGrey rgb_dGrey
81244>>>                DFHeaderPos hdr_Left
81245>>>                DFHeaderMargin hm_BottomOuter 0.08
81246>>>        
81246>>>                DFWriteLnPos "Orders by Customer Report" 0.10 (FONT_BOLD+RGB_WHITE)
81247>>>            DFEndHeader
81249>>>        End_Procedure
81250>>>        
81250>>>        Procedure SubHeader1
81253>>>            Integer iClr
81253>>>            DFFont "Arial" //  Use Arial
81254>>>            DFFontSize 8
81255>>>            Get DFGetDFColor of winprintId  242 242 242 to iClr // Move -218959360 to iClr  can be used instead
81256>>>        
81256>>>            DFBeginHeader DFSubHeader 1 // customer sub-header
81257>>>                DFHeaderFrame hdr_Margins 0.01 rgb_dGrey iClr
81258>>>                DFHeaderPos   hdr_Left
81259>>>                DFHeaderWrap hdr_Wrap
81260>>>                DFHeaderLineCheck 10 //Check that the header + 10 lines fits on the page, if not wrap
81261>>>        
81261>>>                DFWritePos    "Customer Number"         0.10  (FONT_BOLD+RGB_DBLUE)
81262>>>                DFWriteLnPos  Customer.Customer_number    4.0
81263>>>                DFWritePos    "Name"                    0.10  (FONT_BOLD+RGB_DBLUE)
81264>>>                DFWriteLnPos  Customer.Name               4.0   (FONT_DEFAULT)
81265>>>                DFWritePos    "Address"                 0.10  (FONT_BOLD+RGB_DBLUE)
81266>>>                DFWriteLnPos  Customer.Address            4.0   (FONT_DEFAULT)
81267>>>                DFWritePos    "City"                    0.10  (FONT_BOLD+RGB_DBLUE)
81268>>>                DFWriteLnPos  Customer.City               4.0   (FONT_DEFAULT)
81269>>>                DFWritePos    "State"                   0.10  (FONT_BOLD+RGB_DBLUE)
81270>>>                DFWriteLnPos  Customer.State              4.0   (FONT_DEFAULT)
81271>>>                DFWritePos    "Zip"                     0.10  (FONT_BOLD+RGB_DBLUE)
81272>>>                DFWriteLnPos  Customer.Zip                4.0   (FONT_DEFAULT)
81273>>>            DFEndHeader
81275>>>        End_Procedure
81276>>>        
81276>>>        Procedure SubTotal1 // customer total
81279>>>            Number nAmount
81279>>>            Integer iClr
81279>>>            Boolean bBreak
81279>>>        
81279>>>            Get SubTotal 2 to nAmount
81280>>>            Send Add_SubTotal 3 nAmount // subtotal 3 is total of all
81281>>>        
81281>>>            Get DFGetDFColor of winprintId  242 242 242 to iClr // Move -218959360 to iClr   can be used instead
81282>>>        
81282>>>            DFFont "Arial" //  Use Arial
81283>>>            DFFontSize 8
81284>>>            DFBeginHeader DFSubTotal 1
81285>>>                DFHeaderPos hdr_Left
81286>>>                DFHeaderFrame hdr_Margins 0.01 rgb_dGrey iClr
81287>>>                DFHeaderMargin hm_BottomOuter 0.16
81288>>>        
81288>>>                DFWritePos   "Customer Total:"  14.0 (FONT_BOLD+RGB_DBLUE+FONT_RIGHT)
81289>>>                DFWriteLnPos nAmount 16.0              (FONT_RIGHT+FONT_Bold) 2 0
81290>>>            DFEndHeader
81292>>>            Get pbOnePagePerCust to bBreak
81293>>>            If bBreak Begin
81295>>>                Send DFNew_Page
81296>>>            End
81296>>>>
81296>>>        End_Procedure
81297>>>        
81297>>>        Procedure Total // total of all customers
81300>>>            Number nTotal
81300>>>            Get SubTotal 3 to nTotal
81301>>>        
81301>>>            DFFont "Arial" //  Use Arial
81302>>>            DFFontSize 10
81303>>>        
81303>>>            DFBeginHeader DFTotal
81304>>>        
81304>>>                DFHeaderPos   hdr_Left
81305>>>                DFHeaderFrame hdr_Margins 0.01 rgb_dGrey rgb_Grey
81306>>>        
81306>>>                DFWritePos    "Grand Total:"  14.0        (FONT_BOLD+RGB_DBLUE+FONT_RIGHT)
81307>>>                DFWriteLnPos   nTotal         16.0      (FONT_BOLD+FONT_RIGHT) 2
81308>>>        
81308>>>            DFEndHeader                     //End and print header
81310>>>        
81310>>>        End_Procedure
81311>>>        
81311>>>        Procedure Page_Bottom
81314>>>            DateTime dtDT
81314>>>            Move (CurrentDateTime()) to dtDT
81315>>>        
81315>>>            DFFont "Arial"
81316>>>            DFFontSize 8
81317>>>            DFBeginHeader DFPageBottom
81318>>>                DFHeaderPos   hdr_Center
81319>>>                DFHeaderFrame hdr_Margins 0.01 rgb_dGrey
81320>>>                DFWriteLn   ("Report Printed on: " +String(dtDT)) (rgb_dBlue)
81321>>>            DFEndHeader
81323>>>        
81323>>>        End_Procedure
81324>>>
81324>>>    End_Object    // oOrders
81325>>>
81325>>>    // Procedures and functions used by the user interface
81325>>>    
81325>>>    //This function is called by the procedure StartReport
81325>>>    Function Print_to_Screen_State Returns Integer
81328>>>        Integer iRad
81328>>>        Get Current_Radio of oPrintTo To iRad
81329>>>        Function_Return (iRad=1)
81330>>>    End_Function
81331>>>    
81331>>>    // Use this procedure to do print setup
81331>>>    Procedure SetupReport
81334>>>        Boolean bSetupOk
81334>>>        Get DFPrintSetupDialog of oOrders to bSetupOk
81335>>>    End_Procedure
81336>>>    
81336>>>    // Use this procedure to start the report
81336>>>    Procedure StartReport
81339>>>        Boolean bToPrinter
81339>>>        String sVal
81339>>>        Get Print_to_Screen_State to bToPrinter
81340>>>        If bToPrinter Set OutPut_Device_Mode to PRINT_TO_PRINTER
81343>>>        Else          Set OutPut_Device_Mode to PRINT_TO_WINDOW
81345>>>    
81345>>>        Send Run_Report of oOrders
81346>>>    
81346>>>    End_Procedure
81347>>>    
81347>>>    Function OnePagePerCust returns boolean
81350>>>        boolean bBreak
81350>>>        Get checked_state of oOnePageCkBx to bBreak
81351>>>        Function_return bBreak
81352>>>    end_function
81353>>>    
81353>>>    // The Report
81353>>>    //    Object oOrders is a cWinReport2
81353>>>    //    //Object oOrders is a WinReport
81353>>>    
81353>>>    //        Property Boolean pbOnePagePerCust False
81353>>>    //        Set Report_Title to "Printing all Orders by Customer"
81353>>>    
81353>>>    //        //Main File for the report
81353>>>    //        Set Server to Customer_DD
81353>>>    //        //Breaks and Index for the report
81353>>>    //        Report_Breaks ORDERHEA.CUSTOMER_NUMBER
81353>>>    //        Set Ordering to 2
81353>>>    
81353>>>    //        Function Starting_Main_Report Returns Integer
81353>>>    //            Integer iRetVal bBreak
81353>>>    //            Get OnePagePerCust to bBreak
81353>>>    //            Set pbOnePagePerCust to bBreak
81353>>>    //            Send DFSetMetrics To WinPrintId "CM"
81353>>>    //            Send DFSetmargins To WinPrintId 1 1 1 1
81353>>>    //            Forward Get Starting_Main_Report To iRetVal
81353>>>    //            If iRetVal Function_return iRetVal
81353>>>    //        End_Function
81353>>>    
81353>>>    //        Procedure Page_Top
81353>>>    //            DFFont "Arial"
81353>>>    //            DFFontSize 8
81353>>>    //            DFBeginHeader DFPageTop
81353>>>    //                DFHeaderFrame HDR_NOFRAME
81353>>>    //                DFHeaderPos   HDR_RIGHT
81353>>>    
81353>>>    //                DFWriteLn ("Page:" * "#pagecount#")
81353>>>    //            DFEndHeader
81353>>>    //        End_Procedure
81353>>>    
81353>>>    //        Procedure Page_Title
81353>>>    //            DFFont "Arial"
81353>>>    //            DFFontSize 14
81353>>>    //            DFBeginHeader DFPageTitle
81353>>>    //                DFHeaderFrame HDR_MARGINs 0.01 RGB_DGREY RGB_DGREY
81353>>>    //                DFHEADERPOS HDR_LEFT
81353>>>    //                DfHeaderMargin hm_BottomOuter 0.08
81353>>>    
81353>>>    //                DFWritelnPos "Orders by Customer Report" 0.10 (FONT_BOLD+RGB_WHITE)
81353>>>    //            DFEndHeader
81353>>>    //        End_Procedure
81353>>>    
81353>>>    //        Procedure SubHeader1
81353>>>    //            integer iClr
81353>>>    //            DFFont "Arial" //  Use Arial
81353>>>    //            DFFontSize 8
81353>>>    //            //Get DFGetDFColor of winprintId  242 242 242 to iClr // doesn't work YET
81353>>>    //            Move -218959360 to iClr
81353>>>    
81353>>>    //            DFBeginHeader DFSubHeader 1 // customer sub-header
81353>>>    //                DFHeaderFrame hdr_Margins 0.01 rgb_dGrey iClr
81353>>>    //                DFHeaderPos   HDR_LEFT
81353>>>    //                DFHeaderWrap HDR_WRAP
81353>>>    //                DFHeaderLineCheck 10 //Check that the header + 10 lines fits on the page, if not wrap
81353>>>    
81353>>>    //                DFWritePos    "Customer Number"         0.10  (FONT_BOLD+RGB_DBLUE)
81353>>>    //                DFWritelnPos  Customer.CUSTOMER_NUMBER    4.0
81353>>>    //                DFWritePos    "Name"                    0.10  (FONT_BOLD+RGB_DBLUE)
81353>>>    //                DFWritelnPos  Customer.NAME               4.0   (FONT_DEFAULT)
81353>>>    //                DFWritePos    "Address"                 0.10  (FONT_BOLD+RGB_DBLUE)
81353>>>    //                DFWritelnPos  Customer.ADDRESS            4.0   (FONT_DEFAULT)
81353>>>    //                DFWritePos    "City"                    0.10  (FONT_BOLD+RGB_DBLUE)
81353>>>    //                DFWritelnPos  Customer.CITY               4.0   (FONT_DEFAULT)
81353>>>    //                DFWritePos    "State"                   0.10  (FONT_BOLD+RGB_DBLUE)
81353>>>    //                DFWritelnPos  Customer.STATE              4.0   (FONT_DEFAULT)
81353>>>    //                DFWritePos    "Zip"                     0.10  (FONT_BOLD+RGB_DBLUE)
81353>>>    //                DFWritelnPos  Customer.ZIP                4.0   (FONT_DEFAULT)
81353>>>    //            DFEndHeader
81353>>>    //        End_Procedure
81353>>>    
81353>>>    //        Object oOrderHea is a cWinReport2
81353>>>    //    //        Object oOrders is a WinReport
81353>>>    
81353>>>    //            Set Server to Orderhea_DD
81353>>>    //            Report_Breaks ORDERHEA.Order_number
81353>>>    //            set Ordering to 2
81353>>>    
81353>>>    //            Object oOrderDtl is a cWinReport2
81353>>>    //    //            Object oOrders is a WinReport
81353>>>    
81353>>>    //                Set Server to Orderdtl_DD
81353>>>    //                Report_Breaks ORDERHEA.Order_Number
81353>>>    //                Set Ordering to 1
81353>>>    
81353>>>    //                Procedure SubHeader1 // order sub-header
81353>>>    //                      Send Update_Status (Customer.Name - '/' - string(Orderhea.order_number))
81353>>>    
81353>>>    //                      DFFont "Arial"
81353>>>    //                      DFFontSize 8
81353>>>    
81353>>>    //                      DFBeginHeader DFSubHeader 2
81353>>>    //                        DFHeaderFrame hdr_NoFrame
81353>>>    //                        DFHeaderPos   HDR_LEFT
81353>>>    //                        DFHeaderWrap HDR_WRAP
81353>>>    //                        DfHeaderMargin hm_BottomOuter 0.04
81353>>>    //                        DFHeaderLineCheck 5            //Check that the header + 5 lines fits on the page, if not wrap
81353>>>    
81353>>>    //                        DFWritePos    "Order Number"            0.10  (FONT_BOLD+RGB_DBLUE)
81353>>>    //                        DFWritelnPos  Orderhea.ORDER_NUMBER       4.0   (FONT_DEFAULT)
81353>>>    //                        DFWritePos    "Order Date"              0.10  (FONT_BOLD+RGB_DBLUE)
81353>>>    //                        DFWritelnPos  Orderhea.ORDER_DATE         4.0   (FONT_DEFAULT)
81353>>>    //                        DFWritePos    "Terms"                   0.10  (FONT_BOLD+RGB_DBLUE)
81353>>>    //                        DFWritelnPos  Orderhea.TERMS              4.0   (FONT_DEFAULT)
81353>>>    //                        DFWritePos    "Ship Via"                0.10  (FONT_BOLD+RGB_DBLUE)
81353>>>    //                        DFWritelnPos  Orderhea.SHIP_VIA           4.0   (FONT_DEFAULT)
81353>>>    
81353>>>    //                        DfWriteRect DFGR_CURRLINE 0 0.34 DFGR_RB_MARGIN RGB_GREY 0.0 dfgr_noWrap RGB_GREY
81353>>>    //                        DFWritePos    "Item Id"                 0.1     (FONT_BOLD+RGB_DBLUE)            -1 1.36
81353>>>    //                        DFWritePos    "Description"             2.36    (FONT_BOLD+RGB_DBLUE)            -1 4.77
81353>>>    //                        DFWritePos    "Qty Ordered"             9.5     (FONT_BOLD+FONT_RIGHT+RGB_DBLUE) -1 1.87
81353>>>    //                        DFWritePos    "Price"                   11.22   (FONT_BOLD+FONT_RIGHT+RGB_DBLUE) -1 1.22
81353>>>    //                        DFWritePos    "Extended Price"          14.1    (FONT_BOLD+FONT_RIGHT+RGB_DBLUE) -1 2.38
81353>>>    //                        DFWriteln
81353>>>    
81353>>>    //                      DFEndHeader
81353>>>    
81353>>>    //                End_Procedure
81353>>>    
81353>>>    //                Procedure Body // order detail body
81353>>>    
81353>>>    //                    DFFont "Arial"
81353>>>    //                    DFFontSize 8
81353>>>    
81353>>>    //                    DFLineCheck 5
81353>>>    
81353>>>    //                    DFWritePos    Invt.ITEM_ID                0.1     (FONT_DEFAULT)            -1 2.24
81353>>>    //                    DFWritePos    Invt.DESCRIPTION            2.36    (FONT_DEFAULT)            -1 4.77
81353>>>    //                    DFWritePos    Orderdtl.QTY_ORDERED        9.5     (FONT_DEFAULT+FONT_RIGHT)  0 1.87
81353>>>    //                    DFWritePos    Orderdtl.PRICE              11.22   (FONT_DEFAULT+FONT_RIGHT)  2 1.22
81353>>>    //                    DFWritePos    Orderdtl.EXTENDED_PRICE     14.1    (FONT_DEFAULT+FONT_RIGHT)  2 2.38
81353>>>    //                    DFWriteln
81353>>>    
81353>>>    //                    // Using rectotal in WinPrint.
81353>>>    //                    Send Add_SubTotal 1 (Orderdtl.EXTENDED_PRICE)
81353>>>    
81353>>>    //                End_Procedure
81353>>>    
81353>>>    //                Procedure SubTotal1 // order total
81353>>>    //                    Number nAmount
81353>>>    
81353>>>    //                    Get SubTotal 1 to nAmount
81353>>>    //                    Send Add_SubTotal 2 nAmount // subtotal 2 is customer total
81353>>>    
81353>>>    //                    DFFont "Arial"
81353>>>    //                    DFFontSize 8
81353>>>    //                    DFBeginHeader DFSubTotal 2
81353>>>    //                        DFHEADERPOS HDR_LEFT
81353>>>    //                        DFHEADERFRAME HDR_Margins 0.01 rgb_dGrey rgb_Grey
81353>>>    //                        DfHeaderMargin hm_TopInner 0.02
81353>>>    //                        DfHeaderMargin hm_BottomInner 0.02
81353>>>    //                        DfHeaderMargin hm_BottomOuter 0.08
81353>>>    //                        DfHeaderMargin hm_TopOuter 0.04
81353>>>    
81353>>>    //                        DFWritePos   "Order Total:"  12.00  (FONT_BOLD+RGB_DBLUE+FONT_RIGHT)
81353>>>    //                        DFWritelnPos nAmount         14.1   (FONT_RIGHT) 2
81353>>>    //                    DFEndHeader
81353>>>    
81353>>>    //                End_Procedure
81353>>>    
81353>>>    //            end_object // orderdtl nested report
81353>>>    
81353>>>    //        end_object // orderhea nested report
81353>>>    
81353>>>    //        Procedure SubTotal1 // customer total
81353>>>    //            Number nAmount
81353>>>    //            integer iClr
81353>>>    //            Boolean bBreak
81353>>>    
81353>>>    //            Get SubTotal 2 to nAmount
81353>>>    //            Send Add_SubTotal 3 nAmount // subtotal 3 is total of all
81353>>>    
81353>>>    //            //Get DFGetDFColor of winprintId  242 242 242 to iClr // doesn't work YET
81353>>>    //            Move -218959360 to iClr
81353>>>    
81353>>>    //            DFFont "Arial" //  Use Arial
81353>>>    //            DFFontSize 8
81353>>>    //            DFBeginHeader DFSubTotal 1
81353>>>    //                DFHEADERPOS HDR_LEFT
81353>>>    //                DFHeaderFrame HDR_Margins 0.01 RGB_DGREY iClr
81353>>>    //                DfHeaderMargin hm_BottomOuter 0.16
81353>>>    
81353>>>    //                DFWritePos   "Customer Total:"  12.00 (FONT_BOLD+RGB_DBLUE+FONT_RIGHT)
81353>>>    //                DFWritelnPos nAmount 14.1              (FONT_RIGHT+FONT_Bold) 2 0
81353>>>    //            DFEndHeader
81353>>>    //            Get pbOnePagePerCust to bBreak
81353>>>    //            If bBreak Begin
81353>>>    //                send DFNew_Page
81353>>>    //            end
81353>>>    //        end_procedure
81353>>>    
81353>>>    //        Procedure Total // total of all customers
81353>>>    //            Number nTotal
81353>>>    //            Get SubTotal 3 to nTotal
81353>>>    
81353>>>    //            DFFont "Arial" //  Use Arial
81353>>>    //            DFFontSize 10
81353>>>    
81353>>>    //            DFBeginHeader DFTotal
81353>>>    
81353>>>    //                DFHeaderPos   HDR_LEFT
81353>>>    //                DFHeaderFrame HDR_MARGINs 0.01 RGB_DGREY RGB_GREY
81353>>>    
81353>>>    //                DFWritePos    "Grand Total:"  12        (FONT_BOLD+RGB_DBLUE+FONT_RIGHT)
81353>>>    //                DFWritelnPos   nTotal         14.1      (FONT_BOLD+FONT_RIGHT) 2
81353>>>    
81353>>>    //            DFEndHeader                     //End and print header
81353>>>    
81353>>>    //        End_Procedure
81353>>>    
81353>>>    //        Procedure Page_Bottom
81353>>>    //            DateTime dtDT
81353>>>    //            Move (CurrentDateTime()) to dtDT
81353>>>    
81353>>>    //            DFFont "Arial"
81353>>>    //            DFFontSize 8
81353>>>    //            DFBeginHeader DFPageBottom
81353>>>    //                DFHeaderPos   HDR_CENTER
81353>>>    //                DFHeaderFrame HDR_MARGINS 0.01 rgb_dGrey
81353>>>    //                DFWriteLn   ("Report Printed on: " +string(dtDT)) (rgb_dBlue)
81353>>>    //            DFEndHeader
81353>>>    
81353>>>    //        End_Procedure
81353>>>    
81353>>>    //    End_Object // customer main report
81353>>>    
81353>>>End_Object    // oOrdersByCustomerWP
81354>
81354>        On_Key Key_Ctrl+Key_1 Send Activate_oCustomerView
81355>        On_Key Key_Ctrl+Key_2 Send Activate_oInventoryView
81356>        On_Key Key_Ctrl+Key_3 Send Activate_oOrderEntryView
81357>        On_Key Key_Ctrl+Key_4 Send Activate_oSalesPersonView
81358>        On_Key Key_Ctrl+Key_5 Send Activate_oVendorView
81359>        On_Key Key_Ctrl+Key_6 Send Activate_oCustomerListWP
81360>        On_Key Key_Ctrl+Key_7 Send Activate_oItemsPerOrderWP
81361>        On_Key Key_Ctrl+Key_8 Send Activate_oOrdersByCustomerWP
81362>        On_Key Key_Ctrl+Key_9 Send Activate_oOrdersWP
81363>
81363>        Use StdAbout.pkg
Including file: StdAbout.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\StdAbout.pkg)
81363>>>//************************************************************************
81363>>>// Confidential Trade Secret.
81363>>>// Copyright (c) 1997 Data Access Corporation, Miami Florida
81363>>>// as an unpublished work.  All rights reserved.
81363>>>// DataFlex is a registered trademark of Data Access Corporation.
81363>>>//
81363>>>//************************************************************************
81363>>>//************************************************************************
81363>>>//
81363>>>// $File name  : StdAbout.pkg
81363>>>// $File title : Standard about object package for VDF
81363>>>// Notice      :
81363>>>// $Author(s)  : John Tuohy
81363>>>//
81363>>>// $Rev History
81363>>>//
81363>>>// JT 06/27/97   File created
81363>>>//************************************************************************
81363>>>
81363>>>// This provides a quick and simple way to create an about package for a program.
81363>>>// You need to create a message inside you client area called Activate_About.
81363>>>// Within this message you should send the message DoAbout passing needed
81363>>>// string information.
81363>>>//
81363>>>//       Procedure Activate_About
81363>>>//           Send DoAbout sTitle sVersion sCopyright sAuthor sBitmap
81363>>>//       End_Procedure
81363>>>//    where: sTitle =     Name of application. If none provided, uses caption
81363>>>//                        bar title
81363>>>//           sVersion   = Version Line. If none provided, will be blank
81363>>>//           sCopyRight = Copyright Line. If none provided, will be blank
81363>>>//           sAuthor    = Author name, blank if none provided
81363>>>//           sBitMap    = Bitmap logo. If none provided, standard VDF bitmap
81363>>>//                        is used.
81363>>>// It is expected that you will place this in your own object package. For
81363>>>// example an order about package may look like this:
81363>>>//
81363>>>//   // OrderAbout.pkg
81363>>>//   Use StdAbout.pkg
81363>>>//   Procedure Activate_About
81363>>>//      String sTitle sCopyright sVersion sAuthor
81363>>>//      Move "My Order Entry System" to sTitle
81363>>>//      Move "Version 2.1" to sVersion
81363>>>//      Move "Copyright 1997, Super Software Inc." to sCopyright
81363>>>//      Move "John Smith"  to sAuthor
81363>>>//      Send DoAbout sTitle sVersion sCopyright sAuthor ""
81363>>>//   end_procedure
81363>>>//   // end of file.
81363>>>
81363>>>Use DfAbout.pkg
Including file: Dfabout.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\Dfabout.pkg)
81363>>>>>//************************************************************************
81363>>>>>// Confidential Trade Secret.
81363>>>>>// Copyright (c) 1997 Data Access Corporation, Miami Florida
81363>>>>>// as an unpublished work.  All rights reserved.
81363>>>>>// DataFlex Is A registered trademark Of Data Access Corporation.
81363>>>>>//
81363>>>>>//************************************************************************
81363>>>>>//************************************************************************
81363>>>>>//
81363>>>>>// $File name  : DfAbout.pkg
81363>>>>>// $File title : About class support
81363>>>>>// Notice      :
81363>>>>>// $Author(s)  : Vincent Oorsprong, Ken Ross
81363>>>>>//
81363>>>>>// $Rev History
81363>>>>>//
81363>>>>>// VOO 02/22/2012 Replaced obsolete code, improved Network_User_Name by asking
81363>>>>>//                Windows for the size first. 
81363>>>>>// VOO 07/25/2003 Removed OnResize procedure for sysinfo dialog. Replaced logic
81363>>>>>//                with anchor technique. Removed unnessary property in the
81363>>>>>//                sysinfo dialog. Changed the size Of the about & sysinfo dialog
81363>>>>>//                object To better look in Windows XP. Repositioned the close
81363>>>>>//                button in the sysinfo dialog To line up with the display area
81363>>>>>//                Replaced obsolete code and techniques. Removed dead code.
81363>>>>>// JJT 10/23/2001 removed all ghoworkspace support. Uses app object or nothing
81363>>>>>// SWB 07/19/01   Added support Of the Application object in preference to
81363>>>>>//                the global Workspace object, if it is present
81363>>>>>// JJT 11/05/98   Added version information
81363>>>>>// VOO 29/10/98   Replaced the GetFreeSystemResources for the Win32 variant
81363>>>>>// JJT 7/31/97    Registered Enumerate Workspace so dfabout can exist without
81363>>>>>//                workspace package.
81363>>>>>// JJT 6/27/97    Turned the sysinfo objects into classes so the AboutDialog
81363>>>>>//                class can create this object.
81363>>>>>//                Cleaned up the interface (used correct classes and messages)
81363>>>>>//                Added workspace reporting support To sys-info.
81363>>>>>//                Turned off wrapping in the sys-info editor.
81363>>>>>// KR  ??/??/96   File created
81363>>>>>//************************************************************************
81363>>>>>Use LanguageText.pkg
81363>>>>>Use Windows.pkg
81363>>>>>Use DFbitmap.pkg
81363>>>>>Use GlobalFunctionsProcedures.pkg
81363>>>>>Use cTextEdit.pkg
81363>>>>>
81363>>>>>Use cli.pkg
Including file: cli.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cli.pkg)
81363>>>>>>>//*****************************************************************************
81363>>>>>>>//*** CLI.PKG                                                               ***
81363>>>>>>>//***                                                                       ***
81363>>>>>>>//*** Author: Ben Weijers                                                   ***
81363>>>>>>>//***         Data Access Nederland                                         ***
81363>>>>>>>//***         10 September 1998                                             ***
81363>>>>>>>//***                                                                       ***
81363>>>>>>>//*** Purpose:                                                              ***
81363>>>>>>>//***   CLI specific functionality. There are several connectivity kits     ***
81363>>>>>>>//***   based on  SQL/92 CLI. Those are:                                    ***
81363>>>>>>>//***    - ODBC_DRV  The Data Access CK for ODBC                            ***
81363>>>>>>>//***    - DB2_DRV   The Data Access CK for DB2                             ***
81363>>>>>>>//***    - MSSQLDRV  The Data Access CK for Microsoft SQL Server            ***
81363>>>>>>>//***                                                                       ***
81363>>>>>>>//***   This package defines the common functionality for all CLI based     ***
81363>>>>>>>//***   drivers.                                                            ***
81363>>>>>>>//***                                                                       ***
81363>>>>>>>//***   Updated:  May 23rd 2008 (Current CK build: 5.0.0.53 )               ***
81363>>>>>>>//***             Added NULLABLE and DEFAULT attributes for DATETIME type   ***
81363>>>>>>>//***   Updated:  Apr  6th 2009 (Current CK build: 5.0.0.61 )               ***
81363>>>>>>>//***             Added DF_DRIVER_MATCH_CLIENT_SERVER_VERSION attribute     ***
81363>>>>>>>//***                   DF_DRIVER_SQLSERVER_CLIENT_VERSION    attribute     ***
81363>>>>>>>//***   Updated:  Mar 30th 2012 (Current CK build: 5.1.0.93 )               ***
81363>>>>>>>//***             Added SQLSERVER2012CLIENT return value for                ***
81363>>>>>>>//***             DF_DRIVER_SQLSERVER_CLIENT_VERSION attribute              ***
81363>>>>>>>//***   Updated:  June 4th 2012 (Current CK build: 5.1.0.96)                ***
81363>>>>>>>//***             Moved SQL Server client constants from cli.pkg to         ***
81363>>>>>>>//***             mssqldrv.pkg                                              ***
81363>>>>>>>//***   Updated:  april 23, 2013 (Current CK build: 6.0.0.4)                ***
81363>>>>>>>//***             Added type mappings attributes                            ***
81363>>>>>>>//***   Updated:  october 11, 2013 (Current CK build: 6.0.0.18)             ***
81363>>>>>>>//***             Added DF_FILE_SQL_FILTER_EQ attribute                     ***
81363>>>>>>>//*****************************************************************************
81363>>>>>>>
81363>>>>>>>//*** We are not using ifndef below because that is not supported in Character Mode
81363>>>>>>>//*** Driver attributes
81363>>>>>>>
81363>>>>>>>
81363>>>>>>>
81363>>>>>>>
81363>>>>>>>
81363>>>>>>>
81363>>>>>>>
81363>>>>>>>
81363>>>>>>>
81363>>>>>>>//------------------------------------------------------------
81363>>>>>>>
81363>>>>>>>
81363>>>>>>>//-------------------------------------
81363>>>>>>>
81363>>>>>>>
81363>>>>>>>
81363>>>>>>>//*** Replacement for logical column number that indicates all columns
81363>>>>>>>
81363>>>>>>>//*** Possible DF_FILE_GENERATE_RECORD_ID_METHOD values
81363>>>>>>>
81363>>>>>>>//*** Possible DF_FIELD_READ_ONLY values
81363>>>>>>>
81363>>>>>>>
81363>>>>>>>//*** Possible DF_DRIVER_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA values
81363>>>>>>>// #Replace MAP_DF_TO_SQL_TYPE_CK5        1       
81363>>>>>>>// #Replace MAP_DF_TO_SQL_TYPE_CK6        2   
81363>>>>>>>
81363>>>>>>>
81363>>>>>>>// Moved to Mssqldrv.pkg
81363>>>>>>>//*** Possible DF_DRIVER_SQLSERVER_CLIENT_VERSION values
81363>>>>>>>//#REPLACE SQLSERVERUNKNOWNCLIENT  0
81363>>>>>>>//#REPLACE SQLSERVER2000CLIENT     8          //   "SQL Server"
81363>>>>>>>//#REPLACE SQLSERVER2005CLIENT     9          //   "SQL Native Client"
81363>>>>>>>//#REPLACE SQLSERVER2008CLIENT    10          //   "SQL Server Native Client 10.0"
81363>>>>>>>//#Replace SQLSERVER2012CLIENT    11          //   "SQL Server Native Client 11.0"
81363>>>>>>>
81363>>>>>>>//*** Possible SQL Column type values
81363>>>>>>>Define SQL_UNKNOWN_TYPE   For    0
81363>>>>>>>Define SQL_CHAR           For    1
81363>>>>>>>Define SQL_NUMERIC        For    2
81363>>>>>>>Define SQL_DECIMAL        For    3
81363>>>>>>>Define SQL_INTEGER        For    4
81363>>>>>>>Define SQL_SMALLINT       For    5
81363>>>>>>>Define SQL_FLOAT          For    6
81363>>>>>>>Define SQL_REAL           For    7
81363>>>>>>>Define SQL_DOUBLE         For    8
81363>>>>>>>Define SQL_DATETIME       For    9
81363>>>>>>>Define SQL_VARCHAR        For   12
81363>>>>>>>Define SQL_TYPE_DATE      For   91
81363>>>>>>>Define SQL_TYPE_TIME      For   92
81363>>>>>>>Define SQL_TYPE_TIMESTAMP for   93
81363>>>>>>>// Moved to mssqldrv.pkg
81363>>>>>>>//Define SQL_TYPE_TIMESTAMP2 for   (-200) //SQL server datetime2 type */
81363>>>>>>>
81363>>>>>>>
81363>>>>>>>Define SQL_DATE           For    9
81363>>>>>>>Define SQL_INTERVAL       For   10
81363>>>>>>>Define SQL_TIME           For   10
81363>>>>>>>Define SQL_TIMESTAMP      For   11
81363>>>>>>>Define SQL_LONGVARCHAR    For  (-1)
81363>>>>>>>Define SQL_BINARY         For  (-2)
81363>>>>>>>Define SQL_VARBINARY      For  (-3)
81363>>>>>>>Define SQL_LONGVARBINARY  For  (-4)
81363>>>>>>>Define SQL_BIGINT         For  (-5)
81363>>>>>>>Define SQL_TINYINT        For  (-6)
81363>>>>>>>Define SQL_BIT            For  (-7)
81363>>>>>>>Define SQL_WCHAR          For  (-8)
81363>>>>>>>Define SQL_WVARCHAR       For  (-9)
81363>>>>>>>Define SQL_WLONGVARCHAR   For (-10)
81363>>>>>>>Define SQL_GUID           For (-11)
81363>>>>>>>
81363>>>>>>>//*** Driver level attributes
81363>>>>>>>
81363>>>>>>>
81363>>>>>>>//*** Error number constants
81363>>>>>>>
81363>>>>>>>
81363>>>>>>>//*** Call driver function identifiers
81363>>>>>>>
81363>>>>>>>
81363>>>>>>>//*** Init data source types
81363>>>>>>>
81363>>>>>>>
81363>>>>>>>//*** Dummy strings used in the commands
81363>>>>>>>    String  CLI$StrDummy 255
81363>>>>>>>    Integer CLI$IntDummy
81363>>>>>>>
81363>>>>>>>
81363>>>>>>>//*****************************************************************************
81363>>>>>>>//*** CLI_SetConstraint <FileNum> <NewState>                                ***
81363>>>>>>>//***                                                                       ***
81363>>>>>>>//***   Setup a constraint for a file.                                      ***
81363>>>>>>>//*****************************************************************************
81363>>>>>>>
81363>>>>>>>
81363>>>>>>>
81363>>>>>>>
81363>>>>>>>//*****************************************************************************
81363>>>>>>>//*** CLI_Set_Driver_Atrtribute / CLI_Get_Driver_Attribute                  ***
81363>>>>>>>//***                                                                       ***
81363>>>>>>>//*** Set or get an attribute at driver level. These attributes, when set,  ***
81363>>>>>>>//*** will be set for the remainder of the session or until set again. To   ***
81363>>>>>>>//*** permanently set driver level attributes change the driver             ***
81363>>>>>>>//*** configuration file.                                                   ***
81363>>>>>>>//*****************************************************************************
81363>>>>>>>
81363>>>>>>>
81363>>>>>>>
81363>>>>>>>
81363>>>>>>>
81363>>>>>>>
81363>>>>>>>
81363>>>>>>>//*****************************************************************************
81363>>>>>>>//*** Class  : cCLIHandler                                                  ***
81363>>>>>>>//*** Purpose: An instance of this class can be used as a broker object to  ***
81363>>>>>>>//***          call several CLI releated methods.                           ***
81363>>>>>>>//*****************************************************************************
81363>>>>>>>
81363>>>>>>>Class cCLIHandler Is An Array
81364>>>>>>>
81364>>>>>>>    Procedure Construct_Object Integer iImage
81366>>>>>>>        Forward Send Construct_object iImage
81368>>>>>>>
81368>>>>>>>        Property String  psDriverID       Public ""
81369>>>>>>>    End_Procedure // Construct_Object
81370>>>>>>>
81370>>>>>>>
81370>>>>>>>
81370>>>>>>>    //***
81370>>>>>>>    //*** Fucntion: CKRevsion
81370>>>>>>>    //*** Purpose : The revsion of a CLI Connectivity Kit
81370>>>>>>>    //***
81370>>>>>>>
81370>>>>>>>    Function CKRevision Returns String
81372>>>>>>>        Local String  sDriverID
81372>>>>>>>        Local String  sRevision
81372>>>>>>>        Local String  sVoid
81372>>>>>>>        Local Integer iRetval
81372>>>>>>>
81372>>>>>>>        Get psDriverID To sDriverID
81373>>>>>>>        If (sDRiverID <> "") Begin
81375>>>>>>>            Move (Repeat(" ", 255)) To sRevision
81376>>>>>>>            Call_Driver 0 sDRiverID Function CLI_CKREVISION Callback 0 Passing sRevision sVoid 0 Result iRetval
81381>>>>>>>        End
81381>>>>>>>>
81381>>>>>>>
81381>>>>>>>        Function_Return sRevision
81382>>>>>>>    End_Function // CKRevision
81383>>>>>>>
81383>>>>>>>
81383>>>>>>>
81383>>>>>>>    //***
81383>>>>>>>    //*** Function: ExtractPartFromRevision
81383>>>>>>>    //*** Purpose : Extarct the Nth part of a a.b.c.d revsion string.
81383>>>>>>>    //***
81383>>>>>>>    //*** Returns : The part version number or -1 if there is no such part number.
81383>>>>>>>    //***
81383>>>>>>>
81383>>>>>>>    Function ExtractPartFromRevision Integer iPartNum String sRevision Returns Integer
81385>>>>>>>        Local Integer iPartRev
81385>>>>>>>        Local Integer iCurrentPart
81385>>>>>>>        Local Integer iSeparatorPos
81385>>>>>>>
81385>>>>>>>        If (iPartNum > 4) ;            Function_Return -1
81388>>>>>>>
81388>>>>>>>        Move 0 To iCurrentPart
81389>>>>>>>        Repeat
81389>>>>>>>>
81389>>>>>>>            Move (Pos(".", sRevision)) To iSeparatorPos
81390>>>>>>>            If (iSeparatorPos > 0) Begin
81392>>>>>>>                Move (Left(sRevision, iSeparatorPos - 1)) To iPartRev
81393>>>>>>>                Move (Right(sRevision, Length(sRevision) - iSeparatorPos)) To sRevision
81394>>>>>>>                Increment iCurrentPart
81395>>>>>>>            End
81395>>>>>>>>
81395>>>>>>>            Else If (sRevision <> "") Begin
81398>>>>>>>                Move sRevision To iPartRev
81399>>>>>>>                Move "" To sRevision
81400>>>>>>>                Increment iCurrentPart
81401>>>>>>>            End
81401>>>>>>>>
81401>>>>>>>            Else ;                Move -1 To iPartRev
81403>>>>>>>        Until (iCurrentPart >= iPartNum Or iPartRev = -1)
81405>>>>>>>
81405>>>>>>>        Function_Return iPartRev
81406>>>>>>>    End_Function // EcxtractPartFromRevision
81407>>>>>>>
81407>>>>>>>
81407>>>>>>>
81407>>>>>>>    //***
81407>>>>>>>    //*** Function: CKMajorRevision
81407>>>>>>>    //*** Purpose : Returns the major revision of the CK
81407>>>>>>>    //***
81407>>>>>>>
81407>>>>>>>    Function CKMajorRevision Returns Integer
81409>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 1, CKRevision(Current_Object)))
81410>>>>>>>    End_Function // CKMajorRevision
81411>>>>>>>
81411>>>>>>>
81411>>>>>>>
81411>>>>>>>    //***
81411>>>>>>>    //*** Function: CKMinorRevision
81411>>>>>>>    //*** Purpose : Returns the minor revision of the CK
81411>>>>>>>    //***
81411>>>>>>>
81411>>>>>>>    Function CKMinorRevision Returns Integer
81413>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 2, CKRevision(Current_Object)))
81414>>>>>>>    End_Function // CKMinorRevision
81415>>>>>>>
81415>>>>>>>
81415>>>>>>>
81415>>>>>>>    //***
81415>>>>>>>    //*** Function: CKReleaseRevision
81415>>>>>>>    //*** Purpose : Returns the release revision of the CK
81415>>>>>>>    //***
81415>>>>>>>
81415>>>>>>>    Function CKReleaseRevision Returns Integer
81417>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 3, CKRevision(Current_Object)))
81418>>>>>>>    End_Function // CKReleaseRevision
81419>>>>>>>
81419>>>>>>>
81419>>>>>>>
81419>>>>>>>    //***
81419>>>>>>>    //*** Function: CKBuildRevision
81419>>>>>>>    //*** Purpose : Returns the major revision of the CK
81419>>>>>>>    //***
81419>>>>>>>
81419>>>>>>>    Function CKBuildRevision Returns Integer
81421>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 4, CKRevision(Current_Object)))
81422>>>>>>>    End_Function // CKBuildRevision
81423>>>>>>>
81423>>>>>>>
81423>>>>>>>
81423>>>>>>>    //***
81423>>>>>>>    //*** Function: IsMinimalRevision
81423>>>>>>>    //*** Purpose : Determines if the CK conforms to a passed minimal revsion.
81423>>>>>>>    //***
81423>>>>>>>
81423>>>>>>>    Function IsMinimalRevision Integer iMajor Integer iMinor Integer iRelease Integer iBuild Returns Integer
81425>>>>>>>        If (iMajor < CKMajorRevision(Current_object)) ;            Function_return (TRUE)
81428>>>>>>>        Else If (iMajor = CKMajorRevision(Current_object)) Begin
81431>>>>>>>            If (iMinor < CKMinorRevision(Current_object)) ;                Function_return (TRUE)
81434>>>>>>>            Else If (iMinor = CKMinorRevision(Current_object)) Begin
81437>>>>>>>                If (iRelease < CKReleaseRevision(Current_object)) ;                    Function_return (TRUE)
81440>>>>>>>                Else If (iRelease = CKReleaseRevision(Current_object) And iBuild <= CKBuildRevision(Current_object)) ;                    Function_return (TRUE)
81444>>>>>>>            End
81444>>>>>>>>
81444>>>>>>>        End
81444>>>>>>>>
81444>>>>>>>
81444>>>>>>>        Function_Return (FALSE)
81445>>>>>>>    End_Function // IsMinimalRevision
81446>>>>>>>
81446>>>>>>>
81446>>>>>>>
81446>>>>>>>    //***
81446>>>>>>>    //*** Function: RegistrationName
81446>>>>>>>    //*** Purpose : Returns the Connectiivty Kit registration name.
81446>>>>>>>    //***
81446>>>>>>>
81446>>>>>>>    Function RegistrationName Returns String
81448>>>>>>>        Local String  sRegistration
81448>>>>>>>        Local String  sDRiverId
81448>>>>>>>        Local String  sVoid
81448>>>>>>>        Local Integer iRetval
81448>>>>>>>
81448>>>>>>>        Get psDriverID To sDriverID
81449>>>>>>>        If (sDRiverID <> "") Begin
81451>>>>>>>            Move (Repeat(" ", 255)) To sRegistration
81452>>>>>>>            Call_Driver 0 sDRiverID Function CLI_GETREGNAME Callback 0 Passing sRegistration sVoid 0 Result iRetval
81457>>>>>>>        End
81457>>>>>>>>
81457>>>>>>>
81457>>>>>>>        Function_Return sRegistration
81458>>>>>>>    End_Function // RegistrationName
81459>>>>>>>
81459>>>>>>>
81459>>>>>>>
81459>>>>>>>    //***
81459>>>>>>>    //*** Function: SerialNumber
81459>>>>>>>    //*** Purpose : Returns the Connectiivty Kit serial number.
81459>>>>>>>    //***
81459>>>>>>>
81459>>>>>>>    Function SerialNumber Returns Integer
81461>>>>>>>        Local String  sDRiverId
81461>>>>>>>        Local String  sVoid
81461>>>>>>>        Local Integer iRetval
81461>>>>>>>
81461>>>>>>>        Get psDriverID To sDriverID
81462>>>>>>>        If (sDRiverID <> "") Begin
81464>>>>>>>            Call_Driver 0 sDRiverID Function CLI_GETSERIALNUM Callback 0 Passing sVoid sVoid 0 Result iRetval
81469>>>>>>>        End
81469>>>>>>>>
81469>>>>>>>
81469>>>>>>>        Function_Return iRetval
81470>>>>>>>    End_Function // SerialNumber
81471>>>>>>>
81471>>>>>>>
81471>>>>>>>
81471>>>>>>>    //***
81471>>>>>>>    //*** Function: MaxUsers
81471>>>>>>>    //*** Purpose : Returns the Connectiivty Kit maximum number of users.
81471>>>>>>>    //***
81471>>>>>>>
81471>>>>>>>    Function MaxUsers Returns Integer
81473>>>>>>>        Local String  sDRiverId
81473>>>>>>>        Local String  sVoid
81473>>>>>>>        Local Integer iRetval
81473>>>>>>>
81473>>>>>>>        Get psDriverID To sDriverID
81474>>>>>>>        If (sDRiverID <> "") Begin
81476>>>>>>>            Call_Driver 0 sDRiverID Function CLI_GETMAXUSERS Callback 0 Passing sVoid sVoid 0 Result iRetval
81481>>>>>>>        End
81481>>>>>>>>
81481>>>>>>>
81481>>>>>>>        Function_Return iRetval
81482>>>>>>>    End_Function // MaxUsers
81483>>>>>>>
81483>>>>>>>
81483>>>>>>>
81483>>>>>>>    //***
81483>>>>>>>    //*** Procedure: DumpStatus
81483>>>>>>>    //*** Purpose  : Dump the current status of the drver in the passed disk file.
81483>>>>>>>    //***
81483>>>>>>>
81483>>>>>>>    Procedure DumpStatus String sFileName
81485>>>>>>>        Local String  sVoid
81485>>>>>>>        Local String  sDriverID
81485>>>>>>>        Local Integer iVoid
81485>>>>>>>
81485>>>>>>>        Get psDriverID To sDriverID
81486>>>>>>>        If (sDriverID <> "") ;            Call_driver 0 sDriverID Function CLI_DUMPSTATUS Callback 0 Passing sFileName sVoid iVoid Result iVoid
81493>>>>>>>    End_Procedure // DumpStatus
81494>>>>>>>
81494>>>>>>>
81494>>>>>>>
81494>>>>>>>    //***
81494>>>>>>>    //*** Procedure: ReadConfiguration
81494>>>>>>>    //*** Purpose  : Reset all driver level configurable attributes to the
81494>>>>>>>    //***            default value and then reread the configuration.
81494>>>>>>>    //***
81494>>>>>>>
81494>>>>>>>    Procedure ReadConfiguration
81496>>>>>>>        Local String  sVoid
81496>>>>>>>        Local String  sDriverID
81496>>>>>>>        Local Integer iVoid
81496>>>>>>>
81496>>>>>>>        Get psDriverID To sDriverID
81497>>>>>>>        If (sDriverID <> "") ;            Call_driver 0 sDriverID Function CLI_READCONFIGURATION Callback 0 Passing sVoid sVoid iVoid Result iVoid
81504>>>>>>>    End_Procedure // ReadConfiguration
81505>>>>>>>
81505>>>>>>>
81505>>>>>>>
81505>>>>>>>    //***
81505>>>>>>>    //*** Function: TextToRIMValue
81505>>>>>>>    //*** Purpose : Convert a text to the corresponding
81505>>>>>>>    //***           Generate_Record_ID_Method attribute value
81505>>>>>>>    //***
81505>>>>>>>
81505>>>>>>>    Function TextToRIMValue String sText Returns Integer
81507>>>>>>>        If (sText = "None") ;            Function_return RIM_NONE
81510>>>>>>>        Else If (sText = "Identity Column") ;            Function_return RIM_IDENTITY_COLUMN
81514>>>>>>>        Else If (sText = "Dispenser Table") ;            Function_return RIM_DISPENSER_TABLE
81518>>>>>>>        Else If (sText = "External") ;            Function_return RIM_EXTERNAL
81522>>>>>>>    End_Function // TextToRIMValue
81523>>>>>>>
81523>>>>>>>
81523>>>>>>>
81523>>>>>>>    //***
81523>>>>>>>    //*** Function: RIMValueTotext
81523>>>>>>>    //*** Purpose : Convert a Generate_Record_ID_Method attribute value to the
81523>>>>>>>    //***           corresponding text.
81523>>>>>>>    //***
81523>>>>>>>
81523>>>>>>>    Function RIMValueToText Integer iAttrValue Returns String
81525>>>>>>>        If (iAttrValue = RIM_NONE) ;            Function_return "None"
81528>>>>>>>        Else If (iAttrValue = RIM_IDENTITY_COLUMN) ;            Function_return "Identity Column"
81532>>>>>>>        Else If (iAttrValue = RIM_DISPENSER_TABLE) ;            Function_return "Dispenser Table"
81536>>>>>>>        Else If (iAttrValue = RIM_EXTERNAL) ;            Function_return "External"
81540>>>>>>>    End_Function // RIMValueToText
81541>>>>>>>
81541>>>>>>>
81541>>>>>>>
81541>>>>>>>    //***
81541>>>>>>>    //*** Function: TextToROValue
81541>>>>>>>    //*** Purpose : Convert a text to the corresponding
81541>>>>>>>    //***           Generate_Record_ID_Method attribute value
81541>>>>>>>    //***
81541>>>>>>>
81541>>>>>>>    Function TextToROValue String sText Returns Integer
81543>>>>>>>        If (sText = "No") ;            Function_return RO_NO
81546>>>>>>>        Else If (sText = "Ignore Change") ;            Function_return RO_IGNORECHANGE
81550>>>>>>>        Else If (sText = "Accept Change") ;            Function_return RO_ACCEPTCHANGE
81554>>>>>>>        Else If (sText = "Error On Change") ;            Function_return RO_ERRORONCHANGE
81558>>>>>>>    End_Function // TextToRIMValue
81559>>>>>>>
81559>>>>>>>
81559>>>>>>>
81559>>>>>>>    //***
81559>>>>>>>    //*** Function: ROValueTotext
81559>>>>>>>    //*** Purpose : Convert a Generate_Record_ID_Method attribute value to the
81559>>>>>>>    //***           corresponding text.
81559>>>>>>>    //***
81559>>>>>>>
81559>>>>>>>    Function ROValueToText Integer iAttrValue Returns String
81561>>>>>>>        If (iAttrValue = RO_NO) ;            Function_return "No"
81564>>>>>>>        Else If (iAttrValue = RO_IGNORECHANGE) ;            Function_return "Ignore Change"
81568>>>>>>>        Else If (iAttrValue = RO_ACCEPTCHANGE) ;            Function_return "Accept Change"
81572>>>>>>>        Else If (iAttrValue = RO_ERRORONCHANGE) ;            Function_return "Error On Change"
81576>>>>>>>    End_Function // RIMValueToText
81577>>>>>>>
81577>>>>>>>
81577>>>>>>>
81577>>>>>>>    //***
81577>>>>>>>    //*** Function: LastDriverError
81577>>>>>>>    //*** Purpose : Return the text f the last error geneated by the driver.
81577>>>>>>>    //***
81577>>>>>>>
81577>>>>>>>    Function LastDriverError Returns String
81579>>>>>>>        Local String  sDriverID
81579>>>>>>>        Local String  sLastError
81579>>>>>>>        Local String  sLastErrorLength
81579>>>>>>>        Local Integer iLastErrorLength
81579>>>>>>>        Local Integer iVoid
81579>>>>>>>
81579>>>>>>>        //*** Initialize
81579>>>>>>>        Move "" To sLastError
81580>>>>>>>
81580>>>>>>>        Get psDriverID To sDriverID
81581>>>>>>>        If (sDriverID <> "") Begin
81583>>>>>>>            //*** Get the text of the last error
81583>>>>>>>            Move (Repeat(Character(" "), 14)) To sLastErrorlength
81584>>>>>>>            Call_driver 0 sDriverID Function CLI_GETDRIVERATTRIBUTE Callback 0 Passing sLastErrorLength iVoid DRVR_LASTERRORTEXTLENGTH Result iVoid
81589>>>>>>>            Move (Left(sLastErrorLength, Pos(Character(0), sLastErrorLength) - 1)) To iLastErrorLength
81590>>>>>>>
81590>>>>>>>            If (iLastErrorLength > 0) Begin
81592>>>>>>>                Move (Repeat(Character(" "), iLastErrorLength + 1)) To sLastError
81593>>>>>>>                Call_driver 0 sDriverID Function CLI_GETDRIVERATTRIBUTE Callback 0 Passing sLastError iVoid DRVR_LASTERRORTEXT Result iVoid
81598>>>>>>>                Move (Left(sLastError, Pos(Character(0), sLastError) - 1)) To sLastError
81599>>>>>>>            End
81599>>>>>>>>
81599>>>>>>>        End
81599>>>>>>>>
81599>>>>>>>
81599>>>>>>>        Function_Return sLastError
81600>>>>>>>    End_Function // LastDriverError
81601>>>>>>>
81601>>>>>>>
81601>>>>>>>
81601>>>>>>>    //***
81601>>>>>>>    //*** Function: EnumerateTables
81601>>>>>>>    //*** Purpose : Enumerate the tables in a database
81601>>>>>>>    //***
81601>>>>>>>
81601>>>>>>>    Function EnumerateTables String sLogin Returns Integer
81603>>>>>>>        Local String  sDriver
81603>>>>>>>        Local String  sVoid
81603>>>>>>>        Local Integer iNumTables
81603>>>>>>>        Local Integer iVoid
81603>>>>>>>
81603>>>>>>>        Get psDriverID To sDriver
81604>>>>>>>        If (sDriver <> "") ;            Call_driver 0 sDriver Function CLI_ENUMERATE_TABLES Callback 0 Passing sLogin sVoid iVoid Result iNumTables
81611>>>>>>>
81611>>>>>>>        Function_Return iNumTables
81612>>>>>>>    End_Function // EnumerateTables
81613>>>>>>>
81613>>>>>>>
81613>>>>>>>
81613>>>>>>>    //***
81613>>>>>>>    //*** Function: TableName
81613>>>>>>>    //*** Purpose : Returns the name of the table enumerated at the given position
81613>>>>>>>    //***
81613>>>>>>>
81613>>>>>>>    Function TableName Integer iIndex Returns String
81615>>>>>>>        Local String  sDriver
81615>>>>>>>        Local String  sTableName
81615>>>>>>>        Local String  sVoid
81615>>>>>>>        Local Integer iVoid
81615>>>>>>>
81615>>>>>>>        Get psDriverID To sDriver
81616>>>>>>>        If (sDriver <> "") Begin
81618>>>>>>>            Move (Repeat(" ", 255)) To sTableName
81619>>>>>>>            Call_driver 0 sDriver Function CLI_TABLENAME Callback 0 Passing sTableName sVoid iIndex Result iVoid
81624>>>>>>>        End
81624>>>>>>>>
81624>>>>>>>
81624>>>>>>>        Function_Return sTableName
81625>>>>>>>    End_Function // TableName
81626>>>>>>>
81626>>>>>>>
81626>>>>>>>
81626>>>>>>>    //***
81626>>>>>>>    //*** Function: SchemaName
81626>>>>>>>    //*** Purpose : Returns the name of the schema of the table enumerated at the given position
81626>>>>>>>    //***
81626>>>>>>>
81626>>>>>>>    Function SchemaName Integer iIndex Returns String
81628>>>>>>>        Local String  sDriver
81628>>>>>>>        Local String  sSchemaName
81628>>>>>>>        Local String  sVoid
81628>>>>>>>        Local Integer iVoid
81628>>>>>>>
81628>>>>>>>        Get psDriverID To sDriver
81629>>>>>>>        If (sDriver <> "") Begin
81631>>>>>>>            Move (Repeat(" ", 255)) To sSchemaName
81632>>>>>>>            Call_driver 0 sDriver Function CLI_TABLESCHEMA Callback 0 Passing sSchemaName sVoid iIndex Result iVoid
81637>>>>>>>        End
81637>>>>>>>>
81637>>>>>>>
81637>>>>>>>        Function_Return sSchemaName
81638>>>>>>>    End_Function // SchemaName
81639>>>>>>>
81639>>>>>>>
81639>>>>>>>
81639>>>>>>>    //***
81639>>>>>>>    //*** Function: TableType
81639>>>>>>>    //*** Purpose : Returns the type of the table enumerated at the given position.
81639>>>>>>>    //***           Types can be "TABLE", "VIEW", "SYSTEM TABLE", "GLOBAL TEMPORARY",
81639>>>>>>>    //***           "LOCAL TEMPORARY", "ALIAS", "SYNONYM"
81639>>>>>>>    //***
81639>>>>>>>
81639>>>>>>>    Function TableType Integer iIndex Returns String
81641>>>>>>>        Local String  sDriver
81641>>>>>>>        Local String  sTableType
81641>>>>>>>        Local String  sVoid
81641>>>>>>>        Local Integer iVoid
81641>>>>>>>
81641>>>>>>>        Get psDriverID To sDriver
81642>>>>>>>        If (sDriver <> "") Begin
81644>>>>>>>            Move (Repeat(" ", 25)) To sTableType
81645>>>>>>>            Call_driver 0 sDriver Function CLI_TABLETYPE Callback 0 Passing sTableType sVoid iIndex Result iVoid
81650>>>>>>>        End
81650>>>>>>>>
81650>>>>>>>
81650>>>>>>>        Function_Return sTableType
81651>>>>>>>    End_Function // TableType
81652>>>>>>>
81652>>>>>>>
81652>>>>>>>
81652>>>>>>>    //***
81652>>>>>>>    //*** Function: TableComment
81652>>>>>>>    //*** Purpose : Returns the comment of the table enumerated at the given position
81652>>>>>>>    //***
81652>>>>>>>
81652>>>>>>>    Function TableComment Integer iIndex Returns String
81654>>>>>>>        Local String  sDriver
81654>>>>>>>        Local String  sTableComment
81654>>>>>>>        Local String  sVoid
81654>>>>>>>        Local Integer iVoid
81654>>>>>>>
81654>>>>>>>        Get psDriverID To sDriver
81655>>>>>>>        If (sDriver <> "") Begin
81657>>>>>>>            Move (Repeat(" ", 255)) To sTableComment
81658>>>>>>>            Call_driver 0 sDriver Function CLI_TABLECOMMENT Callback 0 Passing sTableComment sVoid iIndex Result iVoid
81663>>>>>>>        End
81663>>>>>>>>
81663>>>>>>>
81663>>>>>>>        Function_Return sTableComment
81664>>>>>>>    End_Function // TableComment
81665>>>>>>>
81665>>>>>>>
81665>>>>>>>
81665>>>>>>>    //***
81665>>>>>>>    //*** Function: EnumerateColumns
81665>>>>>>>    //*** Purpose : Enumerate the columns in a table
81665>>>>>>>    //***
81665>>>>>>>
81665>>>>>>>    Function EnumerateColumns String sLogin String sTableName Returns Integer
81667>>>>>>>        Local String  sDriver
81667>>>>>>>        Local Integer iNumColumns
81667>>>>>>>        Local Integer iVoid
81667>>>>>>>
81667>>>>>>>        Get psDriverID To sDriver
81668>>>>>>>        If (sDriver <> "") ;            Call_driver 0 sDriver Function CLI_ENUMERATE_COLUMNS Callback 0 Passing sLogin sTablename iVoid Result iNumColumns
81675>>>>>>>
81675>>>>>>>        Function_Return iNumColumns
81676>>>>>>>    End_Function // EnumerateColumns
81677>>>>>>>
81677>>>>>>>
81677>>>>>>>
81677>>>>>>>    //***
81677>>>>>>>    //*** Function: ColumnName
81677>>>>>>>    //*** Purpose : Returns the name of the column enumerated at the given position
81677>>>>>>>    //***
81677>>>>>>>
81677>>>>>>>    Function ColumnName Integer iIndex Returns String
81679>>>>>>>        Local String  sDriver
81679>>>>>>>        Local String  sColumnName
81679>>>>>>>        Local String  sVoid
81679>>>>>>>        Local Integer iVoid
81679>>>>>>>
81679>>>>>>>        Get psDriverID To sDriver
81680>>>>>>>        If (sDriver <> "") Begin
81682>>>>>>>            Move (Repeat(" ", 255)) To sColumnName
81683>>>>>>>            Call_driver 0 sDriver Function CLI_COLUMNNAME Callback 0 Passing sColumnName sVoid iIndex Result iVoid
81688>>>>>>>        End
81688>>>>>>>>
81688>>>>>>>
81688>>>>>>>        Function_Return sColumnName
81689>>>>>>>    End_Function // ColumnName
81690>>>>>>>
81690>>>>>>>
81690>>>>>>>
81690>>>>>>>    //***
81690>>>>>>>    //*** Function: CLIDFDateToSQLDate
81690>>>>>>>    //*** Purpose : Convert a DataFlex date to a SQL date using the dummy zero date value.
81690>>>>>>>    //***
81690>>>>>>>
81690>>>>>>>    Function CLIDFDateToSQLDate String sDRiver Date dDFDate Returns String
81692>>>>>>>        Local String sSQLDate
81692>>>>>>>        Local Integer iOrgDateFmt
81692>>>>>>>        Local Integer iOrgDateSep
81692>>>>>>>
81692>>>>>>>        //*** Change date format to military, SQL dates are military dates
81692>>>>>>>        Get_Attribute DF_DATE_FORMAT To iOrgDateFmt
81695>>>>>>>        Get_Attribute DF_DATE_SEPARATOR To iOrgDateSep
81698>>>>>>>        Set_Attribute DF_DATE_FORMAT To DF_DATE_MILITARY
81701>>>>>>>        Set_Attribute DF_DATE_SEPARATOR To (Ascii('-'))
81704>>>>>>>
81704>>>>>>>        //*** We only need to convert if the date is 0
81704>>>>>>>        If (Integer(dDFDate = 0)) ;            CLI_Get_Driver_Attribute sDRiver DRVR_DUMMY_ZERO_DATE_VALUE To sSQLDate
81713>>>>>>>        Else ;            Move dDFDate To sSQLDate
81715>>>>>>>
81715>>>>>>>        //*** Change date format back to original
81715>>>>>>>        Set_Attribute DF_DATE_FORMAT To iOrgDateFmt
81718>>>>>>>        Set_Attribute DF_DATE_SEPARATOR To iOrgDateSep
81721>>>>>>>
81721>>>>>>>        Function_Return sSQLDate
81722>>>>>>>    End_Function // CLIDFDateToSQLDate
81723>>>>>>>
81723>>>>>>>
81723>>>>>>>
81723>>>>>>>    //***
81723>>>>>>>    //*** Function: CLISQLDateToDFDate
81723>>>>>>>    //*** Purpose : Convert a SQL date to a DataFlex date using the dummy zero date value.
81723>>>>>>>    //***
81723>>>>>>>
81723>>>>>>>    Function CLISQLDateToDFDate String sDRiver String sSQLDate Returns Date
81725>>>>>>>        Local Date dDFDate
81725>>>>>>>        Local String sDummyDateValue
81725>>>>>>>        Local Integer iOrgDateFmt
81725>>>>>>>        Local Integer iOrgDateSep
81725>>>>>>>
81725>>>>>>>        //*** Change date format to military, SQL dates are military dates
81725>>>>>>>        Get_Attribute DF_DATE_FORMAT To iOrgDateFmt
81728>>>>>>>        Get_Attribute DF_DATE_SEPARATOR To iOrgDateSep
81731>>>>>>>        Set_Attribute DF_DATE_FORMAT To DF_DATE_MILITARY
81734>>>>>>>        Set_Attribute DF_DATE_SEPARATOR To (Ascii('-'))
81737>>>>>>>
81737>>>>>>>        //*** We only need to convert if the date is the dummy zero date value
81737>>>>>>>        CLI_Get_Driver_Attribute sDRiver DRVR_DUMMY_ZERO_DATE_VALUE To sDummyDateValue
81744>>>>>>>        If (sDummyDateValue = sSQLDate) ;            Move 0 To dDFDate
81747>>>>>>>        Else ;            Move sSQLDate To dDFDate
81749>>>>>>>
81749>>>>>>>        //*** Change date format back to original
81749>>>>>>>        Set_Attribute DF_DATE_FORMAT To iOrgDateFmt
81752>>>>>>>        Set_Attribute DF_DATE_SEPARATOR To iOrgDateSep
81755>>>>>>>
81755>>>>>>>        Function_Return dDFDate
81756>>>>>>>    End_Function // CLISQLDateToDFDate
81757>>>>>>>
81757>>>>>>>
81757>>>>>>>
81757>>>>>>>    //***
81757>>>>>>>    //*** Function: RedirectConnection
81757>>>>>>>    //*** Purpose : Redirect an exisitng connection. The existing connection
81757>>>>>>>    //***           will point to another database but all tables will stay
81757>>>>>>>    //***           open!
81757>>>>>>>    //***
81757>>>>>>>
81757>>>>>>>    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
81759>>>>>>>        Local String  sDriver
81759>>>>>>>        Local String  sVoid
81759>>>>>>>        Local Integer iResult
81759>>>>>>>        Local Integer iVoid
81759>>>>>>>
81759>>>>>>>        Get psDriverID To sDriver
81760>>>>>>>        If (sDriver <> "") Begin
81762>>>>>>>            Call_driver 0 sDriver Function CLI_REDIRECTCONNECTION Callback 0 Passing sOldConnection sNewConnection iVoid Result iResult
81767>>>>>>>        End
81767>>>>>>>>
81767>>>>>>>        Function_Return iResult
81768>>>>>>>    End_Function // RedirectConnect
81769>>>>>>>
81769>>>>>>>
81769>>>>>>>
81769>>>>>>>    //***
81769>>>>>>>    //*** Function: CreateConnectionID
81769>>>>>>>    //*** Purpose : Create a DataFlex side connection id that can be used later on.
81769>>>>>>>    //***
81769>>>>>>>
81769>>>>>>>    Function CreateConnectionID String sID String sConnStr Integer iOpt Returns Integer
81771>>>>>>>        Local String  sDriver
81771>>>>>>>        Local Integer iResult
81771>>>>>>>        Local Integer iOptions
81771>>>>>>>
81771>>>>>>>        Get psDriverID to sDriver
81772>>>>>>>        If (Num_Arguments = 2) ;            Move 0 to iOptions
81775>>>>>>>        Else ;            Move iOpt to iOptions
81777>>>>>>>        If (sDriver <> "") Begin
81779>>>>>>>            Call_Driver 0 sDriver Function CLI_CREATECONNECTIONID Callback 0 Passing sID sConnStr iOptions Result iResult
81784>>>>>>>        End
81784>>>>>>>>
81784>>>>>>>        Function_Return iResult
81785>>>>>>>    End_Function // CreateConnectionID
81786>>>>>>>
81786>>>>>>>
81786>>>>>>>
81786>>>>>>>    //***
81786>>>>>>>    //*** Function: DeleteConnectionID
81786>>>>>>>    //*** Purpose : Delete a DataFlex side connection id.
81786>>>>>>>    //***
81786>>>>>>>
81786>>>>>>>    Function DeleteConnectionID String sID Integer iIndex Returns Integer
81788>>>>>>>        Local String  sDriver
81788>>>>>>>        Local Integer iResult
81788>>>>>>>        Local String sVoid
81788>>>>>>>
81788>>>>>>>        Get psDriverID To sDriver
81789>>>>>>>        If (sDriver <> "") Begin
81791>>>>>>>            Call_Driver 0 sDriver Function CLI_DELETECONNECTIONID Callback 0 Passing sID sVoid iIndex Result iResult
81796>>>>>>>        End
81796>>>>>>>>
81796>>>>>>>        Function_Return iResult
81797>>>>>>>    End_Function // DeleteConnectionID
81798>>>>>>>
81798>>>>>>>End_Class // cCLIHandler
81799>>>>>Use DFBTRDRV.PKG
Including file: DFBTRDRV.PKG    (C:\Program Files (x86)\DataFlex 18.2\Pkg\DFBTRDRV.PKG)
81799>>>>>>>//****************************************************************************
81799>>>>>>>//
81799>>>>>>>// $File name  : DFBTRDRV.PKG
81799>>>>>>>// $File title : Package for the DataFlex Connectivity Kit for Pervasive.SQL
81799>>>>>>>// Notice      : This package contains constants and commands, used to call
81799>>>>>>>//               specific functions in the DFBTRDRV.
81799>>>>>>>// $Author(s)  : Eddy Kleinjan
81799>>>>>>>//
81799>>>>>>>// $System     : DataFlex Connectivity Kit for Pervasive.SQL
81799>>>>>>>// Created     : 01-07-97 @ 12:00:00
81799>>>>>>>//
81799>>>>>>>// Changed     : 04-04-2001.
81799>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 1.3.0.145
81799>>>>>>>//
81799>>>>>>>// Changed     : June 6, 2001
81799>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 1.3.0.148
81799>>>>>>>//
81799>>>>>>>//               Added DFBTR_DDF_OWNER command.
81799>>>>>>>//
81799>>>>>>>// Changed     : June 12, 2001
81799>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 1.3.0.149
81799>>>>>>>//
81799>>>>>>>//               Added DF_FIELD_IS_NULL and DF_FIELD_NULL_ALLOWED attributes
81799>>>>>>>//
81799>>>>>>>// Changed     : August 4, 2004
81799>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 3.0.0.1
81799>>>>>>>//
81799>>>>>>>//               Added cDfbtrdrvHandler class.
81799>>>>>>>//               New functions in this class:
81799>>>>>>>//                  Function CKRevision Returns String
81799>>>>>>>//                  Function CkUsesUri Returns Integer
81799>>>>>>>//                  Function PSQLRequesterVersionInfo Integer iFileNum Returns String
81799>>>>>>>//                  Function PSQLLocalEngineVersionInfo Integer iFileNum Returns String
81799>>>>>>>//                  Function PSQLServerEngineVersionInfo Integer iFileNum Returns String
81799>>>>>>>//
81799>>>>>>>// Changed     : September 30, 2005
81799>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 3.0.0.14
81799>>>>>>>//
81799>>>>>>>//               Bugfix: Prevent compiler errors when no (df)error.pkg is used
81799>>>>>>>//****************************************************************************
81799>>>>>>>Use Ui
81799>>>>>>>//
81799>>>>>>>// Driver Indentification
81799>>>>>>>//
81799>>>>>>>
81799>>>>>>>//*** Driver attributes
81799>>>>>>>//
81799>>>>>>>// Call_Driver functions ID's
81799>>>>>>>//
81799>>>>>>>//
81799>>>>>>>// DFBTRFN_CONVERT_FILE options
81799>>>>>>>//
81799>>>>>>>
81799>>>>>>>//
81799>>>>>>>// DFBTRFN_SET_OWNER options
81799>>>>>>>//
81799>>>>>>>
81799>>>>>>>//
81799>>>>>>>// DFBTRFN_SET_TRANSACTION_TYPE options
81799>>>>>>>//
81799>>>>>>>
81799>>>>>>>
81799>>>>>>>//
81799>>>>>>>// Command to create all vars which may be needed
81799>>>>>>>// in other commands.
81799>>>>>>>//
81799>>>>>>>
81799>>>>>>>
81799>>>>>>>
81799>>>>>>>//
81799>>>>>>>// Command to set the owner of a Btrieve file.
81799>>>>>>>// File must have been opened.
81799>>>>>>>// Filenumber needs to be passed.
81799>>>>>>>// To clear set the owner to "".
81799>>>>>>>// Examples:
81799>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret"
81799>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY CALLBACK MyCallBack
81799>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" ENCRYPT
81799>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY ENCRYPT CALLBACK MyCallBack
81799>>>>>>>// To clear:
81799>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to ""
81799>>>>>>>//
81799>>>>>>>
81799>>>>>>>
81799>>>>>>>
81799>>>>>>>//
81799>>>>>>>// Command to parse DFBTR_SET_OWNVER
81799>>>>>>>// options.
81799>>>>>>>//
81799>>>>>>>
81799>>>>>>>
81799>>>>>>>
81799>>>>>>>//
81799>>>>>>>// Command to parse for Callback
81799>>>>>>>//
81799>>>>>>>
81799>>>>>>>
81799>>>>>>>
81799>>>>>>>//
81799>>>>>>>// Command to clear the owner of a Btrieve file.
81799>>>>>>>// File must have been opened.
81799>>>>>>>// Filenumber needs to be passed.
81799>>>>>>>// Examples:
81799>>>>>>>//      DFBTR_CLEAR_OWNER MyFileNumber
81799>>>>>>>//
81799>>>>>>>
81799>>>>>>>
81799>>>>>>>
81799>>>>>>>//
81799>>>>>>>// Command to add a owner name to the internal list of ownernames
81799>>>>>>>// which will be tries when opening files.
81799>>>>>>>//
81799>>>>>>>
81799>>>>>>>
81799>>>>>>>
81799>>>>>>>//
81799>>>>>>>// Command to remove all owners from the internal list of ownernames
81799>>>>>>>//
81799>>>>>>>
81799>>>>>>>
81799>>>>>>>//
81799>>>>>>>// Command to set the owner name to be used when opening the DDF files.
81799>>>>>>>// The DDF owner is required when Pervasive.SQL security is turned on.
81799>>>>>>>// The DDF owner is equal to the password of the Master user in Pervasive.SQL
81799>>>>>>>// This command overwrites the DDF_OWNER setting in DFBTRDRV.INT
81799>>>>>>>//
81799>>>>>>>
81799>>>>>>>//
81799>>>>>>>// Command to change the transaction type.
81799>>>>>>>// Valid types are:
81799>>>>>>>//     DFBTRTT_NONE
81799>>>>>>>//     DFBTRTT_EXCLUSIVE
81799>>>>>>>//     DFBTRTT_CONCURRENT
81799>>>>>>>//
81799>>>>>>>//
81799>>>>>>>
81799>>>>>>>
81799>>>>>>>
81799>>>>>>>//
81799>>>>>>>// Command to get the current transaction type.
81799>>>>>>>//
81799>>>>>>>
81799>>>>>>>//
81799>>>>>>>// Command to set explicit_locking
81799>>>>>>>//
81799>>>>>>>
81799>>>>>>>//
81799>>>>>>>// Command to get explicit locking
81799>>>>>>>//
81799>>>>>>>
81799>>>>>>>//
81799>>>>>>>// Command to set detection for incompatible positive signs in numeric fields
81799>>>>>>>//
81799>>>>>>>
81799>>>>>>>//
81799>>>>>>>// Command to get detection for incompatible positive signs in numeric fields
81799>>>>>>>//
81799>>>>>>>
81799>>>>>>>//*****************************************************************************
81799>>>>>>>//*** Class  : cDfbtrdrvHandler                                                  ***
81799>>>>>>>//*** Purpose: An instance of this class can be used as a broker object to  ***
81799>>>>>>>//***          call several Dfbtrdrv releated methods.                           ***
81799>>>>>>>//*****************************************************************************
81799>>>>>>>
81799>>>>>>>Class cDFBtrDrvHandler Is An Array
81800>>>>>>>
81800>>>>>>>    Procedure Construct_Object Integer iImage
81802>>>>>>>        Forward Send Construct_object iImage
81804>>>>>>>
81804>>>>>>>        Property String  psDriverID       Public "DFBTRDRV"
81805>>>>>>>    End_Procedure // Construct_Object
81806>>>>>>>
81806>>>>>>>
81806>>>>>>>
81806>>>>>>>    //***
81806>>>>>>>    //*** Function: CKRevsion
81806>>>>>>>    //*** Purpose : The revsion of a Dfbtrdrv Connectivity Kit
81806>>>>>>>    //***
81806>>>>>>>
81806>>>>>>>    Function CKRevision Returns String
81808>>>>>>>        Local String  sDriverID
81808>>>>>>>        Local String  sRevision
81808>>>>>>>        Local String  sVoid
81808>>>>>>>        Local Integer iRetval
81808>>>>>>>
81808>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
81808>>>>>>>        // This error would otherwise be raised when we have an older
81808>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
81808>>>>>>>        Send Ignore_error To Error_object_Id 20491
81809>>>>>>>        Get psDriverID To sDriverID
81810>>>>>>>        Move (Repeat(" ", 255)) To sRevision
81811>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKREVISION Callback 0 Passing sRevision sVoid 0 Result iRetval
81816>>>>>>>        Send Trap_Error To Error_object_Id 20491
81817>>>>>>>        If (Trim(sRevision) = "") Begin
81819>>>>>>>            // Unable to get the revision. return all zeroes.
81819>>>>>>>            Move "0.0.0.0" To sRevision
81820>>>>>>>        End
81820>>>>>>>>
81820>>>>>>>        Function_Return sRevision
81821>>>>>>>    End_Function // CKRevision
81822>>>>>>>
81822>>>>>>>    Function CkUsesUri Returns Integer
81824>>>>>>>        Local String  sDriverID
81824>>>>>>>        Local String  sVoid1
81824>>>>>>>        Local String  sVoid2
81824>>>>>>>        Local Integer iRetval
81824>>>>>>>
81824>>>>>>>        Get psDriverID To sDriverID
81825>>>>>>>
81825>>>>>>>        Move 0 To iRetval
81826>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
81826>>>>>>>        // This error would otherwise be raised when we have an older
81826>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKUSESURI function
81826>>>>>>>        Send Ignore_error To Error_object_Id 20491
81827>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKUSESURI Callback 0 Passing sVoid1 sVoid2 0 Result iRetval
81832>>>>>>>        Send Trap_Error To Error_object_Id 20491
81833>>>>>>>
81833>>>>>>>        Function_Return iRetval
81834>>>>>>>    End_Function // CKUsesUri
81835>>>>>>>
81835>>>>>>>
81835>>>>>>>
81835>>>>>>>    //***
81835>>>>>>>    //*** Function: ExtractPartFromRevsion
81835>>>>>>>    //*** Purpose : Extarct the Nth part of a a.b.c.d revsion string.
81835>>>>>>>    //***
81835>>>>>>>    //*** Returns : The part version number or -1 if there is no such part number.
81835>>>>>>>    //***
81835>>>>>>>
81835>>>>>>>    Function ExtractPartFromRevision Integer iPartNum String sRevision Returns Integer
81837>>>>>>>        Local Integer iPartRev
81837>>>>>>>        Local Integer iCurrentPart
81837>>>>>>>        Local Integer iSeparatorPos
81837>>>>>>>
81837>>>>>>>        If (iPartNum > 4) ;            Function_Return -1
81840>>>>>>>
81840>>>>>>>        Move 0 To iCurrentPart
81841>>>>>>>        Repeat
81841>>>>>>>>
81841>>>>>>>            Move (Pos(".", sRevision)) To iSeparatorPos
81842>>>>>>>            If (iSeparatorPos > 0) Begin
81844>>>>>>>                Move (Left(sRevision, iSeparatorPos - 1)) To iPartRev
81845>>>>>>>                Move (Right(sRevision, Length(sRevision) - iSeparatorPos)) To sRevision
81846>>>>>>>                Increment iCurrentPart
81847>>>>>>>            End
81847>>>>>>>>
81847>>>>>>>            Else If (sRevision <> "") Begin
81850>>>>>>>                Move sRevision To iPartRev
81851>>>>>>>                Move "" To sRevision
81852>>>>>>>                Increment iCurrentPart
81853>>>>>>>            End
81853>>>>>>>>
81853>>>>>>>            Else ;                Move -1 To iPartRev
81855>>>>>>>        Until (iCurrentPart >= iPartNum Or iPartRev = -1)
81857>>>>>>>
81857>>>>>>>        Function_Return iPartRev
81858>>>>>>>    End_Function // EcxtractPartFromRevision
81859>>>>>>>
81859>>>>>>>
81859>>>>>>>
81859>>>>>>>    //***
81859>>>>>>>    //*** Function: CKMajorRevision
81859>>>>>>>    //*** Purpose : Returns the major revision of the CK
81859>>>>>>>    //***
81859>>>>>>>
81859>>>>>>>    Function CKMajorRevision Returns Integer
81861>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 1, CKRevision(Current_Object)))
81862>>>>>>>    End_Function // CKMajorRevision
81863>>>>>>>
81863>>>>>>>
81863>>>>>>>
81863>>>>>>>    //***
81863>>>>>>>    //*** Function: CKMinorRevision
81863>>>>>>>    //*** Purpose : Returns the minor revision of the CK
81863>>>>>>>    //***
81863>>>>>>>
81863>>>>>>>    Function CKMinorRevision Returns Integer
81865>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 2, CKRevision(Current_Object)))
81866>>>>>>>    End_Function // CKMinorRevision
81867>>>>>>>
81867>>>>>>>
81867>>>>>>>
81867>>>>>>>    //***
81867>>>>>>>    //*** Function: CKReleaseRevision
81867>>>>>>>    //*** Purpose : Returns the release revision of the CK
81867>>>>>>>    //***
81867>>>>>>>
81867>>>>>>>    Function CKReleaseRevision Returns Integer
81869>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 3, CKRevision(Current_Object)))
81870>>>>>>>    End_Function // CKReleaseRevision
81871>>>>>>>
81871>>>>>>>
81871>>>>>>>
81871>>>>>>>    //***
81871>>>>>>>    //*** Function: CKBuildRevision
81871>>>>>>>    //*** Purpose : Returns the major revision of the CK
81871>>>>>>>    //***
81871>>>>>>>
81871>>>>>>>    Function CKBuildRevision Returns Integer
81873>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 4, CKRevision(Current_Object)))
81874>>>>>>>    End_Function // CKBuildRevision
81875>>>>>>>
81875>>>>>>>
81875>>>>>>>
81875>>>>>>>    //***
81875>>>>>>>    //*** Function: IsMinimalRevision
81875>>>>>>>    //*** Purpose : Determines if the CK conforms to a passed minimal revsion.
81875>>>>>>>    //***
81875>>>>>>>
81875>>>>>>>    Function IsMinimalRevision Integer iMajor Integer iMinor Integer iRelease Integer iBuild Returns Integer
81877>>>>>>>        If (iMajor < CKMajorRevision(Current_object)) ;            Function_return (TRUE)
81880>>>>>>>        Else If (iMajor = CKMajorRevision(Current_object)) Begin
81883>>>>>>>            If (iMinor < CKMinorRevision(Current_object)) ;                Function_return (TRUE)
81886>>>>>>>            Else If (iMinor = CKMinorRevision(Current_object)) Begin
81889>>>>>>>                If (iRelease < CKReleaseRevision(Current_object)) ;                    Function_return (TRUE)
81892>>>>>>>                Else If (iRelease = CKReleaseRevision(Current_object) And iBuild <= CKBuildRevision(Current_object)) ;                    Function_return (TRUE)
81896>>>>>>>            End
81896>>>>>>>>
81896>>>>>>>        End
81896>>>>>>>>
81896>>>>>>>
81896>>>>>>>        Function_Return (FALSE)
81897>>>>>>>    End_Function // IsMinimalRevision
81898>>>>>>>
81898>>>>>>>    //   Functions to query the Pervasive.SQL version:
81898>>>>>>>    //       PSQLRequesterVersionInfo    Integer iFileNum Returns String
81898>>>>>>>    //       PSQLLocalEngineVersionInfo  Integer iFileNum Returns String
81898>>>>>>>    //       PSQLServerEngineVersionInfo Integer iFileNum Returns String
81898>>>>>>>    //
81898>>>>>>>    //   All 3 functions return the version of a Pervasive.SQL component
81898>>>>>>>    //   in the following format:
81898>>>>>>>    //       <version>.<revision>.<type>
81898>>>>>>>    //   possible values for <type>:
81898>>>>>>>    //       9 for 32-bit Windows workstation/workgroup engine or Linux
81898>>>>>>>    //         server using Workgroup authentication mode
81898>>>>>>>    //       C for client cache engine
81898>>>>>>>    //       D for DOS workstation
81898>>>>>>>    //       N for client Requester
81898>>>>>>>    //       S for NetWare server
81898>>>>>>>    //       T for 32-bit Windows server engine
81898>>>>>>>    //       U for Linux server using PAM or BTPASSWD authentication
81898>>>>>>>    //
81898>>>>>>>    //   example:
81898>>>>>>>    //       8.50.T
81898>>>>>>>    //   will be returned for a Pervasive.SQL 8.5 Server Engine running on
81898>>>>>>>    //   32-bits Windows server.
81898>>>>>>>    //
81898>>>>>>>    //   The FileNumber parameter must specify an opened table or 0.
81898>>>>>>>    //   For PSQLServerEngineVersionInfo the FileNumber can not be 0.
81898>>>>>>>    //
81898>>>>>>>    //   If the version information is not available or can not be obtained
81898>>>>>>>    //   the functions will return "0.0.0"
81898>>>>>>>
81898>>>>>>>
81898>>>>>>>    //***
81898>>>>>>>    //*** Function: PSQLRequesterVersionInfo
81898>>>>>>>    //*** Purpose : Returns the version information of the
81898>>>>>>>    //***           Pervasive.SQL Client requester.
81898>>>>>>>
81898>>>>>>>    Function PSQLRequesterVersionInfo Integer iFileNum Returns String
81900>>>>>>>
81900>>>>>>>        Local String  sDriverID
81900>>>>>>>        Local String  sVersion
81900>>>>>>>        Local String  sVoid
81900>>>>>>>        Local Integer iRetval
81900>>>>>>>
81900>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
81900>>>>>>>        // This error would otherwise be raised when we have an older
81900>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
81900>>>>>>>        Send Ignore_error To Error_object_Id 20491
81901>>>>>>>        Get psDriverID To sDriverID
81902>>>>>>>        Move (Repeat(" ", 255)) To sVersion
81903>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLREQUESTERVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
81908>>>>>>>        Send Trap_Error To Error_object_Id 20491
81909>>>>>>>        If (Trim(sVersion) = "") Begin
81911>>>>>>>            // Unable to get the revision. return all zeroes.
81911>>>>>>>            Move "0.0.0" To sVersion
81912>>>>>>>        End
81912>>>>>>>>
81912>>>>>>>        Function_Return sVersion
81913>>>>>>>    End_Function //  PSQLRequesterVersion
81914>>>>>>>
81914>>>>>>>    //***
81914>>>>>>>    //*** Function: PSQLLocalEngineVersionInfo
81914>>>>>>>    //*** Purpose : Returns the version information of the
81914>>>>>>>    //***           Pervasive.SQL Local Engine
81914>>>>>>>
81914>>>>>>>    Function PSQLLocalEngineVersionInfo Integer iFileNum Returns String
81916>>>>>>>
81916>>>>>>>        Local String  sDriverID
81916>>>>>>>        Local String  sVersion
81916>>>>>>>        Local String  sVoid
81916>>>>>>>        Local Integer iRetval
81916>>>>>>>
81916>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
81916>>>>>>>        // This error would otherwise be raised when we have an older
81916>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
81916>>>>>>>        Send Ignore_error To Error_object_Id 20491
81917>>>>>>>        Get psDriverID To sDriverID
81918>>>>>>>        Move (Repeat(" ", 255)) To sVersion
81919>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLLOCALENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
81924>>>>>>>        Send Trap_Error To Error_object_Id 20491
81925>>>>>>>        If (Trim(sVersion) = "") Begin
81927>>>>>>>            // Unable to get the revision. return all zeroes.
81927>>>>>>>            Move "0.0.0" To sVersion
81928>>>>>>>        End
81928>>>>>>>>
81928>>>>>>>        Function_Return sVersion
81929>>>>>>>    End_Function //  PSQLLocalEngineVersion
81930>>>>>>>
81930>>>>>>>    //***
81930>>>>>>>    //*** Function: PSQLServerEngineVersionInfo
81930>>>>>>>    //*** Purpose : Returns the version information of the
81930>>>>>>>    //***           Pervasive.SQL Server Engine
81930>>>>>>>
81930>>>>>>>    Function PSQLServerEngineVersionInfo Integer iFileNum Returns String
81932>>>>>>>
81932>>>>>>>        Local String  sDriverID
81932>>>>>>>        Local String  sVersion
81932>>>>>>>        Local String  sVoid
81932>>>>>>>        Local Integer iRetval
81932>>>>>>>
81932>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
81932>>>>>>>        // This error would otherwise be raised when we have an older
81932>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
81932>>>>>>>        Send Ignore_error To Error_object_Id 20491
81933>>>>>>>        Get psDriverID To sDriverID
81934>>>>>>>        Move (Repeat(" ", 255)) To sVersion
81935>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLSERVERENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
81940>>>>>>>        Send Trap_Error To Error_object_Id 20491
81941>>>>>>>        If (Trim(sVersion) = "") Begin
81943>>>>>>>            // Unable to get the revision. return all zeroes.
81943>>>>>>>            Move "0.0.0" To sVersion
81944>>>>>>>        End
81944>>>>>>>>
81944>>>>>>>        Function_Return sVersion
81945>>>>>>>    End_Function //  PSQLServerEngineVersion
81946>>>>>>>
81946>>>>>>>End_Class // cDfbtrdrvHandler
81947>>>>>>>
81947>>>>>
81947>>>>>
81947>>>>>External_Function WNetGetUser "WNetGetUserA" MPR.DLL Pointer lpName Pointer lpUser_Name Pointer lpLength Returns DWord
81948>>>>>
81948>>>>>Register_Function phoWorkspace Returns Handle
81948>>>>>Register_Function Help_filename Returns String
81948>>>>>Register_Function GetHelpFile Returns String
81948>>>>>Register_Function pbEnterKeyAsTabKey Returns Boolean
81948>>>>>
81948>>>>>//****************************************************************************
81948>>>>>// $Module type: FUNCTION
81948>>>>>// $Module name: Network_User_Name
81948>>>>>// $Author     : AK/VOO/KCR
81948>>>>>// Created     : 09-24-96 @ 19:17
81948>>>>>//
81948>>>>>// Description
81948>>>>>//    This function reads the current username Of windows and returns that
81948>>>>>//    name or an text unknown user
81948>>>>>//
81948>>>>>// $Rev History
81948>>>>>//  02/22/2012  Ask Windows how long the size of the name should be
81948>>>>>//  07/25/2003  Replaced obsolete code
81948>>>>>//  09/24/1996  Module header created
81948>>>>>//****************************************************************************
81948>>>>>Function Network_User_Name for cDesktop Returns String
81950>>>>>    String sName
81950>>>>>    Integer iRetval iLength
81950>>>>>
81950>>>>>    Move 0 to iLength
81951>>>>>    Move (WNetGetUser (0, 0, AddressOf (iLength))) to iRetval
81952>>>>>    ZeroString iLength to sName
81953>>>>>    Move (WNetGetUser (0, AddressOf (sName), AddressOf (iLength))) to iRetval
81954>>>>>
81954>>>>>    If (iRetval = NO_ERROR) Begin
81956>>>>>        Function_Return (CString (sName))
81957>>>>>    End
81957>>>>>>
81957>>>>>    
81957>>>>>    Function_Return "User Unknown"
81958>>>>>End_Function
81959>>>>>
81959>>>>>// OBSOLETE STRUCTURE AND WINDOWS API CALL. KEPT FOR BACKWARDS COMPATIBILITY
81959>>>>>Type MEMORYSTATUS
81959>>>>>   Field MEMORYSTATUS.dwLength         as DWord // sizeof(MEMORYSTATUS)
81959>>>>>   Field MEMORYSTATUS.dwMemoryLoad     as DWord // percent Of memory in use
81959>>>>>   Field MEMORYSTATUS.dwTotalPhys      as DWord // bytes Of physical memory
81959>>>>>   Field MEMORYSTATUS.dwAvailPhys      as DWord // free physical memory bytes
81959>>>>>   Field MEMORYSTATUS.dwTotalPageFile  as DWord // bytes Of paging file
81959>>>>>   Field MEMORYSTATUS.dwAvailPageFile  as DWord // free bytes Of paging file
81959>>>>>   Field MEMORYSTATUS.dwTotalVirtual   as DWord // user bytes Of address space
81959>>>>>   Field MEMORYSTATUS.dwAvailVirtual   as DWord // free user bytes
81959>>>>>End_Type // MEMORYSTATUS
81959>>>>>
81959>>>>>External_Function GlobalMemoryStatus "GlobalMemoryStatus" Kernel32.Dll Pointer lpsMemoryStatus Returns Integer
81960>>>>>
81960>>>>>Struct tWinMemoryStatusEx
81960>>>>>    UInteger dwLength                
81960>>>>>    UInteger dwMemoryLoad          
81960>>>>>    UBigInt ullTotalPhys           
81960>>>>>    UBigInt ullAvailPhys           
81960>>>>>    UBigInt ullTotalPageFile       
81960>>>>>    UBigInt ullAvailPageFile       
81960>>>>>    UBigInt ullTotalVirtual        
81960>>>>>    UBigInt ullAvailVirtual        
81960>>>>>    UBigInt ullAvailExtendedVirtual
81960>>>>>End_Struct
81960>>>>>
81960>>>>>External_Function GlobalMemoryStatusEx "GlobalMemoryStatusEx" Kernel32.Dll Pointer lpMemoryStatus Returns Integer
81961>>>>>
81961>>>>>Class SysinfoDisplay is a cTextEdit
81962>>>>>    Procedure Construct_Object
81964>>>>>        Forward Send Construct_Object
81966>>>>>
81966>>>>>        Set Location To 6 6
81967>>>>>        Set Size To 110 255
81968>>>>>        Set Read_Only_State To True
81969>>>>>        Set pbWrap to False
81970>>>>>    End_Procedure
81971>>>>>
81971>>>>>    //****************************************************************************
81971>>>>>    // $Module type: PROCEDURE
81971>>>>>    // $Module name: Show_Current_Directory
81971>>>>>    // $Author     : VOO
81971>>>>>    // Created     : 06-10-96 @ 15:24
81971>>>>>    //
81971>>>>>    // Description
81971>>>>>    //    This method will show the name Of the current directory in the system
81971>>>>>    //    information box
81971>>>>>    //
81971>>>>>    // $Rev History
81971>>>>>    //    06-10-96  Module header created
81971>>>>>    //****************************************************************************
81971>>>>>    Procedure Show_Current_Directory
81973>>>>>        String sDir
81973>>>>>
81973>>>>>        Get_Current_Directory To sDir
81974>>>>>
81974>>>>>        Send AppendTextLn (SFormat (C_$CurrentDirectory, sDir))
81975>>>>>    End_Procedure
81976>>>>>
81976>>>>>    Procedure Show_Windows_Directory
81978>>>>>        String sWindir
81978>>>>>
81978>>>>>        Get_Windows_Directory To sWindir
81979>>>>>
81979>>>>>        Send AppendTextLn (SFormat (C_$WindowsDirectory, sWindir))
81980>>>>>    End_Procedure
81981>>>>>
81981>>>>>    Procedure Show_Current_User
81983>>>>>        Send AppendTextLn (SFormat (C_$NetworkUserName, Network_User_Name (Self)))
81984>>>>>    End_Procedure
81985>>>>>
81985>>>>>    Procedure Show_Number_Format
81987>>>>>        Integer iFormat
81987>>>>>        String sFormatText
81987>>>>>
81987>>>>>        Get_Attribute DF_THOUSANDS_SEPARATOR to iFormat
81990>>>>>        Move (Character (iFormat)) To sFormatText
81991>>>>>        Send AppendTextLn (SFormat (C_$ThousandsSeparator, sFormatText, iFormat))
81992>>>>>
81992>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iFormat
81995>>>>>        Move (Character (iFormat)) to sFormatText
81996>>>>>        Send AppendTextLn (SFormat (C_$DecimalSeparator, sFormatText))
81997>>>>>    End_Procedure
81998>>>>>
81998>>>>>    Procedure Show_Filelist_Name
82000>>>>>        String sFilename
82000>>>>>
82000>>>>>        Get_Attribute DF_FILELIST_NAME to sFilename
82003>>>>>
82003>>>>>        Send AppendTextLn (SFormat (C_$CurrentFilelist, sFilename))
82004>>>>>        Send AppendTextLn ""
82005>>>>>    End_Procedure
82006>>>>>
82006>>>>>    Procedure Show_Lock_Delay
82008>>>>>        Integer iLockdelay
82008>>>>>
82008>>>>>        Get_Attribute DF_LOCK_DELAY to iLockdelay
82011>>>>>
82011>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingDelay, iLockDelay))
82012>>>>>    End_Procedure
82013>>>>>
82013>>>>>    Procedure Show_Lock_Timeout
82015>>>>>        Integer iLockTimeout
82015>>>>>
82015>>>>>        Get_Attribute DF_LOCK_TIMEOUT to iLockTimeout
82018>>>>>
82018>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingTimeout, iLockTimeOut))
82019>>>>>    End_Procedure
82020>>>>>
82020>>>>>    Procedure Show_Screen_Size
82022>>>>>        Integer iYscreensize iXscreensize
82022>>>>>
82022>>>>>        Move (GetSystemMetrics (SM_CXSCREEN)) To iXscreensize
82023>>>>>        Move (GetSystemMetrics (SM_CYSCREEN)) To iYscreensize
82024>>>>>
82024>>>>>        Send AppendTextLn (SFormat (C_$VideoResolution, iXscreensize, iYscreensize))
82025>>>>>    End_Procedure
82026>>>>>
82026>>>>>    Procedure Show_Page_Size
82028>>>>>        Send AppendTextLn (SFormat (C_$PageEndFormFeed, Pageend, Pagefeed))
82029>>>>>    End_procedure
82030>>>>>
82030>>>>>    Procedure Show_Date
82032>>>>>        Date dToday
82032>>>>>
82032>>>>>        Sysdate dToday
82033>>>>>
82033>>>>>        Send AppendTextLn (SFormat (C_$CurrentSystemDate, String (dToday)))
82034>>>>>    End_procedure
82035>>>>>
82035>>>>>    Procedure Show_Date_Format
82037>>>>>        Integer iDateFormat
82037>>>>>        String sDateFormat
82037>>>>>
82037>>>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
82040>>>>>        Case Begin
82040>>>>>            Case (iDateFormat = DF_DATE_USA)
82042>>>>>                Move C_$USA To sDateFormat
82043>>>>>                Case Break
82044>>>>>            Case (iDateFormat = DF_DATE_EUROPEAN)
82047>>>>>                Move C_$European To sDateFormat
82048>>>>>                Case Break
82049>>>>>            Case (iDateFormat = DF_DATE_MILITARY)
82052>>>>>                Move C_$Military To sDateFormat
82053>>>>>                Case Break
82054>>>>>            Case Else
82054>>>>>                Move C_$UnknownDateType To sDateFormat
82055>>>>>                Case Break
82056>>>>>        Case End
82056>>>>>
82056>>>>>        Send AppendTextLn (SFormat (C_$DateFormat, sDateformat))
82057>>>>>    End_Procedure
82058>>>>>
82058>>>>>    Procedure Show_Systemresources
82060>>>>>        tWinMemoryStatusEx MemoryStatusInfo
82060>>>>>        tWinMemoryStatusEx MemoryStatusInfo
82060>>>>>        Integer iRetval
82060>>>>>
82060>>>>>        Move (SizeOfType (tWinMemoryStatusEx)) to MemoryStatusInfo.dwLength
82061>>>>>        Move (GlobalMemoryStatusEx (AddressOf (MemoryStatusInfo))) to iRetval
82062>>>>>        If (iRetval = 0) Begin
82064>>>>>            Move (ShowLastError ()) to iRetval
82065>>>>>        End
82065>>>>>>
82065>>>>>
82065>>>>>        Send AppendTextLn (SFormat (C_$AvailableMemory, MemoryStatusInfo.ullTotalPhys))
82066>>>>>        Send AppendTextLn (SFormat (C_$MemoryUtilization, MemoryStatusInfo.dwMemoryLoad))
82067>>>>>        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, Real (MemoryStatusInfo.ullAvailPhys) / Real (MemoryStatusInfo.ullTotalPhys) * 100.0))
82068>>>>>        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, Real (MemoryStatusInfo.ullAvailPageFile) / Real (MemoryStatusInfo.ullTotalPageFile) * 100.0))
82069>>>>>        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, Real (MemoryStatusInfo.ullAvailVirtual) / Real (MemoryStatusInfo.ullTotalVirtual) * 100.0))
82070>>>>>    End_Procedure
82071>>>>>
82071>>>>>    Procedure Show_Registration
82073>>>>>        String sRegName
82073>>>>>        Integer iSN iMaxUsers
82073>>>>>
82073>>>>>        Registration sRegName iSN
82074>>>>>>
82074>>>>>        
82074>>>>>        Get_Licensed_Max_Users to iMaxUsers
82075>>>>>
82075>>>>>        Send AppendTextLn ""
82076>>>>>        Send AppendTextLn (SFormat (C_$Serial, iSN))
82077>>>>>        Send AppendTextLn (SFormat (C_$RegName, sRegName))
82078>>>>>        Send AppendTextLn (SFormat (C_$MaxNumUsers, iMaxUsers))
82079>>>>>    End_Procedure
82080>>>>>
82080>>>>>    //****************************************************************************
82080>>>>>    // If workspaces are used, we will send the message EnumerateWorkspaceData
82080>>>>>    // To the workspace object passing the an object and message To send back
82080>>>>>    // To this object. It is expected that the workspace object will send this
82080>>>>>    // message for every line Of information it wants displayed (passing the
82080>>>>>    // information To be displayed
82080>>>>>    //****************************************************************************
82080>>>>>    Register_Procedure EnumerateWorkspaceData Integer hObjId Integer hmMessId
82080>>>>>
82080>>>>>    Procedure Show_ServicePack
82082>>>>>        String sKey sVersionDescription sVersion 
82082>>>>>        Handle hoRegistry
82082>>>>>        Boolean bExists bOpened
82082>>>>>        
82082>>>>>        Get Create (RefClass (cRegistry)) to hoRegistry
82083>>>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
82084>>>>>        Set pfAccessRights of hoRegistry to KEY_READ
82085>>>>>
82085>>>>>        Move C_DFVersionRegistryRoot to sKey
82086>>>>>        Get KeyExists of hoRegistry sKey to bExists
82087>>>>>        If (bExists) Begin
82089>>>>>            Get OpenKey of hoRegistry sKey to bOpened
82090>>>>>            If (bOpened) Begin
82092>>>>>                Get ValueExists of hoRegistry "CurrentVersionDescription" to bExists
82093>>>>>                If (bExists) Begin
82095>>>>>                    Get ReadString of hoRegistry "CurrentVersionDescription" to sVersionDescription
82096>>>>>                End
82096>>>>>>
82096>>>>>                
82096>>>>>                Get ValueExists of hoRegistry "CurrentVersion" to bExists
82097>>>>>                If (bExists) Begin
82099>>>>>                    Get ReadString of hoRegistry "CurrentVersion" to sVersion
82100>>>>>                End                
82100>>>>>>
82100>>>>>                Send CloseKey of hoRegistry
82101>>>>>            End
82101>>>>>>
82101>>>>>        End
82101>>>>>>
82101>>>>>        Send Destroy of hoRegistry
82102>>>>>
82102>>>>>        If (sVersionDescription <> "") Begin
82104>>>>>           Send AppendTextLn (sVersionDescription * "-" * sVersion)
82105>>>>>           Send AppendTextLn ""
82106>>>>>        End
82106>>>>>>
82106>>>>>    End_Procedure
82107>>>>>    
82107>>>>>
82107>>>>>    Procedure Show_WorkspaceInformation
82109>>>>>        Integer hoWorkspace
82109>>>>>
82109>>>>>        If (ghoApplication <> 0) Begin
82111>>>>>            Get phoWorkspace of ghoApplication to hoWorkspace
82112>>>>>            If (hoWorkspace <> 0) Begin
82114>>>>>                Send EnumerateWorkspaceData of hoWorkspace Self (Refproc (AppendTextLn))
82115>>>>>                Send AppendTextLn ""
82116>>>>>            End
82116>>>>>>
82116>>>>>        End
82116>>>>>>
82116>>>>>    End_Procedure
82117>>>>>
82117>>>>>    Function VersionStr Integer iVer Integer iRev Integer iBld Returns String
82119>>>>>        Function_Return (String (iVer) - "." - String (iRev) - "." - String (iBld))
82120>>>>>    End_Function
82121>>>>>
82121>>>>>    Procedure Show_Versions
82123>>>>>        Integer iVersion iRevision iBuild
82123>>>>>
82123>>>>>        Version_Information iVersion iRevision iBuild
82125>>>>>
82125>>>>>        Send AppendTextLn (SFormat (C_$RuntimeVersion, VersionStr(Self,iVersion,iRevision,iBuild) ))
82126>>>>>        Send AppendTextLn (SFormat (C_$PackageVersion, VersionStr(Self,PKG_VERSION, PKG_REVISION, PKG_BUILD) ))
82127>>>>>        Send AppendTextLn (SFormat (C_$FMACVersion, VersionStr(Self,FMAC_VERSION, FMAC_REVISION, FMAC_BUILD) ))
82128>>>>>    End_Procedure
82129>>>>>    
82129>>>>>    Function CKRevisionNumber String sDriverID Returns String
82131>>>>>        Handle hoCLIHandler
82131>>>>>        Handle hoDFBtrDrvHandler
82131>>>>>        String sCKRevision
82131>>>>>
82131>>>>>
82131>>>>>        If (sDriverID = "MSSQLDRV" or sDriverID = "ODBC_DRV" or sDriverID = "DB2_DRV") Begin
82133>>>>>            Get Create (RefClass(cCLIHandler)) to hoCLIHandler
82134>>>>>            Set psDriverID of hoCLIHandler to sDriverID
82135>>>>>            Move (CKRevision(hoCLIHandler)) to sCKRevision
82136>>>>>            Send Destroy of hoCLIHandler
82137>>>>>        End
82137>>>>>>
82137>>>>>        Else Begin
82138>>>>>            If (sDriverID = "DFBTRDRV") Begin
82140>>>>>                Get Create (RefClass(cDFBtrDrvHandler)) to hoDFBtrDrvHandler
82141>>>>>                Set psDriverID of hoDFBtrDrvHandler to sDriverID
82142>>>>>                Move (CKRevision(hoDFBtrDrvHandler)) to sCKRevision
82143>>>>>                Send Destroy of hoDFBtrDrvHandler
82144>>>>>            End
82144>>>>>>
82144>>>>>        End
82144>>>>>>
82144>>>>>        
82144>>>>>        Function_Return sCKRevision
82145>>>>>    End_Function
82146>>>>>    
82146>>>>>    
82146>>>>>    Function IsDataAccessCK String sDriverID Returns Boolean
82148>>>>>        
82148>>>>>        If (sDriverID = "DATAFLEX") Begin
82150>>>>>            Function_Return False
82151>>>>>        End
82151>>>>>>
82151>>>>>    
82151>>>>>        Function_Return (sDriverID = "MSSQLDRV" or sDriverID = "ODBC_DRV" or sDriverID = "DB2_DRV" or sDriverID = "DFBTRDRV")
82152>>>>>    End_Function    
82153>>>>>
82153>>>>>
82153>>>>>    //***
82153>>>>>    //*** BW
82153>>>>>    //*** Procedure: Show_Drivers
82153>>>>>    //*** Purpose  : Show loaded database drivers
82153>>>>>    //***
82153>>>>>
82153>>>>>    Procedure Show_Drivers
82155>>>>>        String sCurrentDriver sRevNumber
82155>>>>>        String sLoadedDrivers
82155>>>>>        Integer iNumberOfDrivers iCount
82155>>>>>        Boolean bOK
82155>>>>>
82155>>>>>        Move "" To sLoadedDrivers
82156>>>>>        Get_Attribute DF_NUMBER_DRIVERS To iNumberOfDrivers
82159>>>>>        For iCount From 1 To iNumberOfDrivers
82165>>>>>>
82165>>>>>            Get_Attribute DF_DRIVER_NAME Of iCount To sCurrentDriver
82168>>>>>            If (sLoadedDrivers <> "") Begin
82170>>>>>                Move (Append (sLoadedDrivers, ", ")) To sLoadedDrivers
82171>>>>>            End
82171>>>>>>
82171>>>>>            Get IsDataAccessCK sCurrentDriver to bOK
82172>>>>>            If (bOK) Begin
82174>>>>>                Get CKRevisionNumber sCurrentDriver to sRevNumber
82175>>>>>                Move (sCurrentDriver * "(" + sRevNumber + ")") to sCurrentDriver
82176>>>>>            End
82176>>>>>>
82176>>>>>            Move (Append (sLoadedDrivers, sCurrentDriver)) To sLoadedDrivers
82177>>>>>        Loop
82178>>>>>>
82178>>>>>        Send AppendTextLn (SFormat (C_$DatabaseDriver, sLoadedDrivers))
82179>>>>>    End_Procedure
82180>>>>>
82180>>>>>    Procedure Show_HelpFile
82182>>>>>        String sHelpFile
82182>>>>>        Integer eHelpType
82182>>>>>
82182>>>>>        If (ghoApplication <> 0) Begin
82184>>>>>            Get peHelpType Of ghoApplication To eHelpType
82185>>>>>            If (eHelpType = htHtmlHelp and ghoHtmlHelp) Begin
82187>>>>>                Get GetHelpFile Of ghoHtmlHelp To sHelpFile
82188>>>>>            End
82188>>>>>>
82188>>>>>            Else If (eHelpType = htWinHelp and Help_object_id) Begin
82191>>>>>                Get Help_filename Of Help_object_id To sHelpFile
82192>>>>>            End
82192>>>>>>
82192>>>>>            Else Begin
82193>>>>>                Move C_$ThereIsNoHelpfileDefined To sHelpFile
82194>>>>>            End
82194>>>>>>
82194>>>>>
82194>>>>>            Send AppendTextLn ""
82195>>>>>            Send AppendTextLn (SFormat (C_$HelpFile, sHelpFile))
82196>>>>>        End
82196>>>>>>
82196>>>>>    End_Procedure
82197>>>>>
82197>>>>>    Procedure Show_EnterAsTab
82199>>>>>        Boolean bEnterKeyAsTabKey
82199>>>>>        String sText
82199>>>>>
82199>>>>>        If (ghoApplication <> 0) Begin
82201>>>>>            Get pbEnterKeyAsTabKey Of ghoApplication To bEnterKeyAsTabKey
82202>>>>>            If (bEnterKeyAsTabKey) Begin
82204>>>>>                Move "True" To sText
82205>>>>>            End
82205>>>>>>
82205>>>>>            Else Begin
82206>>>>>                Move "False" To sText
82207>>>>>            End
82207>>>>>>
82207>>>>>            Send AppendTextLn (SFormat (C_$EnterKeyNavForward, sText))
82208>>>>>        End
82208>>>>>>
82208>>>>>    End_Procedure
82209>>>>>
82209>>>>>    //****************************************************************************
82209>>>>>    // $Module type: PROCEDURE
82209>>>>>    // $Module name: Add_Focus
82209>>>>>    // $Author     : VOO
82209>>>>>    // Created     : 24-09-96 @ 19:43
82209>>>>>    //
82209>>>>>    // Description
82209>>>>>    //    During activation we will remove the old information and add the newly
82209>>>>>    //    found systeminformation
82209>>>>>    //
82209>>>>>    // $Rev History
82209>>>>>    //    24-09-96  Module header created
82209>>>>>    //****************************************************************************
82209>>>>>    Procedure Add_Focus Integer hoRoot
82211>>>>>        Forward Send Add_Focus hoRoot
82213>>>>>
82213>>>>>        Send Delete_Data
82214>>>>>
82214>>>>>        Set Changed_State To False
82215>>>>>        Set Read_Only_State To True
82216>>>>>
82216>>>>>        Send Show_ServicePack
82217>>>>>        Send Show_Versions   
82218>>>>>        Send Show_Drivers         
82219>>>>>        Send Show_HelpFile
82220>>>>>        Send Show_Current_Directory
82221>>>>>        Send Show_Filelist_Name          
82222>>>>>        If (ghoApplication <> 0) Begin
82224>>>>>            Send Show_WorkSpaceInformation // added To show WS info
82225>>>>>        End
82225>>>>>>
82225>>>>>        Send Show_Current_User 
82226>>>>>        Send Show_Windows_Directory 
82227>>>>>        Send Show_Screen_Size
82228>>>>>        Send Show_Page_Size
82229>>>>>        Send Show_EnterAsTab        
82230>>>>>        Send Show_Number_Format
82231>>>>>        Send Show_Date_Format
82232>>>>>        Send Show_Lock_Delay
82233>>>>>        Send Show_Lock_Timeout
82234>>>>>        Send Show_Date
82235>>>>>        Send Show_Systemresources
82236>>>>>        Send Show_Registration
82237>>>>>        Send Beginning_of_Data
82238>>>>>
82238>>>>>        Set Icon to 'default.ico'
82239>>>>>    End_Procedure
82240>>>>>End_Class
82241>>>>>
82241>>>>>//****************************************************************************
82241>>>>>// $Module type: OBJECT
82241>>>>>// $Module name: Sysinfo_Dialog
82241>>>>>// $Author     : VOO
82241>>>>>// Created     : 24-09-96 @ 18:47
82241>>>>>//
82241>>>>>// Description
82241>>>>>//    This object shows the systeminformation on the screen
82241>>>>>//
82241>>>>>// $Rev History
82241>>>>>//    24-09-96  Module header created
82241>>>>>//****************************************************************************
82241>>>>>Class SysInfoDialog Is A ModalPanel
82242>>>>>    Procedure Construct_Object
82244>>>>>        Forward Send Construct_Object
82246>>>>>
82246>>>>>        Set Label to C_$SystemInformation
82247>>>>>        Set Size to 140 267
82248>>>>>        Set piMinSize to 140 267
82249>>>>>        Set Locate_Mode To CENTER_ON_SCREEN
82250>>>>>        Set Border_Style to Border_Thick
82251>>>>>
82251>>>>>        Object oSysinfoDisplay Is A SysInfoDisplay
82253>>>>>            Set peAnchors to anAll
82254>>>>>        End_Object
82255>>>>>
82255>>>>>        Object oCloseButton Is A Button
82257>>>>>            Set Label To C_$Close
82258>>>>>            Set Location To 120 210
82259>>>>>            Set Message Item 0 To (Refproc (Close_Panel))
82260>>>>>            Set Default_State To True
82261>>>>>            Set peAnchors to anBottomRight
82262>>>>>        End_Object
82263>>>>>
82263>>>>>        On_Key kCancel Send Close_Panel
82264>>>>>    End_Procedure
82265>>>>>End_Class
82266>>>>>
82266>>>>>// Purpose:
82266>>>>>//
82266>>>>>// Ken Ross 12/17/96 5:16PM
82266>>>>>//
82266>>>>>Class AboutDialog Is A ModalPanel
82267>>>>>    Procedure Construct_Object
82269>>>>>        String sVdfRootDir
82269>>>>>
82269>>>>>        Forward Send Construct_Object
82271>>>>>
82271>>>>>        Set Label To C_$About
82272>>>>>        Set Size to 89 212
82273>>>>>        Set Locate_Mode To CENTER_ON_SCREEN
82274>>>>>
82274>>>>>        Object oSysInfoDialog Is A SysInfoDialog
82276>>>>>        End_Object
82277>>>>>
82277>>>>>        Object oBox Is A Container3d
82279>>>>>            Set Border_Style To Border_StaticEdge
82280>>>>>            Set Size to 63 202
82281>>>>>            Set Location To 4 5
82282>>>>>
82282>>>>>            Object oAboutGraphic Is A BitmapContainer
82284>>>>>                Set Border_Style To Border_None
82285>>>>>                Set Bitmap_Style To Bitmap_Center
82286>>>>>                Set Size To 48 48
82287>>>>>                Set Location To 7 2
82288>>>>>            End_Object
82289>>>>>
82289>>>>>            Object oProductName Is A TextBox
82291>>>>>                Set Label To C_$ProductName
82292>>>>>                Set Size To 10 45
82293>>>>>                Set Location To 8 53
82294>>>>>            End_Object
82295>>>>>
82295>>>>>            Object oVersion Is A TextBox
82297>>>>>                Set Label To C_$Version
82298>>>>>                Set Size To 10 25
82299>>>>>                Set Location To 21 53
82300>>>>>            End_Object
82301>>>>>
82301>>>>>            Object oCopyright Is A TextBox
82303>>>>>                Set Label To C_$Copyright
82304>>>>>                Set Size To 10 31
82305>>>>>                Set Location To 34 53
82306>>>>>            End_Object
82307>>>>>
82307>>>>>            Object oAuthor Is A TextBox
82309>>>>>                Set Label To C_$Author
82310>>>>>                Set Size To 10 22
82311>>>>>                Set Location To 46 53
82312>>>>>            End_Object
82313>>>>>        End_Object
82314>>>>>
82314>>>>>        Object oOKButton Is A Button
82316>>>>>            On_Item C_$OK Send Close_Panel
82317>>>>>            Set Size To 14 50
82318>>>>>            Set Location To 71 157
82319>>>>>        End_Object
82320>>>>>
82320>>>>>        Object oSysInfoButton Is A Button
82322>>>>>            On_Item C_$SystemInfo Send Show_Sysinfo
82323>>>>>            Set Size To 14 50
82324>>>>>            Set Location To 71 101
82325>>>>>        End_Object
82326>>>>>
82326>>>>>        On_Key Kcancel Send KeyAction Of oOKButton
82327>>>>>
82327>>>>>        Set Logo To "DacAbout.bmp"  // square bitmaps Of 42x42 work best
82328>>>>>    End_Procedure
82329>>>>>
82329>>>>>    Procedure Set ProductName String sProductName
82331>>>>>        Set Label Of oProductName To sProductName
82332>>>>>    End_Procedure
82333>>>>>
82333>>>>>    Procedure Set Version String sVersion
82335>>>>>        Set Label Of oVersion To sVersion
82336>>>>>    End_Procedure
82337>>>>>
82337>>>>>    Procedure Set Copyright string sCopyright
82339>>>>>        Set Label Of oCopyright To sCopyright
82340>>>>>    End_Procedure
82341>>>>>
82341>>>>>    Procedure Set Author String sAuthor
82343>>>>>        Set Label Of oAuthor To sAuthor
82344>>>>>    End_Procedure
82345>>>>>
82345>>>>>    Procedure Set Logo string sLogo
82347>>>>>        // square bitmaps Of 42x42 work best
82347>>>>>        Set Bitmap Of oAboutGraphic To sLogo
82348>>>>>    End_Procedure
82349>>>>>
82349>>>>>    Procedure Show_Sysinfo
82351>>>>>        Send Popup_Modal Of oSysinfoDialog
82352>>>>>    End_Procedure
82353>>>>>
82353>>>>>    Procedure End_Construct_Object
82355>>>>>        Handle hoVersionInfo
82355>>>>>        Boolean bIncluded
82355>>>>>        Integer iMajor iMinor iRelease iBuild
82355>>>>>        String sLabel
82355>>>>>
82355>>>>>        Get Label Of oVersion To sLabel
82356>>>>>        If (sLabel = C_$VERSION) Begin
82358>>>>>            // set it To the version info Of the program, if available
82358>>>>>            If (ghoApplication <> 0) Begin
82360>>>>>                Get phoVersionInfo of ghoApplication to hoVersionInfo
82361>>>>>                If (hoVersionInfo <> 0) Begin
82363>>>>>                    Get pbIncluded of hoVersionInfo to bIncluded
82364>>>>>                    If (bIncluded) Begin
82366>>>>>                        Get piVersionMajor of hoVersionInfo to iMajor
82367>>>>>                        Get piVersionMinor of hoVersionInfo to iMinor
82368>>>>>                        Get piVersionRelease of hoVersionInfo to iRelease
82369>>>>>                        Get piVersionBuild of hoVersionInfo to iBuild
82370>>>>>                        Move (SFormat (C_$VERSION + ": %1.%2.%3.%4", iMajor, iMinor, iRelease, iBuild)) to sLabel
82371>>>>>                        Set Version to sLabel
82372>>>>>                    End
82372>>>>>>
82372>>>>>                End
82372>>>>>>
82372>>>>>            End
82372>>>>>>
82372>>>>>        End
82372>>>>>>
82372>>>>>
82372>>>>>        Forward Send End_Construct_Object
82374>>>>>    End_Procedure
82375>>>>>End_Class
82376>>>
82376>>>// *************************************************************************
82376>>>//  Public message. This is the default message. It is expected that you will
82376>>>//   create your own message to override this
82376>>>// *************************************************************************
82376>>>
82376>>>Procedure Activate_About
82379>>>   Send DoAbout "" "" "" "" ""
82380>>>End_Procedure
82381>>>
82381>>>// *************************************************************************
82381>>>//  Public message. It is expected that you will send this message (most
82381>>>//  likely from Activate_About. This creates an about object, activates it
82381>>>//  and destroys it when done. It is not exepected that you will augment this.
82381>>>// *************************************************************************
82381>>>
82381>>>Procedure DoAbout string sTitle string sVersion string sCopyRight string sAuthor string sBitmap
82384>>>        integer hoObj hoMain
82384>>>
82384>>>        // create object
82384>>>        Object About is an AboutDialog
82386>>>            // if no title passed use the label of the main panel
82386>>>            // (if a main panel exists).
82386>>>            if sTitle     eq '' Begin
82388>>>                Get Main_Window of desktop to hoMain
82389>>>                if hoMain Get Label of hoMain to sTitle
82392>>>            end
82392>>>>
82392>>>            set productname to sTitle
82393>>>            set version     to sVersion
82394>>>            set copyright   to sCopyRight
82395>>>            set author      to sAuthor
82396>>>            If sBitmap    ne '' ;               set logo to sBitMap // square bitmaps of 42x42 work best
82399>>>            Move self to hoObj // object Id
82400>>>        End_Object
82401>>>        Send Popup   of hoObj    // popup the about object
82402>>>        Send Destroy of hoObj // when done, it will be destroyed
82403>>>End_procedure
82404>        Use DemoSuggestionForm.vw
Including file: DemoSuggestionForm.vw    (C:\Test\Order Entry git\AppSrc\DemoSuggestionForm.vw)
82404>>>Use Windows.pkg
82404>>>Use DFClient.pkg
82404>>>Use dbSuggestionForm.pkg
Including file: dbSuggestionForm.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\dbSuggestionForm.pkg)
82404>>>>>Use Dfentry.pkg
82404>>>>>Use WinSuggestion.pkg
Including file: WinSuggestion.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\WinSuggestion.pkg)
82404>>>>>>>// 
82404>>>>>>>
82404>>>>>>>Use Windows.pkg
82404>>>>>>>Use tWinStructs.pkg
82404>>>>>>>Use tSuggestion.pkg
Including file: tSuggestion.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\tSuggestion.pkg)
82404>>>>>>>>>// struct used for suggestion forms, representing an item of data
82404>>>>>>>>>Enum_List 
82404>>>>>>>>>    Define smFind
82404>>>>>>>>>    Define smValidationTable
82404>>>>>>>>>    Define smCustom
82404>>>>>>>>>End_Enum_List
82404>>>>>>>>>
82404>>>>>>>>>Struct tSuggestion
82404>>>>>>>>>    String sRowId
82404>>>>>>>>>    String[] aValues
82404>>>>>>>>>End_Struct
82404>>>>>>>>>
82404>>>>>>>Use cTimer.pkg
Including file: cTimer.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cTimer.pkg)
82404>>>>>>>>>// cTimer class
82404>>>>>>>>>//
82404>>>>>>>>>// This supercedes the DFTimer class. 
82404>>>>>>>>>// It is simpler and more flexible
82404>>>>>>>>>
82404>>>>>>>>>Use Dftimer.pkg // we still use the Timer Manager classes and global objects
Including file: Dftimer.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\Dftimer.pkg)
82404>>>>>>>>>>>//************************************************************************
82404>>>>>>>>>>>//--- DFTimer   Timer package for DataFlex programs
82404>>>>>>>>>>>//
82404>>>>>>>>>>>// Copyright (c) 1983-2002 Data Access Corporation, Miami Florida,
82404>>>>>>>>>>>// All rights reserved.
82404>>>>>>>>>>>// DataFlex is a registered trademark of Data Access Corporation.
82404>>>>>>>>>>>//
82404>>>>>>>>>>>//************************************************************************
82404>>>>>>>>>>>//  Description:
82404>>>>>>>>>>>//      This package contains all components needed to implement timers
82404>>>>>>>>>>>//      in a DataFlex 4 program.
82404>>>>>>>>>>>//
82404>>>>>>>>>>>//
82404>>>>>>>>>>>//  Author: Eddy Kleinjan, Data Access Nederland
82404>>>>>>>>>>>//************************************************************************
82404>>>>>>>>>>>// 03/03/2001 EK  Fixed Timer_Active_State to check for valid windows
82404>>>>>>>>>>>//                handle before trying to set or kill a timer.
82404>>>>>>>>>>>//                Fixed Kill_All_Timers to check for valid windows
82404>>>>>>>>>>>//                handle before trying to kill a timer.
82404>>>>>>>>>>>//                The windows handle might not exist anymore when the
82404>>>>>>>>>>>//                program is being exited using Exit_Application.
82404>>>>>>>>>>>// 12/13/2001 JJT fixed Timer_Active_State to check for -1 (not 0). Fixed a
82404>>>>>>>>>>>//                a bug where set Timeout started inactive timers.
82404>>>>>>>>>>>//                Added code to force timer object to desktop
82404>>>>>>>>>>>//************************************************************************
82404>>>>>>>>>>>// CLASS DFTimer
82404>>>>>>>>>>>//
82404>>>>>>>>>>>// Usage:
82404>>>>>>>>>>>//    Object MyTimer is a DFTimer
82404>>>>>>>>>>>//
82404>>>>>>>>>>>//        Set Timeout to 2000                             // Default 1000
82404>>>>>>>>>>>//        Set Auto_Start_State to TRUE|FALSE              // Default TRUE
82404>>>>>>>>>>>//        Set Auto_Stop_State to TRUE|FALSE               // Default TRUE
82404>>>>>>>>>>>//        Set Timer_Message to MyMessage                  // Default 0
82404>>>>>>>>>>>//        Set Timer_Object to (MyObject(self))            // Default 0
82404>>>>>>>>>>>//        Set Timer_Active_State to TRUE|FALSE            // Default FALSE
82404>>>>>>>>>>>//
82404>>>>>>>>>>>//        // Augment when no Timer_Message
82404>>>>>>>>>>>//        Procedure OnTimer
82404>>>>>>>>>>>//            Send Info_Box "HEY, WAKE UP!"
82404>>>>>>>>>>>//        End_Procedure
82404>>>>>>>>>>>//
82404>>>>>>>>>>>//    End_Object
82404>>>>>>>>>>>//
82404>>>>>>>>>>>// DESCRIPTION
82404>>>>>>>>>>>//      Objects of this class can be used to trigger an event after a
82404>>>>>>>>>>>//      certain amount of time has passed. You can specify this time
82404>>>>>>>>>>>//      by setting the Timeout property of the object. This timeout
82404>>>>>>>>>>>//      is in miliseconds.
82404>>>>>>>>>>>//
82404>>>>>>>>>>>//      Whenever a timer event happens, it will notify the object by
82404>>>>>>>>>>>//      sending an OnTimer event. You can trap this event to do whatever
82404>>>>>>>>>>>//      you want the timer to do. By default this OnTimer event
82404>>>>>>>>>>>//      will send the Timer_Message to Timer_Object, when these have
82404>>>>>>>>>>>//      been specified.
82404>>>>>>>>>>>//
82404>>>>>>>>>>>//      By default, you have to activate a timer by setting its
82404>>>>>>>>>>>//      Timer_Active_State to TRUE. When the timer has been placed
82404>>>>>>>>>>>//      inside a user-interface object, it can also be activated
82404>>>>>>>>>>>//      automatically when this user-interface object is being
82404>>>>>>>>>>>//      activated. This only happes when it Auto_Start_State is TRUE,
82404>>>>>>>>>>>//      which is the default setting. In such a case, the timer will
82404>>>>>>>>>>>//      also automatically being stopped when the user-interface
82404>>>>>>>>>>>//      object is taken of the screen. This depends on the
82404>>>>>>>>>>>//      Auto_Stop_Timer state to happen.
82404>>>>>>>>>>>//
82404>>>>>>>>>>>//      When you need to set a new timeout value, you can do so
82404>>>>>>>>>>>//      even when the timer is active. It will adjust the timeout
82404>>>>>>>>>>>//      immediately.
82404>>>>>>>>>>>//
82404>>>>>>>>>>>//      Note that timer events depend on Windows for the delivery of
82404>>>>>>>>>>>//      the event. Since timer events get a low priority in Windows,
82404>>>>>>>>>>>//      it might put your program on hold when other programs are very
82404>>>>>>>>>>>//      busy. In such a case, you will only receive one timer event
82404>>>>>>>>>>>//      after the process stopped. There is no way, other than
82404>>>>>>>>>>>//      calculating it yourself, to determine how many time has passed
82404>>>>>>>>>>>//      or how many timer event should have happened since the last
82404>>>>>>>>>>>//      timer event or timer activation.
82404>>>>>>>>>>>//
82404>>>>>>>>>>>// PUBLIC INTERFACE
82404>>>>>>>>>>>//
82404>>>>>>>>>>>//    PROPERTIES
82404>>>>>>>>>>>//
82404>>>>>>>>>>>//    Auto_Start_State When TRUE (default) the timer will be activated
82404>>>>>>>>>>>//                     automatically when the object will be (virtually)
82404>>>>>>>>>>>//                     paged on the screen.
82404>>>>>>>>>>>//                     Example: When a timer object has been placed
82404>>>>>>>>>>>//                     inside a view, then the timer will be activated
82404>>>>>>>>>>>//                     when the view is activated.
82404>>>>>>>>>>>//
82404>>>>>>>>>>>//    Auto_Stop_State  When TRUE (default) the timer will be deactivated
82404>>>>>>>>>>>//                     automatically when the object will be (virtually)
82404>>>>>>>>>>>//                     taken off the screen.
82404>>>>>>>>>>>//
82404>>>>>>>>>>>//    Timeout          The timeout value for the timer to fire. The
82404>>>>>>>>>>>//                     timeout value must be set in miliseconds.
82404>>>>>>>>>>>//                     This property may be set even when the timer is
82404>>>>>>>>>>>//                     active. The new timeout value will be applied
82404>>>>>>>>>>>//                     immediately.
82404>>>>>>>>>>>//                     NOTE: The timeout set here is never precise. It
82404>>>>>>>>>>>//                     depends on Windows to deliver the message to our
82404>>>>>>>>>>>//                     application.
82404>>>>>>>>>>>//                     Default 1000.
82404>>>>>>>>>>>//
82404>>>>>>>>>>>//    Timer_Active_State
82404>>>>>>>>>>>//                     Set to TRUE to activate the timer, to FALSE to
82404>>>>>>>>>>>//                     deactivate the timer.
82404>>>>>>>>>>>//
82404>>>>>>>>>>>//
82404>>>>>>>>>>>//    Timer_Message    This property can be set to a messageID which has
82404>>>>>>>>>>>//                     to be sent whenever a timer event occurs. Default
82404>>>>>>>>>>>//                     this message will be send to the object itself
82404>>>>>>>>>>>//                     unless a Timer_Object as been specified.
82404>>>>>>>>>>>//
82404>>>>>>>>>>>//    Timer_Object     This property can be set to an objectID which has
82404>>>>>>>>>>>//                     to receive the Timer_Message whenever a timer
82404>>>>>>>>>>>//                     event occurs. This value has no meaning when
82404>>>>>>>>>>>//                     no Timer_Message has been set.
82404>>>>>>>>>>>//
82404>>>>>>>>>>>//    METHODS
82404>>>>>>>>>>>//
82404>>>>>>>>>>>//    OnTimer          This event will happen whenever the specified
82404>>>>>>>>>>>//                     amount of time has passed and the timer is
82404>>>>>>>>>>>//                     active. By default it sends the message in
82404>>>>>>>>>>>//                     the Timer_Message property to the object in
82404>>>>>>>>>>>//                     the Timer_Object when these have been specified.
82404>>>>>>>>>>>//                     When you don't need this, you can just override
82404>>>>>>>>>>>//                     the OnTimer event.
82404>>>>>>>>>>>//
82404>>>>>>>>>>>// PUBLIC INTERFACE
82404>>>>>>>>>>>//
82404>>>>>>>>>>>//    Page_Object      Has been augmented to auto_start the timer when
82404>>>>>>>>>>>//                     it becomes active as part or a user-interface
82404>>>>>>>>>>>//                     object.
82404>>>>>>>>>>>//
82404>>>>>>>>>>>//    Page_Delete      Has been augmented to auto_stop the timer when
82404>>>>>>>>>>>//                     it is deactivated as part or a user-interface
82404>>>>>>>>>>>//                     object.
82404>>>>>>>>>>>//
82404>>>>>>>>>>>//    Destroy_Object   Has been augmented to deactivate the timer.
82404>>>>>>>>>>>//
82404>>>>>>>>>>>Use LanguageText.pkg
82404>>>>>>>>>>>Use Windows.pkg
82404>>>>>>>>>>>Use WinUser.pkg
82404>>>>>>>>>>>
82404>>>>>>>>>>>External_Function SetTimer "SetTimer" User32.DLL ;    Integer hWnd ;    Integer idTimer ;    Integer idTimeout ;    Pointer tmprc ;    Returns Integer
82405>>>>>>>>>>>
82405>>>>>>>>>>>External_Function KillTimer "KillTimer" User32.DLL ;    Integer hWnd ;    Integer idTimer ;    Returns Integer
82406>>>>>>>>>>>
82406>>>>>>>>>>>// This global integer holds the ID of the object
82406>>>>>>>>>>>// that manages all timers.
82406>>>>>>>>>>>Integer giTimerManager
82406>>>>>>>>>>>
82406>>>>>>>>>>>// This class is used to store the object IDs
82406>>>>>>>>>>>// of the active timer objects. It augments
82406>>>>>>>>>>>// the Destroy_Object procedure to notify
82406>>>>>>>>>>>// the DFTimerManager to kill all its active
82406>>>>>>>>>>>// timers.
82406>>>>>>>>>>>// NOTE: This class looks very much like the
82406>>>>>>>>>>>// Set class. I didn't want to use Set because
82406>>>>>>>>>>>// Remove_Element shifts items which I don't
82406>>>>>>>>>>>// want to happen because item numbers are used
82406>>>>>>>>>>>// as timerIDs.
82406>>>>>>>>>>>
82406>>>>>>>>>>>Class TimersArray is an Array
82407>>>>>>>>>>>
82407>>>>>>>>>>>    Function Find_Object Integer iObj Returns Integer
82409>>>>>>>>>>>        Integer iMax
82409>>>>>>>>>>>        Integer iItem
82409>>>>>>>>>>>        Integer iValue
82409>>>>>>>>>>>        Get Item_count to iMax
82410>>>>>>>>>>>        Decrement iMax
82411>>>>>>>>>>>        For iItem from 1 to iMax
82417>>>>>>>>>>>>
82417>>>>>>>>>>>            Get Integer_Value item iItem to iValue
82418>>>>>>>>>>>            If iValue EQ iObj;                Function_Return iItem
82421>>>>>>>>>>>        Loop
82422>>>>>>>>>>>>
82422>>>>>>>>>>>        Function_Return -1
82423>>>>>>>>>>>    End_Function
82424>>>>>>>>>>>
82424>>>>>>>>>>>    Procedure Add_Object Integer iObj Returns Integer
82426>>>>>>>>>>>        Integer iItem
82426>>>>>>>>>>>        Get Find_Object iObj to iItem
82427>>>>>>>>>>>        If iItem LT 0 Begin
82429>>>>>>>>>>>            Get Find_Object 0 to iItem
82430>>>>>>>>>>>            If iItem LT 0 ;                Get Item_Count to iItem
82433>>>>>>>>>>>        End
82433>>>>>>>>>>>>
82433>>>>>>>>>>>        Set Array_Value item iItem to iObj
82434>>>>>>>>>>>        Procedure_Return iItem
82435>>>>>>>>>>>    End_Procedure
82436>>>>>>>>>>>
82436>>>>>>>>>>>    Procedure Remove_Object Integer iObj
82438>>>>>>>>>>>        Integer iItem
82438>>>>>>>>>>>        Get Find_Object iObj to iItem
82439>>>>>>>>>>>        If iItem GT 0 ;            Set Array_Value item iItem to 0
82442>>>>>>>>>>>    End_Procedure
82443>>>>>>>>>>>
82443>>>>>>>>>>>    Procedure Destroy_Object
82445>>>>>>>>>>>        Delegate Send Kill_All_Timers
82447>>>>>>>>>>>        Forward Send Destroy_Object
82449>>>>>>>>>>>    End_Procedure
82450>>>>>>>>>>>
82450>>>>>>>>>>>End_Class // TimersArray
82451>>>>>>>>>>>
82451>>>>>>>>>>>// This class is the actual timer manager
82451>>>>>>>>>>>// A timer will be created when Message Set_Timer_Active_State
82451>>>>>>>>>>>// has been send. This message needs two arguments. The first
82451>>>>>>>>>>>// is the objectID of the object to receive the timer event,
82451>>>>>>>>>>>// and the second is state. The object which ID has been passed,
82451>>>>>>>>>>>// needs to have a Timeout property to return the timeout for the
82451>>>>>>>>>>>// timer and it also needs to handle the MSG_OnTimer whenever a
82451>>>>>>>>>>>// timer event occurs.
82451>>>>>>>>>>>// The objectID of the Object will be placed in an array which contains
82451>>>>>>>>>>>// the objectIDs of all active timers. The Windows timer ID of a timer
82451>>>>>>>>>>>// is the itemnumber of the object in the array.
82451>>>>>>>>>>>//
82451>>>>>>>>>>>Class DFTimerManager is a DfBaseControl
82452>>>>>>>>>>>
82452>>>>>>>>>>>    Procedure Construct_Object
82454>>>>>>>>>>>
82454>>>>>>>>>>>        Forward Send Construct_Object
82456>>>>>>>>>>>
82456>>>>>>>>>>>        Set Visible_State to FALSE
82457>>>>>>>>>>>
82457>>>>>>>>>>>        Set External_Class_Name "cVdfTimer" to "static"
82458>>>>>>>>>>>        Set External_Message WM_TIMER to OnTimer
82459>>>>>>>>>>>
82459>>>>>>>>>>>        Object TimersArray is a TimersArray
82461>>>>>>>>>>>            Set Array_Value item 0 to -9999 // So we don't use item 0
82462>>>>>>>>>>>        End_Object
82463>>>>>>>>>>>
82463>>>>>>>>>>>        Move self to giTimerManager
82464>>>>>>>>>>>
82464>>>>>>>>>>>    End_Procedure
82465>>>>>>>>>>>
82465>>>>>>>>>>>    Procedure Set Timer_Active_State Integer iObj Integer iState
82467>>>>>>>>>>>        Integer iTimerID
82467>>>>>>>>>>>        Integer iTimeout
82467>>>>>>>>>>>        Integer iResult
82467>>>>>>>>>>>        Integer iSet
82467>>>>>>>>>>>        Dword   nResult
82467>>>>>>>>>>>        Handle  hWnd
82467>>>>>>>>>>>
82467>>>>>>>>>>>        // Get the handle of this object
82467>>>>>>>>>>>        Get Window_Handle to hWnd
82468>>>>>>>>>>>        If (Not(hWnd)) Begin
82470>>>>>>>>>>>            Error DFERR_DFTIMER C_$TimerNoHandle
82471>>>>>>>>>>>>
82471>>>>>>>>>>>            Procedure_Return
82472>>>>>>>>>>>        End
82472>>>>>>>>>>>>
82472>>>>>>>>>>>
82472>>>>>>>>>>>        // Test if handle is valid. If not, we leave.
82472>>>>>>>>>>>        If (Not(IsWindow(hWnd))) ;            Procedure_Return
82475>>>>>>>>>>>
82475>>>>>>>>>>>        Move (TimersArray(self)) to iSet
82476>>>>>>>>>>>
82476>>>>>>>>>>>        If (iSet) Begin
82478>>>>>>>>>>>
82478>>>>>>>>>>>            // Let's create or modify a timer
82478>>>>>>>>>>>            If iState Begin
82480>>>>>>>>>>>
82480>>>>>>>>>>>                // Get the exising to new TimerID
82480>>>>>>>>>>>                Get MSG_Add_Object of iSet iObj to iTimerID
82481>>>>>>>>>>>
82481>>>>>>>>>>>                // Set/Modify the timer
82481>>>>>>>>>>>                Get Timeout of iObj to iTimeout
82482>>>>>>>>>>>                Move (SetTimer(hWnd, iTimerID, iTimeout, 0)) to iResult
82483>>>>>>>>>>>                If Not iResult Begin
82485>>>>>>>>>>>                    Error DFERR_DFTIMER C_$TooManyTimers
82486>>>>>>>>>>>>
82486>>>>>>>>>>>                    Procedure_Return
82487>>>>>>>>>>>                End
82487>>>>>>>>>>>>
82487>>>>>>>>>>>
82487>>>>>>>>>>>            End
82487>>>>>>>>>>>>
82487>>>>>>>>>>>
82487>>>>>>>>>>>            // Let's kill an existing timer
82487>>>>>>>>>>>            Else Begin
82488>>>>>>>>>>>
82488>>>>>>>>>>>                // Look up the object in the set
82488>>>>>>>>>>>                Get Find_Object of iSet iObj to iTimerID
82489>>>>>>>>>>>
82489>>>>>>>>>>>                If iTimerID EQ -1 ;                    Procedure_Return
82492>>>>>>>>>>>
82492>>>>>>>>>>>                // Kill the timer
82492>>>>>>>>>>>                Move (KillTimer(hWnd, iTimerID)) to iResult
82493>>>>>>>>>>>                If Not iResult Begin
82495>>>>>>>>>>>                    Move (GetLastError()) to nResult
82496>>>>>>>>>>>                    Error DFERR_DFTIMER (C_$CantKillTimer * string(nResult) - "!")
82497>>>>>>>>>>>>
82497>>>>>>>>>>>                    Procedure_Return
82498>>>>>>>>>>>                End
82498>>>>>>>>>>>>
82498>>>>>>>>>>>
82498>>>>>>>>>>>                // Remove the objectID
82498>>>>>>>>>>>                Send Remove_Object to iSet iObj
82499>>>>>>>>>>>            End
82499>>>>>>>>>>>>
82499>>>>>>>>>>>        End
82499>>>>>>>>>>>>
82499>>>>>>>>>>>    End_Procedure
82500>>>>>>>>>>>
82500>>>>>>>>>>>    Function Timer_Active_State Integer iObj Returns Integer
82502>>>>>>>>>>>        Integer iResult
82502>>>>>>>>>>>        Get Find_Object of (TimersArray(self)) iObj to iResult
82503>>>>>>>>>>>        Function_Return (iResult<>-1) // note: -1= not found
82504>>>>>>>>>>>    End_Function
82505>>>>>>>>>>>
82505>>>>>>>>>>>    // Will be called by the Set when it is being destroyed.
82505>>>>>>>>>>>    Procedure Kill_All_Timers
82507>>>>>>>>>>>        Integer iMax
82507>>>>>>>>>>>        Integer iSet
82507>>>>>>>>>>>        Integer iItem
82507>>>>>>>>>>>        Integer iObj
82507>>>>>>>>>>>        Integer iResult
82507>>>>>>>>>>>        Handle  hWnd
82507>>>>>>>>>>>
82507>>>>>>>>>>>        // Get the handle of this object
82507>>>>>>>>>>>        Get Window_Handle to hWnd
82508>>>>>>>>>>>        If (Not(hWnd)) Begin
82510>>>>>>>>>>>            Error DFERR_DFTIMER C_$TimerNoHandle
82511>>>>>>>>>>>>
82511>>>>>>>>>>>            Procedure_Return
82512>>>>>>>>>>>        End
82512>>>>>>>>>>>>
82512>>>>>>>>>>>
82512>>>>>>>>>>>        // If the window handle is no longer valid, we
82512>>>>>>>>>>>        // leave this procedure. This can happen when the
82512>>>>>>>>>>>        // program is begin aborted using Exit_Application
82512>>>>>>>>>>>        If (Not(IsWindow(hWnd))) ;            Procedure_Return
82515>>>>>>>>>>>
82515>>>>>>>>>>>        // Scan the set and kill all known timers
82515>>>>>>>>>>>        Move (TimersArray(self)) to iSet
82516>>>>>>>>>>>        If (iSet) Begin
82518>>>>>>>>>>>            Get Item_Count of iSet to iMax
82519>>>>>>>>>>>            Decrement iMax
82520>>>>>>>>>>>            For iItem From 1 to iMax
82526>>>>>>>>>>>>
82526>>>>>>>>>>>                Get Integer_Value of iSet item iItem to iObj
82527>>>>>>>>>>>                If iObj Begin
82529>>>>>>>>>>>                    Move (KillTimer(hWnd, iItem)) to iResult
82530>>>>>>>>>>>                    Set Array_Value of iSet item iItem to 0
82531>>>>>>>>>>>                End
82531>>>>>>>>>>>>
82531>>>>>>>>>>>            Loop
82532>>>>>>>>>>>>
82532>>>>>>>>>>>        End
82532>>>>>>>>>>>>
82532>>>>>>>>>>>
82532>>>>>>>>>>>    End_Procedure
82533>>>>>>>>>>>
82533>>>>>>>>>>>    Procedure OnTimer Integer wParam Integer lParam
82535>>>>>>>>>>>        Integer iObj
82535>>>>>>>>>>>        Get Integer_Value of (TimersArray(self)) item wParam to iObj
82536>>>>>>>>>>>        If Not iObj Begin
82538>>>>>>>>>>>            Error DFERR_DFTIMER C_$TimerWithoutObject
82539>>>>>>>>>>>>
82539>>>>>>>>>>>            Procedure_Return
82540>>>>>>>>>>>        End
82540>>>>>>>>>>>>
82540>>>>>>>>>>>        Send OnTimer to iObj wParam lParam
82541>>>>>>>>>>>    End_Procedure
82542>>>>>>>>>>>
82542>>>>>>>>>>>    Procedure Destroy_Object
82544>>>>>>>>>>>        Send Kill_All_Timers
82545>>>>>>>>>>>        Forward Send Destroy_Object
82547>>>>>>>>>>>        Move 0 to giTimerManager
82548>>>>>>>>>>>    End_Procedure
82549>>>>>>>>>>>
82549>>>>>>>>>>>End_Class // DFTimerManger
82550>>>>>>>>>>>
82550>>>>>>>>>>>
82550>>>>>>>>>>>
82550>>>>>>>>>>>
82550>>>>>>>>>>>// This class acts as a container for the
82550>>>>>>>>>>>// timer manager object. This is needed because
82550>>>>>>>>>>>// A DFTimerManager object created directly at the
82550>>>>>>>>>>>// desktop doesn't have a Window_Handle which we
82550>>>>>>>>>>>// need to create a Windoows timer. By placing
82550>>>>>>>>>>>// this non-visual container around the timer
82550>>>>>>>>>>>// manager, it does get a Window_Handle.
82550>>>>>>>>>>>// The procedure End_Construct_Object has been
82550>>>>>>>>>>>// augmented to create a window and also
82550>>>>>>>>>>>// automatically page all children, which will
82550>>>>>>>>>>>// be the timer manager.
82550>>>>>>>>>>>//
82550>>>>>>>>>>>Class DFTimerManagerPanel is a dfBasePanel
82551>>>>>>>>>>>
82551>>>>>>>>>>>    Procedure Construct_Object
82553>>>>>>>>>>>        Forward Send Construct_Object
82555>>>>>>>>>>>        Set Visible_State to FALSE
82556>>>>>>>>>>>        Object DFTimerManager is a DFTimerManager
82558>>>>>>>>>>>        End_Object
82559>>>>>>>>>>>    End_Procedure
82560>>>>>>>>>>>
82560>>>>>>>>>>>    Procedure End_Construct_Object
82562>>>>>>>>>>>        Forward Send End_Construct_Object
82564>>>>>>>>>>>        Send Page_Object TRUE
82565>>>>>>>>>>>        Broadcast Send Page_Object TRUE
82567>>>>>>>>>>>    End_Procedure
82568>>>>>>>>>>>
82568>>>>>>>>>>>End_Class
82569>>>>>>>>>>>
82569>>>>>>>>>>>// This is the class the user uses to create DFTimer objects
82569>>>>>>>>>>>
82569>>>>>>>>>>>
82569>>>>>>>>>>>//{ OverrideProperty=Skip_State DesignTime=False }
82569>>>>>>>>>>>//{ OverrideProperty=TypeFace DesignTime=False }
82569>>>>>>>>>>>Class DFTimer is a Textbox
82570>>>>>>>>>>>
82570>>>>>>>>>>>    Procedure Construct_Object
82572>>>>>>>>>>>        Forward Send Construct_Object
82574>>>>>>>>>>>
82574>>>>>>>>>>>        // Make sure this object never appears
82574>>>>>>>>>>>        Set Visible_State to FALSE
82575>>>>>>>>>>>
82575>>>>>>>>>>>        Property Integer Private.Timeout    1000
82576>>>>>>>>>>>
82576>>>>>>>>>>>        Property Integer Timer_Message      0
82577>>>>>>>>>>>        Property Integer Timer_Object       0
82578>>>>>>>>>>>        Property Integer Auto_Start_State   True
82579>>>>>>>>>>>        Property Integer Auto_Stop_State    True
82580>>>>>>>>>>>    End_Procedure
82581>>>>>>>>>>>
82581>>>>>>>>>>>    Procedure Set Timer_Active_State Integer iState
82583>>>>>>>>>>>        Integer iObj
82583>>>>>>>>>>>        Move self to iObj
82584>>>>>>>>>>>        If giTimerManager ;            Set Timer_Active_State of giTimerManager iObj to iState
82587>>>>>>>>>>>    End_Procedure
82588>>>>>>>>>>>
82588>>>>>>>>>>>    Function Timer_Active_State Returns Integer
82590>>>>>>>>>>>        Integer iState
82590>>>>>>>>>>>        Integer iObj
82590>>>>>>>>>>>        Move self to iObj
82591>>>>>>>>>>>        If giTimerManager ;            Get Timer_Active_State of giTimerManager iObj to iState
82594>>>>>>>>>>>        Function_Return iState
82595>>>>>>>>>>>    End_Function
82596>>>>>>>>>>>
82596>>>>>>>>>>>    Procedure Set Timeout Integer iTimeout
82598>>>>>>>>>>>        Integer iActive
82598>>>>>>>>>>>        Set Private.Timeout to iTimeout
82599>>>>>>>>>>>        Get Timer_Active_State to iActive
82600>>>>>>>>>>>        If iActive ;            Set Timer_Active_State to TRUE
82603>>>>>>>>>>>    End_Procedure
82604>>>>>>>>>>>
82604>>>>>>>>>>>    Function Timeout Returns Integer
82606>>>>>>>>>>>        Integer iTimeout
82606>>>>>>>>>>>        Get Private.Timeout to iTimeout
82607>>>>>>>>>>>        Function_Return iTimeout
82608>>>>>>>>>>>    End_Function
82609>>>>>>>>>>>
82609>>>>>>>>>>>    Procedure OnTimer Integer iwParam Integer ilParam
82611>>>>>>>>>>>        Integer iMsg
82611>>>>>>>>>>>        Integer iObj
82611>>>>>>>>>>>        Get Timer_Message to iMsg
82612>>>>>>>>>>>        If (iMsg) Begin
82614>>>>>>>>>>>            Get Timer_Object  to iObj
82615>>>>>>>>>>>            If iObj ;                Send iMsg to iObj iwParam ilParam
82618>>>>>>>>>>>            Else ;                Send iMsg iwParam ilParam
82620>>>>>>>>>>>        End
82620>>>>>>>>>>>>
82620>>>>>>>>>>>    End_Procedure
82621>>>>>>>>>>>
82621>>>>>>>>>>>    // Augmented to Auto_Start a timer
82621>>>>>>>>>>>    //
82621>>>>>>>>>>>    Procedure Page_Object Integer iState
82623>>>>>>>>>>>        Forward Send Page_Object iState
82625>>>>>>>>>>>        If (iState AND Auto_Start_State(self)) ;            Set Timer_Active_State to TRUE
82628>>>>>>>>>>>    End_Procedure
82629>>>>>>>>>>>
82629>>>>>>>>>>>    // Augmented to Auto_Stop a timer
82629>>>>>>>>>>>    //
82629>>>>>>>>>>>    Procedure Page_Delete
82631>>>>>>>>>>>        If (Auto_Stop_State(self)) ;            Set Timer_Active_State to FALSE
82634>>>>>>>>>>>        Forward Send Page_Delete
82636>>>>>>>>>>>    End_Procedure
82637>>>>>>>>>>>
82637>>>>>>>>>>>    // Augmented to stop the timer
82637>>>>>>>>>>>    //
82637>>>>>>>>>>>    Procedure Destroy_Object
82639>>>>>>>>>>>        Set Timer_Active_State to FALSE
82640>>>>>>>>>>>        Forward Send Destroy_Object
82642>>>>>>>>>>>    End_Procedure
82643>>>>>>>>>>>
82643>>>>>>>>>>>End_Class // DFTimer
82644>>>>>>>>>>>
82644>>>>>>>>>>>//
82644>>>>>>>>>>>// This was moved into a method so it can be reliable created
82644>>>>>>>>>>>// at the desktop. Note that cDesktop adds method to cDesktop class (class of desktop)
82644>>>>>>>>>>>//
82644>>>>>>>>>>>Procedure CreateDfTimerManagerPanel FOR cDesktop
82646>>>>>>>>>>>    // Create the Desktop Timer Manager Object.
82646>>>>>>>>>>>    Object DFTimerManagerPanel is a DFTimerManagerPanel
82648>>>>>>>>>>>    End_Object
82649>>>>>>>>>>>End_Procedure
82650>>>>>>>>>>>
82650>>>>>>>>>>>Send CreateDfTimerManagerPanel of DESKTOP
82651>>>>>>>>>>>
82651>>>>>>>>>
82651>>>>>>>>>Class cTimer is a cObject
82652>>>>>>>>>
82652>>>>>>>>>    Procedure Construct_Object
82654>>>>>>>>>        Forward Send Construct_Object
82656>>>>>>>>>        Property Integer piPrivate_Timeout 1000
82657>>>>>>>>>    End_Procedure
82658>>>>>>>>>
82658>>>>>>>>>    Procedure Set pbEnabled Boolean bEnabled
82660>>>>>>>>>        If giTimerManager Begin
82662>>>>>>>>>            Set Timer_Active_State of giTimerManager Self to bEnabled
82663>>>>>>>>>        End
82663>>>>>>>>>>
82663>>>>>>>>>    End_Procedure
82664>>>>>>>>>
82664>>>>>>>>>    Function pbEnabled Returns Boolean
82666>>>>>>>>>        Boolean bEnabled
82666>>>>>>>>>        If giTimerManager Begin
82668>>>>>>>>>            Get Timer_Active_State of giTimerManager Self to bEnabled
82669>>>>>>>>>        End
82669>>>>>>>>>>
82669>>>>>>>>>        Function_Return bEnabled
82670>>>>>>>>>    End_Function
82671>>>>>>>>>
82671>>>>>>>>>    Procedure Set piTimeout Integer iTimeout
82673>>>>>>>>>        Boolean bEnabled
82673>>>>>>>>>        Set piPrivate_Timeout to iTimeout
82674>>>>>>>>>        Get pbEnabled to bEnabled
82675>>>>>>>>>        If bEnabled Begin
82677>>>>>>>>>            Set pbEnabled to True
82678>>>>>>>>>        End
82678>>>>>>>>>>
82678>>>>>>>>>    End_Procedure
82679>>>>>>>>>
82679>>>>>>>>>    Function piTimeout Returns Integer
82681>>>>>>>>>        Integer iTimeout
82681>>>>>>>>>        Get piPrivate_Timeout to iTimeout
82682>>>>>>>>>        Function_Return iTimeout
82683>>>>>>>>>    End_Function
82684>>>>>>>>>
82684>>>>>>>>>    Procedure OnTimer
82686>>>>>>>>>    End_Procedure
82687>>>>>>>>>    
82687>>>>>>>>>    // this is needed by the timer manager 
82687>>>>>>>>>    Function Timeout Returns Integer
82689>>>>>>>>>        Integer iTimeout
82689>>>>>>>>>        Get piPrivate_Timeout to iTimeout
82690>>>>>>>>>        Function_Return iTimeout
82691>>>>>>>>>    End_Function
82692>>>>>>>>>
82692>>>>>>>>>    Procedure Destroy_Object
82694>>>>>>>>>        Set pbEnabled to False
82695>>>>>>>>>        Forward Send Destroy_Object
82697>>>>>>>>>    End_Procedure
82698>>>>>>>>>
82698>>>>>>>>>End_Class
82699>>>>>>>Use cRichEdit.pkg
Including file: cRichEdit.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cRichEdit.pkg)
82699>>>>>>>>>use Windows.pkg
82699>>>>>>>>>Use cEdit_Mixin.pkg
82699>>>>>>>>>
82699>>>>>>>>>// DFO: cRichEdit.Dfo
82699>>>>>>>>>// DFC: cRichEdit.Dfc
82699>>>>>>>>>
82699>>>>>>>>>// constants used for RichEdit Properties
82699>>>>>>>>>// peAlignment 
82699>>>>>>>>>Enum_List 
82699>>>>>>>>>    Define alLeft   for 1 
82699>>>>>>>>>    Define alRight  for 2 
82699>>>>>>>>>    Define alCenter for 3 
82699>>>>>>>>>End_Enum_List 
82699>>>>>>>>>
82699>>>>>>>>>// peBullets 
82699>>>>>>>>>Enum_List 
82699>>>>>>>>>    Define buNone 
82699>>>>>>>>>    Define buBullets 
82699>>>>>>>>>    Define buArabicNumbers 
82699>>>>>>>>>    Define buLowerLetters 
82699>>>>>>>>>    Define buUpperLetters 
82699>>>>>>>>>    Define buLowerRomans 
82699>>>>>>>>>    Define buUpperRomans 
82699>>>>>>>>>End_Enum_List 
82699>>>>>>>>>
82699>>>>>>>>>// peBulletStyle 
82699>>>>>>>>>Enum_List 
82699>>>>>>>>>    Define busRightParen   for 0 
82699>>>>>>>>>    Define busEncloseParen for 256 
82699>>>>>>>>>    Define busPeriod       for 512 
82699>>>>>>>>>    Define busNumberOnly   for 768 
82699>>>>>>>>>    Define busNoDisplay    for 1024 
82699>>>>>>>>>End_Enum_List
82699>>>>>>>>>    
82699>>>>>>>>>// peLineSpacingType
82699>>>>>>>>>Enum_List 
82699>>>>>>>>>    Define lstSingle
82699>>>>>>>>>    Define lstSingleAndOneHalf
82699>>>>>>>>>    Define lstDouble
82699>>>>>>>>>End_Enum_List
82699>>>>>>>>>
82699>>>>>>>>>Class cRichEdit Is A DFBaseRichEdit
82700>>>>>>>>>
82700>>>>>>>>>    Procedure Construct_Object
82702>>>>>>>>>        Forward Send Construct_Object
82704>>>>>>>>>        Send Define_cEdit_Mixin
82705>>>>>>>>>
82705>>>>>>>>>        On_key Key_Ctrl+Key_B send ToggleBold
82706>>>>>>>>>        On_key Key_Ctrl+Key_I send ToggleItalics
82707>>>>>>>>>        On_key Key_Ctrl+Key_U send ToggleUnderline
82708>>>>>>>>>
82708>>>>>>>>>    End_Procedure // Construct_Object
82709>>>>>>>>>
82709>>>>>>>>>    Import_Class_Protocol cEdit_Mixin
82710>>>>>>>>>    
82710>>>>>>>>>    Procedure ToggleBold
82712>>>>>>>>>        Set pbBold to (not(pbBold(self))) 
82713>>>>>>>>>    end_procedure
82714>>>>>>>>>    
82714>>>>>>>>>    Procedure ToggleItalics
82716>>>>>>>>>        Set pbItalics to (not(pbItalics(self))) 
82717>>>>>>>>>    end_procedure
82718>>>>>>>>>    
82718>>>>>>>>>    Procedure ToggleUnderline
82720>>>>>>>>>       Set pbUnderLine to (not(pbUnderLine(self))) 
82721>>>>>>>>>    end_procedure
82722>>>>>>>>>
82722>>>>>>>>>End_Class
82723>>>>>>>>>
82723>>>>>>>Use sql.pkg
Including file: sql.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\sql.pkg)
82723>>>>>>>>>//*****************************************************************************
82723>>>>>>>>>//*** SQL.pkg                                                               ***
82723>>>>>>>>>//***                                                                       ***
82723>>>>>>>>>//*** Author: Ben Weijers                                                   ***
82723>>>>>>>>>//***         Data Access Wordwide                                          ***
82723>>>>>>>>>//***         14 February 2000                                              ***
82723>>>>>>>>>//***                                                                       ***
82723>>>>>>>>>//*** Purpose:                                                              ***
82723>>>>>>>>>//***       Embedded SQL classes for use with Data Access Worldwide CLI     ***
82723>>>>>>>>>//***       Connectivty Kits.                                               ***
82723>>>>>>>>>//***                                                                       ***
82723>>>>>>>>>//*** Last update:                                                          ***
82723>>>>>>>>>//***       February 2014. Current CLI Connectivity Kit 6.0.0.28            ***
82723>>>>>>>>>//***                                                                       ***
82723>>>>>>>>>//*** !! Please Note !!                                                     ***
82723>>>>>>>>>//***       -This version of sql.pkg will only work with CLI Connectivity   ***
82723>>>>>>>>>//***        Kits 6.0.0.28 or later.                                        ***
82723>>>>>>>>>//***       -This version of sql.pkg will no longer function with DataFlex  ***
82723>>>>>>>>>//***        character mode (DataFlex 3.2). To use embedded SQL with        ***
82723>>>>>>>>>//**         DataFlex character mode, use sqlold.pkg.                       ***
82723>>>>>>>>>//***       -This version of sql.pkg no longer contains the embedded SQL    ***
82723>>>>>>>>>//***        command interface. The command interface is still available    ***
82723>>>>>>>>>//***        in sqlold.pkg                                                  ***
82723>>>>>>>>>//***                                                                       ***
82723>>>>>>>>>//*** Changes:                                                              ***
82723>>>>>>>>>//***       February 2014. CLI Connectivity Kit 6.0.0.28                    ***
82723>>>>>>>>>//***                                                                       ***
82723>>>>>>>>>//***       Several performances improvements to speed up SQLColumnValue    ***
82723>>>>>>>>>//***       and SQLGetData                                                  ***
82723>>>>>>>>>//***                                                                       ***
82723>>>>>>>>>//***       New functions:                                                  ***
82723>>>>>>>>>//***           Function SQLFetchRowValues Returns String[]                 ***
82723>>>>>>>>>//***               Fetches a row and returns all columns in an array.      ***
82723>>>>>>>>>//***                                                                       ***
82723>>>>>>>>>//***           Function SQLFetchResultsetValues Returns String[][]         ***
82723>>>>>>>>>//***               Fetches all rows of a result set and returns the        ***
82723>>>>>>>>>//***               result set as a 2-dimensial array.                      ***
82723>>>>>>>>>//***                                                                       ***
82723>>>>>>>>>//*****************************************************************************
82723>>>>>>>>>
82723>>>>>>>>>Use CLI.pkg
82723>>>>>>>>>
82723>>>>>>>>>//*** Global storage for results
82723>>>>>>>>>Integer SQLResult
82723>>>>>>>>>
82723>>>>>>>>>//*** Embedded SQL function constants
82723>>>>>>>>>Define FUNC_SQLCONNECT             For 1000000
82723>>>>>>>>>Define FUNC_SQLFILECONNECT         For 1000001
82723>>>>>>>>>Define FUNC_SQLDISCONNECT          For 1000002
82723>>>>>>>>>Define FUNC_SQLOPEN                For 1000003
82723>>>>>>>>>Define FUNC_SQLCLOSE               For 1000004
82723>>>>>>>>>Define FUNC_SQLPREPARE             For 1000005
82723>>>>>>>>>Define FUNC_SQLEXECUTE             For 1000006
82723>>>>>>>>>Define FUNC_SQLEXECDIRECT          For 1000007
82723>>>>>>>>>Define FUNC_SQLFETCH               For 1000008
82723>>>>>>>>>Define FUNC_SQLCOLUMNINFO          For 1000009
82723>>>>>>>>>Define FUNC_SQLCOLUMNVALUE         For 1000010
82723>>>>>>>>>Define FUNC_SQLBINDFILE            For 1000011
82723>>>>>>>>>Define FUNC_SQLGETDATA             For 1000012
82723>>>>>>>>>Define FUNC_SQLCOLSTRINGATTRIBLEN  For 1000013
82723>>>>>>>>>Define FUNC_SQLCOLSTRINGATTRIB     For 1000014
82723>>>>>>>>>Define FUNC_SQLCOLINTATTRIB        For 1000015
82723>>>>>>>>>Define FUNC_SQLSTMTINTATTRIB       For 1000016
82723>>>>>>>>>Define FUNC_SQLSETPROCNAME         For 1000017
82723>>>>>>>>>DEfine FUNC_SQLSETPROCARG          For 1000018
82723>>>>>>>>>Define FUNC_SQLCALL                For 1000019
82723>>>>>>>>>Define FUNC_SQLGETPROCARGLEN       For 1000020
82723>>>>>>>>>Define FUNC_SQLGETPROCARG          For 1000021
82723>>>>>>>>>Define FUNC_SQLGETPROCRETVALLEN    For 1000022
82723>>>>>>>>>Define FUNC_SQLGETPROCRETVAL       For 1000023
82723>>>>>>>>>Define FUNC_SQLNEXTRESULTSET       For 1000024
82723>>>>>>>>>Define FUNC_SQLBUFFERSTATUS        For 1000025
82723>>>>>>>>>Define FUNC_SQLSETPROCSCHEMA       For 1000026
82723>>>>>>>>>Define FUNC_SQLGETMESSAGE          For 1000027
82723>>>>>>>>>
82723>>>>>>>>>//*** Embedded SQL statement attribute constants
82723>>>>>>>>>Define SQLSTMTATTRIB_COLUMNCOUNT    For 1
82723>>>>>>>>>Define SQLSTMTATTRIB_ROWCOUNT       For 2
82723>>>>>>>>>Define SQLSTMTATTRIB_ROWCOUNT_TYPE  For 3
82723>>>>>>>>>Define SQLSTMTATTRIB_NUMMESSAGES    For 4
82723>>>>>>>>>
82723>>>>>>>>>//*** Embedded SQL column attribute constants
82723>>>>>>>>>Define SQLCOLATTRIB_SIZE           For 1
82723>>>>>>>>>Define SQLCOLATTRIB_LENGTH         For 1
82723>>>>>>>>>Define SQLCOLATTRIB_PRECISION      For 2
82723>>>>>>>>>Define SQLCOLATTRIB_LABEL          For 3
82723>>>>>>>>>Define SQLCOLATTRIB_BASECOLUMNNAME For 4
82723>>>>>>>>>Define SQLCOLATTRIB_BASETABLENAME  For 5
82723>>>>>>>>>Define SQLCOLATTRIB_SQLTYPE        For 6
82723>>>>>>>>>Define SQLCOLATTRIB_NULLABLE       For 7
82723>>>>>>>>>Define SQLCOLATTRIB_DFTYPE         For 8
82723>>>>>>>>>
82723>>>>>>>>>
82723>>>>>>>>>
82723>>>>>>>>>//*****************************************************************************
82723>>>>>>>>>//*** Class  : cSQLStatement                                                ***
82723>>>>>>>>>//*** Purpose: Statement object for embedded sql                            ***
82723>>>>>>>>>//***                                                                       ***
82723>>>>>>>>>//*** Description:                                                          ***
82723>>>>>>>>>//***   An object is created for each statement. These will be children     ***
82723>>>>>>>>>//***   of cSQLConnection objects which manage the create and destruction   ***
82723>>>>>>>>>//***   of these.                                                           ***
82723>>>>>>>>>//*****************************************************************************
82723>>>>>>>>>
82723>>>>>>>>>// Global variables holding last executed embedded SQL connection and statement handles.
82723>>>>>>>>>Integer giLastSQLhdbc
82723>>>>>>>>>Integer giLastSQLhstmt
82723>>>>>>>>>
82723>>>>>>>>>Move -1 to giLastSQLhdbc
82724>>>>>>>>>Move -1 to giLastSQLhstmt
82725>>>>>>>>>
82725>>>>>>>>>Struct tSQLColumn
82725>>>>>>>>>    Integer iSQLType
82725>>>>>>>>>    Integer iSQLSize
82725>>>>>>>>>    Integer iSQLPrecision
82725>>>>>>>>>    Integer iVariableDataType
82725>>>>>>>>>End_Struct
82725>>>>>>>>>
82725>>>>>>>>>Class cSQLStatement is a cObject
82726>>>>>>>>>
82726>>>>>>>>>    Procedure Construct_object 
82728>>>>>>>>>        Forward Send Construct_object 
82730>>>>>>>>>
82730>>>>>>>>>        Property Handle  phCLIStatementHandle   0
82731>>>>>>>>>        Property Handle  phCLIConnectionHandle  0
82732>>>>>>>>>        Property String  psDriverID             ""
82733>>>>>>>>>        
82733>>>>>>>>>        Property Integer piLastColumn      0
82734>>>>>>>>>        Property Integer piLastArgument    0
82735>>>>>>>>>        Property Integer piBindFile        0
82736>>>>>>>>>        Property Integer piColumnCount     0
82737>>>>>>>>>
82737>>>>>>>>>        // Allocated buffer for SQLColumnValue. 
82737>>>>>>>>>        // Allocated size is size of the largest (not variable length) column
82737>>>>>>>>>        Property String  psMaxColValue     ""
82738>>>>>>>>>
82738>>>>>>>>>        // True if there is at least 1 column with a variable length data type                 
82738>>>>>>>>>        Property Integer piHasVariableDataType  0
82739>>>>>>>>>
82739>>>>>>>>>        // Max size of buffer for variable length data. Default 16000        
82739>>>>>>>>>        Property Integer piMaxVariableBufferLength 16000  
82740>>>>>>>>>
82740>>>>>>>>>        // Allocated buffer for SQLGetData. 
82740>>>>>>>>>        Property String  psVariableBuffer  ""
82741>>>>>>>>>
82741>>>>>>>>>        // Allocated size of psVariableBuffer
82741>>>>>>>>>        Property Integer piVariableBufferLength 0
82742>>>>>>>>>
82742>>>>>>>>>        // Stores column properties of a result set.
82742>>>>>>>>>        Property tSQLColumn[] paSQLColumns
82743>>>>>>>>>        
82743>>>>>>>>>        // piFetchResult is set by SQLFetchRowValues and SQLFetchResultSetValues
82743>>>>>>>>>        //               0    = Fetch returned no data.
82743>>>>>>>>>        //               <> 0 = Row fetched
82743>>>>>>>>>        Property Integer piFetchResult     0
82744>>>>>>>>>
82744>>>>>>>>>
82744>>>>>>>>>        Property String psDummyZeroDate              '0001-01-01'
82745>>>>>>>>>        Property String psDummyZeroDateMssqlDatetime '1753-01-01'        
82746>>>>>>>>>
82746>>>>>>>>>    End_Procedure 
82747>>>>>>>>>
82747>>>>>>>>>    //***
82747>>>>>>>>>    //*** Procedure: StoreStatementInfo
82747>>>>>>>>>    //*** Purpose  : Store basic information about the statement.
82747>>>>>>>>>    //***
82747>>>>>>>>>    Procedure StoreStatementInfo Handle hCLIStatementHandle String sDrvrId Handle hCLIConnectionHandle
82749>>>>>>>>>        
82749>>>>>>>>>        Set phCLIStatementHandle   to hCLIStatementHandle
82750>>>>>>>>>        Set phCLIConnectionHandle  to hCLIConnectionHandle
82751>>>>>>>>>        Set psDriverID             to sDrvrId
82752>>>>>>>>>        
82752>>>>>>>>>    End_Procedure 
82753>>>>>>>>>
82753>>>>>>>>>
82753>>>>>>>>>    //***
82753>>>>>>>>>    //*** Procedure: DestroySQLStatement
82753>>>>>>>>>    //*** Purpose  : Destroy the cSQLStatement object
82753>>>>>>>>>    //***
82753>>>>>>>>>    Procedure DestroySQLStatement
82755>>>>>>>>>        Send Destroy
82756>>>>>>>>>    End_Procedure 
82757>>>>>>>>>
82757>>>>>>>>>    //***
82757>>>>>>>>>    //*** Procedure: HandleError
82757>>>>>>>>>    //*** Puprose  : Handle an error that has occured while checking properties.
82757>>>>>>>>>    //***
82757>>>>>>>>>
82757>>>>>>>>>    Procedure HandleError Integer ihstmt Integer ihdbc String sDrvrId String sOriginMsg
82759>>>>>>>>>        Integer iErrHandle
82759>>>>>>>>>        Integer iErrNum
82759>>>>>>>>>        String  sLocationInfo
82759>>>>>>>>>
82759>>>>>>>>>        //*** Get the DataFlex statement identifier
82759>>>>>>>>>        Move Self To iErrHandle
82760>>>>>>>>>
82760>>>>>>>>>        //*** Determine error number
82760>>>>>>>>>        If (ihstmt = 0) ;            Move CLIERR_SQLINVALID_CLI_STMT_HANDLE To iErrNum
82763>>>>>>>>>        Else If (ihdbc = 0) ;            Move CLIERR_SQLINVALID_CLI_CONN_HANDLE To iErrNum
82767>>>>>>>>>        Else If (sDrvrId = "") ;            Move CLIERR_SQLINVALID_DRIVER_ID To iErrNum
82771>>>>>>>>>        Else ;            Move CLIERR_SQL_ERROR To iErrNum
82773>>>>>>>>>
82773>>>>>>>>>        //*** Create location ifnormation
82773>>>>>>>>>        Move "[" To sLocationInfo
82774>>>>>>>>>        If (sOriginMsg <> "") Begin
82776>>>>>>>>>            Move (Append(sLocationInfo, sOriginMsg)) To sLocationInfo
82777>>>>>>>>>            Move (Append(sLocationInfo, ", "))       To sLocationInfo
82778>>>>>>>>>        End
82778>>>>>>>>>>
82778>>>>>>>>>        Move (Append(sLocationInfo, "DataFlex hstmt = ")) To sLocationInfo
82779>>>>>>>>>        Move (Append(sLocationInfo, iErrHandle))          To sLocationInfo
82780>>>>>>>>>        Move (Append(sLocationInfo, "]"))                 To sLocationInfo
82781>>>>>>>>>
82781>>>>>>>>>        //*** Generate the error
82781>>>>>>>>>        Error iErrNum sLocationInfo
82782>>>>>>>>>>
82782>>>>>>>>>    End_Procedure
82783>>>>>>>>>
82783>>>>>>>>>
82783>>>>>>>>>
82783>>>>>>>>>    //***
82783>>>>>>>>>    //*** Procedure: StmtError
82783>>>>>>>>>    //*** Purpose  : Handle general error not related to the properties
82783>>>>>>>>>    //***
82783>>>>>>>>>
82783>>>>>>>>>    Procedure StmtError Integer iErrNum String sErrText String sOriginMsg
82785>>>>>>>>>        Integer iErrHandle
82785>>>>>>>>>        String  sLocationInfo
82785>>>>>>>>>
82785>>>>>>>>>        //*** Get the DataFlex statement identifier
82785>>>>>>>>>        Move Self to iErrHandle
82786>>>>>>>>>
82786>>>>>>>>>        //*** Create location information
82786>>>>>>>>>        Move "[" To sLocationInfo
82787>>>>>>>>>        If (sOriginMsg <> "") Begin
82789>>>>>>>>>            Move (Append(sLocationInfo, sOriginMsg)) To sLocationInfo
82790>>>>>>>>>            Move (Append(sLocationInfo, ", "))       To sLocationInfo
82791>>>>>>>>>        End
82791>>>>>>>>>>
82791>>>>>>>>>        If (sErrtext <> "") Begin
82793>>>>>>>>>            Move (Append(sLocationInfo, sErrtext)) To sLocationInfo
82794>>>>>>>>>            Move (Append(sLocationInfo, ", "))     To sLocationInfo
82795>>>>>>>>>        End
82795>>>>>>>>>>
82795>>>>>>>>>        Move (Append(sLocationInfo, "DataFlex hstmt = ")) To sLocationInfo
82796>>>>>>>>>        Move (Append(sLocationInfo, iErrHandle))          To sLocationInfo
82797>>>>>>>>>        Move (Append(sLocationInfo, "]"))                 To sLocationInfo
82798>>>>>>>>>
82798>>>>>>>>>        //*** Generate the error
82798>>>>>>>>>        Error iErrNum sLocationInfo
82799>>>>>>>>>>
82799>>>>>>>>>    End_Procedure 
82800>>>>>>>>>
82800>>>>>>>>>
82800>>>>>>>>>
82800>>>>>>>>>    //***
82800>>>>>>>>>    //*** Procedure: SQLIllegalAttribute
82800>>>>>>>>>    //*** Purpose  : Handle an illegal attribute error
82800>>>>>>>>>    //***
82800>>>>>>>>>
82800>>>>>>>>>    Procedure SQLIllegalAttribute String sErrText String sOriginMsg
82802>>>>>>>>>        Integer bReport
82802>>>>>>>>>
82802>>>>>>>>>        Get_attribute DF_REPORT_UNSUPPORTED_ATTRIBUTES To bReport
82805>>>>>>>>>        If (bReport) ;            Send StmtError CLIERR_SQLINVALID_ATTRIBUTE sErrtext sOriginMsg
82808>>>>>>>>>    End_Procedure 
82809>>>>>>>>>
82809>>>>>>>>>
82809>>>>>>>>>
82809>>>>>>>>>    //***
82809>>>>>>>>>    //*** Function: SQLPrivateColumnIsLegal
82809>>>>>>>>>    //*** Purpose : Check if a column number is legal
82809>>>>>>>>>    //***
82809>>>>>>>>>
82809>>>>>>>>>    Function SQLPrivateColumnIsLegal Integer ihdbc String sDrvrId Integer ihstmt Integer iCol Returns Integer
82811>>>>>>>>>        Integer bLegal
82811>>>>>>>>>        Integer iNumColumns
82811>>>>>>>>>
82811>>>>>>>>>        Get SQLPrivateStmtAttribute SQLSTMTATTRIB_COLUMNCOUNT ihdbc sDrvrId ihstmt To iNumColumns
82812>>>>>>>>>        If (iCol > 0 And iCol <= iNumColumns) ;            Move DFTRUE To bLegal
82815>>>>>>>>>        Else ;            Move DFFALSE To bLegal
82817>>>>>>>>>
82817>>>>>>>>>        Function_Return bLegal
82818>>>>>>>>>    End_Function 
82819>>>>>>>>>
82819>>>>>>>>>
82819>>>>>>>>>
82819>>>>>>>>>    //***
82819>>>>>>>>>    //*** Procedure: SQLClose
82819>>>>>>>>>    //*** Purpose  : Close a statement and free all alllocated resources
82819>>>>>>>>>    //***
82819>>>>>>>>>
82819>>>>>>>>>    Procedure SQLClose
82821>>>>>>>>>        Integer ihdbc
82821>>>>>>>>>        Integer ihstmt
82821>>>>>>>>>        Integer iVoid
82821>>>>>>>>>        String  sDrvrId
82821>>>>>>>>>        String  sEmpty
82821>>>>>>>>>
82821>>>>>>>>>        //*** Initialize
82821>>>>>>>>>        Move "" To sEmpty
82822>>>>>>>>>
82822>>>>>>>>>        //*** Get the cli handles
82822>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
82823>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
82824>>>>>>>>>        Get psDriverId            to sDrvrId
82825>>>>>>>>>
82825>>>>>>>>>        //*** Free the CLI handle
82825>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
82827>>>>>>>>>            //*** Call the driver function to close
82827>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLCLOSE ;                        Callback Self ;                        Passing ihdbc sEmpty ihstmt ;                        Result iVoid
82832>>>>>>>>>
82832>>>>>>>>>            Move -1 to giLastSQLhstmt
82833>>>>>>>>>            //*** Free the DataFlex handle
82833>>>>>>>>>            Send DestroySQLStatement
82834>>>>>>>>>        End
82834>>>>>>>>>>
82834>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLClose"
82836>>>>>>>>>    End_Procedure
82837>>>>>>>>>
82837>>>>>>>>>
82837>>>>>>>>>
82837>>>>>>>>>    //***
82837>>>>>>>>>    //*** Procedure: SQLPrepare
82837>>>>>>>>>    //*** Purpose  : Prepare a statement for execution
82837>>>>>>>>>    //***
82837>>>>>>>>>
82837>>>>>>>>>    Procedure SQLPrepare String sStatement
82839>>>>>>>>>        Integer ihdbc
82839>>>>>>>>>        Integer ihstmt
82839>>>>>>>>>        Integer iVoid
82839>>>>>>>>>        String  sDrvrId
82839>>>>>>>>>
82839>>>>>>>>>        //*** Get the cli handles
82839>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
82840>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
82841>>>>>>>>>        Get psDriverId            to sDrvrId
82842>>>>>>>>>
82842>>>>>>>>>        //*** Prepare
82842>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
82844>>>>>>>>>            //*** Call the driver function to prepare
82844>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLPREPARE ;                        Callback Self ;                        Passing ihdbc sStatement ihstmt ;                        Result iVoid
82849>>>>>>>>>        End
82849>>>>>>>>>>
82849>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLPrepare"
82851>>>>>>>>>    End_Procedure
82852>>>>>>>>>
82852>>>>>>>>>    Procedure SQLGetStatementAttributes
82854>>>>>>>>>        Integer ihdbc ihstmt iNumColumns iCol iMaxSize
82854>>>>>>>>>        String sMaxValue
82854>>>>>>>>>        tSQLColumn[] aSQLColumns
82854>>>>>>>>>        tSQLColumn[] aSQLColumns
82855>>>>>>>>>        
82855>>>>>>>>>        Integer iSqlType
82855>>>>>>>>>        Integer iSQLSize
82855>>>>>>>>>        Integer iSQLprecision
82855>>>>>>>>>        Integer iVariableDataType
82855>>>>>>>>>        
82855>>>>>>>>>        String  sDrvrId
82855>>>>>>>>>
82855>>>>>>>>>        Integer iHasVariableDataType
82855>>>>>>>>>
82855>>>>>>>>>        Move 0 to iHasVariableDataType
82856>>>>>>>>>
82856>>>>>>>>>
82856>>>>>>>>>        //*** Get the cli handles
82856>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
82857>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
82858>>>>>>>>>        Get psDriverId            to sDrvrId
82859>>>>>>>>>
82859>>>>>>>>>        Get SQLPrivateStmtAttribute SQLSTMTATTRIB_COLUMNCOUNT ihdbc sDrvrId ihstmt to iNumColumns
82860>>>>>>>>>        
82860>>>>>>>>>        Set piColumnCount to iNumColumns
82861>>>>>>>>>        
82861>>>>>>>>>        // Fill columns array
82861>>>>>>>>>        For iCol from 1 to iNumColumns
82867>>>>>>>>>>
82867>>>>>>>>>            Move 0 to iVariableDataType
82868>>>>>>>>>            
82868>>>>>>>>>            Get SQLPrivateColAttribute iCol SQLCOLATTRIB_SQLTYPE ihdbc sDrvrId ihstmt to iSQLType
82869>>>>>>>>>            Get SQLPrivateColAttribute iCol SQLCOLATTRIB_SIZE ihdbc sDrvrId ihstmt to iSQLSize
82870>>>>>>>>>            Get SQLPrivateColAttribute iCol SQLCOLATTRIB_PRECISION ihdbc sDrvrId ihstmt to iSQLPrecision
82871>>>>>>>>>            
82871>>>>>>>>>            If ( (iSQLType = SQL_LONGVARCHAR) or (iSQLType = SQL_WLONGVARCHAR) ) Begin
82873>>>>>>>>>                 // text type 
82873>>>>>>>>>                Move 1 to iVariableDataType
82874>>>>>>>>>            End
82874>>>>>>>>>>
82874>>>>>>>>>            Else Begin
82875>>>>>>>>>                If (sDrvrId = "MSSQLDRV") Begin
82877>>>>>>>>>                    // SQL Server varchar(max) and nvarchar(max) types return Size = 0                   
82877>>>>>>>>>                    If ( ((iSQLType = SQL_VARCHAR) and (iSQLSize = 0) ) or ;                         ((iSQLType = SQL_WVARCHAR) and (iSQLSize = 0) ) ) Begin
82879>>>>>>>>>                            
82879>>>>>>>>>                        Move 1 to iVariableDataType     
82880>>>>>>>>>                    End
82880>>>>>>>>>>
82880>>>>>>>>>                End
82880>>>>>>>>>>
82880>>>>>>>>>            End
82880>>>>>>>>>>
82880>>>>>>>>>
82880>>>>>>>>>            Move iSqlType           to aSQLColumns[iCol].iSQLType            
82881>>>>>>>>>            Move iSQLSize           to aSQLColumns[iCol].iSQLSize
82882>>>>>>>>>            Move iSQLPrecision      to aSQLColumns[iCol].iSQLPrecision
82883>>>>>>>>>            Move iVariableDataType  to aSQLColumns[iCol].iVariableDataType
82884>>>>>>>>>            
82884>>>>>>>>>            If (not(iVariableDataType)) Begin
82886>>>>>>>>>                If (iSQLSize > iMaxSize) Begin
82888>>>>>>>>>                    Move iSQLSize to iMaxSize
82889>>>>>>>>>                End
82889>>>>>>>>>>
82889>>>>>>>>>            End
82889>>>>>>>>>>
82889>>>>>>>>>            Else Begin
82890>>>>>>>>>                Move 1 to iHasVariableDataType
82891>>>>>>>>>            End
82891>>>>>>>>>>
82891>>>>>>>>>            
82891>>>>>>>>>        Loop
82892>>>>>>>>>>
82892>>>>>>>>>        
82892>>>>>>>>>        Move (Repeat(' ', iMaxSize + 3)) to sMaxValue
82893>>>>>>>>>        Set psMaxColValue to sMaxValue
82894>>>>>>>>>        
82894>>>>>>>>>        Set paSQLColumns   to aSQLColumns        
82895>>>>>>>>>        Set piHasVariableDataType to iHasVariableDataType
82896>>>>>>>>>        
82896>>>>>>>>>    End_Procedure
82897>>>>>>>>>
82897>>>>>>>>>    //***
82897>>>>>>>>>    //*** Procedure: SQLExecute
82897>>>>>>>>>    //*** Purpose  : Execute a prepared statement
82897>>>>>>>>>    //***
82897>>>>>>>>>
82897>>>>>>>>>    Procedure SQLExecute
82899>>>>>>>>>        Integer ihdbc
82899>>>>>>>>>        Integer ihstmt
82899>>>>>>>>>        Integer iVoid
82899>>>>>>>>>        String  sDrvrId
82899>>>>>>>>>        String  sEmpty
82899>>>>>>>>>
82899>>>>>>>>>        //*** Initialize
82899>>>>>>>>>        Move "" To sEmpty
82900>>>>>>>>>
82900>>>>>>>>>        //*** Get the cli handles
82900>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
82901>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
82902>>>>>>>>>        Get psDriverId            to sDrvrId
82903>>>>>>>>>
82903>>>>>>>>>        //*** Execute
82903>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
82905>>>>>>>>>            //*** Call the driver function to execute
82905>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLEXECUTE ;                        Callback Self ;                        Passing ihdbc sEmpty ihstmt ;                        Result iVoid
82910>>>>>>>>>            Send SQLGetStatementAttributes
82911>>>>>>>>>        End
82911>>>>>>>>>>
82911>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLExecute"
82913>>>>>>>>>    End_Procedure
82914>>>>>>>>>
82914>>>>>>>>>
82914>>>>>>>>>
82914>>>>>>>>>    //***
82914>>>>>>>>>    //*** Procedure: SQLExecDirect
82914>>>>>>>>>    //*** Purpose  : Prepare and execute a statement
82914>>>>>>>>>    //***
82914>>>>>>>>>
82914>>>>>>>>>    Procedure SQLExecDirect String sStatement
82916>>>>>>>>>        Integer ihdbc
82916>>>>>>>>>        Integer ihstmt
82916>>>>>>>>>        Integer iVoid
82916>>>>>>>>>        String  sDrvrId
82916>>>>>>>>>
82916>>>>>>>>>        //*** Get the cli handles
82916>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
82917>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
82918>>>>>>>>>        Get psDriverId            to sDrvrId
82919>>>>>>>>>
82919>>>>>>>>>        //*** ExecDirect
82919>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
82921>>>>>>>>>            //*** Call the driver function to execdirect
82921>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLEXECDIRECT ;                        Callback Self ;                        Passing ihdbc sStatement ihstmt ;                        Result iVoid
82926>>>>>>>>>            Send SQLGetStatementAttributes
82927>>>>>>>>>        End
82927>>>>>>>>>>
82927>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLExecDirect"
82929>>>>>>>>>    End_Procedure
82930>>>>>>>>>
82930>>>>>>>>>
82930>>>>>>>>>
82930>>>>>>>>>    //***
82930>>>>>>>>>    //*** Procedure: SQLFetch
82930>>>>>>>>>    //*** Purpose  : Fetch the next row
82930>>>>>>>>>    //*** Returns  : 0   = No more data
82930>>>>>>>>>    //***            <>0 = Success
82930>>>>>>>>>    //***
82930>>>>>>>>>    Function SQLFetch Returns Integer
82932>>>>>>>>>        Integer ihdbc
82932>>>>>>>>>        Integer ihstmt
82932>>>>>>>>>        Integer iResult
82932>>>>>>>>>        String  sDrvrId
82932>>>>>>>>>        String  sEmpty
82932>>>>>>>>>
82932>>>>>>>>>        //*** Initialize
82932>>>>>>>>>        Move "" To sEmpty
82933>>>>>>>>>        Move 0  To iResult
82934>>>>>>>>>
82934>>>>>>>>>        //*** Get the cli handles
82934>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
82935>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
82936>>>>>>>>>        Get psDriverId            to sDrvrId
82937>>>>>>>>>
82937>>>>>>>>>        //*** Fetch
82937>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
82939>>>>>>>>>            Indicate Err False
82940>>>>>>>>>
82940>>>>>>>>>            //*** Call the driver function to fetch
82940>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLFETCH Callback Self Passing ihdbc sEmpty ihstmt Result iResult
82945>>>>>>>>>
82945>>>>>>>>>            //*** If something went wrong, adjust the result
82945>>>>>>>>>            If (Err) Move 0 to iResult
82948>>>>>>>>>
82948>>>>>>>>>            Set piLastcolumn To 0
82949>>>>>>>>>        End
82949>>>>>>>>>>
82949>>>>>>>>>        Else Send HandleError ihstmt ihdbc sDrvrId "SQLFetch"
82951>>>>>>>>>
82951>>>>>>>>>        Function_return iResult
82952>>>>>>>>>    End_Function
82953>>>>>>>>>
82953>>>>>>>>>
82953>>>>>>>>>    //***
82953>>>>>>>>>    //*** Procedure: SQLFetchRowValues
82953>>>>>>>>>    //*** Purpose  : Fetch the next row and return an array with all column values
82953>>>>>>>>>    //*** Returns  : Array of strings with all column values
82953>>>>>>>>>    //***            Sets piFetchResult property 
82953>>>>>>>>>    //***               0    = No more data
82953>>>>>>>>>    //***               <> 0 = Success
82953>>>>>>>>>    //***
82953>>>>>>>>>    Function SQLFetchRowValues Returns String[] 
82955>>>>>>>>>      
82955>>>>>>>>>        String[] asValues
82956>>>>>>>>>
82956>>>>>>>>>        tSQLColumn[] aSQLColumns        
82956>>>>>>>>>        tSQLColumn[] aSQLColumns        
82957>>>>>>>>>        
82957>>>>>>>>>        Integer ihdbc
82957>>>>>>>>>        Integer ihstmt
82957>>>>>>>>>        Integer iResult iVoid
82957>>>>>>>>>        Integer iColCount iCol
82957>>>>>>>>>        String  sDrvrId
82957>>>>>>>>>        String  sEmpty 
82957>>>>>>>>>        String  sResult
82957>>>>>>>>>        String  sVariableResult
82957>>>>>>>>>        Integer iHasVariableDataType
82957>>>>>>>>>        Integer iLen
82957>>>>>>>>>        Integer iVariableBufferLength
82957>>>>>>>>>
82957>>>>>>>>>        //*** Initialize
82957>>>>>>>>>        Move "" to sEmpty
82958>>>>>>>>>        Move 0  to iResult
82959>>>>>>>>>
82959>>>>>>>>>        //*** Get the cli handles
82959>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
82960>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
82961>>>>>>>>>        Get psDriverId            to sDrvrId
82962>>>>>>>>>        
82962>>>>>>>>>        Get paSQLColumns to aSQLColumns
82963>>>>>>>>>        Get piColumnCount to iColCount
82964>>>>>>>>>        Get piHasVariableDataType to iHasVariableDataType
82965>>>>>>>>>        
82965>>>>>>>>>        If (iHasVariableDataType) Begin
82967>>>>>>>>>            
82967>>>>>>>>>            Get piVariableBufferLength      to iVariableBufferLength
82968>>>>>>>>>            Get piMaxVariableBufferLength   to iLen
82969>>>>>>>>>            
82969>>>>>>>>>            If (iLen > iVariableBufferLength) Begin
82971>>>>>>>>>                //*** Allocate
82971>>>>>>>>>                Move (Repeat(' ', iLen)) to sVariableResult
82972>>>>>>>>>               
82972>>>>>>>>>                Set piVariableBufferLength to iLen
82973>>>>>>>>>                Set psVariableBuffer       to sVariableResult
82974>>>>>>>>>                
82974>>>>>>>>>                Get piVariableBufferLength to iVariableBufferLength                
82975>>>>>>>>>            End
82975>>>>>>>>>>
82975>>>>>>>>>        End
82975>>>>>>>>>>
82975>>>>>>>>>
82975>>>>>>>>>        //*** Fetch
82975>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
82977>>>>>>>>>            Move (False) to Err
82978>>>>>>>>>
82978>>>>>>>>>            // FUNC_SQLCOLUMNINFO will tell the driver which hdbc and hstmt to use 
82978>>>>>>>>>            // in the next FUNC_SQLCOLUMNVALUE call.
82978>>>>>>>>>            // If hdbc and hstmt have not changed since the last call we don't have to set it.
82978>>>>>>>>>            If (ihstmt <> giLastSQLhstmt or ihdbc <> giLastSQLhdbc) Begin
82980>>>>>>>>>                //*** Setup function arguments
82980>>>>>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO Callback 0 Passing ihdbc iCol ihstmt Result iVoid
82985>>>>>>>>>                Move ihstmt to giLastSQLhstmt
82986>>>>>>>>>                Move ihdbc to giLastSQLhdbc
82987>>>>>>>>>            End
82987>>>>>>>>>>
82987>>>>>>>>>
82987>>>>>>>>>            //*** Call the driver function to fetch
82987>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLFETCH Callback 0 Passing ihdbc sEmpty ihstmt Result iResult
82992>>>>>>>>>
82992>>>>>>>>>            //*** If something went wrong, adjust the result
82992>>>>>>>>>            If (Err) Move 0 to iResult
82995>>>>>>>>>            
82995>>>>>>>>>            If (iResult) Begin
82997>>>>>>>>>                For iCol from 1 to iColCount
83003>>>>>>>>>>
83003>>>>>>>>>                    
83003>>>>>>>>>                    If (not(aSQLColumns[iCol].iVariableDataType)) Begin
83005>>>>>>>>>                        Get psMaxColValue to sResult
83006>>>>>>>>>                        Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNVALUE Callback 0 Passing sResult sEmpty iCol Result iVoid
83011>>>>>>>>>
83011>>>>>>>>>                        Move sResult to asValues[iCol - 1]
83012>>>>>>>>>                    End
83012>>>>>>>>>>
83012>>>>>>>>>                    Else Begin
83013>>>>>>>>>                        Get psVariableBuffer       to sVariableResult
83014>>>>>>>>>                        Call_Driver 0 sDrvrId Function FUNC_SQLGETDATA ;                                    Callback 0 ;                                    Passing sVariableResult iCol iVariableBufferLength ;                                    Result iVoid
83019>>>>>>>>>                                    
83019>>>>>>>>>                        Move sVariableResult to asValues[iCol - 1]
83020>>>>>>>>>                    End
83020>>>>>>>>>>
83020>>>>>>>>>                    
83020>>>>>>>>>                Loop
83021>>>>>>>>>>
83021>>>>>>>>>            End
83021>>>>>>>>>>
83021>>>>>>>>>        End
83021>>>>>>>>>>
83021>>>>>>>>>        Else Begin    
83022>>>>>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLFetchRowValues"
83023>>>>>>>>>        End
83023>>>>>>>>>>
83023>>>>>>>>>
83023>>>>>>>>>        Set piFetchResult to iResult
83024>>>>>>>>>
83024>>>>>>>>>        Function_Return asValues
83025>>>>>>>>>        
83025>>>>>>>>>    End_Function 
83026>>>>>>>>>
83026>>>>>>>>>    //***
83026>>>>>>>>>    //*** Procedure: SQLFetchResultsetValues
83026>>>>>>>>>    //*** Purpose  : Fetch a complete result set. 
83026>>>>>>>>>    //*** Returns  : 2-dimensional array of strings with result set
83026>>>>>>>>>    //***            Sets piFetchResult property 
83026>>>>>>>>>    //***               0    = No more data
83026>>>>>>>>>    //***               <> 0 = Success
83026>>>>>>>>>    //***
83026>>>>>>>>>    Function SQLFetchResultsetValues Returns String[][] 
83028>>>>>>>>>        
83028>>>>>>>>>        String[][] asValues 
83029>>>>>>>>>        
83029>>>>>>>>>        Integer ihdbc ihstmt iResult iVoid iColCount iCol iRow
83029>>>>>>>>>        String sDrvrId sEmpty sResult sMax
83029>>>>>>>>>
83029>>>>>>>>>        tSQLColumn[] aSQLColumns        
83029>>>>>>>>>        tSQLColumn[] aSQLColumns        
83030>>>>>>>>>        String  sVariableResult
83030>>>>>>>>>        Integer iHasVariableDataType
83030>>>>>>>>>        Integer iLen
83030>>>>>>>>>        Integer iVariableBufferLength
83030>>>>>>>>>
83030>>>>>>>>>        //*** Initialize
83030>>>>>>>>>        Move "" to sEmpty
83031>>>>>>>>>        Move 0  to iResult
83032>>>>>>>>>
83032>>>>>>>>>        //*** Get the cli handles
83032>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
83033>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83034>>>>>>>>>        Get psDriverId            to sDrvrId
83035>>>>>>>>>
83035>>>>>>>>>        //*** Fetch
83035>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
83037>>>>>>>>>            Indicate Err False
83038>>>>>>>>>            
83038>>>>>>>>>            // FUNC_SQLCOLUMNINFO will tell the driver which hdbc and hstmt to use 
83038>>>>>>>>>            // in the next FUNC_SQLCOLUMNVALUE call.
83038>>>>>>>>>            // If hdbc and hstmt have not changed since the last call we don't have to set it.
83038>>>>>>>>>            If (ihstmt <> giLastSQLhstmt or ihdbc <> giLastSQLhdbc) Begin
83040>>>>>>>>>                //*** Setup function arguments
83040>>>>>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO Callback 0 Passing ihdbc iCol ihstmt Result iVoid
83045>>>>>>>>>                Move ihstmt to giLastSQLhstmt
83046>>>>>>>>>                Move ihdbc to giLastSQLhdbc
83047>>>>>>>>>            End
83047>>>>>>>>>>
83047>>>>>>>>>
83047>>>>>>>>>
83047>>>>>>>>>            Get paSQLColumns to aSQLColumns
83048>>>>>>>>>            Get piColumnCount to iColCount
83049>>>>>>>>>            Get piHasVariableDataType to iHasVariableDataType
83050>>>>>>>>>            If (iHasVariableDataType) Begin
83052>>>>>>>>>                Get piVariableBufferLength      to iVariableBufferLength
83053>>>>>>>>>                Get piMaxVariableBufferLength   to iLen
83054>>>>>>>>>                If (iLen > iVariableBufferLength) Begin
83056>>>>>>>>>                    //*** Allocate
83056>>>>>>>>>                    Move (Repeat(' ', iLen)) to sVariableResult
83057>>>>>>>>>                   
83057>>>>>>>>>                    Set piVariableBufferLength to iLen
83058>>>>>>>>>                    Set psVariableBuffer       to sVariableResult
83059>>>>>>>>>                    
83059>>>>>>>>>                    Get piVariableBufferLength to iVariableBufferLength                
83060>>>>>>>>>                End
83060>>>>>>>>>>
83060>>>>>>>>>                Else Begin
83061>>>>>>>>>                   Set psVariableBuffer       to sVariableResult
83062>>>>>>>>>                End
83062>>>>>>>>>>
83062>>>>>>>>>            End
83062>>>>>>>>>>
83062>>>>>>>>>
83062>>>>>>>>>            Get psMaxColValue to sMax
83063>>>>>>>>>
83063>>>>>>>>>            //*** Call the driver function to fetch
83063>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLFETCH Callback Self Passing ihdbc sEmpty ihstmt Result iResult
83068>>>>>>>>>            If (Err) Move 0 to iResult
83071>>>>>>>>>
83071>>>>>>>>>            While (iResult <> 0)
83075>>>>>>>>>
83075>>>>>>>>>                For iCol from 1 to (iColCount)
83081>>>>>>>>>>
83081>>>>>>>>>                    
83081>>>>>>>>>                    If (not(aSQLColumns[iCol].iVariableDataType)) Begin
83083>>>>>>>>>                        Move sMax to sResult
83084>>>>>>>>>                        Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNVALUE ;                                    Callback 0 ;                                    Passing sResult sEmpty iCol ;                                    Result iVoid
83089>>>>>>>>>                        Move sResult to asValues[iRow][iCol - 1]
83090>>>>>>>>>                    End
83090>>>>>>>>>>
83090>>>>>>>>>                    Else Begin
83091>>>>>>>>>                        //Variable data    
83091>>>>>>>>>                        Move sVariableResult to sResult
83092>>>>>>>>>                        Call_Driver 0 sDrvrId Function FUNC_SQLGETDATA ;                                    Callback 0 ;                                    Passing sResult iCol iVariableBufferLength ;                                    Result iVoid
83097>>>>>>>>>                                    
83097>>>>>>>>>                        Move sResult to asValues[iRow][iCol - 1]
83098>>>>>>>>>                    End
83098>>>>>>>>>>
83098>>>>>>>>>                Loop
83099>>>>>>>>>>
83099>>>>>>>>>
83099>>>>>>>>>                Increment iRow
83100>>>>>>>>>
83100>>>>>>>>>                //*** Call the driver function to fetch
83100>>>>>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLFETCH Callback Self Passing ihdbc sEmpty ihstmt Result iResult
83105>>>>>>>>>                If (Err) Move 0 to iResult
83108>>>>>>>>>
83108>>>>>>>>>            Loop
83109>>>>>>>>>>
83109>>>>>>>>>
83109>>>>>>>>>        End
83109>>>>>>>>>>
83109>>>>>>>>>        Else Send HandleError ihstmt ihdbc sDrvrId "SQLFetchResultsetValues"
83111>>>>>>>>>
83111>>>>>>>>>        Set piFetchResult to iResult
83112>>>>>>>>>
83112>>>>>>>>>        Function_Return asValues
83113>>>>>>>>>    End_Function 
83114>>>>>>>>>
83114>>>>>>>>>
83114>>>>>>>>>
83114>>>>>>>>>    //***
83114>>>>>>>>>    //*** Function: SQLNextColumn
83114>>>>>>>>>    //*** Purpose : Get the next column
83114>>>>>>>>>    //***
83114>>>>>>>>>
83114>>>>>>>>>    Function SQLNextColumn Returns String
83116>>>>>>>>>        Integer iCol
83116>>>>>>>>>        String  sResult
83116>>>>>>>>>
83116>>>>>>>>>        Get piLastColumn To iCol
83117>>>>>>>>>        Increment iCol
83118>>>>>>>>>        Get SQLColumnValue iCol To sResult
83119>>>>>>>>>        Set piLastColumn To iCol
83120>>>>>>>>>
83120>>>>>>>>>        Function_return sResult
83121>>>>>>>>>    End_Function 
83122>>>>>>>>>
83122>>>>>>>>>
83122>>>>>>>>>    //***
83122>>>>>>>>>    //*** Function: SQLColumnType
83122>>>>>>>>>    //*** Purpose : Returns the native type of a column
83122>>>>>>>>>    //***
83122>>>>>>>>>    Function SQLColumnType Integer iCol Returns Integer
83124>>>>>>>>>        Integer ihdbc
83124>>>>>>>>>        Integer ihstmt
83124>>>>>>>>>        String  sDrvrId
83124>>>>>>>>>        Integer iSQLType
83124>>>>>>>>>        Integer iColumns
83124>>>>>>>>>        
83124>>>>>>>>>        tSQLColumn[] aSQLColumns
83124>>>>>>>>>        tSQLColumn[] aSQLColumns
83125>>>>>>>>>        
83125>>>>>>>>>        //*** Get the cli handles
83125>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
83126>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83127>>>>>>>>>        Get psDriverId            to sDrvrId
83128>>>>>>>>>
83128>>>>>>>>>        //*** Get the value
83128>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
83130>>>>>>>>>        
83130>>>>>>>>>            Get paSQLColumns   to aSQLColumns        
83131>>>>>>>>>            Move (SizeOfArray(aSQLColumns)) to iColumns
83132>>>>>>>>>            
83132>>>>>>>>>            If (iCol >= 1 and iCol <= iColumns) Begin
83134>>>>>>>>>                Move aSQLColumns[iCol].iSQLType to iSQLType
83135>>>>>>>>>            End
83135>>>>>>>>>>
83135>>>>>>>>>            Else Begin
83136>>>>>>>>>                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLColumnType"        
83137>>>>>>>>>            End
83137>>>>>>>>>>
83137>>>>>>>>>        End
83137>>>>>>>>>>
83137>>>>>>>>>        Else Begin
83138>>>>>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLColumnType"
83139>>>>>>>>>        End
83139>>>>>>>>>>
83139>>>>>>>>>
83139>>>>>>>>>        Function_Return iSQLType
83140>>>>>>>>>    End_Function 
83141>>>>>>>>>
83141>>>>>>>>>    //***
83141>>>>>>>>>    //*** Function: SQLColumnSize
83141>>>>>>>>>    //*** Purpose : Returns the size (max length) of a column
83141>>>>>>>>>    //***
83141>>>>>>>>>    Function SQLColumnSize Integer iCol Returns Integer
83143>>>>>>>>>        Integer ihdbc
83143>>>>>>>>>        Integer ihstmt
83143>>>>>>>>>        String  sDrvrId
83143>>>>>>>>>        Integer iSQLSize
83143>>>>>>>>>        Integer iColumns
83143>>>>>>>>>        
83143>>>>>>>>>        tSQLColumn[] aSQLColumns
83143>>>>>>>>>        tSQLColumn[] aSQLColumns
83144>>>>>>>>>        
83144>>>>>>>>>        //*** Get the cli handles
83144>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
83145>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83146>>>>>>>>>        Get psDriverId            to sDrvrId
83147>>>>>>>>>
83147>>>>>>>>>        //*** Get the value
83147>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
83149>>>>>>>>>        
83149>>>>>>>>>            Get paSQLColumns   to aSQLColumns        
83150>>>>>>>>>            Move (SizeOfArray(aSQLColumns)) to iColumns
83151>>>>>>>>>            
83151>>>>>>>>>            If (iCol >= 1 and iCol <= iColumns) Begin
83153>>>>>>>>>                Move aSQLColumns[iCol].iSQLSize to iSQLSize
83154>>>>>>>>>            End
83154>>>>>>>>>>
83154>>>>>>>>>            Else Begin
83155>>>>>>>>>                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLColumnSize"        
83156>>>>>>>>>            End
83156>>>>>>>>>>
83156>>>>>>>>>        End
83156>>>>>>>>>>
83156>>>>>>>>>        Else Begin
83157>>>>>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLColumnSize"
83158>>>>>>>>>        End
83158>>>>>>>>>>
83158>>>>>>>>>
83158>>>>>>>>>        Function_Return iSQLSize
83159>>>>>>>>>    End_Function 
83160>>>>>>>>>
83160>>>>>>>>>    //***
83160>>>>>>>>>    //*** Function: SQLColumnVariableDatatype
83160>>>>>>>>>    //*** Purpose : Returns 1 for variable length datatypes. 
83160>>>>>>>>>    //***           For example SQL Server varchar(max) or text type
83160>>>>>>>>>    //***           The data of variable length datatype columns should be retrieved with SQLGetData 
83160>>>>>>>>>    Function SQLColumnVariableDatatype Integer iCol Returns Integer
83162>>>>>>>>>        Integer ihdbc
83162>>>>>>>>>        Integer ihstmt
83162>>>>>>>>>        String  sDrvrId
83162>>>>>>>>>        Integer iVariableDataType
83162>>>>>>>>>        Integer iColumns
83162>>>>>>>>>        
83162>>>>>>>>>        tSQLColumn[] aSQLColumns
83162>>>>>>>>>        tSQLColumn[] aSQLColumns
83163>>>>>>>>>        
83163>>>>>>>>>        //*** Get the cli handles
83163>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
83164>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83165>>>>>>>>>        Get psDriverId            to sDrvrId
83166>>>>>>>>>
83166>>>>>>>>>        //*** Get the value
83166>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
83168>>>>>>>>>        
83168>>>>>>>>>            Get paSQLColumns   to aSQLColumns        
83169>>>>>>>>>            Move (SizeOfArray(aSQLColumns)) to iColumns
83170>>>>>>>>>            
83170>>>>>>>>>            If (iCol >= 1 and iCol <= iColumns) Begin
83172>>>>>>>>>                Move aSQLColumns[iCol].iVariableDataType to iVariableDataType
83173>>>>>>>>>            End
83173>>>>>>>>>>
83173>>>>>>>>>            Else Begin
83174>>>>>>>>>                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLColumnVariableDatatype"        
83175>>>>>>>>>            End
83175>>>>>>>>>>
83175>>>>>>>>>        End
83175>>>>>>>>>>
83175>>>>>>>>>        Else Begin
83176>>>>>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLColumnVariableDatatype"
83177>>>>>>>>>        End
83177>>>>>>>>>>
83177>>>>>>>>>
83177>>>>>>>>>        Function_Return iVariableDataType
83178>>>>>>>>>    End_Function 
83179>>>>>>>>>
83179>>>>>>>>>
83179>>>>>>>>>
83179>>>>>>>>>
83179>>>>>>>>>    //***
83179>>>>>>>>>    //*** Function: SQLColumnValue
83179>>>>>>>>>    //*** Purpose : Return the value of a column in a fetched row of a given
83179>>>>>>>>>    //***           statement.
83179>>>>>>>>>    //***
83179>>>>>>>>>    Function SQLColumnValue Integer iCol Returns String
83181>>>>>>>>>        Integer ihdbc
83181>>>>>>>>>        Integer ihstmt
83181>>>>>>>>>        String  sDrvrId
83181>>>>>>>>>        String  sResult
83181>>>>>>>>>
83181>>>>>>>>>        Integer iVoid
83181>>>>>>>>>        Integer iColSize
83181>>>>>>>>>        Integer iColPrecision
83181>>>>>>>>>        String  sEmpty
83181>>>>>>>>>        Integer bLegalColumn
83181>>>>>>>>>
83181>>>>>>>>>        //*** Initialize
83181>>>>>>>>>        Move "" To sResult
83182>>>>>>>>>
83182>>>>>>>>>        //*** Get the cli handles
83182>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
83183>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83184>>>>>>>>>        Get psDriverId            to sDrvrId
83185>>>>>>>>>
83185>>>>>>>>>        // FUNC_SQLCOLUMNINFO will tell the driver which hdbc and hstmt to use 
83185>>>>>>>>>        // in the next FUNC_SQLCOLUMNVALUE call.
83185>>>>>>>>>        // If hdbc and hstmt have not changed since the last call we don't have to set it.
83185>>>>>>>>>        If (ihstmt <> giLastSQLhstmt or ihdbc <> giLastSQLhdbc) Begin
83187>>>>>>>>>            //*** Setup function arguments
83187>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                        Callback 0 ;                        Passing ihdbc iCol ihstmt ;                        Result iVoid
83192>>>>>>>>>            Move ihstmt to giLastSQLhstmt
83193>>>>>>>>>            Move ihdbc to giLastSQLhdbc
83194>>>>>>>>>        End
83194>>>>>>>>>>
83194>>>>>>>>>
83194>>>>>>>>>        If (iCol >= 1 and iCol <= piColumnCount(Self)) Begin
83196>>>>>>>>>            Get psMaxColValue to sResult
83197>>>>>>>>>            //*** Call the driver function to get the value
83197>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNVALUE ;                        Callback 0 ;                        Passing sResult sEmpty iCol ;                        Result iVoid
83202>>>>>>>>>        End
83202>>>>>>>>>>
83202>>>>>>>>>        Else Begin
83203>>>>>>>>>            Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLColumnValue"
83204>>>>>>>>>        End
83204>>>>>>>>>>
83204>>>>>>>>>
83204>>>>>>>>>        Function_Return sResult
83205>>>>>>>>>        
83205>>>>>>>>>    End_Function
83206>>>>>>>>>
83206>>>>>>>>>
83206>>>>>>>>>
83206>>>>>>>>>    //***
83206>>>>>>>>>    //*** Procedure: SQLBindFile
83206>>>>>>>>>    //*** Purpose  : Add a file to the files used to place the statement result in.
83206>>>>>>>>>    //***
83206>>>>>>>>>
83206>>>>>>>>>    Procedure SQLBindFile Integer iFileNum
83208>>>>>>>>>        Integer ihdbc
83208>>>>>>>>>        Integer ihstmt
83208>>>>>>>>>        Integer iVoid
83208>>>>>>>>>        String  sDrvrId
83208>>>>>>>>>        String  sFileType
83208>>>>>>>>>        Integer bIsOpen
83208>>>>>>>>>
83208>>>>>>>>>        //*** Get the cli handles
83208>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
83209>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83210>>>>>>>>>        Get psDriverId            to sDrvrId
83211>>>>>>>>>
83211>>>>>>>>>        //*** If a file number is not passed see if we can use the statement's
83211>>>>>>>>>        //*** default file number which is usually set with SetFileConnection
83211>>>>>>>>>        If (iFileNum = 0) Begin
83213>>>>>>>>>            Get piBindFile To iFileNum
83214>>>>>>>>>            If (iFileNum = 0) Begin
83216>>>>>>>>>                //*** Logic error, if 0 is passed as filenumber, piBindFile should be set.
83216>>>>>>>>>                Send StmtError CLIERR_SQLINVALID_BIND_FILE "piBindFile should be set" "SQLBindFile"
83217>>>>>>>>>
83217>>>>>>>>>                Move 0 to SQLResult
83218>>>>>>>>>                Procedure_Return
83219>>>>>>>>>            End
83219>>>>>>>>>>
83219>>>>>>>>>        End
83219>>>>>>>>>>
83219>>>>>>>>>
83219>>>>>>>>>        //*** Bind the file
83219>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
83221>>>>>>>>>            //*** Chek if the file is open
83221>>>>>>>>>            Get_attribute DF_FILE_OPENED Of iFileNum To bIsOpen
83224>>>>>>>>>            If (bIsOpen) Begin
83226>>>>>>>>>                //*** Check if the file has the correct type
83226>>>>>>>>>                Get_attribute DF_FILE_DRIVER Of iFileNum To sFileType
83229>>>>>>>>>                If (sFileType = sDrvrId) Begin
83231>>>>>>>>>                    //*** Call the driver function to add a file to a statement
83231>>>>>>>>>                    Call_driver 0 sDrvrId Function FUNC_SQLBINDFILE ;                                Callback Self ;                                Passing ihdbc iFileNum ihstmt ;                                Result iVoid
83236>>>>>>>>>                End
83236>>>>>>>>>>
83236>>>>>>>>>                Else ;                    Send StmtError CLIERR_SQLINVALID_BIND_FILE ("File" * String(iFileNum) * "type incompatible with statement ("  + sFileType + ")") "SQLBindFile"
83238>>>>>>>>>            End
83238>>>>>>>>>>
83238>>>>>>>>>            Else ;                Send StmtError CLIERR_SQLINVALID_BIND_FILE ("File not open (number =" * String(iFileNum) + ")") "SQLBindFile"
83240>>>>>>>>>        End
83240>>>>>>>>>>
83240>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLBindFile"
83242>>>>>>>>>    End_Procedure 
83243>>>>>>>>>
83243>>>>>>>>>
83243>>>>>>>>>
83243>>>>>>>>>    //*************************************************************************
83243>>>>>>>>>    //*** Function: SQLGetData                                              ***
83243>>>>>>>>>    //*** Purpose : Get data of a column.                                   ***
83243>>>>>>>>>    //*************************************************************************
83243>>>>>>>>>
83243>>>>>>>>>    Function SQLGetData Integer iCol Integer iLen Returns String
83245>>>>>>>>>        Integer ihdbc
83245>>>>>>>>>        Integer ihstmt
83245>>>>>>>>>        Integer iVoid
83245>>>>>>>>>        Integer iColSize
83245>>>>>>>>>        Integer iResult
83245>>>>>>>>>        String  sDrvrId
83245>>>>>>>>>        String  sResult
83245>>>>>>>>>        String  sEmpty
83245>>>>>>>>>        Integer bLegalColumn
83245>>>>>>>>>        
83245>>>>>>>>>        Integer iVariableBufferLength
83245>>>>>>>>>
83245>>>>>>>>>        //*** Initialize
83245>>>>>>>>>        Move "" To sEmpty
83246>>>>>>>>>        Move 0 To iResult
83247>>>>>>>>>
83247>>>>>>>>>        //*** Get the cli handles
83247>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
83248>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83249>>>>>>>>>        Get psDriverId            to sDrvrId
83250>>>>>>>>>
83250>>>>>>>>>        //*** Get the data
83250>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
83252>>>>>>>>>            //*** Check if the column exists
83252>>>>>>>>>            If (iCol >= 1 and iCol <= piColumnCount(Self)) Begin
83254>>>>>>>>>                If (iLen = 0) Begin
83256>>>>>>>>>                    Get SQLColumnValue iCol to sResult
83257>>>>>>>>>                End
83257>>>>>>>>>>
83257>>>>>>>>>                Else Begin
83258>>>>>>>>>                    // Add 1 for string terminator
83258>>>>>>>>>                    Move (iLen + 1) to iLen
83259>>>>>>>>>
83259>>>>>>>>>                    Get piVariableBufferLength to iVariableBufferLength
83260>>>>>>>>>                    If (iLen > iVariableBufferLength) Begin
83262>>>>>>>>>                        //*** Allocate
83262>>>>>>>>>                        Move (Repeat(' ', iLen)) to sResult
83263>>>>>>>>>                       
83263>>>>>>>>>                        Set piVariableBufferLength to iLen
83264>>>>>>>>>                        Set psVariableBuffer       to sResult
83265>>>>>>>>>                    End
83265>>>>>>>>>>
83265>>>>>>>>>                    Else Begin
83266>>>>>>>>>                        Get psVariableBuffer       to sResult
83267>>>>>>>>>                    End
83267>>>>>>>>>>
83267>>>>>>>>>
83267>>>>>>>>>
83267>>>>>>>>>                    // FUNC_SQLCOLUMNINFO will tell the driver which hdbc and hstmt to use 
83267>>>>>>>>>                    // in the next FUNC_SQLCOLUMNVALUE call.
83267>>>>>>>>>                    // If hdbc and hstmt have not changed since the last call we don't have to set it.
83267>>>>>>>>>                    If (ihstmt <> giLastSQLhstmt or ihdbc <> giLastSQLhdbc) Begin
83269>>>>>>>>>                        //*** Setup function arguments
83269>>>>>>>>>                        Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                                    Callback 0 ;                                    Passing ihdbc iCol ihstmt ;                                    Result iVoid
83274>>>>>>>>>                        Move ihstmt to giLastSQLhstmt
83275>>>>>>>>>                        Move ihdbc to giLastSQLhdbc
83276>>>>>>>>>                    End
83276>>>>>>>>>>
83276>>>>>>>>>
83276>>>>>>>>>                    Indicate Err False
83277>>>>>>>>>                    //*** Call the driver function to get the data
83277>>>>>>>>>                    Call_driver 0 sDrvrId Function FUNC_SQLGETDATA ;                                Callback Self ;                                Passing sResult iCol iLen ;                                Result iResult
83282>>>>>>>>>
83282>>>>>>>>>                    //*** If something went wrong, adjust the result
83282>>>>>>>>>                    If (Err) Begin
83284>>>>>>>>>                        Move 0 to iResult
83285>>>>>>>>>                    End
83285>>>>>>>>>>
83285>>>>>>>>>                End
83285>>>>>>>>>>
83285>>>>>>>>>            End
83285>>>>>>>>>>
83285>>>>>>>>>            Else Begin
83286>>>>>>>>>                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLGetData"
83287>>>>>>>>>            End
83287>>>>>>>>>>
83287>>>>>>>>>        End
83287>>>>>>>>>>
83287>>>>>>>>>        Else Begin
83288>>>>>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLGetData"
83289>>>>>>>>>        End
83289>>>>>>>>>>
83289>>>>>>>>>
83289>>>>>>>>>        //*** Fill global result
83289>>>>>>>>>        Move iResult To SQLResult
83290>>>>>>>>>
83290>>>>>>>>>        Function_Return sResult
83291>>>>>>>>>    End_Function 
83292>>>>>>>>>
83292>>>>>>>>>
83292>>>>>>>>>
83292>>>>>>>>>    //***
83292>>>>>>>>>    //*** Function: SQLColumnMap
83292>>>>>>>>>    //*** Purpose : Map a column name to a number, if the name id not found no
83292>>>>>>>>>    //***           error is generated the returned number will be 0 (zero) in
83292>>>>>>>>>    //***           that case
83292>>>>>>>>>    //***
83292>>>>>>>>>
83292>>>>>>>>>    Function SQLColumnMap String sColname Returns Integer
83294>>>>>>>>>        Integer ihdbc
83294>>>>>>>>>        Integer ihstmt
83294>>>>>>>>>        Integer iNumColumns
83294>>>>>>>>>        Integer iColCount
83294>>>>>>>>>        Integer iColNum
83294>>>>>>>>>        String  sDrvrId
83294>>>>>>>>>        String  sCurColName
83294>>>>>>>>>
83294>>>>>>>>>        //*** Get the cli handles
83294>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
83295>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83296>>>>>>>>>        Get psDriverId            to sDrvrId
83297>>>>>>>>>
83297>>>>>>>>>        //*** Get the number by looping through the column names
83297>>>>>>>>>        Move 0 To iColNum
83298>>>>>>>>>        Get SQLPrivateStmtAttribute SQLSTMTATTRIB_COLUMNCOUNT ihdbc sDrvrId ihstmt To iNumColumns
83299>>>>>>>>>        For iColCount From 1 To iNumColumns
83305>>>>>>>>>>
83305>>>>>>>>>            Get SQLPrivateColAttribute iColCount SQLCOLATTRIB_LABEL ihdbc sDrvrId ihstmt To sCurColName
83306>>>>>>>>>            If (Uppercase(Trim(sColName)) = Uppercase(Trim(sCurColName))) ;                Move iColCount To iColNum
83309>>>>>>>>>
83309>>>>>>>>>            If (iColNum) ;                Break
83312>>>>>>>>>        Loop
83313>>>>>>>>>>
83313>>>>>>>>>
83313>>>>>>>>>        Function_return iColNum
83314>>>>>>>>>    End_Function 
83315>>>>>>>>>
83315>>>>>>>>>
83315>>>>>>>>>
83315>>>>>>>>>    //***
83315>>>>>>>>>    //*** Function: SQLStmtAttribute
83315>>>>>>>>>    //*** Purpose : Get a statement attribute
83315>>>>>>>>>    //***
83315>>>>>>>>>
83315>>>>>>>>>    Function SQLStmtAttribute Integer iAttribId Returns String
83317>>>>>>>>>        Integer ihdbc
83317>>>>>>>>>        Integer ihstmt
83317>>>>>>>>>        String  sResult
83317>>>>>>>>>        String  sDrvrId
83317>>>>>>>>>
83317>>>>>>>>>        //*** Initialize
83317>>>>>>>>>        Move "" To sResult
83318>>>>>>>>>
83318>>>>>>>>>        //*** Get the cli handles
83318>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
83319>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83320>>>>>>>>>        Get psDriverId            to sDrvrId
83321>>>>>>>>>
83321>>>>>>>>>        //*** Get the attribute
83321>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") ;            Get SQLPrivateStmtAttribute iAttribId ihdbc sDrvrId ihstmt To sResult
83324>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLStmtAttribute"
83326>>>>>>>>>
83326>>>>>>>>>        Function_Return sResult
83327>>>>>>>>>    End_Function 
83328>>>>>>>>>
83328>>>>>>>>>    Function SQLPrivateStmtAttribute Integer iAttribId Integer ihdbc String sDrvrId Integer ihstmt Returns String
83330>>>>>>>>>        String  sResult
83330>>>>>>>>>        Integer iLen
83330>>>>>>>>>        Integer bLegalAttrib
83330>>>>>>>>>
83330>>>>>>>>>        //*** Initialize
83330>>>>>>>>>        Move ""     To sResult
83331>>>>>>>>>
83331>>>>>>>>>        //*** Get the attribute
83331>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
83333>>>>>>>>>            Case Begin
83333>>>>>>>>>                Case (iAttribId = SQLSTMTATTRIB_COLUMNCOUNT)
83335>>>>>>>>>                Case (iAttribId = SQLSTMTATTRIB_ROWCOUNT)
83338>>>>>>>>>                Case (iAttribId = SQLSTMTATTRIB_ROWCOUNT_TYPE)
83341>>>>>>>>>                Case (iAttribId = SQLSTMTATTRIB_NUMMESSAGES)
83344>>>>>>>>>                    Move DFTRUE To bLegalAttrib
83345>>>>>>>>>                    Break
83346>>>>>>>>>
83346>>>>>>>>>                Case Else
83346>>>>>>>>>                    Move DFFALSE To bLegalAttrib
83347>>>>>>>>>                    Send SQLIllegalAttribute ("Attribute is = " + String(iAttribId) + ")") "SQLPrivateStmtAttribute"
83348>>>>>>>>>            Case End
83348>>>>>>>>>
83348>>>>>>>>>            If (bLegalAttrib) Begin
83350>>>>>>>>>                //*** Setup function arguments
83350>>>>>>>>>                Call_driver 0 sDrvrId Function FUNC_SQLSTMTINTATTRIB ;                            Callback Self ;                            Passing ihdbc iAttribId ihstmt ;                            Result sResult
83355>>>>>>>>>            End
83355>>>>>>>>>>
83355>>>>>>>>>        End
83355>>>>>>>>>>
83355>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLPrivateStmtAttribute"
83357>>>>>>>>>
83357>>>>>>>>>        Function_Return sResult
83358>>>>>>>>>    End_Function 
83359>>>>>>>>>
83359>>>>>>>>>
83359>>>>>>>>>
83359>>>>>>>>>    //***
83359>>>>>>>>>    //*** Function: SQLColAttribute
83359>>>>>>>>>    //*** Purpose : Get a column's attribute
83359>>>>>>>>>    //***
83359>>>>>>>>>
83359>>>>>>>>>    Function SQLColAttribute Integer iCol Integer iAttribId Returns String
83361>>>>>>>>>        Integer ihdbc
83361>>>>>>>>>        Integer ihstmt
83361>>>>>>>>>        String  sResult
83361>>>>>>>>>        String  sDrvrId
83361>>>>>>>>>
83361>>>>>>>>>        //*** Initialize
83361>>>>>>>>>        Move "" To sResult
83362>>>>>>>>>
83362>>>>>>>>>        //*** Get the cli handles
83362>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
83363>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83364>>>>>>>>>        Get psDriverId            to sDrvrId
83365>>>>>>>>>
83365>>>>>>>>>        //*** Get the attribute
83365>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") ;            Get SQLPrivateColAttribute iCol iAttribId ihdbc sDrvrId ihstmt To sResult
83368>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLColAttribute"
83370>>>>>>>>>
83370>>>>>>>>>        Function_Return sResult
83371>>>>>>>>>    End_Function 
83372>>>>>>>>>
83372>>>>>>>>>    Function SQLPrivateColAttribute Integer iCol Integer iAttribId Integer ihdbc String sDrvrId Integer ihstmt Returns String
83374>>>>>>>>>        String  sResult
83374>>>>>>>>>        String  sEmpty
83374>>>>>>>>>        Integer bIsStringAttribute
83374>>>>>>>>>        Integer iLen
83374>>>>>>>>>        Integer iVoid
83374>>>>>>>>>        Integer bLegalAttrib
83374>>>>>>>>>        Integer bLegalColumn
83374>>>>>>>>>
83374>>>>>>>>>        //*** Initialize
83374>>>>>>>>>        Move "" To sResult
83375>>>>>>>>>        Move "" To sEmpty
83376>>>>>>>>>        MOve 0  To iLen
83377>>>>>>>>>
83377>>>>>>>>>        //*** Get the attribute
83377>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
83379>>>>>>>>>            Get SQLPrivateColumnIsLegal ihdbc sDrvrId ihstmt iCol To bLegalColumn
83380>>>>>>>>>            If (bLegalColumn) Begin
83382>>>>>>>>>                //*** Determine the atributes type
83382>>>>>>>>>                Case Begin
83382>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_SIZE)
83384>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_LENGTH)
83387>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_PRECISION)
83390>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_SQLTYPE)
83393>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_NULLABLE)
83396>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_DFTYPE)
83399>>>>>>>>>                        Move DFFALSE To bIsStringAttribute
83400>>>>>>>>>                        Move DFTRUE To bLegalAttrib
83401>>>>>>>>>                        Break
83402>>>>>>>>>
83402>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_LABEL)
83405>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_BASECOLUMNNAME)
83408>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_BASETABLENAME)
83411>>>>>>>>>                        Move DFTRUE To bIsStringAttribute
83412>>>>>>>>>                        Move DFTRUE To bLegalAttrib
83413>>>>>>>>>                        Break
83414>>>>>>>>>
83414>>>>>>>>>                    Case Else
83414>>>>>>>>>                        Move DFFALSE To bLegalAttrib
83415>>>>>>>>>                        Send SQLIllegalAttribute ("Attribute is = " + String(iAttribId) + ")") "SQLPrivateColAttribute"
83416>>>>>>>>>                Case End
83416>>>>>>>>>
83416>>>>>>>>>                If (bLegalAttrib) Begin
83418>>>>>>>>>                    //*** Setup function arguments
83418>>>>>>>>>                    Call_driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                                Callback Self ;                                Passing ihdbc iCol ihstmt ;                                Result iVoid
83423>>>>>>>>>
83423>>>>>>>>>                    If (bIsStringAttribute) Begin
83425>>>>>>>>>                        //*** Call the driver function to get the data length
83425>>>>>>>>>                        Call_driver 0 sDrvrId Function FUNC_SQLCOLSTRINGATTRIBLEN ;                                    Callback Self ;                                    Passing sEmpty sEmpty iAttribId ;                                    Result iLen
83430>>>>>>>>>
83430>>>>>>>>>                        If (iLen) Begin
83432>>>>>>>>>                            //*** Allocate
83432>>>>>>>>>                            Move (Repeat(' ', iLen)) To sResult
83433>>>>>>>>>
83433>>>>>>>>>                            //*** Call the driver function to get the name
83433>>>>>>>>>                            Call_driver 0 sDrvrId Function FUNC_SQLCOLSTRINGATTRIB ;                                        Callback Self ;                                        Passing sResult sEmpty iAttribId ;                                        Result iVoid
83438>>>>>>>>>                        End
83438>>>>>>>>>>
83438>>>>>>>>>                    End
83438>>>>>>>>>>
83438>>>>>>>>>                    Else Begin
83439>>>>>>>>>                        //*** get the attribute
83439>>>>>>>>>                        Call_driver 0 sDrvrId Function FUNC_SQLCOLINTATTRIB ;                                    Callback Self ;                                    Passing sEmpty sEmpty iAttribId ;                                    Result sResult
83444>>>>>>>>>                    End
83444>>>>>>>>>>
83444>>>>>>>>>                End
83444>>>>>>>>>>
83444>>>>>>>>>            End
83444>>>>>>>>>>
83444>>>>>>>>>            Else ;                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLPrivateColAttribute"
83446>>>>>>>>>        End
83446>>>>>>>>>>
83446>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLPrivateColAttribute"
83448>>>>>>>>>
83448>>>>>>>>>        Function_Return sResult
83449>>>>>>>>>    End_Function 
83450>>>>>>>>>
83450>>>>>>>>>
83450>>>>>>>>>
83450>>>>>>>>>    //***
83450>>>>>>>>>    //*** Procedure: SQLSetProcedureName
83450>>>>>>>>>    //*** Purpsoe  : Preapre for calling a stored procedure, pass the procedure name.
83450>>>>>>>>>    //***
83450>>>>>>>>>
83450>>>>>>>>>    Procedure SQLSetProcedureName String sProcName String sSchemaArg
83452>>>>>>>>>        Integer ihdbc
83452>>>>>>>>>        Integer ihstmt
83452>>>>>>>>>        String  sDrvrId
83452>>>>>>>>>        Integer iVoid
83452>>>>>>>>>        String  sSchema
83452>>>>>>>>>        String  sEmpty
83452>>>>>>>>>
83452>>>>>>>>>        //*** Initialize
83452>>>>>>>>>        Move "" To sEmpty
83453>>>>>>>>>
83453>>>>>>>>>        //*** Get the cli handles
83453>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
83454>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83455>>>>>>>>>        Get psDriverId            to sDrvrId
83456>>>>>>>>>
83456>>>>>>>>>        //*** Call the procedure
83456>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
83458>>>>>>>>>            If (Num_Arguments >= 2) ;                Move sSchemaArg To sSchema
83461>>>>>>>>>            Else ;                Move "" To sSchema
83463>>>>>>>>>
83463>>>>>>>>>            If (sSchema <> "") Begin
83465>>>>>>>>>                Call_driver 0 sDrvrId Function FUNC_SQLSETPROCSCHEMA ;                            Callback Self ;                            Passing ihdbc sSchema ihstmt ;                            Result iVoid
83470>>>>>>>>>            End
83470>>>>>>>>>>
83470>>>>>>>>>
83470>>>>>>>>>            //*** Call the procedure
83470>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLSETPROCNAME ;                        Callback Self ;                        Passing ihdbc sProcName ihstmt ;                        Result iVoid
83475>>>>>>>>>
83475>>>>>>>>>            Set piLastArgument To 0
83476>>>>>>>>>        End
83476>>>>>>>>>>
83476>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLSetProcedurename"
83478>>>>>>>>>    End_Procedure 
83479>>>>>>>>>
83479>>>>>>>>>
83479>>>>>>>>>
83479>>>>>>>>>    //***
83479>>>>>>>>>    //*** Function: SQLSetNextArgument
83479>>>>>>>>>    //*** Purpose : Pass the next argument
83479>>>>>>>>>    //***
83479>>>>>>>>>
83479>>>>>>>>>    Procedure SQLSetNextArgument String sArgument
83481>>>>>>>>>        Integer iArgnum
83481>>>>>>>>>
83481>>>>>>>>>        Get piLastArgument To iArgnum
83482>>>>>>>>>        Increment iArgnum
83483>>>>>>>>>        Send SQLSetArgument iArgnum sArgument
83484>>>>>>>>>        Set piLastArgument To iArgnum
83485>>>>>>>>>    End_Procedure 
83486>>>>>>>>>
83486>>>>>>>>>
83486>>>>>>>>>
83486>>>>>>>>>    //***
83486>>>>>>>>>    //*** Procedure: SQLSetArgument
83486>>>>>>>>>    //*** Purpose  : Set the next argument
83486>>>>>>>>>    //***
83486>>>>>>>>>
83486>>>>>>>>>    Procedure SQLSetArgument Integer iArgnum String sArgument
83488>>>>>>>>>        Integer ihdbc
83488>>>>>>>>>        Integer ihstmt
83488>>>>>>>>>        String  sDrvrId
83488>>>>>>>>>        Integer iVoid
83488>>>>>>>>>        String  sEmpty
83488>>>>>>>>>
83488>>>>>>>>>        //*** Initialize
83488>>>>>>>>>        Move "" To sEmpty
83489>>>>>>>>>
83489>>>>>>>>>        //*** Get the cli handles
83489>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
83490>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83491>>>>>>>>>        Get psDriverId            to sDrvrId
83492>>>>>>>>>
83492>>>>>>>>>        //*** Call the procedure
83492>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
83494>>>>>>>>>            //*** Pass the information
83494>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                        Callback Self ;                        Passing ihdbc iArgnum ihstmt ;                        Result iVoid
83499>>>>>>>>>
83499>>>>>>>>>            //*** Pass the argument
83499>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLSETPROCARG ;                        Callback Self ;                        Passing sArgument sEmpty 0 ;                        Result iVoid
83504>>>>>>>>>        End
83504>>>>>>>>>>
83504>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLSetArgument"
83506>>>>>>>>>    End_Procedure
83507>>>>>>>>>
83507>>>>>>>>>
83507>>>>>>>>>
83507>>>>>>>>>    //***
83507>>>>>>>>>    //*** Procedure: SQLCall
83507>>>>>>>>>    //*** Purpose  : Call a stored procedure
83507>>>>>>>>>    //***
83507>>>>>>>>>
83507>>>>>>>>>    Procedure SQLCall
83509>>>>>>>>>        Integer ihdbc
83509>>>>>>>>>        Integer ihstmt
83509>>>>>>>>>        String  sDrvrId
83509>>>>>>>>>        Integer iVoid
83509>>>>>>>>>        String  sEmpty
83509>>>>>>>>>
83509>>>>>>>>>        //*** Initialize
83509>>>>>>>>>        Move "" To sEmpty
83510>>>>>>>>>
83510>>>>>>>>>        //*** Get the cli handles
83510>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
83511>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83512>>>>>>>>>        Get psDriverId            to sDrvrId
83513>>>>>>>>>
83513>>>>>>>>>        //*** Call the procedure
83513>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
83515>>>>>>>>>            //*** Call the procedure
83515>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLCALL ;                        Callback Self ;                        Passing ihdbc sEmpty ihstmt ;                        Result iVoid
83520>>>>>>>>>                        
83520>>>>>>>>>            Send SQLGetStatementAttributes
83521>>>>>>>>>            Set piLastArgument To 0
83522>>>>>>>>>        End
83522>>>>>>>>>>
83522>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLCall"
83524>>>>>>>>>    End_Procedure 
83525>>>>>>>>>
83525>>>>>>>>>
83525>>>>>>>>>
83525>>>>>>>>>    //***
83525>>>>>>>>>    //*** Function: SQLGetNextArgument
83525>>>>>>>>>    //*** Purpose : Get the next argument
83525>>>>>>>>>    //***
83525>>>>>>>>>
83525>>>>>>>>>    Function SQLGetNextArgument Returns String
83527>>>>>>>>>        Integer iArgnum
83527>>>>>>>>>        String  sResult
83527>>>>>>>>>
83527>>>>>>>>>        Get piLastArgument To iArgnum
83528>>>>>>>>>        Increment iArgnum
83529>>>>>>>>>        Get SQLGetArgument iArgnum To sResult
83530>>>>>>>>>        Set piLastArgument To iArgnum
83531>>>>>>>>>
83531>>>>>>>>>        Function_return sResult
83532>>>>>>>>>    End_Function 
83533>>>>>>>>>
83533>>>>>>>>>
83533>>>>>>>>>
83533>>>>>>>>>    //***
83533>>>>>>>>>    //*** Function: SQLGetArgument
83533>>>>>>>>>    //*** Purpose : Get the specified argument from a procedure
83533>>>>>>>>>    //***
83533>>>>>>>>>
83533>>>>>>>>>    Function SQLGetArgument Integer iArgnum Returns String
83535>>>>>>>>>        Integer ihdbc
83535>>>>>>>>>        Integer ihstmt
83535>>>>>>>>>        String  sDrvrId
83535>>>>>>>>>        Integer iVoid
83535>>>>>>>>>        String  sEmpty
83535>>>>>>>>>        String  sArgument
83535>>>>>>>>>        Integer iLen
83535>>>>>>>>>
83535>>>>>>>>>        //*** Initialize
83535>>>>>>>>>        Move "" To sEmpty
83536>>>>>>>>>        Move "" To sArgument
83537>>>>>>>>>
83537>>>>>>>>>        //*** Get the cli handles
83537>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
83538>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83539>>>>>>>>>        Get psDriverId            to sDrvrId
83540>>>>>>>>>
83540>>>>>>>>>        //*** Call the procedure
83540>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
83542>>>>>>>>>            //*** Pass the information
83542>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                        Callback Self ;                        Passing ihdbc iArgnum ihstmt ;                        Result iVoid
83547>>>>>>>>>
83547>>>>>>>>>            //*** Get the length
83547>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLGETPROCARGLEN ;                        Callback Self ;                        Passing sEmpty sEmpty 0 ;                        Result iLen
83552>>>>>>>>>
83552>>>>>>>>>            If (iLen) Begin
83554>>>>>>>>>                //*** Allocate
83554>>>>>>>>>                Move (Repeat(' ', iLen)) To sArgument
83555>>>>>>>>>
83555>>>>>>>>>                //*** Pass the argument
83555>>>>>>>>>                Call_driver 0 sDrvrId Function FUNC_SQLGETPROCARG ;                            Callback Self ;                            Passing sArgument sEmpty 0 ;                            Result iVoid
83560>>>>>>>>>            End
83560>>>>>>>>>>
83560>>>>>>>>>        End
83560>>>>>>>>>>
83560>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLGetArgument"
83562>>>>>>>>>
83562>>>>>>>>>        Function_Return sArgument
83563>>>>>>>>>    End_Function 
83564>>>>>>>>>
83564>>>>>>>>>
83564>>>>>>>>>
83564>>>>>>>>>    //***
83564>>>>>>>>>    //*** Function: SQLReturnValue
83564>>>>>>>>>    //*** Purpose : Get the return value of a stored function
83564>>>>>>>>>    //***
83564>>>>>>>>>
83564>>>>>>>>>    Function SQLReturnValue Returns String
83566>>>>>>>>>        Integer ihdbc
83566>>>>>>>>>        Integer ihstmt
83566>>>>>>>>>        String  sDrvrId
83566>>>>>>>>>        Integer iVoid
83566>>>>>>>>>        String  sEmpty
83566>>>>>>>>>        String  sRetval
83566>>>>>>>>>        Integer iLen
83566>>>>>>>>>
83566>>>>>>>>>        //*** Initialize
83566>>>>>>>>>        Move "" To sEmpty
83567>>>>>>>>>        Move "" To sRetval
83568>>>>>>>>>
83568>>>>>>>>>        //*** Get the cli handles
83568>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
83569>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83570>>>>>>>>>        Get psDriverId            to sDrvrId
83571>>>>>>>>>
83571>>>>>>>>>        //*** Call the procedure
83571>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
83573>>>>>>>>>            //*** Get the length
83573>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLGETPROCRETVALLEN ;                        Callback Self ;                        Passing ihdbc sEmpty ihstmt  ;                        Result iLen
83578>>>>>>>>>
83578>>>>>>>>>            If (iLen) Begin
83580>>>>>>>>>                //*** Allocate
83580>>>>>>>>>                Move (Repeat(' ', iLen)) To sRetval
83581>>>>>>>>>
83581>>>>>>>>>                //*** Pass the argument
83581>>>>>>>>>                Call_driver 0 sDrvrId Function FUNC_SQLGETPROCRETVAL ;                            Callback Self ;                            Passing ihdbc sRetval ihstmt ;                            Result iVoid
83586>>>>>>>>>            End
83586>>>>>>>>>>
83586>>>>>>>>>        End
83586>>>>>>>>>>
83586>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLReturnValue"
83588>>>>>>>>>
83588>>>>>>>>>        Function_Return sRetval
83589>>>>>>>>>    End_Function 
83590>>>>>>>>>
83590>>>>>>>>>
83590>>>>>>>>>
83590>>>>>>>>>    //***
83590>>>>>>>>>    //*** Function: SQLNextResultSet
83590>>>>>>>>>    //*** Purpose : Switch to the next set
83590>>>>>>>>>    //*** Returns : 0   = No more result sets
83590>>>>>>>>>    //***           <>0 = Switched to next set
83590>>>>>>>>>    //***
83590>>>>>>>>>
83590>>>>>>>>>    Function SQLNextResultSet Returns Integer
83592>>>>>>>>>        Integer ihdbc
83592>>>>>>>>>        Integer ihstmt
83592>>>>>>>>>        String  sDrvrId
83592>>>>>>>>>        Integer iResult
83592>>>>>>>>>        String  sEmpty
83592>>>>>>>>>
83592>>>>>>>>>        //*** Initialize
83592>>>>>>>>>        Move "" To sEmpty
83593>>>>>>>>>        Move 0  To iResult
83594>>>>>>>>>
83594>>>>>>>>>        //*** Get the cli handles
83594>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
83595>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83596>>>>>>>>>        Get psDriverId            to sDrvrId
83597>>>>>>>>>
83597>>>>>>>>>        //*** Call the procedure
83597>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
83599>>>>>>>>>            //*** Get the length
83599>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLNEXTRESULTSET ;                        Callback Self ;                        Passing ihdbc sEmpty ihstmt  ;                        Result iResult
83604>>>>>>>>>                        
83604>>>>>>>>>            Send SQLGetStatementAttributes
83605>>>>>>>>>            Set piLastArgument to 0
83606>>>>>>>>>        End
83606>>>>>>>>>>
83606>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLNextResultSet"
83608>>>>>>>>>
83608>>>>>>>>>        Function_Return iResult
83609>>>>>>>>>    End_Function
83610>>>>>>>>>
83610>>>>>>>>>
83610>>>>>>>>>
83610>>>>>>>>>    //***
83610>>>>>>>>>    //*** Procedure: SQLFetchActivatesBuffer
83610>>>>>>>>>    //*** Purpose  : Setup a file that will be acivated after a succesfull
83610>>>>>>>>>    //***            fetch on the statement
83610>>>>>>>>>    //***
83610>>>>>>>>>
83610>>>>>>>>>    Procedure SQLFetchActivatesBuffer Integer iFileNum Integer bState
83612>>>>>>>>>        Integer ihdbc
83612>>>>>>>>>        Integer ihstmt
83612>>>>>>>>>        String  sDrvrId
83612>>>>>>>>>        Integer iResult
83612>>>>>>>>>        Integer bIsOpen
83612>>>>>>>>>        Integer iVoid
83612>>>>>>>>>        String  sFileType
83612>>>>>>>>>
83612>>>>>>>>>        //*** Check if file is open
83612>>>>>>>>>        Get_attribute DF_FILE_OPENED Of iFileNum To bIsOpen
83615>>>>>>>>>        If (bIsOpen) Begin
83617>>>>>>>>>            //*** Get the cli handles
83617>>>>>>>>>            Get phCLIStatementHandle  to ihstmt
83618>>>>>>>>>            Get phCLIConnectionHandle to ihdbc
83619>>>>>>>>>            Get psDriverId            to sDrvrId
83620>>>>>>>>>
83620>>>>>>>>>            //*** Call the procedure
83620>>>>>>>>>            If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
83622>>>>>>>>>                //*** Check if the file has the correct type
83622>>>>>>>>>                Get_attribute DF_FILE_DRIVER Of iFileNum To sFileType
83625>>>>>>>>>                If (sFileType = sDrvrId) Begin
83627>>>>>>>>>                    //*** Setup the buffer
83627>>>>>>>>>                    Call_driver iFileNum sDrvrId Function FUNC_SQLBUFFERSTATUS ;                                Callback Self ;                                Passing ihdbc bState ihstmt  ;                                Result iVoid
83632>>>>>>>>>                End
83632>>>>>>>>>>
83632>>>>>>>>>                Else ;                    Send StmtError CLIERR_SQLINVALID_BIND_FILE ("File" * String(iFileNum) * "type incompatible with statement ("  + sFileType + ")") "SQLBindFile"
83634>>>>>>>>>            End
83634>>>>>>>>>>
83634>>>>>>>>>            Else ;                Send HandleError ihstmt ihdbc sDrvrId "SQLFetchActivatesBuffer"
83636>>>>>>>>>        End
83636>>>>>>>>>>
83636>>>>>>>>>        Else ;            Send StmtError CLIERR_SQLINVALID_BUFFER ("File not open (number =" * String(iFileNum) + ")") "SQLFetchActivatesBuffer"
83638>>>>>>>>>    End_Procedure 
83639>>>>>>>>>
83639>>>>>>>>>
83639>>>>>>>>>
83639>>>>>>>>>    Function SQLGetMessage Integer iMessageNum Returns String
83641>>>>>>>>>        Integer ihdbc
83641>>>>>>>>>        Integer ihstmt
83641>>>>>>>>>        String  sDrvrId
83641>>>>>>>>>        String  sMessage
83641>>>>>>>>>        Integer iVoid
83641>>>>>>>>>
83641>>>>>>>>>        //*** Initialize
83641>>>>>>>>>        Move "" To sMessage
83642>>>>>>>>>
83642>>>>>>>>>        //*** Get the cli handles
83642>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
83643>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83644>>>>>>>>>        Get psDriverId            to sDrvrId
83645>>>>>>>>>
83645>>>>>>>>>        //*** Call the procedure
83645>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
83647>>>>>>>>>            //*** Setup function arguments
83647>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                        Callback Self ;                        Passing ihdbc iMessageNum ihstmt ;                        Result iVoid
83652>>>>>>>>>
83652>>>>>>>>>            Move (Repeat(' ', 1024)) To sMessage
83653>>>>>>>>>            //*** Get the length
83653>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLGETMESSAGE ;                        Callback Self ;                        Passing iVoid sMessage iVoid ;                        Result iVoid
83658>>>>>>>>>        End
83658>>>>>>>>>>
83658>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLGetDiagRec"
83660>>>>>>>>>
83660>>>>>>>>>        Function_Return sMessage
83661>>>>>>>>>    End_Function 
83662>>>>>>>>>
83662>>>>>>>>>
83662>>>>>>>>>
83662>>>>>>>>>    //***
83662>>>>>>>>>    //*** Function: RemoveComponentIdentifier
83662>>>>>>>>>    //*** Purpose : Remove the component identifier from a diagnostic message
83662>>>>>>>>>    //***
83662>>>>>>>>>
83662>>>>>>>>>    Function RemoveComponentIdentifier String sDiagMessage Returns String
83664>>>>>>>>>        While (Left(sDiagMessage, 1) = "[")
83668>>>>>>>>>            Move (Right(sDiagMessage, Length(sDiagMessage) - Pos("]", sDiagMessage))) To sDiagMessage
83669>>>>>>>>>        End
83670>>>>>>>>>>
83670>>>>>>>>>
83670>>>>>>>>>        Function_Return sDiagMessage
83671>>>>>>>>>    End_Function
83672>>>>>>>>>
83672>>>>>>>>>
83672>>>>>>>>>
83672>>>>>>>>>    //***
83672>>>>>>>>>    //*** Function: DFDateToSQLDate
83672>>>>>>>>>    //*** Purpose : Convert a DataFlex date to a SQL Date. Use dummy zero dates.
83672>>>>>>>>>    //***
83672>>>>>>>>>    Function DFDateToSQLDate Date dDFDate Integer iSQLType Returns String
83674>>>>>>>>>        
83674>>>>>>>>>        Integer iType
83674>>>>>>>>>        String  sSQLDate
83674>>>>>>>>>        Integer iOrgDateFmt
83674>>>>>>>>>        Integer iOrgDateSep
83674>>>>>>>>>
83674>>>>>>>>>        String sDriverId
83674>>>>>>>>>        String sDummyZeroDate
83674>>>>>>>>>        String sDummyZeroDateMssqlDatetime
83674>>>>>>>>>
83674>>>>>>>>>        //*** Change date format to military, SQL dates are military dates
83674>>>>>>>>>        Get_Attribute DF_DATE_FORMAT to iOrgDateFmt
83677>>>>>>>>>        Get_Attribute DF_DATE_SEPARATOR to iOrgDateSep
83680>>>>>>>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_MILITARY
83683>>>>>>>>>        Set_Attribute DF_DATE_SEPARATOR to (Ascii('-'))
83686>>>>>>>>>
83686>>>>>>>>>        //*** We only need to convert if the date is 0
83686>>>>>>>>>        If (Integer(dDFDate = 0)) Begin
83688>>>>>>>>>
83688>>>>>>>>>            If (num_arguments < 2) Begin
83690>>>>>>>>>                Move SQL_TYPE_TIMESTAMP to iType
83691>>>>>>>>>            End
83691>>>>>>>>>>
83691>>>>>>>>>            Else Begin
83692>>>>>>>>>                Move iSQLType to iType
83693>>>>>>>>>            End
83693>>>>>>>>>>
83693>>>>>>>>>
83693>>>>>>>>>            
83693>>>>>>>>>            Get psDriverID to sDriverId
83694>>>>>>>>>            Get psDummyZeroDate to sDummyZeroDate
83695>>>>>>>>>                
83695>>>>>>>>>            If ( (iType = SQL_TYPE_TIMESTAMP) and (sDriverID = 'MSSQLDRV') ) Begin
83697>>>>>>>>>                Get psDummyZeroDateMssqlDatetime to sDummyZeroDateMssqlDatetime
83698>>>>>>>>>                Move sDummyZeroDateMssqlDatetime to sSQLDate
83699>>>>>>>>>            End
83699>>>>>>>>>>
83699>>>>>>>>>            Else Begin
83700>>>>>>>>>                Move sDummyZeroDate to sSQLDate
83701>>>>>>>>>            End
83701>>>>>>>>>>
83701>>>>>>>>>            
83701>>>>>>>>>            //CLI_Get_Driver_Attribute sDRiver DRVR_DUMMY_ZERO_DATE_VALUE to sSQLDate
83701>>>>>>>>>        End
83701>>>>>>>>>>
83701>>>>>>>>>        Else Begin
83702>>>>>>>>>            Move dDFDate to sSQLDate
83703>>>>>>>>>        End
83703>>>>>>>>>>
83703>>>>>>>>>
83703>>>>>>>>>        //*** Change date format back to original
83703>>>>>>>>>        Set_Attribute DF_DATE_FORMAT to iOrgDateFmt
83706>>>>>>>>>        Set_Attribute DF_DATE_SEPARATOR to iOrgDateSep
83709>>>>>>>>>
83709>>>>>>>>>        Function_Return sSQLDate
83710>>>>>>>>>    End_Function 
83711>>>>>>>>>
83711>>>>>>>>>
83711>>>>>>>>>    //***
83711>>>>>>>>>    //*** Function: SQLDateToDFDate
83711>>>>>>>>>    //*** Purpose : Convert a SQL date to a DataFlex Date. Use dummy zero dates.
83711>>>>>>>>>    //***
83711>>>>>>>>>    Function SQLDateToDFDate String sSQLDate Returns Date
83713>>>>>>>>>        
83713>>>>>>>>>        Integer iType
83713>>>>>>>>>        Date    dDFDate
83713>>>>>>>>>        Integer iOrgDateFmt
83713>>>>>>>>>        Integer iOrgDateSep
83713>>>>>>>>>        
83713>>>>>>>>>        String  sDriverId
83713>>>>>>>>>        String  sDummyZeroDate
83713>>>>>>>>>        String  sDummyZeroDateMssqlDatetime
83713>>>>>>>>>        
83713>>>>>>>>>        Get psDriverID to sDriverId
83714>>>>>>>>>        
83714>>>>>>>>>        Get psDummyZeroDate to sDummyZeroDate
83715>>>>>>>>>        Get psDummyZeroDateMssqlDatetime to sDummyZeroDateMssqlDatetime
83716>>>>>>>>>        
83716>>>>>>>>>        Get_Attribute DF_DATE_FORMAT to iOrgDateFmt
83719>>>>>>>>>        Get_Attribute DF_DATE_SEPARATOR to iOrgDateSep
83722>>>>>>>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_MILITARY
83725>>>>>>>>>        Set_Attribute DF_DATE_SEPARATOR to (Ascii('-'))
83728>>>>>>>>>        
83728>>>>>>>>>        Move (Left(sSQLDate,10)) to sSQLDate 
83729>>>>>>>>>
83729>>>>>>>>>        If ( (sSQLDate = sDummyZeroDate) or ;             ( (sDriverId = 'MSSQLDRV') and (sSQLDate = sDummyZeroDateMssqlDatetime) ) )  Begin
83731>>>>>>>>>            Move 0 to dDFDate
83732>>>>>>>>>        End
83732>>>>>>>>>>
83732>>>>>>>>>        Else Begin
83733>>>>>>>>>            Move sSQLDate to dDFDate
83734>>>>>>>>>        End
83734>>>>>>>>>>
83734>>>>>>>>>
83734>>>>>>>>>        //*** Change date format back to original
83734>>>>>>>>>        Set_Attribute DF_DATE_FORMAT to iOrgDateFmt
83737>>>>>>>>>        Set_Attribute DF_DATE_SEPARATOR to iOrgDateSep
83740>>>>>>>>>
83740>>>>>>>>>        Function_Return dDFDate
83741>>>>>>>>>    End_Function 
83742>>>>>>>>>
83742>>>>>>>>>End_Class 
83743>>>>>>>>>
83743>>>>>>>>>
83743>>>>>>>>>//*****************************************************************************
83743>>>>>>>>>//*** Class  : cSQLConnection                                               ***
83743>>>>>>>>>//*** Purpose: Connection object for embedded SQL                           ***
83743>>>>>>>>>//***                                                                       ***
83743>>>>>>>>>//*** Description:                                                          ***
83743>>>>>>>>>//***   This provides the ability to create a connection for a driver.      ***
83743>>>>>>>>>//***   It will contain child statement objects                             ***
83743>>>>>>>>>//*****************************************************************************
83743>>>>>>>>>
83743>>>>>>>>>Class cSQLConnection is a cObject
83744>>>>>>>>>
83744>>>>>>>>>    Procedure Construct_object 
83746>>>>>>>>>        Forward Send Construct_object 
83748>>>>>>>>>
83748>>>>>>>>>        Property Integer phCLIConnectionHandle       0
83749>>>>>>>>>        
83749>>>>>>>>>        Property String  psDriverID        ""
83750>>>>>>>>>        Property Integer piBindFile        0
83751>>>>>>>>>        
83751>>>>>>>>>        Property String psDummyZeroDate              '0001-01-01'
83752>>>>>>>>>        Property String psDummyZeroDateMssqlDatetime '1753-01-01'        
83753>>>>>>>>>
83753>>>>>>>>>    End_Procedure
83754>>>>>>>>>
83754>>>>>>>>>
83754>>>>>>>>>
83754>>>>>>>>>    //***
83754>>>>>>>>>    //*** Procedure: StoreConnectionInfo
83754>>>>>>>>>    //*** Purpose  : Store basic information about the connection
83754>>>>>>>>>    //***
83754>>>>>>>>>    Procedure StoreConnectionInfo Handle hCLIConnectionHandle String sDrvrId 
83756>>>>>>>>>        
83756>>>>>>>>>        String sDummyZeroDate
83756>>>>>>>>>        
83756>>>>>>>>>        Set phCLIConnectionHandle to hCLIConnectionHandle
83757>>>>>>>>>        Set psDriverID            to sDrvrId
83758>>>>>>>>>        
83758>>>>>>>>>        Case Begin
83758>>>>>>>>>            Case (sDrvrId = "MSSQLDRV")
83760>>>>>>>>>                Set psDummyZeroDate to '0001-01-01'
83761>>>>>>>>>                Set psDummyZeroDateMssqlDatetime to '1753-01-01'
83762>>>>>>>>>                Break
83763>>>>>>>>>            Case (sDrvrId = "DB2_DRV")
83766>>>>>>>>>                Set psDummyZeroDate to '0001-01-01'
83767>>>>>>>>>                Break
83768>>>>>>>>>            Case (sDrvrId = "ODBC_DRV")
83771>>>>>>>>>                CLI_Get_Driver_Attribute sDrvrId DRVR_DUMMY_ZERO_DATE_VALUE to sDummyZeroDate
83778>>>>>>>>>                Set psDummyZeroDate to sDummyZeroDate
83779>>>>>>>>>                Break
83780>>>>>>>>>        Case End
83780>>>>>>>>>        
83780>>>>>>>>>    End_Procedure 
83781>>>>>>>>>
83781>>>>>>>>>
83781>>>>>>>>>    //***
83781>>>>>>>>>    //*** Procedure: DestroySQLConnection
83781>>>>>>>>>    //*** Purpose : Destroy the SQLConnection object
83781>>>>>>>>>    //***
83781>>>>>>>>>    Procedure DestroySQLConnection
83783>>>>>>>>>        Send Destroy
83784>>>>>>>>>    End_Procedure 
83785>>>>>>>>>
83785>>>>>>>>>
83785>>>>>>>>>    //***
83785>>>>>>>>>    //*** Function: SQLConnect
83785>>>>>>>>>    //*** Purpose : Connect to a database server
83785>>>>>>>>>    //*** Returns : 1 Succesfully connected
83785>>>>>>>>>    //***           0 Not connected
83785>>>>>>>>>    Function SQLConnect String sDrvrID String sConnect Returns Integer
83787>>>>>>>>>        Integer ihdbc
83787>>>>>>>>>        String  sEmpty
83787>>>>>>>>>
83787>>>>>>>>>        //*** Initialize
83787>>>>>>>>>        Move "" To sEmpty
83788>>>>>>>>>        Move 0  To ihdbc
83789>>>>>>>>>
83789>>>>>>>>>        Indicate Err False
83790>>>>>>>>>
83790>>>>>>>>>        //*** Call the driver function to connect
83790>>>>>>>>>        Call_driver 0 sDrvrId Function FUNC_SQLCONNECT ;                    Callback Self ;                    Passing sConnect sEmpty Self ;                    Result ihdbc
83795>>>>>>>>>
83795>>>>>>>>>        //*** If there was an error, make result invalid
83795>>>>>>>>>        If (Err) ;            Move 0 To ihdbc
83798>>>>>>>>>
83798>>>>>>>>>        //*** Check result and store it
83798>>>>>>>>>        If (ihdbc <> 0) ;            Send StoreConnectionInfo ihdbc sDrvrId
83801>>>>>>>>>
83801>>>>>>>>>        //*** Return success status
83801>>>>>>>>>        Function_Return (ihdbc <> 0)
83802>>>>>>>>>    End_Function 
83803>>>>>>>>>
83803>>>>>>>>>
83803>>>>>>>>>
83803>>>>>>>>>    //***
83803>>>>>>>>>    //*** Function: SQLFileConnect
83803>>>>>>>>>    //*** Purpose : Use a connection of an already open file
83803>>>>>>>>>    //***
83803>>>>>>>>>    Function SQLFileConnect Integer iFileNum Returns Integer
83805>>>>>>>>>        Integer ihdbc
83805>>>>>>>>>        Integer bIsOpen
83805>>>>>>>>>        String  sDrvrId
83805>>>>>>>>>        String  sEmpty
83805>>>>>>>>>
83805>>>>>>>>>        //*** Initialize
83805>>>>>>>>>        Move "" To sEmpty
83806>>>>>>>>>        Move 0  To ihdbc
83807>>>>>>>>>
83807>>>>>>>>>        //*** Check if file is open
83807>>>>>>>>>        Get_attribute DF_FILE_OPENED Of iFileNum To bIsOpen
83810>>>>>>>>>        If (bIsOpen) Begin
83812>>>>>>>>>            //*** Fill the driver id, assume longest is 255 characters
83812>>>>>>>>>            Move (Repeat(' ', 255)) To sDrvrId
83813>>>>>>>>>            Get_attribute DF_FILE_DRIVER Of iFileNum To sDrvrId
83816>>>>>>>>>
83816>>>>>>>>>            Indicate Err False
83817>>>>>>>>>
83817>>>>>>>>>            //*** Call the driver function to connect
83817>>>>>>>>>            Call_driver iFileNum sDrvrId Function FUNC_SQLFILECONNECT ;                        Callback Self ;                        Passing sEmpty sEmpty 0 ;                        Result ihdbc
83822>>>>>>>>>
83822>>>>>>>>>            //*** If there was an error, make result invalid
83822>>>>>>>>>            If (Err) ;                Move 0 To ihdbc
83825>>>>>>>>>
83825>>>>>>>>>            //*** Check result and store it
83825>>>>>>>>>            If (ihdbc <> 0) Begin
83827>>>>>>>>>                //*** Somehow Call_driver overwrites the sDrvrId variable, restore it here
83827>>>>>>>>>                Get_attribute DF_FILE_DRIVER Of iFileNum To sDrvrId
83830>>>>>>>>>                Send StoreConnectionInfo ihdbc sDrvrId
83831>>>>>>>>>
83831>>>>>>>>>                //*** Set filenum so it can be used for fetching
83831>>>>>>>>>                Set piBindFile To iFileNum
83832>>>>>>>>>            End
83832>>>>>>>>>>
83832>>>>>>>>>        End
83832>>>>>>>>>>
83832>>>>>>>>>
83832>>>>>>>>>        //*** Return success status
83832>>>>>>>>>        Function_Return (ihdbc <> 0)
83833>>>>>>>>>    End_Function
83834>>>>>>>>>
83834>>>>>>>>>
83834>>>>>>>>>
83834>>>>>>>>>    //***
83834>>>>>>>>>    //*** Procedure: SQLDisconnect
83834>>>>>>>>>    //*** Purpose  : Disconnect from an embedded SQL server and free allocated
83834>>>>>>>>>    //***            resources
83834>>>>>>>>>    //***
83834>>>>>>>>>    Procedure SQLDisconnect
83836>>>>>>>>>        Integer ihdbc
83836>>>>>>>>>        Integer iVoid
83836>>>>>>>>>        String  sDrvrId
83836>>>>>>>>>        String  sEmpty
83836>>>>>>>>>
83836>>>>>>>>>        //*** Initialize
83836>>>>>>>>>        Move "" To sEmpty
83837>>>>>>>>>
83837>>>>>>>>>        //*** Get the cli handle
83837>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83838>>>>>>>>>        Get psDriverId To sDrvrId
83839>>>>>>>>>
83839>>>>>>>>>        //*** Free the CLI handle
83839>>>>>>>>>        If (ihdbc <> 0) Begin
83841>>>>>>>>>            //*** Call the driver function to disconnect
83841>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLDISCONNECT ;                        Callback Self ;                        Passing sEmpty sEmpty ihdbc ;                        Result iVoid
83846>>>>>>>>>
83846>>>>>>>>>            Move -1 to giLastSQLhdbc
83847>>>>>>>>>
83847>>>>>>>>>            //*** Free the DataFlex handle
83847>>>>>>>>>            Send DestroySQLConnection
83848>>>>>>>>>        End
83848>>>>>>>>>>
83848>>>>>>>>>    End_Procedure 
83849>>>>>>>>>
83849>>>>>>>>>
83849>>>>>>>>>
83849>>>>>>>>>    //***
83849>>>>>>>>>    //*** Function: CreateSQLStatement
83849>>>>>>>>>    //*** Purpose : Create a cSQLStatement object
83849>>>>>>>>>    //***
83849>>>>>>>>>    Function CreateSQLStatement Returns Handle
83851>>>>>>>>>        
83851>>>>>>>>>        Handle hoSQLStatement
83851>>>>>>>>>        Get Create (RefClass(cSQLStatement)) to hoSQLStatement
83852>>>>>>>>>        
83852>>>>>>>>>        //*** If the connection has a default Bind File, assign it to the
83852>>>>>>>>>        //*** statement object. The default is set when you open a file with a
83852>>>>>>>>>        //*** SetFileConnection command.
83852>>>>>>>>>        Set piBindFile of hoSQLStatement to (piBindFile(Self))
83853>>>>>>>>>        
83853>>>>>>>>>        Function_Return hoSQLStatement
83854>>>>>>>>>    End_Function 
83855>>>>>>>>>
83855>>>>>>>>>
83855>>>>>>>>>    //***
83855>>>>>>>>>    //*** Function: SQLOpen
83855>>>>>>>>>    //*** Prupose : Open a statement for use
83855>>>>>>>>>    //***
83855>>>>>>>>>    Function SQLOpen Returns Handle
83857>>>>>>>>>        Handle  hoSQLStatement
83857>>>>>>>>>        Integer ihdbc
83857>>>>>>>>>        Integer ihstmt
83857>>>>>>>>>        Integer iVoid
83857>>>>>>>>>        String  sDrvrId
83857>>>>>>>>>        String  sEmpty
83857>>>>>>>>>        String  sDummyZeroDate
83857>>>>>>>>>        String  sDummyZeroDateMssqlDatetime 
83857>>>>>>>>>
83857>>>>>>>>>        //*** Initialize
83857>>>>>>>>>        Move "" To sEmpty
83858>>>>>>>>>
83858>>>>>>>>>        //*** Get the cli handle to the connection
83858>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83859>>>>>>>>>        Get psDriverId  To sDrvrId
83860>>>>>>>>>
83860>>>>>>>>>        //*** Allocate a new handle and populate it
83860>>>>>>>>>        If (ihdbc <> 0) Begin
83862>>>>>>>>>            //**** Create a new cSQLStatement object
83862>>>>>>>>>            Get CreateSQLStatement to hoSQLStatement
83863>>>>>>>>>
83863>>>>>>>>>            //*** Call the driver function to allocate a cli statement handle
83863>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLOPEN ;                        Callback Self ;                        Passing hoSQLStatement sEmpty ihdbc ;                        Result ihstmt
83868>>>>>>>>>
83868>>>>>>>>>            //*** If unsuccessful destroy hoSQLStatement
83868>>>>>>>>>            If (ihstmt = 0) Begin
83870>>>>>>>>>                Send DestroySQLStatement of hoSQLStatement
83871>>>>>>>>>                Move 0 to hoSQLStatement
83872>>>>>>>>>            End
83872>>>>>>>>>>
83872>>>>>>>>>            Else Begin
83873>>>>>>>>>                Send StoreStatementInfo of hoSQLStatement ihstmt sDrvrId ihdbc
83874>>>>>>>>>
83874>>>>>>>>>                // Store DummyZeroDate of hoSQLConnection in hoSQLStatement
83874>>>>>>>>>                Get psDummyZeroDate              to sDummyZeroDate
83875>>>>>>>>>                Get psDummyZeroDateMssqlDatetime to sDummyZeroDateMssqlDatetime
83876>>>>>>>>>                
83876>>>>>>>>>                Set psDummyZeroDate              of hoSQLStatement to sDummyZeroDate
83877>>>>>>>>>                Set psDummyZeroDateMssqlDatetime of hoSQLStatement to sDummyZeroDateMssqlDatetime
83878>>>>>>>>>                
83878>>>>>>>>>            End
83878>>>>>>>>>>
83878>>>>>>>>>        End
83878>>>>>>>>>>
83878>>>>>>>>>
83878>>>>>>>>>        Function_Return hoSQLStatement
83879>>>>>>>>>    End_Function 
83880>>>>>>>>>
83880>>>>>>>>>End_Class 
83881>>>>>>>>>
83881>>>>>>>>>
83881>>>>>>>>>
83881>>>>>>>>>//*****************************************************************************
83881>>>>>>>>>//*** Class  : cSQLHandlemanager                                            ***
83881>>>>>>>>>//*** Purpose: Manager for embedded SQL handles.                            ***
83881>>>>>>>>>//***                                                                       ***
83881>>>>>>>>>//*** Description:                                                          ***
83881>>>>>>>>>//***   We want to be able to use multiple drivers and multiple             ***
83881>>>>>>>>>//***   connections within a driver and multiple statements within a        ***
83881>>>>>>>>>//***   connection. To allow this we have placed our own handle logic on    ***
83881>>>>>>>>>//***   top of the driver handle logic. This way we can handle the          ***
83881>>>>>>>>>//***   situation where two driver handles may be equal.                    ***
83881>>>>>>>>>//*****************************************************************************
83881>>>>>>>>>
83881>>>>>>>>>Class cSQLHandleManager is a cObject
83882>>>>>>>>>
83882>>>>>>>>>    Procedure Construct_object 
83884>>>>>>>>>        Forward Send Construct_object 
83886>>>>>>>>>
83886>>>>>>>>>        Property String  psDefaultDriver      ""
83887>>>>>>>>>        Property String  psDefaultConnection  ""
83888>>>>>>>>>
83888>>>>>>>>>    End_Procedure 
83889>>>>>>>>>
83889>>>>>>>>>    //***
83889>>>>>>>>>    //*** Function: CreateSQLConnection
83889>>>>>>>>>    //*** Purpose : Create a cSQLConnection object
83889>>>>>>>>>    //***
83889>>>>>>>>>    Function CreateSQLConnection Returns Handle
83891>>>>>>>>>        Handle hoSQLConnection
83891>>>>>>>>>        Get Create (RefClass(cSQLConnection)) to hoSQLConnection
83892>>>>>>>>>        Function_Return hoSQLConnection
83893>>>>>>>>>    End_Function 
83894>>>>>>>>>
83894>>>>>>>>>
83894>>>>>>>>>    //***
83894>>>>>>>>>    //*** Procedure: SQLSetConnect
83894>>>>>>>>>    //*** Purpose  : Store default connection information
83894>>>>>>>>>    //***
83894>>>>>>>>>
83894>>>>>>>>>    Procedure SQLSetConnect String sDriver String sConnect
83896>>>>>>>>>        Set psDefaultDriver      To sDriver
83897>>>>>>>>>        Set psDefaultConnection  To sConnect
83898>>>>>>>>>    End_Procedure 
83899>>>>>>>>>
83899>>>>>>>>>
83899>>>>>>>>>
83899>>>>>>>>>    //***
83899>>>>>>>>>    //*** Function: SQLConnect
83899>>>>>>>>>    //*** Purpose : Make a connection to an embedded SQL server
83899>>>>>>>>>    //*** Returns : The DataFlex handle to the connection
83899>>>>>>>>>    //***
83899>>>>>>>>>    Function SQLConnect String sDrvrID String sConnect Returns integer
83901>>>>>>>>>        Handle hoSQLConnection
83901>>>>>>>>>        Integer bOK
83901>>>>>>>>>
83901>>>>>>>>>        //*** Check arguments
83901>>>>>>>>>        If (sDrvrID = "" And sConnect = "") Begin
83903>>>>>>>>>            Get psDefaultDriver      To sDrvrId
83904>>>>>>>>>            Get psDefaultConnection  To sConnect
83905>>>>>>>>>        End
83905>>>>>>>>>>
83905>>>>>>>>>
83905>>>>>>>>>        //*** Create a cSQLConnection object
83905>>>>>>>>>        Get CreateSQLConnection to hoSQLConnection
83906>>>>>>>>>        //*** Connect to the database 
83906>>>>>>>>>        Get SQLConnect of hoSQLConnection sDrvrID sConnect to bOK
83907>>>>>>>>>
83907>>>>>>>>>        //*** If connection to the database failed, destroy the cSQLConnection object and return a 0 handle
83907>>>>>>>>>        If (not(bOK)) Begin
83909>>>>>>>>>            Send DestroySQLConnection of hoSQLConnection
83910>>>>>>>>>            Move 0 to hoSQLConnection
83911>>>>>>>>>        End
83911>>>>>>>>>>
83911>>>>>>>>>
83911>>>>>>>>>        Function_Return hoSQLConnection
83912>>>>>>>>>    End_Function 
83913>>>>>>>>>
83913>>>>>>>>>
83913>>>>>>>>>
83913>>>>>>>>>    //***
83913>>>>>>>>>    //*** Function: SQLFileConnect
83913>>>>>>>>>    //*** Purpose : Make an existing connection available for use with Embedded SQL.
83913>>>>>>>>>    //***           The connection is identified by the number of a file
83913>>>>>>>>>    //***           that is open for that connection.
83913>>>>>>>>>    //***
83913>>>>>>>>>
83913>>>>>>>>>    Function SQLFileConnect Integer iFileNum Returns Handle
83915>>>>>>>>>        Handle hoSQLConnection
83915>>>>>>>>>        Integer bOK
83915>>>>>>>>>
83915>>>>>>>>>        //*** Create a cSQLConnection object
83915>>>>>>>>>        Get CreateSQLConnection to hoSQLConnection
83916>>>>>>>>>        Get SQLFileConnect of hoSQLConnection iFileNum To bOK
83917>>>>>>>>>
83917>>>>>>>>>        //*** If connection to the database failed, destroy the cSQLConnection object and return a 0 handle
83917>>>>>>>>>        If (not(bOK)) Begin
83919>>>>>>>>>            Send DestroySQLConnection of hoSQLConnection
83920>>>>>>>>>            Move 0 to hoSQLConnection
83921>>>>>>>>>        End
83921>>>>>>>>>>
83921>>>>>>>>>
83921>>>>>>>>>        Function_Return hoSQLConnection
83922>>>>>>>>>    End_Function 
83923>>>>>>>>>
83923>>>>>>>>>End_Class 
83924>>>>>>>>>
83924>>>>>>>
83924>>>>>>>// defines interface for cWindowMesageHook - currently a private runtime class
83924>>>>>>>Define     U_DFWINDOWSMESSAGEHOOK  for |CI0106
83924>>>>>>>Define     GET_ENABLEWINDOWSHOOK   for |CI$0542
83924>>>>>>>Define     MSG_DISABLEWINDOWSHOOK  for |CI$0543
83924>>>>>>>Define     GET_ONWINDOWSHOOK       for |CI$0544
83924>>>>>>>Define     WH_MOUSE for 7
83924>>>>>>>Define     WH_KEYBOARD for 2
83924>>>>>>>
83924>>>>>>>
83924>>>>>>>// suggestion lists use a global timer and a global suggestion list
83924>>>>>>>Global_Variable Handle ghoSuggestionList 
83924>>>>>>>Move 0 to ghoSuggestionList
83925>>>>>>>
83925>>>>>>>Global_Variable Handle ghoSuggestionTimer
83925>>>>>>>Move 0 to ghoSuggestionTimer
83926>>>>>>>
83926>>>>>>>// this will get created the first time it is needed. 
83926>>>>>>>Class cSuggestionTimer is a cTimer
83927>>>>>>>
83927>>>>>>>    Procedure Construct_Object
83929>>>>>>>        Forward Send Construct_Object
83931>>>>>>>        Property Handle phoTimerOwner 0
83932>>>>>>>        Set piTimeout to 50
83933>>>>>>>    End_Procedure
83934>>>>>>>  
83934>>>>>>>    Procedure OnTimer 
83936>>>>>>>        Handle hoOwner
83936>>>>>>>        Get phoTimerOwner to hoOwner
83937>>>>>>>        // do this in case progam close destroys owner before timer
83937>>>>>>>        Get Object_Id of hoOwner to hoOwner
83938>>>>>>>        If hoOwner Begin
83940>>>>>>>            Send OnSuggestionTimer to hoOwner
83941>>>>>>>        End
83941>>>>>>>>
83941>>>>>>>        Else Begin
83942>>>>>>>            // something wrong, shut off timer
83942>>>>>>>            Set pbEnabled to False   
83943>>>>>>>        End                                
83943>>>>>>>>
83943>>>>>>>    End_Procedure
83944>>>>>>>    
83944>>>>>>>End_Class
83945>>>>>>>
83945>>>>>>>Class cSuggestionHookMouse is a DFWindowsMessageHook
83946>>>>>>>    
83946>>>>>>>    // If mouse not in suggestion list or form, close suggestionlist
83946>>>>>>>    Function OnWindowsHook Integer i1 Integer i2 Integer i3 Returns Integer
83948>>>>>>>        tWinMouseHookStruct MouseHook
83948>>>>>>>        tWinMouseHookStruct MouseHook
83948>>>>>>>        Integer ivoid hObj
83948>>>>>>>        Handle hoOwner hoParent
83948>>>>>>>        If (i1=0 and (i2=WM_LBUTTONDOWN or i2=WM_RBUTTONDOWN or i2=WM_MBUTTONDOWN or ;                      i2=WM_NCLBUTTONDOWN or i2=WM_NCRBUTTONDOWN or i2=WM_NCMBUTTONDOWN)) Begin
83950>>>>>>>            Move (CopyMemory(AddressOf(MouseHook), i3, SizeOfType(tWinMouseHookStruct))) to iVoid
83951>>>>>>>            GET_OBJECT_FROM_WINDOW MouseHook.hwnd to hObj
83952>>>>>>>            Get Parent to hoParent
83953>>>>>>>            Get phoOwner of hoParent to hoOwner
83954>>>>>>>            If (not(hObj) or (hObj<>hoParent and hObj<>hoOwner)) Begin
83956>>>>>>>                Send DisableWindowsHook
83957>>>>>>>                Send DeActivateSuggestionList of hoOwner
83958>>>>>>>            End
83958>>>>>>>>
83958>>>>>>>        End
83958>>>>>>>>
83958>>>>>>>    End_Function
83959>>>>>>>
83959>>>>>>>    Procedure End_Construct_Object
83961>>>>>>>        Boolean bOk
83961>>>>>>>        Forward Send End_Construct_Object
83963>>>>>>>        Get EnableWindowsHook WH_MOUSE to bOk 
83964>>>>>>>    End_Procedure
83965>>>>>>>
83965>>>>>>>End_Class
83966>>>>>>>
83966>>>>>>>Class cSuggestionHookKbd is a DFWindowsMessageHook
83967>>>>>>>    
83967>>>>>>>    // If menu key, close suggestionlist
83967>>>>>>>    Function OnWindowsHook Integer i1 Integer i2 Integer i3 Returns Integer
83969>>>>>>>        Handle hoOwner
83969>>>>>>>        If (i1=0 and i2=VK_MENU) Begin
83971>>>>>>>            Delegate Get phoOwner to hoOwner
83973>>>>>>>            Send DisableWindowsHook
83974>>>>>>>            Send DeActivateSuggestionList of hoOwner
83975>>>>>>>        End
83975>>>>>>>>
83975>>>>>>>    End_Function
83976>>>>>>>    
83976>>>>>>>    Procedure End_Construct_Object
83978>>>>>>>        Boolean bOk
83978>>>>>>>        Forward Send End_Construct_Object
83980>>>>>>>        Get EnableWindowsHook WH_KEYBOARD  to bOk  
83981>>>>>>>    End_Procedure
83982>>>>>>>
83982>>>>>>>End_Class
83983>>>>>>>
83983>>>>>>>Class cSuggestionList is a cRichEdit
83984>>>>>>>    
83984>>>>>>>    Procedure Construct_Object
83986>>>>>>>        Handle hoObj
83986>>>>>>>        Forward Send Construct_Object
83988>>>>>>>        Property Handle phoOwner
83989>>>>>>>        Set Focus_Mode to NonFocusable
83990>>>>>>>        Set Attach_Parent_State to True
83991>>>>>>>        Set pbWrap to False
83992>>>>>>>        If (ghoSuggestionList) Begin
83994>>>>>>>            Send Destroy of ghoSuggestionList
83995>>>>>>>        End
83995>>>>>>>>
83995>>>>>>>        Get CreateNamed (RefClass(cSuggestionHookMouse)) "oMouseHook" to hoObj
83996>>>>>>>        Get CreateNamed (RefClass(cSuggestionHookKbd))"oKbdHook" to hoObj
83997>>>>>>>    End_Procedure
83998>>>>>>>    
83998>>>>>>>    Procedure Destroy_Object
84000>>>>>>>        Forward Send Destroy_Object
84002>>>>>>>        Move 0 to ghoSuggestionList
84003>>>>>>>    End_Procedure
84004>>>>>>>    
84004>>>>>>>    Procedure DeactivateList
84006>>>>>>>        Set pbEnabled of ghoSuggestionTimer to False
84007>>>>>>>        Send Deactivate
84008>>>>>>>        Send Destroy
84009>>>>>>>    End_Procedure
84010>>>>>>>    
84010>>>>>>>    Procedure InitList Handle hoForm
84012>>>>>>>        Integer iSize iLoc iLoc2
84012>>>>>>>        Get GuiSize of hoForm to iSize
84013>>>>>>>        Set GuiSize to (Hi(iSize)) (1000)
84014>>>>>>>        Get Absolute_GUIOrigin of hoForm to iLoc
84015>>>>>>>        Delegate Get Absolute_GUIOrigin to iLoc2
84017>>>>>>>        Set GuiLocation to (Hi(iLoc)-Hi(iLoc2)+Hi(iSize)+2) (Low(iLoc)+2-Low(iLoc2))
84018>>>>>>>        Set Visible_State to False
84019>>>>>>>    End_Procedure
84020>>>>>>>    
84020>>>>>>>    // scroll up one line
84020>>>>>>>    Procedure ScrollUp
84022>>>>>>>        Integer iLine
84022>>>>>>>        Get SelectedRow to iLine
84023>>>>>>>        If (iLine) Begin
84025>>>>>>>            Send SelectRow (iLine-1)
84026>>>>>>>        End
84026>>>>>>>>
84026>>>>>>>    End_Procedure
84027>>>>>>>    
84027>>>>>>>    // scroll down one line
84027>>>>>>>    Procedure ScrollDown
84029>>>>>>>        Integer iLine iLines
84029>>>>>>>        Get Line_Count to iLines
84030>>>>>>>        Get SelectedRow to iLine
84031>>>>>>>        // there can be an extra line at the end
84031>>>>>>>        If (iLine<iLines-1) Begin
84033>>>>>>>            Send SelectRow (iLine+1)
84034>>>>>>>        End
84034>>>>>>>>
84034>>>>>>>    End_Procedure
84035>>>>>>>    
84035>>>>>>>    // sets the current line to iLine and highlights it
84035>>>>>>>    Procedure SelectRow Integer iLine
84037>>>>>>>        Integer iPos iLen
84037>>>>>>>        Get FirstCharInLinePos iLine to iPos
84038>>>>>>>        Get LineLength iLine to iLen
84039>>>>>>>        Send SetSel iPos (iPos+iLen)
84040>>>>>>>    End_Procedure
84041>>>>>>>    
84041>>>>>>>    // get the current selected Line
84041>>>>>>>    Function SelectedRow Returns Integer
84043>>>>>>>        Integer iLine
84043>>>>>>>        Get LineFromChar -1 to iLine
84044>>>>>>>        Function_Return iLine
84045>>>>>>>    End_Function
84046>>>>>>>
84046>>>>>>>    // select the current row 
84046>>>>>>>    Procedure Mouse_Up Integer hCell Integer iPos
84048>>>>>>>        Handle hoObj
84048>>>>>>>        Get phoOwner to hoObj
84049>>>>>>>        Send Activate of hoObj // move focus to owner, which will close the list
84050>>>>>>>        Send SelectSuggestion of hoObj
84051>>>>>>>    End_Procedure // Mouse_Up
84052>>>>>>>      
84052>>>>>>>End_Class
84053>>>>>>>
84053>>>>>>>// This contains mixin support for suggestion logic and contains the interface that
84053>>>>>>>// is accessed publicly. This should be mixed into the form or column DEO object
84053>>>>>>>Class cSuggestion_mixin is a Mixin
84054>>>>>>>    
84054>>>>>>>    Procedure Define_cSuggestion_mixin
84056>>>>>>>        
84056>>>>>>>        Property Integer peSuggestionMode smFind
84057>>>>>>>        Property Boolean pbFullText False
84058>>>>>>>        Property Boolean pbCaseSensitive False
84059>>>>>>>        Property Integer piMaxResults 15
84060>>>>>>>        Property Integer piStartAtChar 2
84061>>>>>>>        Property Boolean pbFullWidth True
84062>>>>>>>        Property Integer piFindIndex 0
84063>>>>>>>        Property Boolean pbFindOnSelect True
84064>>>>>>>        Property Integer piPopupTimeout 50
84065>>>>>>>        
84065>>>>>>>        Property tSuggestion[] pSearchResults
84066>>>>>>>
84066>>>>>>>        Property Handle phcSuggestionListClass (RefClass(cSuggestionList))
84067>>>>>>>        
84067>>>>>>>    End_Procedure
84068>>>>>>>    
84068>>>>>>>    // Display one Suggestion Line in Suggestion List. Good for augmentation although
84068>>>>>>>    // this must be done carefully as you must know the suggestionlist interface, which
84068>>>>>>>    // if private
84068>>>>>>>    Procedure ShowSuggestion tSuggestion SuggestionData String sSearch
84070>>>>>>>        Integer i iCols iPos
84070>>>>>>>        String sValue
84070>>>>>>>        Integer eSuggestionMode
84070>>>>>>>        Boolean bFullText
84070>>>>>>>        
84070>>>>>>>        Get peSuggestionMode to eSuggestionMode
84071>>>>>>>        Get pbFullText to bFullText
84072>>>>>>>        
84072>>>>>>>        Move SuggestionData.aValues[0] to sValue
84073>>>>>>>        If (not(bFullText)) Begin
84075>>>>>>>            Set pbBold of ghoSuggestionList to True
84076>>>>>>>            Send AppendText of ghoSuggestionList (Left(sValue,Length(sSearch))) 
84077>>>>>>>            Set pbBold of ghoSuggestionList to False
84078>>>>>>>            Send AppendText of ghoSuggestionList (Mid(sValue,255,Length(sSearch)+1)) 
84079>>>>>>>        End
84079>>>>>>>>
84079>>>>>>>        Else Begin
84080>>>>>>>            Set pbBold of ghoSuggestionList to False
84081>>>>>>>            Move (Pos(Uppercase(sSearch),Uppercase(sValue))) to iPos
84082>>>>>>>            If (iPos) Begin
84084>>>>>>>                Send AppendText of ghoSuggestionList (Left(sValue,iPos-1)) 
84085>>>>>>>                Set pbBold of ghoSuggestionList to True
84086>>>>>>>                Send AppendText of ghoSuggestionList (Mid(sValue,Length(sSearch),iPos)) 
84087>>>>>>>                Set pbBold of ghoSuggestionList to False
84088>>>>>>>            End
84088>>>>>>>>
84088>>>>>>>            Send AppendText of ghoSuggestionList (Mid(sValue,255,iPos+Length(sSearch))) 
84089>>>>>>>        End
84089>>>>>>>>
84089>>>>>>>        
84089>>>>>>>        // if addiitonal columns (usually validation) we assume the first value is the one that is
84089>>>>>>>        // matched and we display all other values (usually just one) to the
84089>>>>>>>        // right of it. 
84089>>>>>>>        Move (SizeOfArray(SuggestionData.aValues)) to iCols
84090>>>>>>>        If (iCols>1) Begin
84092>>>>>>>            Move "" to sValue
84093>>>>>>>            For i from 1 to (iCols-1)
84099>>>>>>>>
84099>>>>>>>                Move (sValue + If(i=1," - ","  ") + SuggestionData.aValues[i]) to sValue
84100>>>>>>>            Loop
84101>>>>>>>>
84101>>>>>>>            Send AppendText of ghoSuggestionList sValue
84102>>>>>>>        End
84102>>>>>>>>
84102>>>>>>>    End_Procedure
84103>>>>>>>    
84103>>>>>>>    // used to catch a set_field_value_Error
84103>>>>>>>    Procedure Error_Report Integer iError Integer iLine String sErr
84105>>>>>>>    End_Procedure
84106>>>>>>>    
84106>>>>>>>    // does a Set_Field_Value with error testing around it.
84106>>>>>>>    Function SafeSetFieldValue Integer iFile Integer iField String sValue Returns Boolean
84108>>>>>>>        Handle hoOldError
84108>>>>>>>        Boolean bErr
84108>>>>>>>        Move Error_Object_Id to hoOldError
84109>>>>>>>        Move Self to Error_Object_Id
84110>>>>>>>        Move False to Err 
84111>>>>>>>        Set_Field_Value iFile iField to sValue
84114>>>>>>>        Move Err to bErr
84115>>>>>>>        Move hoOldError to Error_Object_Id
84116>>>>>>>        Function_Return bErr        
84117>>>>>>>    End_Function
84118>>>>>>>
84118>>>>>>>
84118>>>>>>>    Procedure SuggestionsFindIncremental String sSearch tSuggestion[] ByRef aSuggestions
84120>>>>>>>        Integer iFile iField iIndex iLen iRow iMax eType iLength iDec
84120>>>>>>>        Handle hoServer
84120>>>>>>>        Boolean bContinue bCase bOldRelate bNeedsRelate bInvalid
84120>>>>>>>        String sVal sLowSearch
84120>>>>>>>        RowID riTest
84120>>>>>>>        
84120>>>>>>>        Get Server to hoServer
84121>>>>>>>        Get Data_File  to iFile
84122>>>>>>>        Get Data_Field to iField       
84123>>>>>>>        
84123>>>>>>>        If ((hoServer <> 0) and (iFile <> 0)) Begin
84125>>>>>>>            Get piFindIndex to iIndex
84126>>>>>>>            Get piMaxResults to iMax
84127>>>>>>>            Get pbCaseSensitive to bCase
84128>>>>>>>            
84128>>>>>>>            Get_Attribute DF_FIELD_TYPE of iFile iField to eType
84131>>>>>>>            Get_Attribute DF_FIELD_LENGTH of iFile iField to iLength
84134>>>>>>>            Get_Attribute DF_FIELD_PRECISION of iFile iField to iDec
84137>>>>>>>            
84137>>>>>>>            Move (iLength - iDec) to iLength
84138>>>>>>>            
84138>>>>>>>            If (iIndex <= 0) Begin
84140>>>>>>>                Get_Attribute DF_FIELD_INDEX of iFile iField to iIndex
84143>>>>>>>            End
84143>>>>>>>>
84143>>>>>>>            
84143>>>>>>>            
84143>>>>>>>            
84143>>>>>>>            If (iIndex > 0) Begin
84145>>>>>>>                Get No_Relate_State of hoServer to bOldRelate
84146>>>>>>>                Get DDOConstraintNeedsRelate of hoServer iIndex to bNeedsRelate
84147>>>>>>>                Set No_Relate_State of hoServer to (not(bNeedsRelate))
84148>>>>>>>                                
84148>>>>>>>                Move True to bContinue
84149>>>>>>>                Move (Length(sSearch)) to iLen
84150>>>>>>>                Move (Lowercase(sSearch)) to sLowSearch
84151>>>>>>>                Move 0 to iRow
84152>>>>>>>                
84152>>>>>>>                //  Find first record
84152>>>>>>>                Send Request_Read of hoServer FIRST_RECORD iFile iIndex
84153>>>>>>>                Get SafeSetFieldValue iFile iField sSearch to bInvalid
84154>>>>>>>                If bInvalid Begin
84156>>>>>>>                    Move False to bContinue
84157>>>>>>>                End
84157>>>>>>>>
84157>>>>>>>                
84157>>>>>>>                If (bContinue) Begin
84159>>>>>>>                    Send Request_Read of hoServer GE iFile iIndex
84160>>>>>>>                End
84160>>>>>>>>
84160>>>>>>>                
84160>>>>>>>                While (Found and bContinue)
84164>>>>>>>                    Get_Field_Value iFile iField to sVal
84167>>>>>>>                    
84167>>>>>>>                    If ((not(bCase) and Lowercase(Left(sVal, iLen)) = sLowSearch) or (bCase and Left(sVal, iLen) = sSearch)) Begin
84169>>>>>>>
84169>>>>>>>                        Move (SerializeRowID(GetRowID(iFile)))  to aSuggestions[iRow].sRowId
84170>>>>>>>                        Move (Trim(sVal))                       to aSuggestions[iRow].aValues[0]
84171>>>>>>>                        Increment iRow
84172>>>>>>>                        
84172>>>>>>>                        Move (iRow < iMax) to bContinue
84173>>>>>>>                       
84173>>>>>>>                        Send Request_Read of hoServer GT iFile iIndex  
84174>>>>>>>                    End
84174>>>>>>>>
84174>>>>>>>                    Else Begin
84175>>>>>>>                        If (eType = DF_BCD and Length(sSearch) < iLength) Begin
84177>>>>>>>                            //  For numeric fields we'll jump in the index to the next possible value (for example from 40 to 400)
84177>>>>>>>                            
84177>>>>>>>                            Move (GetRowID(iFile)) to riTest
84178>>>>>>>                            
84178>>>>>>>                            Move (sSearch * 10) to sSearch
84179>>>>>>>                            
84179>>>>>>>                            Get SafeSetFieldValue iFile iField sSearch to bInvalid
84180>>>>>>>                            If bInvalid Begin
84182>>>>>>>                                Move False to bContinue
84183>>>>>>>                            End
84183>>>>>>>>
84183>>>>>>>                            Else Begin
84184>>>>>>>                                Send Request_Read of hoServer GE iFile iIndex
84185>>>>>>>                                Move (not(IsSameRowID(riTest, GetRowID(iFile)))) to bContinue
84186>>>>>>>                            End 
84186>>>>>>>>
84186>>>>>>>                        End
84186>>>>>>>>
84186>>>>>>>                        Else Begin
84187>>>>>>>                            Move False to bContinue
84188>>>>>>>                        End
84188>>>>>>>>
84188>>>>>>>                    End
84188>>>>>>>>
84188>>>>>>>                    
84188>>>>>>>                Loop
84189>>>>>>>>
84189>>>>>>>                Set No_Relate_State of hoServer to bOldRelate
84190>>>>>>>            End
84190>>>>>>>>
84190>>>>>>>        End
84190>>>>>>>>
84190>>>>>>>    End_Procedure
84191>>>>>>>    
84191>>>>>>>    Procedure SuggestionsFindFullText String sSearch tSuggestion[] ByRef aSuggestions
84193>>>>>>>        Integer iFile iField iIndex iRow iMax
84193>>>>>>>        Handle hoServer
84193>>>>>>>        Boolean bContinue bCase  bOldRelate bNeedsRelate
84193>>>>>>>        String sVal sLowSearch
84193>>>>>>>        
84193>>>>>>>        Get Server to hoServer
84194>>>>>>>        Get Data_File  to iFile
84195>>>>>>>        Get Data_Field to iField       
84196>>>>>>>        
84196>>>>>>>        If ((hoServer <> 0) and (iFile <> 0)) Begin
84198>>>>>>>            Get piMaxResults to iMax
84199>>>>>>>            Get pbCaseSensitive to bCase
84200>>>>>>>            
84200>>>>>>>            Get piFindIndex to iIndex
84201>>>>>>>            If (iIndex <= 0) Begin
84203>>>>>>>                Get_Attribute DF_FIELD_INDEX of iFile iField to iIndex
84206>>>>>>>            End
84206>>>>>>>>
84206>>>>>>>            
84206>>>>>>>            Get No_Relate_State of hoServer to bOldRelate
84207>>>>>>>            Get DDOConstraintNeedsRelate of hoServer iIndex to bNeedsRelate
84208>>>>>>>            Set No_Relate_State of hoServer to (not(bNeedsRelate))
84209>>>>>>>            
84209>>>>>>>            
84209>>>>>>>            Move (Lowercase(sSearch)) to sLowSearch
84210>>>>>>>            Move True to bContinue
84211>>>>>>>            Move 0 to iRow
84212>>>>>>>                
84212>>>>>>>            //  Find first record
84212>>>>>>>            Send Request_Read of hoServer FIRST_RECORD iFile iIndex
84213>>>>>>>            
84213>>>>>>>            While (Found and (iRow < iMax))
84217>>>>>>>                Get_Field_Value iFile iField to sVal
84220>>>>>>>                
84220>>>>>>>                If ((bCase and sVal contains sSearch) or (not(bCase) and Lowercase(sVal) contains sLowSearch)) Begin
84222>>>>>>>                    Move (SerializeRowID(GetRowID(iFile)))  to aSuggestions[iRow].sRowId
84223>>>>>>>                    Move (Trim(sVal))                       to aSuggestions[iRow].aValues[0]
84224>>>>>>>                    Increment iRow
84225>>>>>>>                End
84225>>>>>>>>
84225>>>>>>>                
84225>>>>>>>                Send Request_Read of hoServer GT iFile iIndex 
84226>>>>>>>            Loop
84227>>>>>>>>
84227>>>>>>>            Set No_Relate_State of hoServer to bOldRelate
84228>>>>>>>        End
84228>>>>>>>>
84228>>>>>>>    End_Procedure
84229>>>>>>>    
84229>>>>>>>    Procedure SuggestionsSQLFullText String sSearch tSuggestion[] ByRef aSuggestions
84231>>>>>>>        Integer iFile iField iIndex iRow iMax
84231>>>>>>>        Handle hoServer
84231>>>>>>>        Boolean bContinue bOrigActive  bOldRelate bNeedsRelate
84231>>>>>>>        String sVal sOrigFilter sFilter sFile sField
84231>>>>>>>        
84231>>>>>>>        Get Server to hoServer
84232>>>>>>>        Get Data_File  to iFile
84233>>>>>>>        Get Data_Field to iField       
84234>>>>>>>        
84234>>>>>>>        If ((hoServer <> 0) and (iFile <> 0)) Begin
84236>>>>>>>            
84236>>>>>>>            // make sure we send DD messages to owner DDO
84236>>>>>>>            Get Which_Data_Set of hoServer iFile to hoServer
84237>>>>>>>            If (hoServer=0) Begin
84239>>>>>>>                Procedure_Return
84240>>>>>>>            End
84240>>>>>>>>
84240>>>>>>>            
84240>>>>>>>            Get piMaxResults to iMax
84241>>>>>>>            Get piFindIndex to iIndex
84242>>>>>>>            If (iIndex <= 0) Begin
84244>>>>>>>                Get_Attribute DF_FIELD_INDEX of iFile iField to iIndex
84247>>>>>>>            End
84247>>>>>>>>
84247>>>>>>>            
84247>>>>>>>            //  Determine current filter settings
84247>>>>>>>            Get psSQLFilter of hoServer to sOrigFilter
84248>>>>>>>            Get pbUseDDSqlFilters of hoServer to bOrigActive
84249>>>>>>>            
84249>>>>>>>            // generate the Like filter string
84249>>>>>>>            Get SQLStrLike of hoServer iField sSearch to sFilter
84250>>>>>>>            // If filtering was active append this to what's there
84250>>>>>>>            If (bOrigActive) Begin
84252>>>>>>>                Get SQLStrAppend of hoServer sOrigFilter sFilter to sFilter
84253>>>>>>>            End
84253>>>>>>>>
84253>>>>>>>            
84253>>>>>>>            //  Set filter
84253>>>>>>>            Set psSQLFilter of hoServer to sFilter
84254>>>>>>>            Set pbUseDDSqlFilters of hoServer to True
84255>>>>>>>            
84255>>>>>>>            
84255>>>>>>>            // this will optimize No_relate. If your DF constraint does not
84255>>>>>>>            // need a post-relate test, we will disabled relates for this
84255>>>>>>>            Get No_Relate_State of hoServer to bOldRelate
84256>>>>>>>            Get DDOConstraintNeedsRelate of hoServer iIndex to bNeedsRelate
84257>>>>>>>            Set No_Relate_State of hoServer to (not(bNeedsRelate))
84258>>>>>>>
84258>>>>>>>            //  Find records
84258>>>>>>>            Move True to bContinue
84259>>>>>>>            Move 0 to iRow
84260>>>>>>>            
84260>>>>>>>            Send Request_Read of hoServer FIRST_RECORD iFile iIndex
84261>>>>>>>            
84261>>>>>>>            While (bContinue)
84265>>>>>>>                Get_Field_Value iFile iField to sVal
84268>>>>>>>                
84268>>>>>>>                If (Found) Begin // and ((bCase and sVal contains sSearch) or (not(bCase) and Lowercase(sVal) contains sLowSearch))) Begin
84270>>>>>>>                    Move (SerializeRowID(GetRowID(iFile)))  to aSuggestions[iRow].sRowId
84271>>>>>>>                    Move (Trim(sVal))                       to aSuggestions[iRow].aValues[0]
84272>>>>>>>                    Increment iRow
84273>>>>>>>                    
84273>>>>>>>                    Move (iRow < iMax) to bContinue
84274>>>>>>>                   
84274>>>>>>>                    Send Request_Read of hoServer GT iFile iIndex 
84275>>>>>>>                End
84275>>>>>>>>
84275>>>>>>>                Else Begin
84276>>>>>>>                    Move False to bContinue
84277>>>>>>>                End
84277>>>>>>>>
84277>>>>>>>                
84277>>>>>>>            Loop
84278>>>>>>>>
84278>>>>>>>            
84278>>>>>>>            //  Restore filters
84278>>>>>>>            Set psSQLFilter of hoServer to sOrigFilter
84279>>>>>>>            Set pbUseDDSqlFilters of hoServer to bOrigActive
84280>>>>>>>            Set No_Relate_State of hoServer to bOldRelate
84281>>>>>>>        End
84281>>>>>>>>
84281>>>>>>>    End_Procedure
84282>>>>>>>    
84282>>>>>>>    Procedure SuggestionsValidation String sSearch tSuggestion[] ByRef aSuggestions Boolean bFullText
84284>>>>>>>        Handle hoServer hoTable
84284>>>>>>>        Integer iFile iField iRow iCount iFound iMax iLen
84284>>>>>>>        Variant[][] aData
84285>>>>>>>        Boolean bCaseSensitive bContinue
84285>>>>>>>        String sDescr sVal
84285>>>>>>>        
84285>>>>>>>        Get Server to hoServer
84286>>>>>>>        Get Data_File  to iFile
84287>>>>>>>        Get Data_Field to iField       
84288>>>>>>>        
84288>>>>>>>        If ((hoServer <> 0) and (iFile <> 0)) Begin
84290>>>>>>>            Get File_Field_Table_Object of hoServer iFile iField to hoTable
84291>>>>>>>            If (hoTable <> 0) Begin
84293>>>>>>>                Get tabledata of hoTable to aData
84294>>>>>>>        
84294>>>>>>>                Get piMaxResults to iMax
84295>>>>>>>                Get pbCaseSensitive to bCaseSensitive  
84296>>>>>>>            
84296>>>>>>>                If (not(bCaseSensitive)) Begin
84298>>>>>>>                    Move (Lowercase(sSearch)) to sSearch
84299>>>>>>>                End
84299>>>>>>>>
84299>>>>>>>                
84299>>>>>>>                
84299>>>>>>>                Move (SizeOfArray(aData)) to iCount
84300>>>>>>>                Move 0 to iRow
84301>>>>>>>                Move (Length(sSearch)) to iLen
84302>>>>>>>                Move True to bContinue
84303>>>>>>>                
84303>>>>>>>            
84303>>>>>>>                While (iFound < iMax and iRow < iCount and bContinue)
84307>>>>>>>                    If (not(bCaseSensitive)) Begin
84309>>>>>>>                        Move (Lowercase(aData[iRow][0])) to sVal
84310>>>>>>>                        Move (Lowercase(aData[iRow][1])) to sDescr
84311>>>>>>>                    End
84311>>>>>>>>
84311>>>>>>>                    Else Begin
84312>>>>>>>                        Move aData[iRow][0] to sVal
84313>>>>>>>                        Move aData[iRow][1] to sDescr
84314>>>>>>>                    End
84314>>>>>>>>
84314>>>>>>>                    
84314>>>>>>>                    If ((bFullText and (sVal contains sSearch)) or (not(bFullText) and (Left(sVal, iLen) = sSearch))) Begin
84316>>>>>>>                        Move aData[iRow][0] to aSuggestions[iFound].sRowId
84317>>>>>>>                        Move aData[iRow][0] to aSuggestions[iFound].aValues[0]
84318>>>>>>>                        Move aData[iRow][1] to aSuggestions[iFound].aValues[1]
84319>>>>>>>                        Increment iFound
84320>>>>>>>                    End
84320>>>>>>>>
84320>>>>>>>                    Else Begin
84321>>>>>>>                        Move (bFullText or iFound = 0) to bContinue
84322>>>>>>>                    End
84322>>>>>>>>
84322>>>>>>>                    
84322>>>>>>>                    Increment iRow
84323>>>>>>>                Loop
84324>>>>>>>>
84324>>>>>>>            End
84324>>>>>>>>
84324>>>>>>>        End
84324>>>>>>>>
84324>>>>>>>         
84324>>>>>>>    End_Procedure
84325>>>>>>>    
84325>>>>>>>    
84325>>>>>>>    Procedure OnFindSuggestions String sSearch tSuggestion[] ByRef aSuggestions
84327>>>>>>>        Integer iMode iFile
84327>>>>>>>        Boolean bFullText bResult bSupportsSQL
84327>>>>>>>        Handle hoServer
84327>>>>>>>        
84327>>>>>>>        Get Server to hoServer
84328>>>>>>>        Get Data_File  to iFile
84329>>>>>>>        
84329>>>>>>>        If ((hoServer <> 0) and (iFile <> 0)) Begin
84331>>>>>>>            
84331>>>>>>>            Get peSuggestionMode to iMode
84332>>>>>>>            Get pbFullText to bFullText
84333>>>>>>>            
84333>>>>>>>            If (iMode = smFind) Begin
84335>>>>>>>                If (not(bFullText)) Begin
84337>>>>>>>                    Send SuggestionsFindIncremental sSearch (&aSuggestions)
84338>>>>>>>                End
84338>>>>>>>>
84338>>>>>>>                Else Begin
84339>>>>>>>                    Get SupportsSQLFilters of hoServer to bSupportsSQL
84340>>>>>>>                    If (bSupportsSQL) Begin
84342>>>>>>>                        Send SuggestionsSQLFullText sSearch (&aSuggestions)
84343>>>>>>>                    End
84343>>>>>>>>
84343>>>>>>>                    Else Begin
84344>>>>>>>                        Send SuggestionsFindFullText sSearch (&aSuggestions)
84345>>>>>>>                    End
84345>>>>>>>>
84345>>>>>>>                End
84345>>>>>>>>
84345>>>>>>>            End
84345>>>>>>>>
84345>>>>>>>            Else If (iMode = smValidationTable) Begin
84348>>>>>>>                Send SuggestionsValidation sSearch (&aSuggestions) bFullText
84349>>>>>>>            End
84349>>>>>>>>
84349>>>>>>>        End
84349>>>>>>>>
84349>>>>>>>    End_Procedure
84350>>>>>>>    
84350>>>>>>>    Procedure OnSelectSuggestion String sSearch tSuggestion Suggestion
84352>>>>>>>        Handle hoServer
84352>>>>>>>        Integer iFile iField iMode
84352>>>>>>>        Boolean bFind
84352>>>>>>>        RowID rRowId
84352>>>>>>>        
84352>>>>>>>        Get Server to hoServer
84353>>>>>>>        Get Data_File  to iFile
84354>>>>>>>        Get Data_Field to iField       
84355>>>>>>>        
84355>>>>>>>        If ((hoServer <> 0) and (iFile <> 0)) Begin
84357>>>>>>>            Get peSuggestionMode to iMode
84358>>>>>>>            
84358>>>>>>>            If (iMode = smFind) Begin
84360>>>>>>>                Get pbFindOnSelect to bFind
84361>>>>>>>                If (bFind) Begin
84363>>>>>>>                    Move (DeserializeRowID(Suggestion.sRowId)) to rRowId    
84364>>>>>>>                    
84364>>>>>>>                    If (not(IsNullRowID(rRowId))) Begin
84366>>>>>>>                        Send FindByRowId of hoServer iFile rRowId
84367>>>>>>>                    End
84367>>>>>>>>
84367>>>>>>>                End
84367>>>>>>>>
84367>>>>>>>                Else Begin
84368>>>>>>>                    Set Value to Suggestion.aValues[0]
84369>>>>>>>                    Set Item_Changed_State to True
84370>>>>>>>                End
84370>>>>>>>>
84370>>>>>>>            End
84370>>>>>>>>
84370>>>>>>>            Else If (imode = smValidationTable) Begin
84373>>>>>>>                Set Value to Suggestion.sRowId
84374>>>>>>>                Set Item_Changed_State to True
84375>>>>>>>            End
84375>>>>>>>>
84375>>>>>>>            
84375>>>>>>>        End
84375>>>>>>>>
84375>>>>>>>    End_Procedure
84376>>>>>>>    
84376>>>>>>>    // Return true if Suggestion should be invoked. Can be augmented
84376>>>>>>>    Function ShouldSuggestion String sValue Boolean bChanged Returns Boolean
84378>>>>>>>        Integer iStartAtChar
84378>>>>>>>        Get piStartAtChar to iStartAtChar
84379>>>>>>>        Function_Return (bChanged and Length(sValue)>=iStartAtChar)
84380>>>>>>>    End_Function
84381>>>>>>>    
84381>>>>>>>    
84381>>>>>>>End_Class
84382>>>>>>>
84382>>>>>>>
84382>>>>>>>// This contains logic that deals with the Windows object. It relies on the interface in 
84382>>>>>>>// sSuggestion_mixin, which means it must be mixed in as a sibling of this object (as is done
84382>>>>>>>// in dbSuggestionForm or as a child of this object (as is done in cDbCJGridColumnSuggestion), which
84382>>>>>>>// means messages are resolved via delegation. sSuggestion_mixin does not send messages to this class.
84382>>>>>>>// Note that cSuggestion_mixin and cSuggestionControl_mixin are designed so they can be mixed in at
84382>>>>>>>// the same level or mixed in such that cSuggestionControl_mixin is in the child object and cSuggestion_mixin
84382>>>>>>>// is in the parent
84382>>>>>>> 
84382>>>>>>>Class cSuggestionControl_mixin is a Mixin
84383>>>>>>>    
84383>>>>>>>    Procedure Define_cSuggestionControl_mixin
84385>>>>>>>        
84385>>>>>>>        Property Integer piTimeOutTicks 0
84386>>>>>>>        
84386>>>>>>>        On_Key kEnter Send SelectSuggestion
84387>>>>>>>        On_Key Key_Escape Send DeActivateSuggestionList
84388>>>>>>>        On_Key Key_Up_Arrow Send Up
84389>>>>>>>        On_Key Key_Down_Arrow Send Down
84390>>>>>>>
84390>>>>>>>    End_Procedure
84391>>>>>>>
84391>>>>>>>    Procedure AdjustSuggestionListSize Integer iLines
84393>>>>>>>        Integer i  iX iMax iY
84393>>>>>>>        String sTxt
84393>>>>>>>        Boolean bFullWidth
84393>>>>>>>        For i from 0 to (iLines-1)
84399>>>>>>>>
84399>>>>>>>            Get Line of ghoSuggestionList i to sTxt
84400>>>>>>>            Get Text_Extent of ghoSuggestionList sTxt to iX
84401>>>>>>>            Move (Low(iX) max iMax) to iMax
84402>>>>>>>            Move (Hi(iX)) to iY
84403>>>>>>>        Loop
84404>>>>>>>>
84404>>>>>>>        Move (iMax + 20) to imax
84405>>>>>>>        Get pbFullWidth to bFullWidth
84406>>>>>>>        If bFullWidth Begin
84408>>>>>>>            Move (iMax max (Low(GuiSize(Self)))) to iMax
84409>>>>>>>        End
84409>>>>>>>>
84409>>>>>>>        If (iLines) Begin
84411>>>>>>>            Set GuiSize of ghoSuggestionList to (iY*(iLines)+8) iMax
84412>>>>>>>            Send SelectRow of ghoSuggestionList 0 // go to first line
84413>>>>>>>        End
84413>>>>>>>>
84413>>>>>>>        Else Begin
84414>>>>>>>            Set GuiSize of ghoSuggestionList to (Hi(GuiSize(Self))) (low(GuiSize(Self)))
84415>>>>>>>        End
84415>>>>>>>>
84415>>>>>>>    End_Procedure
84416>>>>>>>    
84416>>>>>>>    // show all suggestions
84416>>>>>>>    Procedure ShowSuggestions
84418>>>>>>>        tSuggestion[] aResults
84418>>>>>>>        tSuggestion[] aResults
84419>>>>>>>        Integer i iLines
84419>>>>>>>        String sSearch 
84419>>>>>>>        Get pSearchResults to aResults
84420>>>>>>>        Get Value to sSearch
84421>>>>>>>        Send Delete_Data of ghoSuggestionList
84422>>>>>>>        Move (SizeOfArray(aResults)) to iLines
84423>>>>>>>        For i from 0 to (iLines-1)
84429>>>>>>>>
84429>>>>>>>            Send ShowSuggestion aResults[i] sSearch
84430>>>>>>>            If ((iLines-1)<>i) Begin
84432>>>>>>>                Send AppendTextLn of ghoSuggestionList ""
84433>>>>>>>            End
84433>>>>>>>>
84433>>>>>>>        Loop
84434>>>>>>>>
84434>>>>>>>        Send AdjustSuggestionListSize iLines
84435>>>>>>>    End_Procedure
84436>>>>>>>
84436>>>>>>>    Procedure FindSuggestions 
84438>>>>>>>        String sSearch
84438>>>>>>>        tSuggestion[] aResults
84438>>>>>>>        tSuggestion[] aResults
84439>>>>>>>        String[] aParams
84440>>>>>>>        Get Value to sSearch
84441>>>>>>>        Send OnFindSuggestions sSearch (&aResults)
84442>>>>>>>        Set pSearchResults to aResults
84443>>>>>>>        // if an error was raised, the suggestion list will be gone
84443>>>>>>>        If (ghoSuggestionList) Begin
84445>>>>>>>            Send ShowSuggestions
84446>>>>>>>        End
84446>>>>>>>>
84446>>>>>>>    End_Procedure
84447>>>>>>>
84447>>>>>>>    Procedure SelectSuggestion 
84449>>>>>>>        String sSearch
84449>>>>>>>        tSuggestion[] aData
84449>>>>>>>        tSuggestion[] aData
84450>>>>>>>        Integer iSelRow
84450>>>>>>>        If ghoSuggestionList Begin
84452>>>>>>>            Get SelectedRow of ghoSuggestionList to iSelRow
84453>>>>>>>            Get Value to sSearch
84454>>>>>>>            Get pSearchResults to aData        
84455>>>>>>>            Send DeActivateSuggestionList
84456>>>>>>>            Send CancelEditIfGrid
84457>>>>>>>            If (iSelRow>=0 and SizeOfArray(aData)>iSelRow) Begin
84459>>>>>>>                Send OnSelectSuggestion sSearch aData[iSelRow] 
84460>>>>>>>            End
84460>>>>>>>>
84460>>>>>>>        End
84460>>>>>>>>
84460>>>>>>>        Else Begin
84461>>>>>>>            Send Default_Action
84462>>>>>>>        End
84462>>>>>>>>
84462>>>>>>>    End_Procedure
84463>>>>>>>    
84463>>>>>>>    Procedure CancelEditIfGrid
84465>>>>>>>        // do nothing with forms, remember
84465>>>>>>>        // to replace or augment with grid to
84465>>>>>>>        // cancel the edit control
84465>>>>>>>    End_Procedure
84466>>>>>>>
84466>>>>>>>    
84466>>>>>>>    Function ParentForSuggestion Returns Handle
84468>>>>>>>        Handle hoMain hoMainPanel
84468>>>>>>>
84468>>>>>>>        // we must have an application object and a main panel object
84468>>>>>>>        If ghoApplication Begin
84470>>>>>>>            Get phoMainPanel of ghoApplication to hoMainPanel
84471>>>>>>>        End
84471>>>>>>>>
84471>>>>>>>        If (hoMainPanel=0 or Self<=Desktop) Begin
84473>>>>>>>            Function_Return 0
84474>>>>>>>        End
84474>>>>>>>>
84474>>>>>>>
84474>>>>>>>        Move Self to hoMain
84475>>>>>>>        Repeat
84475>>>>>>>>
84475>>>>>>>            Get Parent of hoMain to hoMain
84476>>>>>>>        Until (hoMain=Desktop or Block_Mouse_State(hoMain) or hoMainPanel=hoMain)
84478>>>>>>>
84478>>>>>>>        Function_Return (If(hoMain>Desktop,hoMain,0))
84479>>>>>>>        
84479>>>>>>>    End_Function
84480>>>>>>>    
84480>>>>>>>    Procedure ActivateSuggestionList
84482>>>>>>>        Handle hoView hcSuggest
84482>>>>>>>        Get ParentForSuggestion to hoView
84483>>>>>>>        If hoView Begin
84485>>>>>>>            Get phcSuggestionListClass to hcSuggest
84486>>>>>>>            Get CreateNamed of hoView hcSuggest "oSuggestList" to ghoSuggestionList
84487>>>>>>>            Send InitList of ghoSuggestionList Self
84488>>>>>>>            Set Focus_Mode of ghoSuggestionList to Focusable
84489>>>>>>>            Set phoOwner of ghoSuggestionList to Self
84490>>>>>>>            Send Add_Focus of ghoSuggestionList hoView
84491>>>>>>>        End
84491>>>>>>>>
84491>>>>>>>    End_Procedure
84492>>>>>>>    
84492>>>>>>>    Procedure DeActivateSuggestionList
84494>>>>>>>        If ghoSuggestionList Begin
84496>>>>>>>            Send DeactivateList of ghoSuggestionList
84497>>>>>>>        End
84497>>>>>>>>
84497>>>>>>>    End_Procedure
84498>>>>>>>    
84498>>>>>>>    // augment to kill suggest list if focus is not moving to it  
84498>>>>>>>    // customized for grid
84498>>>>>>>    Procedure OnKillFocus
84500>>>>>>>        // note focus has already changed here
84500>>>>>>>        If (ghoSuggestionList) Begin
84502>>>>>>>            If (Focus(Self)<>ghoSuggestionList) Begin
84504>>>>>>>                Send DeActivateSuggestionList
84505>>>>>>>                Forward Send OnKillFocus
84507>>>>>>>            End
84507>>>>>>>>
84507>>>>>>>            Else Begin
84508>>>>>>>                // giving focus to the suggestion list here
84508>>>>>>>            End
84508>>>>>>>>
84508>>>>>>>        End
84508>>>>>>>>
84508>>>>>>>        Else Begin
84509>>>>>>>            Forward Send OnKillFocus
84511>>>>>>>        End
84511>>>>>>>>
84511>>>>>>>    End_Procedure
84512>>>>>>>    
84512>>>>>>>    Procedure Up
84514>>>>>>>        If (Focus(Desktop) = Self and ghoSuggestionList) Begin
84516>>>>>>>           Send ScrollUp of ghoSuggestionList
84517>>>>>>>        End
84517>>>>>>>>
84517>>>>>>>    End_Procedure
84518>>>>>>>
84518>>>>>>>    Procedure Down
84520>>>>>>>        If (Focus(Desktop) = Self and ghoSuggestionList) Begin
84522>>>>>>>           Send ScrollDown of ghoSuggestionList
84523>>>>>>>        End
84523>>>>>>>>
84523>>>>>>>    End_Procedure
84524>>>>>>>    
84524>>>>>>>
84524>>>>>>>    Procedure Key Integer iKey
84526>>>>>>>        Integer iEndTicks
84526>>>>>>>        
84526>>>>>>>        If (Focus(Desktop) <> Self) Begin
84528>>>>>>>          Forward Send Key iKey
84530>>>>>>>          Procedure_Return
84531>>>>>>>        End
84531>>>>>>>>
84531>>>>>>>        
84531>>>>>>>        Send DeActivateSuggestionList
84532>>>>>>>        Move (GetTickCount()) to iEndTicks
84533>>>>>>>        // record the time of key press
84533>>>>>>>        If (piTimeOutTicks(Self) = 0) Begin
84535>>>>>>>         
84535>>>>>>>            If (ghoSuggestionTimer=0) Begin
84537>>>>>>>               Send CreateSuggestionTimer
84538>>>>>>>            End
84538>>>>>>>>
84538>>>>>>>         
84538>>>>>>>            Set pbEnabled of ghoSuggestionTimer to True
84539>>>>>>>            Set phoTimerOwner of ghoSuggestionTimer to Self
84540>>>>>>>        End
84540>>>>>>>>
84540>>>>>>>        Set piTimeOutTicks to iEndTicks
84541>>>>>>>        
84541>>>>>>>        Forward Send Key iKey
84543>>>>>>>    End_Procedure
84544>>>>>>>    
84544>>>>>>>    Procedure CreateSuggestionTimer
84546>>>>>>>        Handle hoMainPanel
84546>>>>>>>        // we must have an application object and a main panel object
84546>>>>>>>        If ghoApplication Begin
84548>>>>>>>            Get phoMainPanel of ghoApplication to hoMainPanel
84549>>>>>>>        End
84549>>>>>>>>
84549>>>>>>>        If (hoMainPanel=0) Begin
84551>>>>>>>            Error DFERR_PROGRAM "Auto-suggest requires an application object and a main panel object"
84552>>>>>>>>
84552>>>>>>>            Procedure_Return
84553>>>>>>>        End
84553>>>>>>>>
84553>>>>>>>        Get CreateNamed of hoMainPanel (RefClass(cSuggestionTimer)) "oSuggestionTimer" to ghoSuggestionTimer
84554>>>>>>>    End_Procedure
84555>>>>>>>  
84555>>>>>>>    // sent by Auto Suggest Timer. Invoke suggestion list as needed
84555>>>>>>>    Procedure OnSuggestionTimer
84557>>>>>>>        Boolean bDoIt
84557>>>>>>>        Integer iEndTicks iStartTicks iTicks iTimeOut iChanged
84557>>>>>>>        String sValue
84557>>>>>>>        
84557>>>>>>>        If (Focus(Desktop) <> Self) Begin
84559>>>>>>>            // focus out of whack. Stop the timer
84559>>>>>>>            Set pbEnabled of ghoSuggestionTimer to False
84560>>>>>>>            Send DeActivateSuggestionList   
84561>>>>>>>            Procedure_Return
84562>>>>>>>        End                                
84562>>>>>>>>
84562>>>>>>>
84562>>>>>>>        Get piTimeOutTicks to iStartTicks
84563>>>>>>>        If (iStartTicks <> 0) Begin           
84565>>>>>>>            Move (GetTickCount()) to iEndTicks 
84566>>>>>>>            Move (iEndTicks - iStartTicks) to iTicks
84567>>>>>>>            // If tick count rolled over
84567>>>>>>>            If (iTicks < 0) Begin
84569>>>>>>>                Move (-iTicks) to iTicks 
84570>>>>>>>            End
84570>>>>>>>>
84570>>>>>>>        End
84570>>>>>>>>
84570>>>>>>>        Get piPopupTimeout to iTimeOut
84571>>>>>>>        If (iTicks >= iTimeOut) Begin
84573>>>>>>>            // If time delay has been met, launch autocomplete
84573>>>>>>>            Set pbEnabled  of ghoSuggestionTimer to False
84574>>>>>>>            Get Value to sValue
84575>>>>>>>            Get Item_Changed_State 0 to iChanged
84576>>>>>>>            Get ShouldSuggestion sValue iChanged to bDoIt
84577>>>>>>>            If bDoIt Begin
84579>>>>>>>                Send ActivateSuggestionList
84580>>>>>>>                Send FindSuggestions
84581>>>>>>>                Set Visible_State of ghoSuggestionList to True
84582>>>>>>>            End
84582>>>>>>>>
84582>>>>>>>            Set piTimeOutTicks to 0
84583>>>>>>>        End
84583>>>>>>>>
84583>>>>>>>    End_Procedure
84584>>>>>>>
84584>>>>>>>End_Class
84585>>>>>>>
84585>>>>>
84585>>>>>Class DbSuggestionForm is a dbForm
84586>>>>>    
84586>>>>>    Import_Class_Protocol cSuggestionControl_mixin
84587>>>>>    Import_Class_Protocol cSuggestion_mixin
84588>>>>>    
84588>>>>>    Procedure Construct_Object
84590>>>>>        Forward Send Construct_Object
84592>>>>>        Send Define_cSuggestionControl_mixin
84593>>>>>        Send Define_cSuggestion_mixin    
84594>>>>>    End_Procedure
84595>>>>>    
84595>>>>>End_Class
84596>>>>>
84596>>>Use cDbCJGridColumnSuggestion.pkg
Including file: cDbCJGridColumnSuggestion.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cDbCJGridColumnSuggestion.pkg)
84596>>>>>Use WinSuggestion.pkg
84596>>>>>Use cDbCJGridColumn.pkg
84596>>>>>Use cDbCJGridColumnEdit.pkg
84596>>>>>
84596>>>>>// This is the edit control that gets embedded in cDbCJGridColumnSuggestion object.
84596>>>>>
84596>>>>>Class cDbCJGridColumnSuggestionEdit is a cDbCJGridColumnEdit
84597>>>>>
84597>>>>>    Import_Class_Protocol cSuggestionControl_mixin
84598>>>>>
84598>>>>>    Procedure Construct_Object
84600>>>>>        Forward Send Construct_Object
84602>>>>>        Send Define_cSuggestionControl_mixin
84603>>>>>    End_Procedure
84604>>>>>    
84604>>>>>    // Called when closing a suggestion form. With grids we must also make sure that the
84604>>>>>    // edit is canceled. 
84604>>>>>    Procedure CancelEditIfGrid
84606>>>>>        Send CancelEdit
84607>>>>>    End_Procedure
84608>>>>>    
84608>>>>>End_Class
84609>>>>>
84609>>>>>// A cDbCJGridColumnSuggestion would be dropped inside of cDbCJGrid.
84609>>>>>
84609>>>>>Class cDbCJGridColumnSuggestion is a cDbCJGridColumn
84610>>>>>    
84610>>>>>    Import_Class_Protocol cSuggestion_mixin            
84611>>>>>    
84611>>>>>    Procedure Construct_Object
84613>>>>>        Forward Send Construct_Object
84615>>>>>
84615>>>>>        Send Define_cSuggestion_mixin
84616>>>>>        Set phcEditClass to (RefClass(cDbCJGridColumnSuggestionEdit))
84617>>>>>    End_Procedure
84618>>>>>    
84618>>>>>End_Class
84619>>>
84619>>>Use Customer.DD
84619>>>Use Vendor.DD
84619>>>Use dfTabDlg.pkg
84619>>>
84619>>>
84619>>>Deferred_View Activate_oDemoSuggestionForm for ;Object oDemoSuggestionForm is a dbView
84644>>>
84644>>>    Set Border_Style to Border_Thick
84645>>>    Set Size to 227 300
84646>>>    Set Location to 2 2
84647>>>    Set Label to "Suggestion Forms and Grids"
84648>>>
84648>>>    Object oSuggestionsTP is a dbTabDialogView
84650>>>        Set Size to 208 284
84651>>>        Set Location to 10 7
84652>>>
84652>>>        Object oVendor_DD is a Vendor_DataDictionary
84654>>>        End_Object
84655>>>    
84655>>>        Object oCustomer_DD is a Customer_DataDictionary
84657>>>            Procedure Field_defaults
84660>>>                Forward Send Field_Defaults
84662>>>                Set Field_Changed_Value   Field Customer.State to ""
84663>>>            End_Procedure
84664>>>        End_Object
84665>>>    
84665>>>        Set Main_DD to oCustomer_DD
84666>>>        Set Server to oCustomer_DD
84667>>>
84667>>>        Object oSuggestionForms is a dbTabView
84669>>>            Set Label to 'dbSuggestionForm'
84670>>>
84670>>>            Object oLabel1 is a TextBox
84672>>>                Set Auto_Size_State to False
84673>>>                Set Size to 10 237
84674>>>                Set Location to 17 16
84675>>>                Set Label to "Data bound, incremental, starting at character 1"
84676>>>                Set FontWeight to fw_Bold
84677>>>            End_Object
84678>>>            Object oSuggestionForm2 is a dbSuggestionForm
84680>>>                Set Location to 28 74
84681>>>                Entry_Item Customer.Customer_Number
84682>>>                Set size to 14 45
84683>>>                Set Label to "Customer Num:"
84684>>>                Set piStartAtChar to 1
84685>>>            End_Object
84686>>>            Object oSuggestionForm1 is a dbSuggestionForm
84688>>>                Set Location to 44 74
84689>>>                Entry_Item Customer.Name
84690>>>                Set size to 14 146
84691>>>                Set Label to "Customer Name:"
84692>>>                Set piStartAtChar to 1
84693>>>            End_Object
84694>>>            Object oLabel3 is a TextBox
84696>>>                Set Auto_Size_State to False
84697>>>                Set Size to 9 211
84698>>>                Set Location to 77 17
84699>>>                Set Label to "Validation Table, incremental, starting at character 1"
84700>>>                Set FontWeight to fw_Bold
84701>>>            End_Object
84702>>>            Object oSuggestionForm4 is a dbSuggestionForm
84704>>>                Set Location to 89 74
84705>>>                Entry_Item Customer.State
84706>>>                Set Size to 14 50
84707>>>                Set Label to "Customer State:"
84708>>>                Set peSuggestionMode to smValidationTable
84709>>>                Set piStartAtChar to 1
84710>>>            End_Object
84711>>>            Object oLabel2 is a TextBox
84713>>>                Set Auto_Size_State to False
84714>>>                Set Size to 10 199
84715>>>                Set Location to 120 16
84716>>>                Set Label to "Data bound, full text, starting at character 2"
84717>>>                Set FontWeight to fw_Bold
84718>>>            End_Object
84719>>>            
84719>>>            Object oSuggestionForm3 is a dbSuggestionForm
84721>>>                Set Location to 137 74
84722>>>                Entry_Item Vendor.Name
84723>>>                Set Server to oVendor_DD
84724>>>                Set Size to 14 100
84725>>>                Set pbFullText to True
84726>>>                Set Label to "Vendor name:"
84727>>>            End_Object
84728>>>
84728>>>            Object oLabel3 is a TextBox
84730>>>                Set Auto_Size_State to False
84731>>>                Set Size to 10 199
84732>>>                Set Location to 158 16
84733>>>                Set Label to "Custom Suggestion List"
84734>>>                Set FontWeight to fw_Bold
84735>>>            End_Object
84736>>>            
84736>>>            // this shows how to create you own custom suggestion list
84736>>>            Object oSuggestionForm5 is a dbSuggestionForm
84738>>>                Set Location to 175 74
84739>>>                Set Label to "Custom Id:"
84740>>>                Set Size to 14 100
84741>>>                Set peSuggestionMode to smCustom
84742>>>                Set piStartAtChar to 1
84743>>>
84743>>>                // even though we handle searching manually in OnFindSuggestions, pbFullText
84743>>>                // is still used to determine the display and bolding of matched text. Setting
84743>>>                // this true tells it we are matching anywhere within the string.
84743>>>                // Since this is a custom list, it is the developer's job to make sure that
84743>>>                // OnFindSuggestions follows these rules as well.
84743>>>                Set pbFullText to True
84744>>>                
84744>>>                // augment to create an arbitrary list of Ids to be used for our search
84744>>>                Property String[] pCustomIds
84746>>>                
84746>>>                // augment to create a list of Ids
84746>>>                Procedure Activating
84749>>>                    String[] sIds
84750>>>                    Forward Send Activating
84752>>>                    Move "JSON" to sIds[0]
84753>>>                    Move "XML" to sIds[1]
84754>>>                    Move "SQL" to sIds[2]
84755>>>                    Move "SQLExpress" to sIds[3]
84756>>>                    Move "SQLServer" to sIds[4]
84757>>>                    Move "DF" to sIds[5]
84758>>>                    Move "XQuery" to sIds[6]
84759>>>                    Move "JScript" to sIds[7]
84760>>>                    Move "Java" to sIds[8]
84761>>>                    Move "UTF-8" to sIds[9]
84762>>>                    Move "UTF-16" to sIds[10]
84763>>>                    Set pCustomIds to (SortArray(sIds,Desktop,RefFunc(DFSTRICMP)))
84764>>>                End_Procedure
84765>>>                
84765>>>                // custom code to find all matches for the search
84765>>>                // You can write whatever code you want here to find matched items
84765>>>                Procedure OnFindSuggestions String sSearch tSuggestion[] ByRef aSuggestions
84768>>>                    String[] sIds
84769>>>                    Integer i iLen iIds iCount
84769>>>                    Move (Lowercase(sSearch)) to sSearch
84770>>>                    Move (Length(sSearch)) to iLen
84771>>>                    Get pCustomIds to sIds
84772>>>                    Move (SizeOfArray(sIds)-1) to iIds
84773>>>                    For i from 0 to iIds
84779>>>>
84779>>>                        If (Lowercase(sIds[i]) contains sSearch) Begin
84781>>>                            Move sIds[i] to aSuggestions[iCount].sRowId
84782>>>                            Move sIds[i] to aSuggestions[iCount].aValues[0]
84783>>>                            Increment iCount
84784>>>                        End
84784>>>>
84784>>>                    Loop
84785>>>>
84785>>>                End_Procedure
84786>>>
84786>>>                Procedure OnSelectSuggestion String sSearch tSuggestion Suggestion
84789>>>                    Set Value to Suggestion.sRowId
84790>>>                    Set Item_Changed_State to True
84791>>>                End_Procedure
84792>>>
84792>>>            
84792>>>            End_Object
84793>>>        End_Object
84794>>>
84794>>>        Object oSuggestionGrid is a dbTabView
84796>>>
84796>>>            Set Label to "cDbCJGridColumnSuggestion"
84797>>>
84797>>>            Object oCustomer_DD is a Customer_DataDictionary
84799>>>            End_Object
84800>>>        
84800>>>            Set Main_DD to oCustomer_DD
84801>>>            Set Server to oCustomer_DD
84802>>>        
84802>>>            Object oDbCJGrid1 is a cDbCJGrid
84804>>>                Set Size to 177 268
84805>>>                Set Location to 7 7
84806>>>                Set Ordering to 1
84807>>>                Set Verify_Save_msg to (RefFunc(Save_Confirmation))
84808>>>                
84808>>>                Object oCustomer_Customer_Number is a cDbCJGridColumnSuggestion
84810>>>                    Entry_Item Customer.Customer_Number
84811>>>                    Set piWidth to 73
84812>>>                    Set psCaption to "Number"
84813>>>                    Set piStartAtChar to 1
84814>>>                End_Object
84815>>>        
84815>>>                // normally you would not use a suggestion list with a grid's main 
84815>>>                // file. It would be more useful when selecting a parent.
84815>>>                Object oCustomer_Name is a cDbCJGridColumnSuggestion
84817>>>                    Entry_Item Customer.Name
84818>>>                    Set piWidth to 358
84819>>>                    Set psCaption to "Customer Name"
84820>>>                    Set pbFullText to True
84821>>>                    Set piStartAtChar to 1
84822>>>                End_Object
84823>>>        
84823>>>                Object oCustomer_State is a cDbCJGridColumnSuggestion
84825>>>                    Entry_Item Customer.State
84826>>>                    Set piWidth to 105
84827>>>                    Set psCaption to "State"
84828>>>                    Set peSuggestionMode to smValidationTable
84829>>>                    Set piStartAtChar to 1
84830>>>                End_Object
84831>>>            End_Object
84832>>>
84832>>>        End_Object
84833>>>        
84833>>>    End_Object
84834>>>        
84834>>>        
84834>>>Cd_End_Object
84836>>>>
84836>        Use DemoButtonTest.vw
Including file: DemoButtonTest.vw    (C:\Test\Order Entry git\AppSrc\DemoButtonTest.vw)
84836>>>Use Windows.pkg
84836>>>Use DFClient.pkg
84836>>>Use cImageList32.pkg
84836>>>Use cSplitButton.pkg
Including file: cSplitButton.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cSplitButton.pkg)
84836>>>>>// cSplitButton class
84836>>>>>
84836>>>>>// This requires version 6 of common controls (vista or windows server 2008). If used with
84836>>>>>// older versions you will just get a regular button with no split part.
84836>>>>> 
84836>>>>>Use Windows.pkg
84836>>>>>
84836>>>>>Class cSplitButton is a Button
84837>>>>>
84837>>>>>    Procedure Page Integer iPageObject
84839>>>>>        Integer iStyle
84839>>>>>        Boolean bSupported
84839>>>>>        Get IsExControlSupported to bSupported
84840>>>>>        If (iPageObject=1  and bSupported) Begin
84842>>>>>            Get Form_Style iStyle to iStyle
84843>>>>>            Move (iStyle ior BS_SPLITBUTTON) to iStyle
84844>>>>>            Set Form_Style 0 to iStyle
84845>>>>>        End
84845>>>>>>
84845>>>>>        Forward Send Page iPageObject
84847>>>>>    End_Procedure
84848>>>>>    
84848>>>>>    Procedure Notify Integer wParam Integer lParam
84850>>>>>        tWinNmHdr Hdr
84850>>>>>        tWinNmHdr Hdr
84850>>>>>        Integer iVoid
84850>>>>>        Move (MemCopy(AddressOf(Hdr),lParam,SizeOfType(tWinNmHdr))) to iVoid
84851>>>>>        If (Hdr.code=BCN_DROPDOWN) Begin
84853>>>>>            Send OnDropDown
84854>>>>>        End
84854>>>>>>
84854>>>>>        Else Begin
84855>>>>>            Forward Send Notify wParam lParam
84857>>>>>        End
84857>>>>>>
84857>>>>>    End_Procedure
84858>>>>>    
84858>>>>>End_Class
84859>>>Use cCommandLinkButton.pkg
Including file: cCommandLinkButton.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cCommandLinkButton.pkg)
84859>>>>>// cCommandLinkButton class
84859>>>>>
84859>>>>>// This requires version 6 of common controls (vista or windows server 2008). If used with
84859>>>>>// older versions you will just get a regular great big button.
84859>>>>> 
84859>>>>>Use Windows.pkg
84859>>>>>Use CharTranslate.pkg
84859>>>>>
84859>>>>>Class cCommandLinkButton is a Button
84860>>>>>
84860>>>>>        Procedure Construct_Object
84862>>>>>            Forward Send Construct_Object
84864>>>>>            Property String psPrivateNote
84865>>>>>        End_Procedure
84866>>>>>        
84866>>>>>        Procedure Set psNote String sNote
84868>>>>>            Boolean bSupported
84868>>>>>            Set psPrivateNote to sNote
84869>>>>>            Get IsExControlSupported to bSupported
84870>>>>>            If bSupported Begin
84872>>>>>                Send SetWinNote
84873>>>>>            End
84873>>>>>>
84873>>>>>        End_Procedure
84874>>>>>        
84874>>>>>        Procedure SetWinNote
84876>>>>>            String sNote
84876>>>>>            Handle hWnd
84876>>>>>            Integer i
84876>>>>>            Address aVar
84876>>>>>            Get Form_Window_Handle 0 to hWnd
84877>>>>>            If hWnd Begin
84879>>>>>                Get psNote to sNote
84880>>>>>                Move (OemToUtf16Buffer(AddressOf(sNote),Length(sNote))) to aVar
84881>>>>>                Move (SendMessage(hwnd, BCM_SETNOTE, 0, aVar)) to i
84882>>>>>                Move (Free(aVar)) to i 
84883>>>>>            End
84883>>>>>>
84883>>>>>        End_Procedure
84884>>>>>        
84884>>>>>        
84884>>>>>        Function psNote Returns String
84886>>>>>            Function_Return (psPrivateNote(Self))
84887>>>>>        End_Function
84888>>>>>        
84888>>>>>
84888>>>>>        Procedure Page Integer iState
84890>>>>>            Integer i hWnd
84890>>>>>            Boolean bSupported
84890>>>>>            Get IsExControlSupported to bSupported
84891>>>>>            If (iState=1 and bSupported) Begin
84893>>>>>                Get form_style i to i
84894>>>>>                Set Form_Style 0 to (i ior (BS_COMMANDLINK + BS_FLAT))
84895>>>>>                Forward Send Page iState
84897>>>>>                Send SetWinNote
84898>>>>>            End
84898>>>>>>
84898>>>>>            Else Begin
84899>>>>>                Forward Send Page iState
84901>>>>>            End
84901>>>>>>
84901>>>>>        End_Procedure        
84902>>>>>
84902>>>>>End_Class
84903>>>Use cCJStandardMenuItemClasses.pkg
84903>>>
84903>>>
84903>>>Deferred_View Activate_oButtonTest for ;Object oButtonTest is a dbView
84928>>>
84928>>>    Set Border_Style to Border_Thick
84929>>>    Set Size to 212 300
84930>>>    Set Location to 2 3
84931>>>    Set Label to "Button Samples"
84932>>>
84932>>>    Object oTextBox1 is a TextBox
84934>>>        Set Size to 9 110
84935>>>        Set Location to 8 10
84936>>>        Set Label to 'Buttons that use Text and Images'
84937>>>    End_Object
84938>>>
84938>>>    Object oTextButton is a Button
84940>>>        Set Location to 20 11
84941>>>        Set Label to 'Save'
84942>>>    
84942>>>        Procedure OnClick
84945>>>        End_Procedure
84946>>>    
84946>>>    End_Object
84947>>>
84947>>>    Object oTextAndImageButton is a Button
84949>>>        Set Location to 20 71
84950>>>        Set Label to 'Save'
84951>>>        Set psImage to "ActionSave.ico"
84952>>>
84952>>>        Procedure OnClick
84955>>>        End_Procedure
84956>>>    
84956>>>    End_Object
84957>>>
84957>>>    Object oImageButton is a Button
84959>>>        Set Size to 14 27
84960>>>        Set Location to 20 131
84961>>>        Set psImage to "ActionSave.ico"
84962>>>        Set peImageAlign to Button_ImageList_Align_Center
84963>>>
84963>>>        Procedure OnClick
84966>>>        End_Procedure
84967>>>    
84967>>>    End_Object
84968>>>
84968>>>    Object oTextAndImageTopButton is a Button
84970>>>        Set Size to 26 50
84971>>>        Set Location to 20 168
84972>>>        Set Label to 'Save'
84973>>>        Set psImage to "ActionSave.ico"
84974>>>        Set peImageAlign to Button_ImageList_Align_Top
84975>>>        Set piImageMarginTop to 10
84976>>>
84976>>>        Procedure OnClick
84979>>>        End_Procedure
84980>>>    
84980>>>    End_Object
84981>>>
84981>>>    Object oTextAndImageBottomButton is a Button
84983>>>        Set Size to 26 50
84984>>>        Set Location to 20 226
84985>>>        Set Label to 'Save'
84986>>>        Set psImage to "ActionSave.ico"
84987>>>        Set peImageAlign to Button_ImageList_Align_Bottom
84988>>>        Set piImageMarginBottom to 10
84989>>>
84989>>>        Procedure OnClick
84992>>>        End_Procedure
84993>>>    
84993>>>    End_Object
84994>>>
84994>>>    Object oTextBox1 is a TextBox
84996>>>        Set Size to 9 110
84997>>>        Set Location to 51 10
84998>>>        Set Label to 'Buttons with drop down menus'
84999>>>    End_Object
85000>>>
85000>>>    // this is a button with down arrow button on the right that invokes
85000>>>    // a context menu inside of OnClick
85000>>>    Object oDropDownButton is a Button
85002>>>        Set Size to 14 58
85003>>>        Set Location to 65 10
85004>>>        Set Label to "Select"
85005>>>        Set psImage to "Down16.bmp"
85006>>>        Set peImageAlign to Button_ImageList_Align_Right
85007>>>
85007>>>        Procedure OnClick
85010>>>            // OnDropDown is defined to popup menu in phoButtonPopup
85010>>>            Send OnDropDown
85011>>>        End_Procedure
85012>>>        
85012>>>        Object oButtonMenu is a cCJContextMenu
85014>>>            
85014>>>            Object oMenuItem1 is a cCJMenuItem
85016>>>                Set psCaption to "Save"
85017>>>                Set psImage to "ActionSaveRecord.ico"
85018>>>                Procedure OnExecute Variant vCommandBarControl
85021>>>                End_Procedure
85022>>>            End_Object
85023>>>            
85023>>>            Object oMenuItem2 is a cCJMenuItem
85025>>>                Set psCaption to "Clear"
85026>>>                Set psImage to "ActionClear.ico"
85027>>>                Procedure OnExecute Variant vCommandBarControl
85030>>>                End_Procedure
85031>>>            End_Object
85032>>>            
85032>>>            Object oMenuItem3 is a cCJMenuItem
85034>>>                Set psCaption to "Delete"
85035>>>                Set psImage to "ActionDeleteRecord.ico"
85036>>>                Procedure OnExecute Variant vCommandBarControl
85039>>>                End_Procedure
85040>>>            End_Object
85041>>>
85041>>>        End_Object
85042>>>        // Binds OnDropDown to this menu
85042>>>        Set phoButtonPopup to oButtonMenu 
85043>>>
85043>>>    End_Object
85044>>>
85044>>>    // this is split button (Vista or greater required), where OnClick and
85044>>>    // OnDropDown are two events. OnDropDown automatically invokes phoButtonPopup
85044>>>    
85044>>>    Object oSplitButton is a cSplitButton
85046>>>        Set Size to 14 53
85047>>>        Set Location to 65 76
85048>>>        Set Label to 'Save'
85049>>>        Set psImage to "ActionSaveRecord.ico"
85050>>>    
85050>>>        Procedure OnClick
85053>>>        End_Procedure
85054>>>        
85054>>>        Object oButtonMenu is a cCJContextMenu
85056>>>            
85056>>>            Object oMenuItem1 is a cCJMenuItem
85058>>>                Set psCaption to "Set to Save"
85059>>>                Procedure OnExecute Variant vCommandBarControl
85062>>>                    Delegate Set label to "Save"
85064>>>                    Delegate Set psImage to "ActionSaveRecord.ico"
85066>>>                End_Procedure
85067>>>            End_Object
85068>>>            
85068>>>            Object oMenuItem2 is a cCJMenuItem
85070>>>                Set psCaption to "Set to Clear"
85071>>>                Procedure OnExecute Variant vCommandBarControl
85074>>>                    Delegate Set label  to "Clear"
85076>>>                    Delegate Set psImage to  "ActionClear.ico"
85078>>>                End_Procedure
85079>>>            End_Object
85080>>>            
85080>>>            Object oMenuItem3 is a cCJMenuItem
85082>>>                Set psCaption to "Set to Delete"
85083>>>                Procedure OnExecute Variant vCommandBarControl
85086>>>                    Delegate Set label  to "Delete"
85088>>>                    Delegate Set psImage to  "ActionDeleteRecord.ico"
85090>>>                End_Procedure
85091>>>            End_Object
85092>>>
85092>>>            Object oMenuItem4 is a cCJMenuItem
85094>>>                Set psCaption to "Set to Select"
85095>>>                Procedure OnExecute Variant vCommandBarControl
85098>>>                    Delegate Set label  to "Select"
85100>>>                    Delegate Set psImage to  ""
85102>>>                End_Procedure
85103>>>            End_Object
85104>>>
85104>>>        End_Object
85105>>>
85105>>>        Set phoButtonPopup to oButtonMenu 
85106>>>
85106>>>    End_Object
85107>>>
85107>>>    Object oTextBox2 is a TextBox
85109>>>        Set Size to 9 115
85110>>>        Set Location to 51 166
85111>>>        Set Label to "Button using an external image list"
85112>>>    End_Object
85113>>>    
85113>>>    // button have 6 image states. We will provide a different image
85113>>>    // for each of these states
85113>>>    Object oImageList is a cImageList32
85115>>>        Set piMaxImages to 6
85116>>>        Set piImageHeight to 16
85117>>>        Set piImageWidth to 16
85118>>>        Procedure OnCreate
85121>>>            Integer iIndex
85121>>>            // for buttons either create 1 image or 6
85121>>>            // if 6, they are normal, hot, pressed, disabled, defaulted, stylus-hot
85121>>>            Get AddImage "ClosFold.bmp" to iIndex
85122>>>            Get AddImage "OpenFold.bmp" to iIndex
85123>>>            Get AddImage "OpenFold.bmp" to iIndex
85124>>>            Get AddImage "ClosFold.bmp" to iIndex
85125>>>            Get AddImage "OpenFold.bmp" to iIndex
85126>>>            Get AddImage "ClosFold.bmp" to iIndex
85127>>>        End_Procedure
85128>>>    End_Object
85129>>>
85129>>>    // this attaches to an external imageist with 6 images. Because this
85129>>>    // uses an external imagelist you will not see the image modeled in the Studio
85129>>>    Object oMultiImageButton is a Button
85131>>>        Set Location to 65 194
85132>>>        Set phoExternalButtonImageList to oImageList
85133>>>        Set peImageAlign to Button_ImageList_Align_Center
85134>>>        
85134>>>        Procedure OnClick
85137>>>        End_Procedure
85138>>>
85138>>>    End_Object
85139>>>
85139>>>    // CommandLinkButtons work with Vista or greater required
85139>>>    Object oCommandLinkButtonGroup is a Group
85141>>>        Set Size to 115 258
85142>>>        Set Location to 90 10
85143>>>        Set Label to "CommandLink Buttons"
85144>>>
85144>>>        Object oCommandLinkStandard is a cCommandLinkButton
85146>>>            Set Location to 11 9
85147>>>            Set Size to 34 239
85148>>>            Set Label to 'CommandLink Choice 1'
85149>>>            Set psNote to "This is a normal command link button with the standard command link image"
85150>>>    
85150>>>            Procedure OnClick
85153>>>            End_Procedure
85154>>>            
85154>>>        End_Object
85155>>>
85155>>>        Object oCommandLinkShield is a cCommandLinkButton
85157>>>            Set Location to 44 9
85158>>>            Set Size to 34 239
85159>>>            Set Label to 'CommandLink Choice 2'
85160>>>            Set psNote to "This is a command link button using the Windows elevated shield image"
85161>>>            Set pbShield to True
85162>>>    
85162>>>            Procedure OnClick
85165>>>            End_Procedure
85166>>>            
85166>>>        End_Object
85167>>>
85167>>>        Object oCommandLinkCustom is a cCommandLinkButton
85169>>>            Set Location to 78 9
85170>>>            Set Size to 34 239
85171>>>            Set Label to 'CommandLink Choice 3'
85172>>>            Set psNote to "This is a command link with a custom image. This image just happens to be larger"
85173>>>            Set psImage to "DF32.bmp"
85174>>>            Set piImageSize to 48
85175>>>
85175>>>            Procedure OnClick
85178>>>            End_Procedure
85179>>>            
85179>>>        End_Object
85180>>>
85180>>>    End_Object
85181>>>
85181>>>
85181>>>Cd_End_Object
85183>>>>
85183>              Use DemoCalendarControl.vw
Including file: DemoCalendarControl.vw    (C:\Test\Order Entry git\AppSrc\DemoCalendarControl.vw)
85183>>>Use Windows.pkg
85183>>>Use DFClient.pkg
85183>>>
85183>>>Use MonthCalendarPrompt.dg
85183>>>Use cTextEdit.pkg
85183>>>
85183>>>Activate_View Activate_oDemoCalendarControl for oDemoCalendarControl
85193>>>>
85193>>>Object oDemoCalendarControl is a dbView
85195>>>
85195>>>    Set Border_Style to Border_Thick
85196>>>    Set Size to 148 196
85197>>>    Set Location to 2 2
85198>>>    Set Label to "Calendar Control Sample"
85199>>>
85199>>>    // Simplest case example, just set the prompt_object
85199>>>    Object oDateFormTest is a Form
85201>>>        Set Location to 16 89
85202>>>        Set Size to 13 66
85203>>>        Set Label to "Date Select Test:"
85204>>>
85204>>>        Set Prompt_Object to oMonthCalendarPrompt
85205>>>        Set Prompt_Button_Mode to PB_PromptOn
85206>>>
85206>>>    End_Object
85207>>>
85207>>>    Object oDateRangeGroup is a Group
85209>>>
85209>>>        Set Label to "Selecting Date Range"
85210>>>        Set Size to 74 165
85211>>>        Set Location to 39 23
85212>>>        
85212>>>        Object oFromDate is a Form
85214>>>            Set Label to "From:"
85215>>>            Set Location to 29 66
85216>>>            Set Size to 13 66
85217>>>            Set Prompt_Button_Mode to PB_PromptOn
85218>>>            Set Prompt_Object to oMonthCalendarPrompt
85219>>>            
85219>>>            Procedure Prompt_Callback Integer hoPrompt
85222>>>                Send DateRangeCallback hoPrompt
85223>>>            End_Procedure
85224>>>        End_Object
85225>>>        
85225>>>        Object oToDate is a Form
85227>>>            Set Label to "To:"
85228>>>            Set Location to 50 66
85229>>>            Set Size to 13 66
85230>>>            Set Prompt_Button_Mode to PB_PromptOn
85231>>>            
85231>>>            Procedure Prompt
85234>>>                Send Popup to oMonthCalendarPrompt
85235>>>            End_Procedure
85236>>>            
85236>>>            Procedure Prompt_Callback Integer hoPrompt
85239>>>                Send DateRangeCallback hoPrompt
85240>>>            End_Procedure
85241>>>        End_Object
85242>>>
85242>>>              Object oTextBox1 is a TextBox
85244>>>                        Set Size to 10 154
85245>>>                        Set Location to 11 3
85246>>>                        Set Label to "(select initial date and drag the mouse to end date)"
85247>>>              End_Object
85248>>>        
85248>>>        
85248>>>        // Since these two date forms are using the same logic, we delegate to here
85248>>>        // and let the group handle the inititalization and update
85248>>>        
85248>>>        // this is the callback set in DateRangeCallback
85248>>>        Procedure DoDateUpdate Integer hoSel Date dDate1 Date dDate2
85251>>>            Set Value of oFromDate to dDate1
85252>>>            Set Value of oToDate to dDate2
85253>>>        End_Procedure
85254>>>        
85254>>>        // This is the first callback. Make this multi-select, 
85254>>>        // no click select, show week numbers, don't show today stuff.   
85254>>>        // also set the callback to call DoDateUpdate (which will delegate to here)
85254>>>        Procedure DateRangeCallback Integer hoPrompt
85257>>>            Date dDate1 dDate2
85257>>>            
85257>>>            Set pbMultiSelect of hoPrompt to True
85258>>>            Set peMouseSelectOk of hoPrompt to msoNone
85259>>>            Set phmPromptUpdateCallback of hoPrompt to (RefProc(DoDateUpdate))
85260>>>            
85260>>>            Set pbWeekNumbers of hoPrompt to True
85261>>>            Set pbNoToday of hoPrompt to True
85262>>>            Set pbNoTodayCircle of hoPrompt to True
85263>>>            
85263>>>            Get Value of oFromDate to dDate1
85264>>>            Get Value of oToDate to dDate2
85265>>>            Set pdSeedValue of hoPrompt to dDate1 
85266>>>            Set pdSeedValue2 of hoPrompt to dDate2 
85267>>>        End_Procedure
85268>>>    End_Object
85269>>>
85269>>>    Object oDateTextBox is a TextBox
85271>>>        Set Size to 10 34
85272>>>        Set Location to 123 56
85273>>>        Set Label to '1/30/2016'
85274>>>        Procedure Activating 
85277>>>            Set Label to (Date(CurrentDateTime()))
85278>>>            Forward Send Activating
85280>>>        End_Procedure
85281>>>    End_Object
85282>>>
85282>>>    Object oButton1 is a Button
85284>>>        Set Location to 121 100
85285>>>        Set Label to 'Change'
85286>>>        
85286>>>        Procedure Prompt_Callback Integer hoPrompt
85289>>>            Date dDate
85289>>>            Get Value of oDateTextBox to dDate
85290>>>            Set peUpdateMode of hoPrompt to umPromptCustom
85291>>>            Set pdSeedValue of hoPrompt to dDate
85292>>>            Set phmPromptUpdateCallback of hoPrompt to (RefProc(DoDateUpdate))
85293>>>        End_Procedure
85294>>>
85294>>>        Procedure DoDateUpdate Integer hoSel Date dDate1 Date dDate2
85297>>>            Set Value of oDateTextBox to dDate1
85298>>>        End_Procedure
85299>>>    
85299>>>        Procedure OnClick
85302>>>            Send Popup of oMonthCalendarPrompt
85303>>>        End_Procedure
85304>>>    
85304>>>    End_Object
85305>>>    
85305>>>End_Object
85306>        Use DemoParentCombos.vw
Including file: DemoParentCombos.vw    (C:\Test\Order Entry git\AppSrc\DemoParentCombos.vw)
85306>>>Use dfClient.pkg
85306>>>Use DataDict.pkg
85306>>>Use dfEntry.pkg
85306>>>Use dfSpnEnt.pkg
85306>>>Use dfCEntry.pkg
85306>>>Use dfTable.pkg
85306>>>Use Windows.pkg
85306>>>Use Vendor.DD
85306>>>Use Invt.DD
85306>>>Use Customer.DD
85306>>>Use SalesP.DD
85306>>>Use OrderHea.DD
85306>>>Use OrderDtl.DD
85306>>>Use cDbCJGrid.pkg
85306>>>Use cCJGridColumnRowIndicator.pkg
85306>>>Use DbParentCombo.pkg
Including file: dbParentCombo.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\dbParentCombo.pkg)
85306>>>>>Use Dfcentry.pkg
85306>>>>>
85306>>>>>// Combo for parents. 
85306>>>>>Class dbParentCombo is a dbComboForm
85307>>>>>    Procedure Construct_Object
85309>>>>>        Forward Send Construct_Object
85311>>>>>        
85311>>>>>        // Show a psEmptyItemDescription. If Entry_State is false, you probably
85311>>>>>        // want this false as well
85311>>>>>        Property Boolean pbAddEmptyItem True        
85312>>>>>        Property String psEmptyItemDescription DD_BLANK_CODE_DESCRIPTION
85313>>>>>        
85313>>>>>        // if true, the list is refilled each time the combo takes the focus
85313>>>>>        // making it more dynamic. You can manually refill a list sending ComboRefill
85313>>>>>        Property Boolean pbRefillOnFocus False
85314>>>>>        
85314>>>>>        // object maintained. If it detects that the list does not contain a parent it
85314>>>>>        // will set this true to force a refill on the next focus 
85314>>>>>        Property Boolean pbNeedsRefill False
85315>>>>>        
85315>>>>>        // make sure these properties are what we want
85315>>>>>        Set Code_Display_Mode to CB_Code_Display_Description
85316>>>>>        Set Undefined_Display_Mode to CB_ERR_UPDATE_WINDOW_VALUE // don't change
85317>>>>>        Set Undefined_Save_Mode    to CB_ERR_UPDATE_WINDOW_VALUE // don't change
85318>>>>>        
85318>>>>>        // in general this will work best with a non-editable combo
85318>>>>>        // but the other style works as well
85318>>>>>        Set Entry_State 0 to False
85319>>>>>        // its ok to change this - when default it displays in Combo_Index order
85319>>>>>        Set Combo_Sort_State to True
85320>>>>>    End_Procedure
85321>>>>>    
85321>>>>>    // augment to fill list when paged (instead of doing earlier)
85321>>>>>    Procedure Page_Object Boolean bPage
85323>>>>>        If bPage Begin
85325>>>>>            Send ComboRefill
85326>>>>>        End
85326>>>>>>
85326>>>>>        Forward Send Page_Object bPage
85328>>>>>    End_Procedure
85329>>>>>
85329>>>>>    
85329>>>>>    // Augmentation to handle optional combo refill on set focus
85329>>>>>    Procedure Notify_Focus_Change Integer Fg
85331>>>>>        Boolean bReFillOnFocus bNeedsRefill
85331>>>>>        Forward Send Notify_Focus_Change Fg
85333>>>>>        If Fg Begin
85335>>>>>            Get pbNeedsRefill to bNeedsRefill
85336>>>>>            Get pbRefillOnFocus to bReFillOnFocus
85337>>>>>            If (bRefillOnFocus or bNeedsRefill) Begin
85339>>>>>                Send ComboRefill
85340>>>>>            End
85340>>>>>>
85340>>>>>        End
85340>>>>>>
85340>>>>>    End_Procedure
85341>>>>>    
85341>>>>>    // Refill combo list, while maintaining current value
85341>>>>>    Procedure ComboRefill
85343>>>>>        String sValue
85343>>>>>        Set Deferred_State to True
85344>>>>>        Get Value 0 to sValue
85345>>>>>        Send Combo_Fill_List
85346>>>>>        Set Deferred_State to False
85347>>>>>        Set Combo_data_object to (Combo_Data_Object(Self))
85348>>>>>        Set Local_Value 0 to sValue
85349>>>>>    End_Procedure
85350>>>>>    
85350>>>>>    // Augment to  init and fill the list with all parents.
85350>>>>>    Procedure Combo_Fill_List
85352>>>>>        Handle hoServer hoDD
85352>>>>>        Integer iFile iField iIndex
85352>>>>>        String sDescription sData
85352>>>>>        Boolean bAddEmptyItem
85352>>>>>        Boolean bOldRelate bNeedsRelate
85352>>>>>        RowID riID
85352>>>>>        
85352>>>>>        Get Server to hoServer
85353>>>>>        Get Data_File to iFile
85354>>>>>        Get Data_Field to iField
85355>>>>>        Get Combo_Index to iIndex
85356>>>>>        Get pbAddEmptyItem to bAddEmptyItem
85357>>>>>        Send Combo_Delete_Data
85358>>>>>        
85358>>>>>        If (hoServer and iFile) Begin
85360>>>>>    
85360>>>>>            Get Data_Set of hoServer iFile to hoDD
85361>>>>>            
85361>>>>>            If (hoDD) Begin
85363>>>>>                Set Relational_State to True
85364>>>>>                If (bAddEmptyItem) Begin
85366>>>>>                    Get psEmptyItemDescription to sDescription
85367>>>>>                    Send Combo_Add_Blank_Item sDescription
85368>>>>>                    Set Data_Only_State to True // this got cleared - we don't care about dummy item
85369>>>>>                End
85369>>>>>>
85369>>>>>                
85369>>>>>                If (iIndex <= 0) Begin
85371>>>>>                    Get_Attribute DF_FIELD_INDEX of iFile iField to iIndex
85374>>>>>                End
85374>>>>>>
85374>>>>>                // optimize relates. Only do it if needed
85374>>>>>                Get No_Relate_State of hoDD to bOldRelate
85375>>>>>                Get DDOConstraintNeedsRelate of hoDD iIndex to bNeedsRelate
85376>>>>>                Set No_Relate_State of hoDD to (not(bNeedsRelate))
85377>>>>>                Send Request_Read of hoDD FIRST_RECORD iFile iIndex
85378>>>>>                While (Found)
85382>>>>>                    Send AddParentItemFromRecord  
85383>>>>>                    Send Locate_Next of hoDD
85384>>>>>                 Loop
85385>>>>>>
85385>>>>>                Set No_Relate_State of hoDD to bOldRelate
85386>>>>>            End
85386>>>>>>
85386>>>>>        End
85386>>>>>>
85386>>>>>        If (not(hoDD)) Begin
85388>>>>>            Error DFERR_PROGRAM "Invalid use of DbParentCombo"            
85389>>>>>>
85389>>>>>        End
85389>>>>>>
85389>>>>>        Set pbNeedsRefill to False
85390>>>>>    End_Procedure
85391>>>>>    
85391>>>>>    Procedure AddParentItemFromRecord
85393>>>>>        Integer iFile iField iItems
85393>>>>>        String sData sDescription
85393>>>>>        RowID riID
85393>>>>>        
85393>>>>>        Get Data_File to iFile
85394>>>>>        Get Data_Field to iField
85395>>>>>        Move (GetRowID(iFile)) to riID
85396>>>>>        Get_Field_Value iFile iField to sData
85399>>>>>        Move (Trim(sData)) to sData 
85400>>>>>        Move sData to sDescription
85401>>>>>        // user hook to customize the combo description
85401>>>>>        Send OnDefineDescription (&sDescription)
85402>>>>>        Get Combo_Item_Count to iItems
85403>>>>>        Send ComboFillItem iItems sData sDescription iFile riID
85404>>>>>        Increment iItems
85405>>>>>    End_Procedure
85406>>>>>    
85406>>>>>    // Hook to customize a combo item's description.
85406>>>>>    Procedure OnDefineDescription String ByRef sDescription
85408>>>>>    End_Procedure
85409>>>>>    
85409>>>>>    // augment to test that we found a match and if not add it to the list
85409>>>>>    Procedure Display_Description String DataVal
85411>>>>>        String sValue
85411>>>>>        Integer iItem
85411>>>>>        Move (Trim(DataVal)) to DataVal // must be trimmed for Combo_Item_Matching below
85412>>>>>        Get Data_to_Description DataVal to sValue
85413>>>>>        // Test that the combo item exists. We assume that a missing combo item means the list is out of date.
85413>>>>>        // If so, add the missing item and mark that we probably need to do a refill next chance we get.
85413>>>>>        If (DataVal<>"") Begin
85415>>>>>            Get Combo_Item_Matching sValue to iItem
85416>>>>>            If (iItem=-1) Begin
85418>>>>>                Send AddParentItemFromRecord
85419>>>>>                Set pbNeedsRefill to True
85420>>>>>                // now it should work
85420>>>>>                Get Data_to_Description DataVal to sValue
85421>>>>>            End
85421>>>>>>
85421>>>>>        End
85421>>>>>>
85421>>>>>        Set Value item 0 to sValue
85422>>>>>    End_Procedure
85423>>>>>    
85423>>>>>    // cancel so the list is not built upon attach to DDO. Attach upon activation
85423>>>>>    Procedure combo_initialize_list
85425>>>>>    End_Procedure
85426>>>>>    
85426>>>>>    
85426>>>>>End_Class
85427>>>Use MonthCalendarPrompt.dg
85427>>>
85427>>>Activate_View Activate_oDemoParentCombos for oDemoParentCombos
85437>>>>
85437>>>Object oDemoParentCombos is a dbView
85439>>>    Set Border_Style to Border_Thick
85440>>>    Set Maximize_Icon to True
85441>>>    Set Label to "Parent Combo Demo"
85442>>>    Set Location to 2 3
85443>>>    Set Size to 174 383
85444>>>    Set piMinSize to 174 383
85445>>>    
85445>>>
85445>>>    Object Vendor_DD is a Vendor_DataDictionary
85447>>>    End_Object    // Vendor_DD
85448>>>
85448>>>    Object Invt_DD is a Invt_DataDictionary
85450>>>        Set DDO_Server to Vendor_DD
85451>>>    End_Object    // Invt_DD
85452>>>
85452>>>    Object Customer_DD is a Customer_DataDictionary
85454>>>    End_Object    // Customer_DD
85455>>>
85455>>>    Object SalesP_DD is a Salesp_DataDictionary
85457>>>    End_Object    // SalesP_DD
85458>>>
85458>>>    Object OrderHea_DD is a OrderHea_DataDictionary
85460>>>        Set DDO_Server to Customer_DD
85461>>>        Set DDO_Server to SalesP_DD
85462>>>        
85462>>>        // this lets you save a new OrderHea from within OrderDtl.
85462>>>        Set Allow_Foreign_New_Save_State to True
85463>>>        
85463>>>    End_Object    // OrderHea_DD
85464>>>    
85464>>>    Object OrderDtl_DD is a OrderDtl_DataDictionary
85466>>>        Set DDO_Server to OrderHea_DD
85467>>>        Set DDO_Server to Invt_DD
85468>>>        Set Constrain_File to OrderHea.File_Number
85469>>>    End_Object    // OrderDtl_DD
85470>>>
85470>>>    Set Main_DD to OrderHea_DD
85471>>>    Set Server to OrderHea_DD
85472>>>    
85472>>>    Object oDbContainer3d1 is a dbContainer3d
85474>>>        Set Size to 85 377
85475>>>        Set Location to 2 3
85476>>>        Set peAnchors to anTopLeftRight
85477>>>        
85477>>>        
85477>>>        Object oOrderHea_Order_Number is a dbForm
85479>>>            Entry_Item OrderHea.Order_Number
85480>>>            Set Label to "Order Number:"
85481>>>            Set Size to 13 42
85482>>>            Set Location to 4 63
85483>>>            Set peAnchors to anTopLeft
85484>>>            Set Label_Col_Offset to 2
85485>>>            Set Label_Justification_Mode to jMode_Right
85486>>>            
85486>>>        End_Object    // oOrderHea_Order_Number
85487>>>
85487>>>        Object oOrderHea_Customer_Number is a DbParentCombo
85489>>>            Entry_Item Customer.Customer_Number
85490>>>            Set Label to "Customer Number:"
85491>>>            Set Size to 13 42
85492>>>            Set Location to 4 201
85493>>>            Set peAnchors to anTopRight
85494>>>            Set Label_Col_Offset to 2
85495>>>            Set Label_Justification_Mode to jMode_Right
85496>>>            Set psEmptyItemDescription to "???"
85497>>>            // with numbers, not sorting may be preferred
85497>>>            Set Combo_Sort_State to False
85498>>>            // anytime this takes the focus, refill the combo. If the list is very
85498>>>            // large you may not want this. However, if the list is very large you
85498>>>            // may not want parent combos.
85498>>>            Set pbRefillOnFocus to True
85499>>>        End_Object
85500>>>
85500>>>        Object oOrderHea_Order_Date is a dbForm
85502>>>            Entry_Item OrderHea.Order_Date
85503>>>            Set Label to "Order Date:"
85504>>>            Set Size to 13 67
85505>>>            Set Location to 4 299
85506>>>            Set peAnchors to anTopRight
85507>>>            Set Label_Col_Offset to 2
85508>>>            Set Label_Justification_Mode to jMode_Right
85509>>>            
85509>>>            Set Prompt_Object to oMonthCalendarPrompt
85510>>>            Set Prompt_Button_Mode to PB_PromptOn
85511>>>        End_Object    // oOrderHea_Order_Date
85512>>>
85512>>>        Object oCustomer_Name is a dbForm
85514>>>            Entry_Item Customer.Name
85515>>>            Set Label to "Customer Name:"
85516>>>            Set Size to 13 180
85517>>>            Set Location to 18 63
85518>>>            Set peAnchors to anTopLeftRight
85519>>>            Set Label_Col_Offset to 2
85520>>>            Set Label_Justification_Mode to jMode_Right
85521>>>        End_Object    // oCustomer_Name
85522>>>
85522>>>        Object oCustomer_Address is a dbForm
85524>>>            Entry_Item Customer.Address
85525>>>            Set Label to "Street Address:"
85526>>>            Set Size to 13 180
85527>>>            Set Location to 34 63
85528>>>            Set peAnchors to anTopLeftRight
85529>>>            Set Label_Col_Offset to 2
85530>>>            Set Label_Justification_Mode to jMode_Right
85531>>>        End_Object    // oCustomer_Address
85532>>>
85532>>>        Object oCustomer_City is a dbForm
85534>>>            Entry_Item Customer.City
85535>>>            Set Label to "City/State/Zip:"
85536>>>            Set Size to 13 84
85537>>>            Set Location to 49 63
85538>>>            Set peAnchors to anTopLeftRight
85539>>>            Set Label_Col_Offset to 2
85540>>>            Set Label_Justification_Mode to jMode_Right
85541>>>        End_Object    // oCustomer_City
85542>>>
85542>>>        Object oCustomer_State is a dbForm
85544>>>            Entry_Item Customer.State
85545>>>            Set Size to 13 20
85546>>>            Set Location to 49 155
85547>>>            Set peAnchors to anTopRight
85548>>>        End_Object    // oCustomer_State
85549>>>
85549>>>        Object oCustomer_Zip is a dbForm
85551>>>            Entry_Item Customer.Zip
85552>>>            Set Size to 13 60
85553>>>            Set Location to 49 183
85554>>>            Set peAnchors to anTopRight
85555>>>        End_Object    // oCustomer_Zip
85556>>>
85556>>>        Object oOrderHea_Ordered_By is a dbForm
85558>>>            Entry_Item OrderHea.Ordered_By
85559>>>            Set Label to "Ordered By:"
85560>>>            Set Size to 13 67
85561>>>            Set Location to 34 299
85562>>>            Set peAnchors to anTopRight
85563>>>            Set Label_Col_Offset to 2
85564>>>            Set Label_Justification_Mode to jMode_Right
85565>>>        End_Object    // oOrderHea_Ordered_By
85566>>>
85566>>>        Object oOrderHea_Salesperson_ID is a DbParentCombo
85568>>>            Entry_Item Salesp.Id
85569>>>            Set Label to "Sold by:"
85570>>>            Set Size to 11 90
85571>>>            Set Location to 49 276
85572>>>            Set peAnchors to anTopRight
85573>>>            Set Label_Col_Offset to 2
85574>>>            Set Label_Justification_Mode to jMode_Right
85575>>>            Set psEmptyItemDescription to "<none>"
85576>>>            
85576>>>            Procedure OnDefineDescription String ByRef sDescription
85579>>>                Move (trim(Salesp.ID) + " - " * SalesP.Name) to sDescription
85580>>>            End_Procedure
85581>>>        End_Object    // oOrderHea_Salesperson_ID
85582>>>
85582>>>        Object oOrderHea_Terms is a dbComboForm
85584>>>            Entry_Item OrderHea.Terms
85585>>>            Set Label to "Terms:"
85586>>>            Set Size to 13 85
85587>>>            Set Location to 64 63
85588>>>            Set peAnchors to anTopLeft
85589>>>            Set Form_Border to 0
85590>>>            Set Label_Col_Offset to 2
85591>>>            Set Label_Justification_Mode to jMode_Right
85592>>>            Set Entry_State to False
85593>>>
85593>>>        End_Object    // oOrderHea_Terms
85594>>>
85594>>>        Object oOrderHea_Ship_Via is a dbComboForm
85596>>>            Entry_Item OrderHea.Ship_Via
85597>>>            Set Label to "Ship Via:"
85598>>>            Set Size to 13 103
85599>>>            Set Location to 64 183
85600>>>            Set peAnchors to anTopRight
85601>>>            Set Form_Border to 0
85602>>>            Set Label_Col_Offset to 2
85603>>>            Set Label_Justification_Mode to jMode_Right
85604>>>            Set Entry_State to False
85605>>>            
85605>>>
85605>>>        End_Object    // oOrderHea_Ship_Via
85606>>>
85606>>>    End_Object    // oDbContainer3d1
85607>>>
85607>>>    Object oOrderDtl_Grid is a cDbCJGrid
85609>>>        Set Server to OrderDtl_DD
85610>>>        Set Ordering to 1
85611>>>        Set Size to 63 377
85612>>>        Set Location to 90 3
85613>>>        Set peAnchors to anAll
85614>>>        Set pbAllowInsertRow to False
85615>>>        Set pbRestoreLayout to False
85616>>>        Set psLayoutSection to "OrderView_oOrderDtl_Grid2"
85617>>>        Set piLayoutBuild to 6
85618>>>        Set pbHeaderPrompts to True
85619>>>
85619>>>        On_Key Key_F11 Send Request_InsertRow
85620>>>
85620>>>        Object oMark is a cCJGridColumnRowIndicator
85622>>>        End_Object
85623>>>        
85623>>>        Object oInvt_Item_ID is a cDbCJGridColumn
85625>>>            Entry_Item Invt.Item_ID
85626>>>            Set piWidth to 91
85627>>>            Set psCaption to "Item ID"
85628>>>            Set psImage to "ActionPrompt.ico"
85629>>>        End_Object
85630>>>
85630>>>        Object oInvt_Description is a cDbCJGridColumn
85632>>>            Entry_Item Invt.Description
85633>>>            Set piWidth to 213
85634>>>            Set psCaption to "Description"
85635>>>        End_Object
85636>>>
85636>>>        Object oInvt_Unit_Price is a cDbCJGridColumn
85638>>>            Entry_Item Invt.Unit_Price
85639>>>            Set piWidth to 53
85640>>>            Set psCaption to "Unit Price"
85641>>>        End_Object
85642>>>
85642>>>        Object oOrderDtl_Qty_Ordered is a cDbCJGridColumn
85644>>>            Entry_Item OrderDtl.Qty_Ordered
85645>>>            Set piWidth to 50
85646>>>            Set psCaption to "Quantity"
85647>>>        End_Object
85648>>>
85648>>>        Object oOrderDtl_Price is a cDbCJGridColumn
85650>>>            Entry_Item OrderDtl.Price
85651>>>            Set piWidth to 62
85652>>>            Set psCaption to "Price"
85653>>>        End_Object
85654>>>
85654>>>        Object oOrderDtl_Extended_Price is a cDbCJGridColumn
85656>>>            Entry_Item OrderDtl.Extended_Price
85657>>>            Set piWidth to 81
85658>>>            Set psCaption to "Total"
85659>>>        End_Object
85660>>>        
85660>>>    End_Object    // oOrderDtl_Grid
85661>>>
85661>>>    Object oOrderHea_Order_Total is a dbForm
85663>>>        Entry_Item OrderHea.Order_Total
85664>>>        Set Label to "Order Total:"
85665>>>        Set Size to 13 60
85666>>>        Set Location to 156 307
85667>>>        Set peAnchors to anBottomRight
85668>>>        Set Label_Col_Offset to 3
85669>>>        Set Label_Justification_Mode to jMode_Right
85670>>>    End_Object    // oOrderHea_Order_Total
85671>>>
85671>>>    Object oPrintBtn is a Button
85673>>>        Set Label to "Print Order"
85674>>>        Set Location to 156 3
85675>>>        Set peAnchors to anBottomLeft
85676>>>        Set psToolTip to "Print preview of current order"
85677>>>
85677>>>        Procedure OnClick
85680>>>            Delegate Send PrintCurrentOrder // defined in view object
85682>>>        End_Procedure  // OnClick
85683>>>        
85683>>>    End_Object    // oPrintBtn
85684>>>
85684>>>
85684>>>    // Change:   Create custom confirmation messages for save and delete
85684>>>    //           We must create the new functions and assign verify messages
85684>>>    //           to them.
85684>>>    Function Confirm_Delete_Order Returns Integer
85687>>>        Integer iRetVal
85687>>>        Get Confirm "Delete Entire Order?" to iRetVal
85688>>>        Function_Return iRetVal
85689>>>    End_Function
85690>>>    
85690>>>    // Only confirm on the saving of new records
85690>>>    Function Confirm_Save_Order Returns Integer
85693>>>        Integer iNoSave iSrvr
85693>>>        Boolean bOld
85693>>>        Get Server to iSrvr
85694>>>        Get HasRecord of iSrvr to bOld
85695>>>        If not bOld Begin
85697>>>            Get Confirm "Save this NEW order header?" to iNoSave
85698>>>        End
85698>>>>
85698>>>        Function_Return iNoSave
85699>>>    End_Function
85700>>>    
85700>>>    // Define alternate confirmation Messages
85700>>>    Set Verify_Save_MSG       to (RefFunc(Confirm_Save_Order))
85701>>>    Set Verify_Delete_MSG     to (RefFunc(Confirm_Delete_Order))
85702>>>    Set Auto_Clear_DEO_State  to False // don't clear Header on save
85703>>>    
85703>>>    
85703>>>    // print the current order. This message will be sent
85703>>>    // by the print button
85703>>>    Procedure PrintCurrentOrder
85706>>>        Integer hDD iNum
85706>>>        Get Server to hDD // this will be the OrderHea DD
85707>>>        If (HasRecord(hDD)) Begin // only do this if record exists
85709>>>            Get Field_Current_Value of hDD Field OrderHea.Order_Number to iNum
85710>>>//            Send PrintOrder of oOrder_Report iNum
85710>>>            Send Info_Box "This is just a stub and this invoice is not actually being printed" ("Print Order " + String(iNum))
85711>>>        End
85711>>>>
85711>>>    End_Procedure
85712>>>    
85712>>>    // refresh is sent to containers. We will use that to control the print button and only
85712>>>    // enable it when an order exists
85712>>>    Procedure Refresh Integer eMode
85715>>>        Boolean bRec
85715>>>        Handle hoServer
85715>>>        Get Server to hoServer
85716>>>        Get HasRecord of hoServer to bRec
85717>>>        Set Enabled_State of oPrintBtn to bRec
85718>>>    End_Procedure
85719>>>
85719>>>End_Object
85720>    
85720>        Procedure Activate_About
85723>            Send DoAbout "Order Entry Sample Application" "18.2.1.0" "Copyright (c) 2016 Data Access Corporation" "Data Access Worldwide" ""
85724>        End_Procedure
85725>    
85725>    End_Object
85726>
85726>
85726>End_Object
85727>
85727>// open Order Entry view on application startup
85727>Send Activate_oOrderEntryView of (oClientArea(oMain))
85728>Start_UI
85729>
Summary
Memory Available: 2147483646
Total Warnings : 0
Total Errors   : 0
Total Symbols  : 47271
Total Resources: 0
Total Commands : 85728
Total Windows  : 5
Total Pages    : 4
Static Data    : 536625
Message area   : 609332
Total Blocks   : 30616
