Compiling Program: C:\Test\Order Entry git\AppSrc\Order.src
Memory Available: 2147483646
1>Use OrderPrecompile.pkg
Using pre-compiled package ORDERPRECOMPILE.PKG
Including file: OrderPrecompile.pkd    (C:\Test\Order Entry git\AppSrc\OrderPrecompile.pkd)
75734>
75734>Use DfAllent.pkg
75734>Use cCJStandardCommandBarSystem.pkg
75734>Use cToolTipController.pkg
75734>Use cCJCommandBarSystem.pkg
75734>
75734>Object oHtmlHelp is a cHtmlHelp
75736>End_Object
75737>
75737>Object oApplication is a cApplication
75739>    Set psCompany to "Data Access Worldwide"
75740>    Set psProduct to "DataFlex Examples"
75741>    Set psVersion to "18.2"
75742>    Set psProgram to "Order"
75743>    Set psHelpFile to "Examples.chm"
75744>    Set peHelpType to htHtmlHelp
75745>End_Object
75746>
75746>Object oToolTipController is a cToolTipController
75748>    Move Self to ghoToolTipController
75749>End_Object
75750>
75750>Use oEditContextMenu.pkg
Including file: oEditContextMenu.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\oEditContextMenu.pkg)
75750>>>Use cCJStandardMenuItemClasses.pkg
75750>>>
75750>>>Object oEditContextMenu is a cCJContextMenu
75752>>>    
75752>>>    Move Self to Default_Form_Floating_Menu_ID
75753>>>    
75753>>>    Object oUndoMenuItem is a cCJUndoMenuItem
75755>>>    End_Object
75756>>>    
75756>>>    Object oCutMenuItem is a cCJCutMenuItem
75758>>>        Set pbControlBeginGroup to True
75759>>>    End_Object
75760>>>    
75760>>>    Object oCopyMenuItem is a cCJCopyMenuItem
75762>>>    End_Object
75763>>>
75763>>>    Object oPasteMenuItem is a cCJPasteMenuItem
75765>>>    End_Object
75766>>>
75766>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
75768>>>    End_Object
75769>>>
75769>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
75771>>>        Set pbControlBeginGroup to True
75772>>>    End_Object
75773>>>
75773>>>End_Object
75774>>>
75774>Use oDEOEditContextMenu17.pkg
Including file: oDEOEditContextMenu17.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\oDEOEditContextMenu17.pkg)
75774>>>Use Windows.pkg
75774>>>Use cCJStandardMenuItemClasses.pkg
75774>>>Use cCJDeoMenuItemClasses.pkg
75774>>>
75774>>>
75774>>>Object oDEOEditContextMenu17 is a cCJContextMenu
75776>>>    
75776>>>    Move Self to Default_dbFloating_Menu_ID
75777>>>    
75777>>>    Object oUndoMenuItem is a cCJUndoMenuItem
75779>>>    End_Object
75780>>>    
75780>>>    Object oCutMenuItem is a cCJCutMenuItem
75782>>>        Set pbControlBeginGroup to True
75783>>>    End_Object
75784>>>    
75784>>>    Object oCopyMenuItem is a cCJCopyMenuItem
75786>>>    End_Object
75787>>>
75787>>>    Object oPasteMenuItem is a cCJPasteMenuItem
75789>>>    End_Object
75790>>>
75790>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
75792>>>    End_Object
75793>>>
75793>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
75795>>>        Set pbControlBeginGroup to True
75796>>>    End_Object
75797>>>
75797>>>    Object oPromptMenuItem is a cCJPromptMenuItem
75799>>>        Set pbControlBeginGroup to True
75800>>>    End_Object
75801>>>
75801>>>    Object oFindNextMenu is a cCJFindNextMenuItem
75803>>>        Set pbControlBeginGroup to True
75804>>>    End_Object
75805>>>
75805>>>    Object oFindPreviousMenu is a cCJFindPreviousMenuItem
75807>>>    End_Object
75808>>>
75808>>>    Object oClearMenuItem is a cCJClearMenuItem
75810>>>        Set pbControlBeginGroup to True
75811>>>    End_Object
75812>>>
75812>>>    Object oClearAllMenu is a cCJClearAllMenuItem
75814>>>    End_Object
75815>>>
75815>>>    Object oSaveMenu is a cCJSaveMenuItem
75817>>>    End_Object
75818>>>    
75818>>>    Object oDeleteMenu is a cCJDeleteMenuItem
75820>>>    End_Object
75821>>>
75821>>>    Object oRememberitem is a cCJRememberFieldMenuItem
75823>>>        Set pbControlBeginGroup to True
75824>>>    End_Object
75825>>>
75825>>>    Object oRetainItem is a cCJRememberLastFieldMenuItem
75827>>>    End_Object
75828>>>
75828>>>    Object oUnRememberitem is a cCJUnRememberFieldMenuItem
75830>>>    End_Object
75831>>>
75831>>>    Object oCJClearAllDynamicDefaults is a cCJUnRememberFieldAllMenuItem
75833>>>    End_Object
75834>>>
75834>>>End_Object
75835>
75835>Object oMain is a Panel
75837>    Set Label to "Order Entry Sample Application In Git"
75838>    Set Location to 4 3
75839>    Set Size to 300 450
75840>
75840>    Object oCommandBarSystem is a cCJCommandBarSystem
75842>    
75842>        Set pbTimerUpdate to True
75843>    
75843>        Procedure OnCreateCommandBars
75846>            Handle hoOptions
75846>            Get OptionsObject to hoOptions
75847>            Forward Send OnCreateCommandBars
75849>        End_Procedure
75850>    
75850>        Object oMenuBar is a cCJMenuBar
75852>            
75852>            Object oFileMenu is a cCJMenuItem
75854>                
75854>                Set peControlType to xtpControlPopup          
75855>                Set psCaption   to "&File"
75856>                Set psDescription to "Find, Save, Delete, Clear information or quit this application."
75857>                Set psCategory to "Menus"
75858>    
75858>                Object oClearMenuItem is a cCJClearMenuItem
75860>                    Set pbAddToDesignerMenu to True
75861>                End_Object
75862>    
75862>                Object oClearAllMenu is a cCJClearAllMenuItem
75864>                    Set pbAddToDesignerMenu to True
75865>                End_Object
75866>    
75866>                Object oPromptMenuItem is a cCJPromptMenuItem
75868>                    Set pbAddToDesignerMenu to True
75869>                    Set pbControlBeginGroup to True
75870>                End_Object
75871>    
75871>                Object oFindMenuItem is a cCJFindMenuItem
75873>                    Set pbAddToDesignerMenu to True
75874>                    Set pbControlBeginGroup to True
75875>                End_Object
75876>    
75876>                Object oFindNextMenu is a cCJFindNextMenuItem
75878>                    Set pbAddToDesignerMenu to True
75879>                End_Object
75880>    
75880>                Object oFindPreviousMenu is a cCJFindPreviousMenuItem
75882>                    Set pbAddToDesignerMenu to True
75883>                End_Object
75884>    
75884>                Object oFindFirstMenu is a cCJFindFirstMenuItem
75886>                    Set pbAddToDesignerMenu to True
75887>                End_Object
75888>    
75888>                Object oFindLastMenu is a cCJFindLastMenuItem
75890>                    Set pbAddToDesignerMenu to True
75891>                End_Object
75892>    
75892>                Object oSaveMenuItem is a cCJSaveMenuItem
75894>                    Set pbAddToDesignerMenu to True
75895>                    Set pbControlBeginGroup to True
75896>                End_Object
75897>    
75897>                Object oDeleteMenuItem is a cCJDeleteMenuItem
75899>                    Set pbAddToDesignerMenu to True
75900>                End_Object
75901>    
75901>                Object oExitMenu is a cCJExitMenuItem
75903>                    Set pbControlBeginGroup to True
75904>                End_Object
75905>    
75905>            End_Object
75906>            
75906>            Object oViewMenu is a cCJMenuItem
75908>                
75908>                Set peControlType to xtpControlPopup
75909>                Set psCaption to "&View"
75910>                Set psToolTip to "View"
75911>                Set psDescription to "Available Views"
75912>    
75912>                Object oCustomerEntryViewMenuItem is a cCJMenuItem
75914>                    Set psCaption to "Customer Entry View"
75915>                    Set psShortcut to "Ctrl+1"
75916>                    Set psDescription to "Add, edit and delete Customer data."
75917>                    Set psToolTip to "Customer Entry View"
75918>                
75918>                    Procedure OnExecute Variant vCommandBarControl
75921>                        Handle hoClient
75921>                        Get Client_Id to hoClient
75922>                        Send Activate_oCustomerView of hoClient
75923>                    End_Procedure
75924>                End_Object
75925>    
75925>                Object oInventoryItemViewMenuItem is a cCJMenuItem
75927>                    Set psCaption to "Inventory Item View"
75928>                    Set psShortcut to "Ctrl+2"
75929>                    Set psDescription to "Add, edit and delete Inventory data."
75930>                    Set psToolTip to "Inventory Item View"
75931>                
75931>                    Procedure OnExecute Variant vCommandBarControl
75934>                        Handle hoClient
75934>                        Get Client_Id to hoClient
75935>                        Send Activate_oInventoryView of hoClient
75936>                    End_Procedure
75937>                End_Object
75938>    
75938>                Object oOrderEntryMenuItem is a cCJMenuItem
75940>                    Set psCaption to "Order Entry"
75941>                    Set psShortcut to "Ctrl+3"
75942>                    Set psDescription to "Add, edit and delete Order data."
75943>                    Set psToolTip to "Order Entry"
75944>                
75944>                    Procedure OnExecute Variant vCommandBarControl
75947>                        Handle hoClient
75947>                        Get Client_Id to hoClient
75948>                        Send Activate_oOrderEntryView of hoClient
75949>                    End_Procedure
75950>                End_Object
75951>    
75951>                Object oSalesPersonEntryViewMenuItem is a cCJMenuItem
75953>                    Set psCaption to "Sales Person Entry View"
75954>                    Set psShortcut to "Ctrl+4"
75955>                    Set psDescription to "Add, edit and delete Sales Person data."
75956>                    Set psToolTip to "Sales Person Entry View"
75957>                
75957>                    Procedure OnExecute Variant vCommandBarControl
75960>                        Handle hoClient
75960>                        Get Client_Id to hoClient
75961>                        Send Activate_oSalesPersonView of hoClient
75962>                    End_Procedure
75963>                End_Object
75964>    
75964>                Object oVendorEntryViewMenuItem is a cCJMenuItem
75966>                    Set psCaption to "Vendor Entry View"
75967>                    Set psShortcut to "Ctrl+5"
75968>                    Set psDescription to "Add, edit and delete Vendor data."
75969>                    Set psToolTip to "Vendor Entry View"
75970>                
75970>                    Procedure OnExecute Variant vCommandBarControl
75973>                        Handle hoClient
75973>                        Get Client_Id to hoClient
75974>                        Send Activate_oVendorView of hoClient
75975>                    End_Procedure
75976>                End_Object
75977>    
75977>            End_Object
75978>            
75978>            Object oReportMenu is a cCJMenuItem
75980>                
75980>                Set peControlType to xtpControlPopup          
75981>                Set psCaption to "&Report"
75982>                Set psToolTip to "Report"
75983>                Set psDescription to "Available Reports"
75984>    
75984>                Object oBasicReportsMenuItem is a cCJMenuItem
75986>                    Set psCaption to "Basic Reports"
75987>                    Set peControlType to xtpControlPopup
75988>                    Set psToolTip to "Basic Reports"
75989>                    Set psDescription to "Reports based on the Basic Report class."
75990>    
75990>                    Object oCustomerListMenuItem is a cCJMenuItem
75992>                        Set psCaption to "Customer List"
75993>                        Set psToolTip to "Customer List (Basic)"
75994>                    
75994>                        Procedure OnExecute Variant vCommandBarControl
75997>                            Handle hoClient
75997>                            Get Client_Id to hoClient
75998>                            Send Activate_oCustomerListBR of hoClient
75999>                        End_Procedure
76000>                    End_Object
76001>                End_Object
76002>    
76002>                Object oWinPrintReportsMenuItem is a cCJMenuItem
76004>                    Set psCaption to "WinPrint Reports"
76005>                    Set peControlType to xtpControlPopup
76006>                    Set psToolTip to "WinPrint Reports"
76007>                    Set psDescription to "Reports based on the WinPrint class."
76008>    
76008>                    Object oCustomerListMenuItem2 is a cCJMenuItem
76010>                        Set psCaption to "Customer List"
76011>                        Set psShortcut to "Ctrl+6"
76012>                        Set psToolTip to "Customer List (WinPrint)"
76013>                        Set psDescription to "Print Customer data."
76014>                    
76014>                        Procedure OnExecute Variant vCommandBarControl
76017>                            Handle hoClient
76017>                            Get Client_Id to hoClient
76018>                            Send Activate_oCustomerListWP of hoClient
76019>                        End_Procedure
76020>                    End_Object
76021>    
76021>                    Object oItemsperOrderMenuItem is a cCJMenuItem
76023>                        Set psCaption to "Items per Order"
76024>                        Set psShortcut to "Ctrl+7"
76025>                        Set psToolTip to "Items per Order (WinPrint)"
76026>                        Set psDescription to "Print line items for all Orders."
76027>                    
76027>                        Procedure OnExecute Variant vCommandBarControl
76030>                            Handle hoClient
76030>                            Get Client_Id to hoClient
76031>                            Send Activate_oItemsPerOrderWP of hoClient
76032>                        End_Procedure
76033>                    End_Object
76034>    
76034>                    Object oOrdersbyCustomerMenuItem1 is a cCJMenuItem
76036>                        Set psCaption to "Orders by Customer"
76037>                        Set psShortcut to "Ctrl+8"
76038>                        Set psToolTip to "Orders by Customer (WinPrint)"
76039>                        Set psDescription to "Print Order data sorted by Customer."
76040>                    
76040>                        Procedure OnExecute Variant vCommandBarControl
76043>                            Handle hoClient
76043>                            Get Client_Id to hoClient
76044>                            Send Activate_oOrdersByCustomerWP of hoClient
76045>                        End_Procedure
76046>                    End_Object
76047>    
76047>                    Object oOrdersbyOrderNumberMenuItem is a cCJMenuItem
76049>                        Set psCaption to "Orders by Order Number"
76050>                        Set psShortcut to "Ctrl+9"
76051>                        Set psToolTip to "Orders by Order Number (WinPrint)"
76052>                        Set psDescription to "Print Order data."
76053>                    
76053>                        Procedure OnExecute Variant vCommandBarControl
76056>                            Handle hoClient
76056>                            Get Client_Id to hoClient
76057>                            Send Activate_oOrdersWP of hoClient
76058>                        End_Procedure
76059>                    End_Object
76060>                End_Object
76061>    
76061>            End_Object
76062>                        
76062>            Object oNavigateMenu is a cCJMenuItem
76064>                Set peControlType to xtpControlPopup      
76065>                Set psCaption to "&Navigate"    
76066>                Set psTooltip to "Navigate"    
76067>                Set psDescription to "Move to different areas of the application"
76068>                
76068>                Object oNextAreaMenu is a cCJNextAreaMenu
76070>                End_Object
76071>                
76071>                Object oPriorAreaMenu is a cCJPriorAreaMenu
76073>                End_Object
76074>                
76074>                Object oNextViewMenu is a cCJNextViewMenu
76076>                End_Object
76077>                
76077>                Object oPriorViewMenu is a cCJPriorViewMenu
76079>                End_Object
76080>                
76080>                Object oPromptMenu is a cCJPromptMenuItem
76082>                    Set pbControlBeginGroup to True
76083>                End_Object
76084>    
76084>                Object oZoomMenu is a cCJZoomMenuItem
76086>                End_Object
76087>    
76087>            End_Object
76088>    
76088>            Object oWindowMenu is a cCJMDIWindowsMenuItem
76090>                Set peControlType to xtpControlPopup      
76091>                Set psCaption to "&Window"
76092>                Set psToolTip to "Window"
76093>                Set psDescription to "Display Current Views and set other display options."    
76094>                
76094>                // These are the static windows items. More will be created in onInitPopup 
76094>                Object oDisplayOptionsMenu is a cCJMenuItem
76096>                    Set peControlType to xtpControlPopup          
76097>                    Set psCaption to "&Display Options"
76098>                    Set psToolTip to "Display Options"
76099>                    Set psDescription to "Set display options"
76100>    
76100>                    Object oStatusbarMenu is a cCJStatusbarMenuItem
76102>                    End_Object
76103>    
76103>                    Object oAutoArrangeIconsMenu is a cCJAutoArrangeIconsMenuItem
76105>                    End_Object
76106>    
76106>                    Object oRestoreMenusMenu is a cCJRestoreMenusMenuItem
76108>                        Set pbControlBeginGroup to True
76109>                    End_Object
76110>                    
76110>                End_Object
76111>        
76111>                Object oCascadeMenu is a cCJCascadeMenuItem
76113>                    Set pbControlBeginGroup to True
76114>                End_Object
76115>    
76115>                Object oHorizTile is a cCJTileHorizontally
76117>                End_Object
76118>    
76118>                Object oVertTile is a cCJTileVertically
76120>                End_Object
76121>    
76121>                Object oMinimizeMenuItem is a cCJMinimizeWindowsMenuItem
76123>                    Set pbControlBeginGroup to True
76124>                End_Object
76125>    
76125>                Object oRestoreMenuItem is a cCJRestoreWindowsMenuItem
76127>                End_Object
76128>    
76128>                Object oArrangeIconsMenuItem is a cCJAutoArrangeIconsMenuItem
76130>                    Set pbControlBeginGroup to True
76131>                End_Object
76132>    
76132>            End_Object
76133>
76133>            Object oDemoMenuItem is a cCJMenuItem
76135>                Set psCaption to "&Demo"
76136>                Set psTooltip to "&Demo"
76137>                Set peControlType to xtpControlPopup
76138>                
76138>                Object oParentComboDemoMenuItem is a cCJMenuItem
76140>                    Set psCaption to "Parent Combo Demo"
76141>                    Set psTooltip to "Parent Combo Demo"
76142>                
76142>                    Procedure OnExecute Variant vCommandBarControl
76145>                        Handle hoClient
76145>                        Get Client_Id to hoClient
76146>                        Send Activate_oDemoParentCombos of hoClient
76147>                    End_Procedure
76148>                End_Object
76149>
76149>                Object oSuggestionFormMenuItem is a cCJMenuItem
76151>                    Set psCaption to "Suggestion Form"
76152>                    Set psTooltip to "Suggestion Form"
76153>                
76153>                    Procedure OnExecute Variant vCommandBarControl
76156>                        Handle hoClient
76156>                        Get Client_Id to hoClient
76157>                        Send Activate_oDemoSuggestionForm of hoClient
76158>                    End_Procedure
76159>                End_Object
76160>
76160>                Object oButtonSamplesMenuItem is a cCJMenuItem
76162>                    Set psCaption to "Button Samples"
76163>                    Set psTooltip to "Button Samples"
76164>                
76164>                    Procedure OnExecute Variant vCommandBarControl
76167>                        Handle hoClient
76167>                        Get Client_Id to hoClient
76168>                        Send Activate_oButtonTest of hoClient
76169>                    End_Procedure
76170>                End_Object
76171>
76171>                Object oCalendarControlSampleMenuItem is a cCJMenuItem
76173>                          Set psCaption to "Calendar Control Sample"
76174>                          Set psTooltip to "Calendar Control Sample"
76175>                
76175>                          Procedure OnExecute Variant vCommandBarControl
76178>                                    Handle hoClient
76178>                                    Get Client_Id to hoClient
76179>                                    Send Activate_oDemoCalendarControl of hoClient
76180>                          End_Procedure
76181>                End_Object
76182>            End_Object
76183>            
76183>            Object oHelpMenu is a cCJMenuItem
76185>                Set peControlType to xtpControlPopup    
76186>                Set psCaption to "&Help"
76187>                Set psDescription to "Access Information for learning and using this DataFlex application."
76188>                Set psToolTip to "Help"
76189>                
76189>                Object oHelpMenuItem is a cCJHelpMenuItem 
76191>                End_Object
76192>    
76192>                Object oAboutMenuItem is a cCJAboutMenuItem
76194>                End_Object
76195>           
76195>            End_Object
76196>    
76196>        End_Object
76197>    
76197>        Object oFindToolBar is a cCJToolbar
76199>            Set psTitle to "Finding Toolbar"
76200>    
76200>            Object oFindFirstTool is a cCJFindFirstMenuItem
76202>            End_Object
76203>    
76203>            Object oFindPreviousTool is a cCJFindPreviousMenuItem
76205>            End_Object
76206>    
76206>            Object oFindMenuTool is a cCJFindMenuItem
76208>            End_Object
76209>    
76209>            Object oFindNextTool is a cCJFindNextMenuItem
76211>            End_Object
76212>    
76212>            Object oFindLastTool is a cCJFindLastMenuItem
76214>            End_Object
76215>    
76215>            Object oPromptToolItem is a cCJPromptMenuItem
76217>                Set pbControlBeginGroup to True
76218>            End_Object
76219>    
76219>        End_Object
76220>            
76220>        Object oFileToolBar is a cCJToolbar
76222>            Set psTitle to "Data Entry Toolbar"
76223>    
76223>            Object oClearToolItem is a cCJClearMenuItem
76225>                Set peControlStyle to xtpButtonIconAndCaption
76226>            End_Object
76227>            
76227>            Object oClearAllToolItem2 is a cCJClearAllMenuItem
76229>                Set peControlStyle to xtpButtonIconAndCaption
76230>            End_Object
76231>                
76231>            Object oSaveToolItem is a cCJSaveMenuItem
76233>                Set peControlStyle to xtpButtonIconAndCaption
76234>                Set pbControlBeginGroup to True
76235>            End_Object
76236>    
76236>            Object oDeleteToolItem is a cCJDeleteMenuItem
76238>                Set peControlStyle to xtpButtonIconAndCaption
76239>            End_Object
76240>    
76240>        End_Object
76241>    
76241>        Object oEditToolBar is a cCJToolbar
76243>            Set psTitle to "Edit Toolbar"
76244>            
76244>            Object oCutToolbarItem is a cCJCutMenuItem
76246>            End_Object
76247>    
76247>            Object oCopyToolbarItem is a cCJCopyMenuItem
76249>            End_Object
76250>    
76250>            Object oPasteToolbarItem is a cCJPasteMenuItem
76252>            End_Object
76253>    
76253>            Object oDeleteEditToolbarItem is a cCJDeleteEditMenuItem
76255>                Set pbControlBeginGroup to True
76256>            End_Object
76257>    
76257>        End_Object
76258>                
76258>        Object oRememberToolbar is a cCJToolbar
76260>            Set psTitle to "Remember Toolbar"
76261>
76261>            Object oRememberItems is a cCJMenuItem
76263>
76263>                Set peControlType to xtpControlPopup
76264>                Set peControlStyle to xtpButtonCaption
76265>                Set psCaption to C_$Remember
76266>                
76266>                Object oMenuItem is a cCJRememberFieldMenuItem
76268>                    Set peControlStyle to xtpButtonIconAndCaption
76269>                End_Object
76270>                
76270>                Object oMenuItem is a cCJRememberLastFieldMenuItem
76272>                    Set peControlStyle to xtpButtonIconAndCaption
76273>                End_Object
76274>                
76274>                Object oMenuItem is a cCJUnRememberFieldMenuItem
76276>                    Set peControlStyle to xtpButtonIconAndCaption
76277>                End_Object
76278>                
76278>                Object oMenuItem is a cCJUnRememberFieldAllMenuItem
76280>                    Set peControlStyle to xtpButtonIconAndCaption
76281>                End_Object
76282>
76282>            End_Object
76283>
76283>        End_Object
76284>
76284>
76284>        Object oStatusBar is a cCJStatusBar
76286>            
76286>            Object oStatusPane1 is a cCJStatusBarPane
76288>                Set piID to sbpIDIdlePane
76289>                Set pbStyleStretch to True
76290>            End_Object
76291>    
76291>            Object oStatusPane2 is a cCJStatusBarPane
76293>                Set phoViewPane to Self
76294>                Set pbStyleStretch to True
76295>            End_Object
76296>    
76296>        End_Object
76297>    
76297>    End_Object
76298>
76298>    Object oClientArea is a ClientArea
76300>        Use Customer.vw
Including file: Customer.vw    (C:\Test\Order Entry git\AppSrc\Customer.vw)
76300>>>Use dfClient.pkg
76300>>>Use DataDict.pkg
76300>>>Use dfEntry.pkg
76300>>>Use dfTabDlg.pkg
76300>>>Use dfCEntry.pkg
76300>>>Use cDbTextEdit.Pkg
76300>>>Use Customer.DD
Including file: Customer.dd    (C:\Test\Order Entry git\DDSrc\Customer.dd)
76300>>>>>Use Windows.pkg           // Basic Definitions
76300>>>>>Use DataDict.pkg          // DataDictionary Class Definition
76300>>>>>Use DDvalTbl.pkg          // Validation Table Class Definitions
76300>>>>>
76300>>>>>Open Customer
Including file: Customer.fd    (C:\Test\Order Entry git\DDSrc\Customer.fd)
76302>>>>>Open OrderHea
Including file: OrderHea.fd    (C:\Test\Order Entry git\DDSrc\OrderHea.fd)
76304>>>>>Open Ordsys
Including file: OrdSys.fd    (C:\Test\Order Entry git\DDSrc\OrdSys.fd)
76306>>>>>
76306>>>>>
76306>>>>>Register_Object Customer_State_VT
76306>>>>>Register_Object Customer_sl
76306>>>>>
76306>>>>>Object Customer_State_VT  is a CodeValidationTable
76308>>>>>    Set Type_Value        To "STATES"
76309>>>>>    Set Table_Title       To "States"
76310>>>>>End_Object   // Customer_State_VT
76311>>>>>
76311>>>>>Register_Function ValidateEmail Integer iColumn String sValue Returns Boolean
76311>>>>>
76311>>>>>Class Customer_DataDictionary Is A DataDictionary
76312>>>>>
76312>>>>>    Procedure Construct_Object
76314>>>>>        Forward Send Construct_Object
76316>>>>>
76316>>>>>        Set Main_File To Customer.File_Number
76317>>>>>        Set Cascade_Delete_State To False
76318>>>>>
76318>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_FINDREQ to True
76319>>>>>        Set Foreign_Field_Option DD_INDEXFIELD DD_NOPUT to True
76320>>>>>        Set Foreign_Field_Option DD_DEFAULT DD_DISPLAYONLY to True
76321>>>>>
76321>>>>>        Set Add_Client_File to OrderHea.File_Number
76322>>>>>
76322>>>>>        Set Add_System_File to Ordsys.File_Number DD_LOCK_ON_NEW_SAVE
76323>>>>>
76323>>>>>        Set Field_Auto_Increment Field Customer.Customer_Number to File_Field Ordsys.Cust_Number
76324>>>>>        Set Field_Label_Long Field Customer.Customer_Number To "Customer Number"
76325>>>>>        Set Field_Label_Short Field Customer.Customer_Number To "Number"
76326>>>>>        Set Field_Option Field Customer.Customer_Number DD_AUTOFIND to True
76327>>>>>        Set Field_Option Field Customer.Customer_Number DD_NOPUT to True
76328>>>>>        Set Field_Prompt_Object Field Customer.Customer_Number to Customer_sl
76329>>>>>        Set Key_Field_State Field Customer.Customer_Number To True
76330>>>>>        Set Status_Help Field Customer.Customer_Number To "Customer Id Number (system assigned)."
76331>>>>>
76331>>>>>        Set Field_Label_Long Field Customer.Name To "Customer Name"
76332>>>>>        Set Field_Label_Short Field Customer.Name To "Customer Name"
76333>>>>>        Set Field_Option Field Customer.Name DD_REQUIRED to True
76334>>>>>        Set Field_Prompt_Object Field Customer.Name to Customer_sl
76335>>>>>        Set Status_Help Field Customer.Name To "Customer/Company Name."
76336>>>>>
76336>>>>>        Set Field_Label_Long Field Customer.Address To "Street Address"
76337>>>>>        Set Field_Label_Short Field Customer.Address To "Address"
76338>>>>>        Set Status_Help Field Customer.Address To "Street Address."
76339>>>>>
76339>>>>>        Set Status_Help Field Customer.City To "City Name."
76340>>>>>
76340>>>>>        Set Field_Class_Name Field Customer.State To "dbComboForm"
76341>>>>>        Set Field_Label_Long Field Customer.State To "State"
76342>>>>>        Set Field_Label_Short Field Customer.State To "St."
76343>>>>>        Set Field_Option Field Customer.State DD_CAPSLOCK to True
76344>>>>>        Set Field_Value_Table Field Customer.State to Customer_State_VT
76345>>>>>        Set Status_Help Field Customer.State To "Two letter state ID."
76346>>>>>
76346>>>>>        Set Field_Label_Long Field Customer.Zip To "Zip/Postal Code"
76347>>>>>        Set Field_Label_Short Field Customer.Zip To "Zip"
76348>>>>>        Set Field_Mask Field Customer.Zip To "#####-####"
76349>>>>>        Set Field_Mask_Type Field Customer.Zip To MASK_WINDOW
76350>>>>>        Set Status_Help Field Customer.Zip To "Zip or Postal Code."
76351>>>>>
76351>>>>>        Set Field_Label_Long Field Customer.Phone_Number To "Phone Number"
76352>>>>>        Set Field_Label_Short Field Customer.Phone_Number To "Phone"
76353>>>>>        Set Status_Help Field Customer.Phone_Number To "Phone Number."
76354>>>>>
76354>>>>>        Set Field_Label_Long Field Customer.Fax_Number To "Fax Number"
76355>>>>>        Set Field_Label_Short Field Customer.Fax_Number To "Fax"
76356>>>>>        Set Status_Help Field Customer.Fax_Number To "Fax Phone Number."
76357>>>>>
76357>>>>>        Set Field_Label_Long Field Customer.Email_Address To "E-Mail Address"
76358>>>>>        Set Field_Label_Short Field Customer.Email_Address To "E-Mail"
76359>>>>>        Set Status_Help Field Customer.Email_Address To "E-mail Address (internet)."
76360>>>>>        Set Field_Validate_msg Field Customer.EMail_Address to (RefFunc(ValidateEmail))
76361>>>>>        Set Field_Option Field Customer.EMail_Address DD_REQUIRED to True
76362>>>>>
76362>>>>>        Set Field_Class_Name Field Customer.Credit_Limit To "dbSpinForm"
76363>>>>>        Set Field_Mask_Type Field Customer.Credit_Limit To MASK_CURRENCY_WINDOW
76364>>>>>
76364>>>>>        Set Field_Label_Long Field Customer.Purchases To "Total Purchases"
76365>>>>>        Set Field_Label_Short Field Customer.Purchases To "Purchases"
76366>>>>>        Set Field_Mask_Type Field Customer.Purchases To MASK_CURRENCY_WINDOW
76367>>>>>        Set Field_Option Field Customer.Purchases DD_DISPLAYONLY to True
76368>>>>>
76368>>>>>        Set Field_Label_Long Field Customer.Balance To "Balance Due"
76369>>>>>        Set Field_Label_Short Field Customer.Balance To "Balance"
76370>>>>>        Set Field_Mask_Type Field Customer.Balance To MASK_CURRENCY_WINDOW
76371>>>>>        Set Field_Option Field Customer.Balance DD_DISPLAYONLY to True
76372>>>>>
76372>>>>>        Set Status_Help Field Customer.Comments To "Additional Comments and Notes."
76373>>>>>
76373>>>>>        Set Field_Checkbox_Values Field Customer.Status To "Y" "N"
76374>>>>>        Set Field_Label_Long Field Customer.Status To "Active Status"
76375>>>>>        Set Field_Label_Short Field Customer.Status To "Status"
76376>>>>>        Set Status_Help Field Customer.Status To "Active Inactive Status of customer"
76377>>>>>
76377>>>>>    End_Procedure  //  Construct_Object
76378>>>>>
76378>>>>>    Procedure Field_defaults
76380>>>>>        Forward Send Field_Defaults
76382>>>>>        Set Field_Changed_Value   Field Customer.State To "FL"
76383>>>>>        Set Field_Changed_Value   Field Customer.Credit_Limit To 1000
76384>>>>>        Set Field_Changed_Value   Field Customer.Status To "Y"
76385>>>>>    End_Procedure
76386>>>>>
76386>>>>>    //
76386>>>>>    //  Validates if the field contains a valid email address (it allows empty values to).
76386>>>>>    //
76386>>>>>    Function ValidateEmail Integer iColumn String sValue Returns Boolean
76388>>>>>        Integer iAt iDot
76388>>>>>        Boolean bResult
76388>>>>>        
76388>>>>>        If (Trim(sValue) <> "") Begin
76390>>>>>            Move (Pos("@", sValue)) to iAt
76391>>>>>            Move (RightPos(".", sValue)) to iDot
76392>>>>>            
76392>>>>>            If (not(iAt > 1 and iDot > 0 and iDot > iAt + 1 and iDot < Length(sValue))) Begin
76394>>>>>                Send Data_set_error iColumn DFERR_OPERATOR "Please enter a valid email address"
76395>>>>>                Move True to bResult
76396>>>>>            End
76396>>>>>>
76396>>>>>        End
76396>>>>>>
76396>>>>>        
76396>>>>>        Function_Return bResult
76397>>>>>    End_Function
76398>>>>>
76398>>>>>End_Class    //  Customer_DataDictionary
76399>>>>>
76399>>>>>
76399>>>>>Use Customer.sl      // Customer_sl
Including file: Customer.sl    (C:\Test\Order Entry git\AppSrc\Customer.sl)
76399>>>>>>>Use DFClient.pkg
76399>>>>>>>Use DFSelLst.pkg
76399>>>>>>>Use Windows.pkg
76399>>>>>>>Use cDbCJGridPromptList.pkg
76399>>>>>>>
76399>>>>>>>Use Customer.DD
76399>>>>>>>
76399>>>>>>>CD_Popup_Object Customer_sl is a dbModalPanel
76417>>>>>>>>
76417>>>>>>>
76417>>>>>>>    Set Border_Style to Border_Thick
76418>>>>>>>    Set Minimize_Icon to False
76419>>>>>>>    Set Label to "Customer List by john"
76420>>>>>>>    Set Size to 134 238
76421>>>>>>>    Set Location to 4 5
76422>>>>>>>    Set piMinSize to 134 238
76423>>>>>>>
76423>>>>>>>    Object Customer_DD is a Customer_DataDictionary
76425>>>>>>>    End_Object    // Customer_DD
76426>>>>>>>
76426>>>>>>>    Set Main_DD to Customer_DD
76427>>>>>>>    Set Server to Customer_DD
76428>>>>>>>
76428>>>>>>>    Object oSelList is a cDbCJGridPromptList
76430>>>>>>>        Set Size to 100 224
76431>>>>>>>        Set Location to 9 8
76432>>>>>>>        Set peAnchors to anAll
76433>>>>>>>        Set pbAllowColumnRemove to False
76434>>>>>>>
76434>>>>>>>        Object oNumber is a cDbCJGridColumn
76436>>>>>>>            Entry_Item Customer.Customer_Number
76437>>>>>>>            Set piWidth to 93
76438>>>>>>>            Set psCaption to "Number"
76439>>>>>>>        End_Object
76440>>>>>>>
76440>>>>>>>        Object oCustomerName is a cDbCJGridColumn
76442>>>>>>>            Entry_Item Customer.Name
76443>>>>>>>            Set piWidth to 243
76444>>>>>>>            Set psCaption to "Customer Name"
76445>>>>>>>        End_Object
76446>>>>>>>    End_Object  // oSelList
76447>>>>>>>
76447>>>>>>>    Object oOK_bn is a Button
76449>>>>>>>        Set Label to "&Ok"
76450>>>>>>>        Set Location to 116 77
76451>>>>>>>        Set peAnchors to anBottomRight
76452>>>>>>>
76452>>>>>>>        Procedure OnClick
76455>>>>>>>            Send OK of oSelList
76456>>>>>>>        End_Procedure
76457>>>>>>>
76457>>>>>>>    End_Object    // oOK_bn
76458>>>>>>>
76458>>>>>>>    Object oCancel_bn is a Button
76460>>>>>>>        Set Label to "&Cancel"
76461>>>>>>>        Set Location to 116 130
76462>>>>>>>        Set peAnchors to anBottomRight
76463>>>>>>>
76463>>>>>>>        Procedure OnClick
76466>>>>>>>            Send Cancel of oSelList
76467>>>>>>>        End_Procedure
76468>>>>>>>
76468>>>>>>>    End_Object    // oCancel_bn
76469>>>>>>>
76469>>>>>>>    Object oSearch_bn is a Button
76471>>>>>>>        Set Label to "&Search..."
76472>>>>>>>        Set Location to 116 183
76473>>>>>>>        Set peAnchors to anBottomRight
76474>>>>>>>
76474>>>>>>>        Procedure OnClick
76477>>>>>>>            Send Search of oSelList
76478>>>>>>>        End_Procedure
76479>>>>>>>
76479>>>>>>>    End_Object    // oSearch_bn
76480>>>>>>>
76480>>>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOk_bn
76481>>>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_bn
76482>>>>>>>    On_Key Key_Alt+Key_S Send KeyAction of oSearch_bn
76483>>>>>>>
76483>>>>>>>CD_End_Object    // Customer_sl
76485>>>>>>>>
76485>>>>>
76485>>>>>
76485>>>Use cSplitButton.pkg
Including file: cSplitButton.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cSplitButton.pkg)
76485>>>>>// cSplitButton class
76485>>>>>
76485>>>>>// This requires version 6 of common controls (vista or windows server 2008). If used with
76485>>>>>// older versions you will just get a regular button with no split part.
76485>>>>> 
76485>>>>>Use Windows.pkg
76485>>>>>
76485>>>>>Class cSplitButton is a Button
76486>>>>>
76486>>>>>    Procedure Page Integer iPageObject
76488>>>>>        Integer iStyle
76488>>>>>        Boolean bSupported
76488>>>>>        Get IsExControlSupported to bSupported
76489>>>>>        If (iPageObject=1  and bSupported) Begin
76491>>>>>            Get Form_Style iStyle to iStyle
76492>>>>>            Move (iStyle ior BS_SPLITBUTTON) to iStyle
76493>>>>>            Set Form_Style 0 to iStyle
76494>>>>>        End
76494>>>>>>
76494>>>>>        Forward Send Page iPageObject
76496>>>>>    End_Procedure
76497>>>>>    
76497>>>>>    Procedure Notify Integer wParam Integer lParam
76499>>>>>        tWinNmHdr Hdr
76499>>>>>        tWinNmHdr Hdr
76499>>>>>        Integer iVoid
76499>>>>>        Move (MemCopy(AddressOf(Hdr),lParam,SizeOfType(tWinNmHdr))) to iVoid
76500>>>>>        If (Hdr.code=BCN_DROPDOWN) Begin
76502>>>>>            Send OnDropDown
76503>>>>>        End
76503>>>>>>
76503>>>>>        Else Begin
76504>>>>>            Forward Send Notify wParam lParam
76506>>>>>        End
76506>>>>>>
76506>>>>>    End_Procedure
76507>>>>>    
76507>>>>>End_Class
76508>>>
76508>>>DEFERRED_VIEW Activate_oCustomerView FOR ;;Object oCustomerView is a dbView
76533>>>    Set Border_Style to Border_Thick
76534>>>    Set Label to "Customer Entry View"
76535>>>    Set Location to 7 23
76536>>>    Set Size to 146 277
76537>>>    Set piMaxSize to 300 350
76538>>>    Set piMinSize to 146 277
76539>>>
76539>>>    Object Customer_DD is a Customer_DataDictionary
76541>>>    End_Object    // Customer_DD
76542>>>
76542>>>    Set Main_DD to Customer_DD
76543>>>    Set Server to Customer_DD
76544>>>
76544>>>    Object oCustomer_Number is a dbForm
76546>>>        Entry_Item Customer.Customer_Number
76547>>>        Set Label to "Customer Number:"
76548>>>        Set Size to 13 42
76549>>>        Set Location to 5 72
76550>>>        Set peAnchors to anTopLeft
76551>>>        Set Label_Col_Offset to 2
76552>>>        Set Label_Justification_Mode to jMode_Right
76553>>>    End_Object    // oCustomer_Number
76554>>>
76554>>>    Object oCustomer_Name is a dbForm
76556>>>        Entry_Item Customer.Name
76557>>>        Set Label to "Name:"
76558>>>        Set Size to 13 186
76559>>>        Set Location to 20 72
76560>>>        Set peAnchors to anTopLeftRight
76561>>>        Set Label_Col_Offset to 2
76562>>>        Set Label_Justification_Mode to jMode_Right
76563>>>    End_Object    // oCustomer_Name
76564>>>
76564>>>    Object oCustTD is a dbTabDialog
76566>>>        Set Size to 105 265
76567>>>        Set Location to 36 7
76568>>>        Set Rotate_Mode to RM_Rotate
76569>>>        Set peAnchors to anAll
76570>>>        Object oAddress_TP is a dbTabPage
76572>>>            Set Label to "Address"
76573>>>            Set Tab_ToolTip_Value to "Customer contact information"
76574>>>            Object oCustomer_Address is a dbForm
76576>>>                Entry_Item Customer.Address
76577>>>                Set Label to "Street Address:"
76578>>>                Set Size to 13 180
76579>>>                Set Location to 8 62
76580>>>                Set peAnchors to anTopLeftRight
76581>>>                Set Label_Col_Offset to 2
76582>>>                Set Label_Justification_Mode to jMode_Right
76583>>>            End_Object    // oCustomer_Address
76584>>>
76584>>>            Object oCustomer_City is a dbForm
76586>>>                Entry_Item Customer.City
76587>>>                Set Label to "City/State/Zip:"
76588>>>                Set Size to 13 84
76589>>>                Set Location to 24 62
76590>>>                Set peAnchors to anTopLeftRight
76591>>>                Set Label_Col_Offset to 2
76592>>>                Set Label_Justification_Mode to jMode_Right
76593>>>            End_Object    // oCustomer_City
76594>>>
76594>>>            Object oCustomer_State is a dbComboForm
76596>>>                Entry_Item Customer.State
76597>>>                Set Size to 13 32
76598>>>                Set Location to 24 152
76599>>>                Set peAnchors to anTopRight
76600>>>                Set Form_Border to 0
76601>>>                Set Code_Display_Mode to cb_code_display_code
76602>>>            End_Object    // oCustomer_State
76603>>>
76603>>>            Object oCustomer_Zip is a dbForm
76605>>>                Entry_Item Customer.Zip
76606>>>                Set Size to 13 51
76607>>>                Set Location to 24 191
76608>>>                Set peAnchors to anTopRight
76609>>>            End_Object    // oCustomer_Zip
76610>>>
76610>>>            Object oCustomer_Phone_number is a dbForm
76612>>>                Entry_Item Customer.Phone_Number
76613>>>                Set Label to "Phone Number:"
76614>>>                Set Size to 13 120
76615>>>                Set Location to 39 62
76616>>>                Set peAnchors to anTopLeft
76617>>>                Set Label_Col_Offset to 2
76618>>>                Set Label_Justification_Mode to jMode_Right
76619>>>            End_Object    // oCustomer_Phone_number
76620>>>
76620>>>            Object oCustomer_Fax_number is a dbForm
76622>>>                Entry_Item Customer.Fax_Number
76623>>>                Set Label to "Fax Number:"
76624>>>                Set Size to 13 120
76625>>>                Set Location to 54 62
76626>>>                Set peAnchors to anTopLeft
76627>>>                Set Label_Col_Offset to 2
76628>>>                Set Label_Justification_Mode to jMode_Right
76629>>>            End_Object    // oCustomer_Fax_number
76630>>>
76630>>>            Object oCustomer_Email_address is a dbForm
76632>>>                Entry_Item Customer.EMail_Address
76633>>>                Set Label to "E-Mail Address:"
76634>>>                Set Size to 13 180
76635>>>                Set Location to 69 62
76636>>>                Set peAnchors to anTopLeftRight
76637>>>                Set Label_Col_Offset to 2
76638>>>                Set Label_Justification_Mode to jMode_Right
76639>>>            End_Object    // oCustomer_Email_address
76640>>>
76640>>>        End_Object    // oAddress_TP
76641>>>
76641>>>        Object oBalances_TP is a dbTabPage
76643>>>            Set Label to "Balances"
76644>>>            Set Tab_ToolTip_Value to "Current account balances"
76645>>>            Object oCustomer_Credit_Limit is a dbForm
76647>>>                Entry_Item Customer.Credit_limit
76648>>>                Set Label to "Credit Limit:"
76649>>>                Set Size to 13 48
76650>>>                Set Location to 9 72
76651>>>                Set Label_Col_Offset to 2
76652>>>                Set Label_Justification_Mode to jMode_Right
76653>>>            End_Object    // oCustomer_Credit_Limit
76654>>>
76654>>>            Object oCustomer_Purchases is a dbForm
76656>>>                Entry_Item Customer.Purchases
76657>>>                Set Label to "Total Purchases:"
76658>>>                Set Size to 13 48
76659>>>                Set Location to 24 72
76660>>>                Set Label_Col_Offset to 2
76661>>>                Set Label_Justification_Mode to jMode_Right
76662>>>            End_Object    // oCustomer_Purchases
76663>>>
76663>>>            Object oCustomer_Balance is a dbForm
76665>>>                Entry_Item Customer.Balance
76666>>>                Set Label to "Balance Due:"
76667>>>                Set Size to 13 48
76668>>>                Set Location to 39 72
76669>>>                Set Label_Col_Offset to 2
76670>>>                Set Label_Justification_Mode to jMode_Right
76671>>>            End_Object    // oCustomer_Balance
76672>>>
76672>>>        End_Object    // oBalances_TP
76673>>>
76673>>>        Object oDbTabPage1 is a dbTabPage
76675>>>            Set Label to 'oDbTabPage1'
76676>>>
76676>>>            Object oSplitButton1 is a cSplitButton
76678>>>                Set Location to 36 96
76679>>>                Set Label to 'oSplitButton1'
76680>>>            End_Object
76681>>>        End_Object
76682>>>
76682>>>        Object oComments_TP is a dbTabPage
76684>>>            Set Label to "Comments"
76685>>>            Set Tab_ToolTip_Value to "Notes about this customer"
76686>>>            Object oCustomer_Comments is a cDbTextEdit
76688>>>                Entry_Item Customer.Comments
76689>>>                Set Size to 71 242
76690>>>                Set Location to 9 9
76691>>>                Set peAnchors to anAll
76692>>>            End_Object    // oCustomer_Comments
76693>>>
76693>>>        End_Object    // oComments_TP
76694>>>
76694>>>    End_Object    // oCustTD
76695>>>
76695>>>CD_End_Object    // oCustomerView
76697>>>>
76697>        Use Invt.vw
Including file: Invt.vw    (C:\Test\Order Entry git\AppSrc\Invt.vw)
76697>>>Use dfClient.pkg
76697>>>Use DataDict.pkg
76697>>>Use dfEntry.pkg
76697>>>Use Vendor.DD
Including file: Vendor.dd    (C:\Test\Order Entry git\DDSrc\Vendor.dd)
76697>>>>>Use  Windows.pkg           // Basic Definitions
76697>>>>>Use  DataDict.pkg          // DataDictionary Class Definition
76697>>>>>Use  DDvalTbl.pkg          // Validation Table Class Definitions
76697>>>>>
76697>>>>>Open Vendor
Including file: Vendor.fd    (C:\Test\Order Entry git\DDSrc\Vendor.fd)
76699>>>>>Open Invt
Including file: Invt.fd    (C:\Test\Order Entry git\DDSrc\Invt.fd)
76701>>>>>Open OrdSys
76703>>>>>
76703>>>>>
76703>>>>>Register_Object Vendor_State_VT
76703>>>>>
76703>>>>>Object Vendor_State_VT  is a CodeValidationTable
76705>>>>>    Set Type_Value        To "STATES"
76706>>>>>End_Object   // Vendor_State_VT
76707>>>>>Register_Object Vendor_sl
76707>>>>>
76707>>>>>Class Vendor_DataDictionary Is A DataDictionary
76708>>>>>
76708>>>>>    Procedure Construct_Object
76710>>>>>        Forward Send Construct_Object
76712>>>>>
76712>>>>>        Set Main_File To Vendor.File_Number
76713>>>>>        Set Cascade_Delete_State To False
76714>>>>>
76714>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_FINDREQ to True
76715>>>>>        Set Foreign_Field_Option DD_INDEXFIELD DD_NOPUT to True
76716>>>>>        Set Foreign_Field_Option DD_DEFAULT DD_DISPLAYONLY to True
76717>>>>>
76717>>>>>        Set Add_Client_File to Invt.File_Number
76718>>>>>
76718>>>>>        Set Add_System_File to Ordsys.File_Number DD_LOCK_ON_NEW_SAVE
76719>>>>>
76719>>>>>        Set Field_Auto_Increment Field Vendor.Id to File_Field Ordsys.Vendor_Number
76720>>>>>
76720>>>>>
76720>>>>>        Set Field_Label_Long Field Vendor.ID To "Vendor ID"
76721>>>>>        Set Field_Label_Short Field Vendor.ID To "Vndr ID"
76722>>>>>        Set Field_Option Field Vendor.ID DD_AUTOFIND to True
76723>>>>>        Set Field_Option Field Vendor.ID DD_NOPUT to True
76724>>>>>        Set Field_Prompt_Object Field Vendor.ID to Vendor_sl
76725>>>>>        Set Key_Field_State Field Vendor.ID To True
76726>>>>>        Set Status_Help Field Vendor.ID To "Vendor Id Number (system assigned)."
76727>>>>>
76727>>>>>        Set Field_Label_Long Field Vendor.Name To "Vendor Name"
76728>>>>>        Set Field_Label_Short Field Vendor.Name To "Name"
76729>>>>>        Set Field_Option Field Vendor.Name DD_REQUIRED to True
76730>>>>>        Set Field_Prompt_Object Field Vendor.Name to Vendor_sl
76731>>>>>        Set Status_Help Field Vendor.Name To "Vendor Name."
76732>>>>>
76732>>>>>        Set Field_Label_Long Field Vendor.Address To "Street Address"
76733>>>>>        Set Field_Label_Short Field Vendor.Address To "Address"
76734>>>>>        Set Status_Help Field Vendor.Address To "Street Address."
76735>>>>>
76735>>>>>        Set Status_Help Field Vendor.City To "City Name."
76736>>>>>
76736>>>>>        Set Field_Class_Name Field Vendor.State To "dbComboForm"
76737>>>>>        Set Field_Label_Long Field Vendor.State To "State"
76738>>>>>        Set Field_Label_Short Field Vendor.State To "St."
76739>>>>>        Set Field_Option Field Vendor.State DD_CAPSLOCK to True
76740>>>>>        Set Field_Value_Table Field Vendor.State to Vendor_State_VT
76741>>>>>        Set Status_Help Field Vendor.State To "Two letter state ID."
76742>>>>>
76742>>>>>        Set Field_Label_Long Field Vendor.Zip To "Zip/Postal Code"
76743>>>>>        Set Field_Label_Short Field Vendor.Zip To "Zip"
76744>>>>>        Set Field_Mask Field Vendor.Zip To "#####-####"
76745>>>>>        Set Field_Mask_Type Field Vendor.Zip To MASK_WINDOW
76746>>>>>        Set Status_Help Field Vendor.Zip To "Zip or Postal Code."
76747>>>>>
76747>>>>>        Set Field_Label_Long Field Vendor.Phone_Number To "Phone Number"
76748>>>>>        Set Field_Label_Short Field Vendor.Phone_Number To "Phone"
76749>>>>>        Set Status_Help Field Vendor.Phone_Number To "Phone Number."
76750>>>>>
76750>>>>>        Set Field_Label_Long Field Vendor.Fax_Number To "Fax Number"
76751>>>>>        Set Field_Label_Short Field Vendor.Fax_Number To "Fax"
76752>>>>>        Set Status_Help Field Vendor.Fax_Number To "Fax Phone Number."
76753>>>>>
76753>>>>>
76753>>>>>    End_Procedure  //  Construct_Object
76754>>>>>
76754>>>>>
76754>>>>>
76754>>>>>    Procedure Field_Defaults
76756>>>>>        Forward Send Field_Defaults
76758>>>>>    End_Procedure    // Field_Defaults
76759>>>>>    
76759>>>>>End_Class    //  Vendor_DataDictionary
76760>>>>>
76760>>>>>Use Vendor.sl        // Vendor_sl
Including file: Vendor.sl    (C:\Test\Order Entry git\AppSrc\Vendor.sl)
76760>>>>>>>Use DFClient.pkg
76760>>>>>>>Use DFSelLst.pkg
76760>>>>>>>Use Windows.pkg
76760>>>>>>>Use cDbCJGridPromptList.pkg
76760>>>>>>>
76760>>>>>>>Use Vendor.DD
76760>>>>>>>
76760>>>>>>>CD_Popup_Object Vendor_sl is a dbModalPanel
76778>>>>>>>>
76778>>>>>>>    Set Label to "Vendor List"
76779>>>>>>>    Set Size to 132 238
76780>>>>>>>    Set Location to 4 5
76781>>>>>>>    Set piMinSize to 132 238
76782>>>>>>>
76782>>>>>>>    Object Vendor_DD is a Vendor_DataDictionary
76784>>>>>>>    End_Object    // Vendor_DD
76785>>>>>>>
76785>>>>>>>    Set Main_DD to Vendor_DD
76786>>>>>>>    Set Server to Vendor_DD
76787>>>>>>>
76787>>>>>>>    Object oSelList is a cDbCJGridPromptList
76789>>>>>>>        Set Size to 95 229
76790>>>>>>>        Set Location to 12 4
76791>>>>>>>        Set pbAllowColumnRemove to False
76792>>>>>>>        Set peAnchors to anAll
76793>>>>>>>
76793>>>>>>>        Object oVendor_ID is a cDbCJGridColumn
76795>>>>>>>            Entry_Item Vendor.ID
76796>>>>>>>            Set piWidth to 63
76797>>>>>>>            Set psCaption to "ID"
76798>>>>>>>        End_Object
76799>>>>>>>
76799>>>>>>>        Object oVendor_Name is a cDbCJGridColumn
76801>>>>>>>            Entry_Item Vendor.Name
76802>>>>>>>            Set piWidth to 280
76803>>>>>>>            Set psCaption to "Vendor Name"
76804>>>>>>>        End_Object
76805>>>>>>>    End_Object
76806>>>>>>>
76806>>>>>>>    Object oOK_bn is a Button
76808>>>>>>>        Set Label to "&Ok"
76809>>>>>>>        Set Location to 114 77
76810>>>>>>>        Set peAnchors to anBottomRight
76811>>>>>>>
76811>>>>>>>        Procedure OnClick
76814>>>>>>>            Send OK of oSelList
76815>>>>>>>        End_Procedure
76816>>>>>>>
76816>>>>>>>    End_Object    // oOK_bn
76817>>>>>>>
76817>>>>>>>    Object oCancel_bn is a Button
76819>>>>>>>        Set Label to "&Cancel"
76820>>>>>>>        Set Location to 114 130
76821>>>>>>>        Set peAnchors to anBottomRight
76822>>>>>>>
76822>>>>>>>        Procedure OnClick
76825>>>>>>>            Send Cancel of oSelList
76826>>>>>>>        End_Procedure
76827>>>>>>>
76827>>>>>>>    End_Object    // oCancel_bn
76828>>>>>>>
76828>>>>>>>    Object oSearch_bn is a Button
76830>>>>>>>        Set Label to "&Search..."
76831>>>>>>>        Set Location to 114 183
76832>>>>>>>        Set peAnchors to anBottomRight
76833>>>>>>>
76833>>>>>>>        Procedure OnClick
76836>>>>>>>            Send Search of oSelList
76837>>>>>>>        End_Procedure
76838>>>>>>>
76838>>>>>>>    End_Object    // oSearch_bn
76839>>>>>>>
76839>>>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOk_bn
76840>>>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_bn
76841>>>>>>>    On_Key Key_Alt+Key_S Send KeyAction of oSearch_bn
76842>>>>>>>
76842>>>>>>>CD_End_Object    // Vendor_sl
76844>>>>>>>>
76844>>>>>
76844>>>>>
76844>>>Use Invt.DD
Including file: Invt.dd    (C:\Test\Order Entry git\DDSrc\Invt.dd)
76844>>>>>Use  Windows.pkg           // Basic Definitions
76844>>>>>Use  DataDict.pkg          // DataDictionary Class Definition
76844>>>>>Use  DDvalTbl.pkg          // Validation Table Class Definitions
76844>>>>>
76844>>>>>Open Invt
76846>>>>>Open OrderDtl
Including file: OrderDtl.fd    (C:\Test\Order Entry git\DDSrc\OrderDtl.fd)
76848>>>>>Open Vendor
76850>>>>>
76850>>>>>Register_Object Invt_sl
76850>>>>>
76850>>>>>Class Invt_DataDictionary Is A DataDictionary
76851>>>>>
76851>>>>>    Procedure Construct_Object
76853>>>>>        Forward Send Construct_Object
76855>>>>>
76855>>>>>        Set Main_File To Invt.File_Number
76856>>>>>        Set Cascade_Delete_State To False
76857>>>>>
76857>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_FINDREQ to True
76858>>>>>        Set Foreign_Field_Option DD_INDEXFIELD DD_NOPUT to True
76859>>>>>        Set Foreign_Field_Option DD_DEFAULT DD_DISPLAYONLY to True
76860>>>>>
76860>>>>>        Set Add_Client_File to OrderDtl.File_Number
76861>>>>>
76861>>>>>        Set Add_Server_File to Vendor.File_Number
76862>>>>>
76862>>>>>
76862>>>>>        Set Field_Label_Long Field Invt.Item_ID To "Invt. Item ID"
76863>>>>>        Set Field_Label_Short Field Invt.Item_ID To "Item ID"
76864>>>>>        Set Field_Option Field Invt.Item_ID DD_AUTOFIND to True
76865>>>>>        Set Field_Option Field Invt.Item_ID DD_REQUIRED to True
76866>>>>>        Set Field_Option Field Invt.Item_ID DD_CAPSLOCK to True
76867>>>>>        Set Field_Prompt_Object Field Invt.Item_ID to Invt_sl
76868>>>>>        Set Key_Field_State Field Invt.Item_ID To True
76869>>>>>        Set Status_Help Field Invt.Item_ID To "Inventory Item Id - user defined identification"
76870>>>>>
76870>>>>>        Set Field_Label_Long Field Invt.Description To "Invt. Description"
76871>>>>>        Set Field_Label_Short Field Invt.Description To "Description"
76872>>>>>        Set Field_Option Field Invt.Description DD_REQUIRED to True
76873>>>>>        Set Status_Help Field Invt.Description To "Inventory Part Description"
76874>>>>>
76874>>>>>        Set Field_Option Field Invt.Vendor_ID DD_CAPSLOCK to True
76875>>>>>        Set Status_Help Field Invt.Vendor_ID To "Vendor Number"
76876>>>>>
76876>>>>>        Set Field_Option Field Invt.Vendor_Part_ID DD_REQUIRED to True
76877>>>>>        Set Status_Help Field Invt.Vendor_Part_ID To "Vendor ID name for this item"
76878>>>>>
76878>>>>>        Set Field_Mask_Type Field Invt.Unit_Price To MASK_CURRENCY_WINDOW
76879>>>>>        Set Field_Value_Range Field Invt.Unit_Price To 0 999999.99
76880>>>>>        Set Status_Help Field Invt.Unit_Price To "Retail unit price"
76881>>>>>
76881>>>>>        Set Field_Value_Range Field Invt.On_Hand To -999999 999999
76882>>>>>        Set Status_Help Field Invt.On_Hand To "Units currently available"
76883>>>>>
76883>>>>>    End_Procedure  //  Construct_Object
76884>>>>>  
76884>>>>>    Function Validate_Save Returns Integer
76886>>>>>        Integer iRetVal
76886>>>>>    
76886>>>>>        Forward Get Validate_Save to iRetVal
76888>>>>>        
76888>>>>>        If iRetVal Function_Return iRetVal
76891>>>>>    
76891>>>>>        If Invt.On_Hand Lt 0 Begin
76893>>>>>           Send UserError "Insufficient Inventory Stock" ""
76894>>>>>           Function_Return 1
76895>>>>>        End   
76895>>>>>>
76895>>>>>    End_Function  // Validate_Save
76896>>>>>
76896>>>>>
76896>>>>>    Procedure Field_Defaults
76898>>>>>        Forward Send Field_Defaults
76900>>>>>    End_Procedure    // Field_Defaults
76901>>>>>    
76901>>>>>End_Class    //  Invt_DataDictionary
76902>>>>>
76902>>>>>Use Invt.sl          // Invt_sl
Including file: Invt.sl    (C:\Test\Order Entry git\AppSrc\Invt.sl)
76902>>>>>>>Use DFClient.pkg
76902>>>>>>>Use DFSelLst.pkg
76902>>>>>>>Use Windows.pkg
76902>>>>>>>
76902>>>>>>>Use Vendor.DD
76902>>>>>>>Use Invt.DD
76902>>>>>>>
76902>>>>>>>CD_Popup_Object Invt_sl is a dbModalPanel
76920>>>>>>>>
76920>>>>>>>
76920>>>>>>>    Set Minimize_Icon to False
76921>>>>>>>    Set Label to "Inventory List"
76922>>>>>>>    Set Size to 133 284
76923>>>>>>>    Set Location to 4 4
76924>>>>>>>    Set piMinSize to 133 284
76925>>>>>>>
76925>>>>>>>    Object Vendor_DD is a Vendor_DataDictionary
76927>>>>>>>    End_Object    // Vendor_DD
76928>>>>>>>
76928>>>>>>>    Object Invt_DD is a Invt_DataDictionary
76930>>>>>>>        Set DDO_Server to Vendor_DD
76931>>>>>>>    End_Object    // Invt_DD
76932>>>>>>>
76932>>>>>>>    Set Main_DD to Invt_DD
76933>>>>>>>    Set Server to Invt_DD
76934>>>>>>>
76934>>>>>>>    Object oSelList is a cDbCJGridPromptList
76936>>>>>>>        Set Size to 105 273
76937>>>>>>>        Set Location to 6 6
76938>>>>>>>        Set peAnchors to anAll
76939>>>>>>>        Set pbAllowColumnRemove to False
76940>>>>>>>
76940>>>>>>>        Object oItemID is a cDbCJGridColumn
76942>>>>>>>            Entry_Item Invt.Item_iD
76943>>>>>>>            Set psCaption to "Item ID"
76944>>>>>>>            Set piWidth to 74
76945>>>>>>>        End_Object
76946>>>>>>>        
76946>>>>>>>        Object oDescription is a cDbCJGridColumn
76948>>>>>>>            Entry_Item Invt.Description
76949>>>>>>>            Set psCaption to "Description"
76950>>>>>>>            Set piWidth to 205
76951>>>>>>>        End_Object
76952>>>>>>>        
76952>>>>>>>        Object oUnitPrice is a cDbCJGridColumn
76954>>>>>>>            Entry_Item Invt.Unit_Price
76955>>>>>>>            Set psCaption to "Unit Price"
76956>>>>>>>            Set piWidth to 69
76957>>>>>>>        End_Object
76958>>>>>>>        
76958>>>>>>>        Object oOnHand is a cDbCJGridColumn
76960>>>>>>>            Entry_Item Invt.On_Hand
76961>>>>>>>            Set psCaption to "On Hand"
76962>>>>>>>            Set piWidth to 61
76963>>>>>>>        End_Object
76964>>>>>>>
76964>>>>>>>    End_Object    // oSelList
76965>>>>>>>
76965>>>>>>>    Object oOK_bn is a Button
76967>>>>>>>        Set Label to "&Ok"
76968>>>>>>>        Set Location to 115 123
76969>>>>>>>        Set peAnchors to anBottomRight
76970>>>>>>>
76970>>>>>>>        Procedure OnClick
76973>>>>>>>            Send OK of oSelList
76974>>>>>>>        End_Procedure
76975>>>>>>>
76975>>>>>>>    End_Object    // oOK_bn
76976>>>>>>>
76976>>>>>>>    Object oCancel_bn is a Button
76978>>>>>>>        Set Label to "&Cancel"
76979>>>>>>>        Set Location to 115 176
76980>>>>>>>        Set peAnchors to anBottomRight
76981>>>>>>>
76981>>>>>>>        Procedure OnClick
76984>>>>>>>            Send Cancel of oSelList
76985>>>>>>>        End_Procedure
76986>>>>>>>
76986>>>>>>>    End_Object    // oCancel_bn
76987>>>>>>>
76987>>>>>>>    Object oSearch_bn is a Button
76989>>>>>>>        Set Label to "&Search..."
76990>>>>>>>        Set Location to 115 229
76991>>>>>>>        Set peAnchors to anBottomRight
76992>>>>>>>
76992>>>>>>>        Procedure OnClick
76995>>>>>>>            Send Search of oSelList
76996>>>>>>>        End_Procedure
76997>>>>>>>
76997>>>>>>>    End_Object    // oSearch_bn
76998>>>>>>>
76998>>>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOk_bn
76999>>>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_bn
77000>>>>>>>    On_Key Key_Alt+Key_S Send KeyAction of oSearch_bn
77001>>>>>>>
77001>>>>>>>CD_End_Object    // Invt_sl
77003>>>>>>>>
77003>>>>>
77003>>>>>
77003>>>
77003>>>DEFERRED_VIEW Activate_oInventoryView FOR ;;Object oInventoryView is a dbView
77028>>>    Set Border_Style to Border_Thick
77029>>>    Set Label to "Inventory Item View"
77030>>>    Set Location to 5 8
77031>>>    Set Size to 151 305
77032>>>    Set piMaxSize to 115 350
77033>>>    Set piMinSize to 151 270
77034>>>
77034>>>    Object Vendor_DD is a Vendor_DataDictionary
77036>>>    End_Object    // Vendor_DD
77037>>>
77037>>>    Object Invt_DD is a Invt_DataDictionary
77039>>>        Set DDO_Server to Vendor_DD
77040>>>    End_Object    // Invt_DD
77041>>>
77041>>>    Set Main_DD to Invt_DD
77042>>>    Set Server to Invt_DD
77043>>>
77043>>>    Object oDbCont is a dbContainer3d
77045>>>        Set Size to 140 295
77046>>>        Set Location to 5 4
77047>>>        Set peAnchors to anAll
77048>>>        Object oInvt_Item_ID is a dbForm
77050>>>            Entry_Item Invt.Item_ID
77051>>>            Set Label to "Invt. Item ID:"
77052>>>            Set Size to 13 60
77053>>>            Set Location to 10 70
77054>>>            Set peAnchors to anTopLeft
77055>>>            Set Label_Col_Offset to 2
77056>>>            Set Label_Justification_Mode to jMode_Right
77057>>>        End_Object    // oInvt_Item_Id
77058>>>
77058>>>        Object oInvt_Description is a dbForm
77060>>>            Entry_Item Invt.Description
77061>>>            Set Label to "Invt. Description:"
77062>>>            Set Size to 13 210
77063>>>            Set Location to 25 70
77064>>>            Set peAnchors to anTopLeftRight
77065>>>            Set Label_Col_Offset to 2
77066>>>            Set Label_Justification_Mode to jMode_Right
77067>>>        End_Object    // oInvt_Description
77068>>>
77068>>>        Object oVendorGroup is a dbGroup
77070>>>            Set Size to 58 271
77071>>>            Set Location to 41 9
77072>>>            Set peAnchors to anAll
77073>>>            Set Label to "Vendor"
77074>>>            Object oInvt_Vendor_ID is a dbForm
77076>>>                Entry_Item Vendor.ID
77077>>>                Set Label to "Vendor ID:"
77078>>>                Set Size to 13 42
77079>>>                Set Location to 9 61
77080>>>                Set peAnchors to anTopLeft
77081>>>                Set Label_Col_Offset to 2
77082>>>                Set Label_Justification_Mode to jMode_Right
77083>>>            End_Object    // oInvt_Vendor_Id
77084>>>
77084>>>            Object oVendor_Name is a dbForm
77086>>>                Entry_Item Vendor.Name
77087>>>                Set Label to "Vendor Name:"
77088>>>                Set Size to 13 180
77089>>>                Set Location to 24 61
77090>>>                Set peAnchors to anTopLeftRight
77091>>>                Set Label_Col_Offset to 2
77092>>>                Set Label_Justification_Mode to jMode_Right
77093>>>            End_Object    // oVendor_Name
77094>>>
77094>>>            Object oInvt_Vendor_Part_ID is a dbForm
77096>>>                Entry_Item Invt.Vendor_Part_ID
77097>>>                Set Label to "Vendor Part ID:"
77098>>>                Set Size to 13 90
77099>>>                Set Location to 39 61
77100>>>                Set peAnchors to anTopLeft
77101>>>                Set Label_Col_Offset to 2
77102>>>                Set Label_Justification_Mode to jMode_Right
77103>>>            End_Object    // oInvt_Vendor_Part_ID
77104>>>
77104>>>        End_Object    // oVendorGroup
77105>>>
77105>>>        Object oUnitGroup is a dbGroup
77107>>>            Set Size to 28 271
77108>>>            Set Location to 101 9
77109>>>            Set peAnchors to anAll
77110>>>            Object oInvt_Unit_Price is a dbForm
77112>>>                Entry_Item Invt.Unit_Price
77113>>>                Set Label to "Unit Price:"
77114>>>                Set Size to 13 48
77115>>>                Set Location to 10 61
77116>>>                Set peAnchors to anTopLeft
77117>>>                Set Label_Col_Offset to 2
77118>>>                Set Label_Justification_Mode to jMode_Right
77119>>>            End_Object    // oInvt_Unit_Price
77120>>>
77120>>>            Object oInvt_On_Hand is a dbForm
77122>>>                Entry_Item Invt.On_Hand
77123>>>                Set Label to "On Hand:"
77124>>>                Set Size to 13 36
77125>>>                Set Location to 10 205
77126>>>                Set peAnchors to anTopRight
77127>>>                Set Label_Col_Offset to 2
77128>>>                Set Label_Justification_Mode to jMode_Right
77129>>>            End_Object    // oInvt_On_Hand
77130>>>
77130>>>        End_Object    // oUnitGroup
77131>>>
77131>>>    End_Object    // oDbCont
77132>>>
77132>>>CD_End_Object    // oInventoryView
77134>>>>
77134>        Use Order.vw
Including file: Order.vw    (C:\Test\Order Entry git\AppSrc\Order.vw)
77134>>>Use dfClient.pkg
77134>>>Use DataDict.pkg
77134>>>Use dfEntry.pkg
77134>>>Use dfSpnEnt.pkg
77134>>>Use dfCEntry.pkg
77134>>>Use dfTable.pkg
77134>>>Use Windows.pkg
77134>>>Use Vendor.DD
77134>>>Use Invt.DD
77134>>>Use Customer.DD
77134>>>Use SalesP.DD
Including file: SalesP.dd    (C:\Test\Order Entry git\DDSrc\SalesP.dd)
77134>>>>>Use  Windows.pkg           // Basic Definitions
77134>>>>>Use  DataDict.pkg          // DataDictionary Class Definition
77134>>>>>Use  DDvalTbl.pkg          // Validation Table Class Definitions
77134>>>>>
77134>>>>>Open Salesp
Including file: SalesP.fd    (C:\Test\Order Entry git\DDSrc\SalesP.fd)
77136>>>>>Open Orderhea
77138>>>>>
77138>>>>>Register_Object SalesP_sl
77138>>>>>
77138>>>>>Class SalesP_DataDictionary Is A DataDictionary
77139>>>>>
77139>>>>>    Procedure Construct_Object
77141>>>>>        Forward Send Construct_Object
77143>>>>>
77143>>>>>        Set Main_File To Salesp.File_Number
77144>>>>>        Set Cascade_Delete_State To FALSE
77145>>>>>
77145>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_NOPUT to True
77146>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_FINDREQ to True
77147>>>>>        Set Foreign_Field_Option DD_INDEXFIELD DD_NOPUT to True
77148>>>>>        Set Foreign_Field_Option DD_DEFAULT DD_DISPLAYONLY to True
77149>>>>>
77149>>>>>        Set Add_Client_File to Orderhea.File_Number
77150>>>>>
77150>>>>>
77150>>>>>        Set Field_Label_Long Field Salesp.Id To "Sales Person ID"
77151>>>>>        Set Field_Label_Short Field Salesp.Id To "ID"
77152>>>>>        Set Field_Option Field Salesp.Id DD_AUTOFIND to True
77153>>>>>        Set Field_Option Field Salesp.Id DD_REQUIRED to True
77154>>>>>        Set Field_Option Field Salesp.Id DD_CAPSLOCK to True
77155>>>>>        Set Field_Prompt_Object Field Salesp.Id to SalesP_sl
77156>>>>>        Set Key_Field_State Field Salesp.Id To TRUE
77157>>>>>        Set Status_Help Field Salesp.Id To "Sales person ID code - Upper case alpha"
77158>>>>>
77158>>>>>        Set Field_Label_Long Field Salesp.Name To "Sales Person Name"
77159>>>>>        Set Field_Label_Short Field Salesp.Name To "Sales Person Name"
77160>>>>>        Set Field_Prompt_Object Field Salesp.Name to SalesP_sl
77161>>>>>        Set Status_Help Field Salesp.Name To "Sales person name - first and last"
77162>>>>>
77162>>>>>    End_Procedure  //  Construct_Object
77163>>>>>
77163>>>>>
77163>>>>>    Procedure Field_Defaults
77165>>>>>        Forward Send Field_Defaults
77167>>>>>    End_Procedure    // Field_Defaults
77168>>>>>    
77168>>>>>End_Class    //  Salesp_DataDictionary
77169>>>>>
77169>>>>>Use SalesP.sl        // SalesP_sl
Including file: Salesp.sl    (C:\Test\Order Entry git\AppSrc\Salesp.sl)
77169>>>>>>>Use DFClient.pkg
77169>>>>>>>Use DFSelLst.pkg
77169>>>>>>>Use Windows.pkg
77169>>>>>>>Use cDbCJGridPromptList.pkg
77169>>>>>>>
77169>>>>>>>Use SalesP.DD
77169>>>>>>>
77169>>>>>>>CD_Popup_Object SalesP_sl is a dbModalPanel
77187>>>>>>>>
77187>>>>>>>
77187>>>>>>>    Set Minimize_Icon to False
77188>>>>>>>    Set Label to "Sales Person List"
77189>>>>>>>    Set Size to 99 260
77190>>>>>>>    Set Location to 4 5
77191>>>>>>>    Set piMinSize to 99 180
77192>>>>>>>
77192>>>>>>>    Object SalesP_DD is a SalesP_DataDictionary
77194>>>>>>>    End_Object    // Salesp_DD
77195>>>>>>>
77195>>>>>>>    Set Main_DD to SalesP_DD
77196>>>>>>>    Set Server to SalesP_DD
77197>>>>>>>
77197>>>>>>>    Object oSelList is a cDbCJGridPromptList
77199>>>>>>>        Set Size to 70 249
77200>>>>>>>        Set Location to 6 5
77201>>>>>>>        Set pbAllowColumnRemove to False
77202>>>>>>>        Set peAnchors to anAll
77203>>>>>>>
77203>>>>>>>        Object oSalesP_ID is a cDbCJGridColumn
77205>>>>>>>            Entry_Item SalesP.ID
77206>>>>>>>            Set piWidth to 60
77207>>>>>>>            Set psCaption to "ID"
77208>>>>>>>        End_Object
77209>>>>>>>
77209>>>>>>>        Object oSalesP_Name is a cDbCJGridColumn
77211>>>>>>>            Entry_Item SalesP.Name
77212>>>>>>>            Set piWidth to 313
77213>>>>>>>            Set psCaption to "Sales Person Name"
77214>>>>>>>        End_Object
77215>>>>>>>    End_Object
77216>>>>>>>
77216>>>>>>>    Object oOK_bn is a Button
77218>>>>>>>        Set Label to "&Ok"
77219>>>>>>>        Set Location to 81 99
77220>>>>>>>        Set peAnchors to anBottomRight
77221>>>>>>>        Set Default_State to True
77222>>>>>>>
77222>>>>>>>        Procedure OnClick
77225>>>>>>>            Send OK of oSelList
77226>>>>>>>        End_Procedure
77227>>>>>>>
77227>>>>>>>    End_Object    // oOK_bn
77228>>>>>>>
77228>>>>>>>    Object oCancel_bn is a Button
77230>>>>>>>        Set Label to "&Cancel"
77231>>>>>>>        Set Location to 81 152
77232>>>>>>>        Set peAnchors to anBottomRight
77233>>>>>>>
77233>>>>>>>        Procedure OnClick
77236>>>>>>>            Send Cancel of oSelList
77237>>>>>>>        End_Procedure
77238>>>>>>>
77238>>>>>>>    End_Object    // oCancel_bn
77239>>>>>>>
77239>>>>>>>    Object oSearch_bn is a Button
77241>>>>>>>        Set Label to "&Search..."
77242>>>>>>>        Set Location to 81 205
77243>>>>>>>        Set peAnchors to anBottomRight
77244>>>>>>>
77244>>>>>>>        Procedure OnClick
77247>>>>>>>            Send Search of oSelList
77248>>>>>>>        End_Procedure
77249>>>>>>>
77249>>>>>>>    End_Object    // oSearch_bn
77250>>>>>>>
77250>>>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOk_bn
77251>>>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_bn
77252>>>>>>>    On_Key Key_Alt+Key_S Send KeyAction of oSearch_bn
77253>>>>>>>
77253>>>>>>>CD_End_Object    // SalesP_sl
77255>>>>>>>>
77255>>>>>
77255>>>>>
77255>>>Use OrderHea.DD
Including file: OrderHea.dd    (C:\Test\Order Entry git\DDSrc\OrderHea.dd)
77255>>>>>Use  Windows.pkg           // Basic Definitions
77255>>>>>Use  DataDict.pkg          // DataDictionary Class Definition
77255>>>>>Use  DDvalTbl.pkg          // Validation Table Class Definitions
77255>>>>>
77255>>>>>Open OrderHea
77257>>>>>Open OrderDtl
77259>>>>>Open Customer
77261>>>>>Open SalesP
77263>>>>>Open OrdSys
77265>>>>>
77265>>>>>
77265>>>>>Register_Object Terms_table
77265>>>>>Register_Object Ship_Table
77265>>>>>
77265>>>>>Object Terms_table  is a DescriptionValidationTable
77267>>>>>
77267>>>>>    Procedure Fill_List
77270>>>>>        Forward Send Fill_List
77272>>>>>        Send Add_Table_Value  "NONE"  "None established"
77273>>>>>        Send Add_Table_Value  "COD"  "COD"
77274>>>>>        Send Add_Table_Value  "NET30"  "Net 30"
77275>>>>>        Send Add_Table_Value  "NET60"  "Net 60"
77276>>>>>        Send Add_Table_Value  "NET90"  "Net 90"
77277>>>>>        Send Add_Table_Value  "PREPAY"  "Pre-payment required"
77278>>>>>    End_Procedure    // Fill_List
77279>>>>>End_Object   // Terms_table
77280>>>>>
77280>>>>>Object Ship_Table  is a CodeValidationTable
77282>>>>>    Set Type_Value        To "SHIPPING"
77283>>>>>    Set Allow_Blank_State To True
77284>>>>>End_Object   // Ship_Table
77285>>>>>
77285>>>>>Register_Object OrderHea_sl
77285>>>>>
77285>>>>>Class OrderHea_DataDictionary Is A DataDictionary
77286>>>>>
77286>>>>>    Procedure Construct_Object
77288>>>>>        Forward Send Construct_Object
77290>>>>>
77290>>>>>        Set Main_File To OrderHea.File_Number
77291>>>>>
77291>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_FINDREQ to True
77292>>>>>        Set Foreign_Field_Option DD_INDEXFIELD DD_NOPUT to True
77293>>>>>        Set Foreign_Field_Option DD_DEFAULT DD_DISPLAYONLY to True
77294>>>>>
77294>>>>>        Set Add_Client_File to OrderDtl.File_Number
77295>>>>>
77295>>>>>        Set Add_Server_File to Customer.File_Number
77296>>>>>        Set Add_Server_File to SalesP.File_Number
77297>>>>>
77297>>>>>        Set ParentNullAllowed SalesP.File_Number to True
77298>>>>>        Set ParentNoSwitchIfCommitted Customer.File_Number to True
77299>>>>>
77299>>>>>        Set Add_System_File to OrdSys.File_Number DD_LOCK_ON_NEW_SAVE_DELETE
77300>>>>>
77300>>>>>        Set Field_Auto_Increment Field OrderHea.Order_Number to File_Field OrdSys.Order_Number
77301>>>>>
77301>>>>>
77301>>>>>        Set Field_Option Field OrderHea.Order_Number DD_AUTOFIND to True
77302>>>>>        Set Field_Prompt_Object Field OrderHea.Order_Number to OrderHea_SL
77303>>>>>        Set Key_Field_State Field OrderHea.Order_Number To True
77304>>>>>        Set Status_Help Field OrderHea.Order_Number To "Order Number - New orders are assigned numbers automatically"
77305>>>>>
77305>>>>>
77305>>>>>        Set Field_Class_Name Field OrderHea.Order_Date To "dbSpinForm"
77306>>>>>        Set Field_Entry_msg Field OrderHea.Order_Date To Entry_Order_Date
77307>>>>>        Set Field_Mask_Type Field OrderHea.Order_Date To MASK_DATE_WINDOW
77308>>>>>        Set Field_Prompt_Object Field OrderHea.Order_Date to OrderHea_SL
77309>>>>>        Set Status_Help Field OrderHea.Order_Date To "Date on which the order was placed"
77310>>>>>        Set Field_Option Field OrderHea.Order_Date DD_COMMIT to True
77311>>>>>
77311>>>>>        Set Field_Class_Name Field OrderHea.Terms To "dbComboForm"
77312>>>>>        Set Field_Value_Table Field OrderHea.Terms to Terms_table
77313>>>>>        Set Status_Help Field OrderHea.Terms To "Payment terms"
77314>>>>>
77314>>>>>        Set Field_Class_Name Field OrderHea.Ship_Via To "dbComboForm"
77315>>>>>        Set Field_Value_Table Field OrderHea.Ship_Via to Ship_Table
77316>>>>>        Set Status_Help Field OrderHea.Ship_Via To "Shipping method"
77317>>>>>
77317>>>>>        Set Status_Help Field OrderHea.Ordered_By To "Order placed by"
77318>>>>>        Set Field_Option Field OrderHea.Ordered_By DD_COMMIT to True
77319>>>>>
77319>>>>>        Set Field_Label_Long Field OrderHea.Salesperson_ID To "Sales Person ID"
77320>>>>>        Set Field_Label_Short Field OrderHea.Salesperson_ID To "Sales ID"
77321>>>>>        Set Status_Help Field OrderHea.Salesperson_ID To "Sales Person who initiated the order"
77322>>>>>
77322>>>>>        Set Field_Mask_Type Field OrderHea.Order_Total To MASK_CURRENCY_WINDOW
77323>>>>>        Set Field_Option Field OrderHea.Order_Total DD_DISPLAYONLY to True
77324>>>>>
77324>>>>>
77324>>>>>    End_Procedure  // Construct_Object
77325>>>>>
77325>>>>>    Procedure Field_Defaults
77327>>>>>        Forward Send Field_Defaults
77329>>>>>    End_Procedure
77330>>>>>
77330>>>>>    // Add a default date if the field is blank
77330>>>>>    Procedure Entry_Order_Date Integer iField Date dDate
77332>>>>>         Integer iChanged
77332>>>>>         
77332>>>>>         Get Field_Changed_State iField To iChanged
77333>>>>>         If (iChanged=0 And dDate=0) Begin
77335>>>>>            SysDate dDate
77336>>>>>            Set Field_Default_Value iField To dDate
77337>>>>>         End
77337>>>>>>
77337>>>>>    End_Procedure
77338>>>>>
77338>>>>>    Procedure Update
77340>>>>>        Forward Send Update
77342>>>>>        Send Adjust_Balances OrderHea.Order_Total
77343>>>>>    End_Procedure
77344>>>>>
77344>>>>>    Procedure Backout
77346>>>>>        Forward Send Backout
77348>>>>>        Send Adjust_Balances (-OrderHea.Order_Total)
77349>>>>>    End_Procedure
77350>>>>>
77350>>>>>    Procedure Adjust_Balances Number Amt
77352>>>>>        Add Amt To Customer.Purchases
77353>>>>>        Add Amt To Customer.Balance
77354>>>>>    End_Procedure
77355>>>>>
77355>>>>>    Procedure Deleting
77357>>>>>        Forward Send Deleting
77359>>>>>        // see if we can decrement the order number in sys file...can only do
77359>>>>>        // this if this is the newest order.
77359>>>>>        If (OrderHea.Order_Number=OrdSys.Order_Number) Begin // if this is
77361>>>>>           Decrement OrdSys.Order_Number          // the last number,
77362>>>>>           Saverecord OrdSys                      // decrement and save.
77363>>>>>        End
77363>>>>>>
77363>>>>>    End_Procedure
77364>>>>>
77364>>>>>End_Class    //  OrderHea_DataDictionary
77365>>>>>
77365>>>>>Use OrderHea.sl      // OrderHea_sl
Including file: Orderhea.sl    (C:\Test\Order Entry git\AppSrc\Orderhea.sl)
77365>>>>>>>Use DFClient.pkg
77365>>>>>>>Use DFSelLst.pkg
77365>>>>>>>Use Windows.pkg
77365>>>>>>>Use cDbCJGridPromptList.pkg
77365>>>>>>>
77365>>>>>>>Use Customer.DD
77365>>>>>>>Use OrderHea.DD
77365>>>>>>>
77365>>>>>>>
77365>>>>>>>CD_Popup_Object OrderHea_sl is a dbModalPanel
77383>>>>>>>>
77383>>>>>>>
77383>>>>>>>    Set Minimize_Icon to False
77384>>>>>>>    Set Label to "Order List"
77385>>>>>>>    Set Size to 134 392
77386>>>>>>>    Set Location to 4 5
77387>>>>>>>    Set piMinSize to 134 392
77388>>>>>>>
77388>>>>>>>    Object Customer_DD is a Customer_DataDictionary
77390>>>>>>>    End_Object    // Customer_DD
77391>>>>>>>
77391>>>>>>>    Object OrderHea_DD is a OrderHea_DataDictionary
77393>>>>>>>        Set DDO_Server to Customer_DD
77394>>>>>>>    End_Object    // OrderHea_DD
77395>>>>>>>
77395>>>>>>>    Set Main_DD to OrderHea_DD
77396>>>>>>>    Set Server to OrderHea_DD
77397>>>>>>>
77397>>>>>>>    Object oSelList is a cDbCJGridPromptList
77399>>>>>>>        Set Size to 100 377
77400>>>>>>>        Set Location to 9 7
77401>>>>>>>        Set pbAllowColumnRemove to False
77402>>>>>>>        Set peAnchors to anAll
77403>>>>>>>
77403>>>>>>>        Object oOrderHea_Order_Number is a cDbCJGridColumn
77405>>>>>>>            Entry_Item OrderHea.Order_Number
77406>>>>>>>            Set piWidth to 87
77407>>>>>>>            Set psCaption to "Order Number"
77408>>>>>>>        End_Object
77409>>>>>>>
77409>>>>>>>        Object oCustomer_Customer_Number is a cDbCJGridColumn
77411>>>>>>>            Entry_Item Customer.Customer_Number
77412>>>>>>>            Set piWidth to 84
77413>>>>>>>            Set psCaption to "Cust. Number"
77414>>>>>>>        End_Object
77415>>>>>>>
77415>>>>>>>        Object oCustomer_Name is a cDbCJGridColumn
77417>>>>>>>            Entry_Item Customer.Name
77418>>>>>>>            Set piWidth to 231
77419>>>>>>>            Set psCaption to "Customer Name"
77420>>>>>>>        End_Object
77421>>>>>>>
77421>>>>>>>        Object oOrderHea_Order_Date is a cDbCJGridColumn
77423>>>>>>>            Entry_Item OrderHea.Order_Date
77424>>>>>>>            Set piWidth to 75
77425>>>>>>>            Set psCaption to "Order Date"
77426>>>>>>>            Set peTextAlignment to xtpAlignmentRight
77427>>>>>>>        End_Object
77428>>>>>>>
77428>>>>>>>        Object oOrderHea_Order_Total is a cDbCJGridColumn
77430>>>>>>>            Entry_Item OrderHea.Order_Total
77431>>>>>>>            Set piWidth to 88
77432>>>>>>>            Set psCaption to "Order Total"
77433>>>>>>>        End_Object
77434>>>>>>>    End_Object
77435>>>>>>>
77435>>>>>>>    Object oOK_bn is a Button
77437>>>>>>>        Set Label to "&Ok"
77438>>>>>>>        Set Location to 116 231
77439>>>>>>>        Set peAnchors to anBottomRight
77440>>>>>>>
77440>>>>>>>        Procedure OnClick
77443>>>>>>>            Send OK of oSelList
77444>>>>>>>        End_Procedure
77445>>>>>>>
77445>>>>>>>    End_Object    // oOK_bn
77446>>>>>>>
77446>>>>>>>    Object oCancel_bn is a Button
77448>>>>>>>        Set Label to "&Cancel"
77449>>>>>>>        Set Location to 116 284
77450>>>>>>>        Set peAnchors to anBottomRight
77451>>>>>>>
77451>>>>>>>        Procedure OnClick
77454>>>>>>>            Send Cancel of oSelList
77455>>>>>>>        End_Procedure
77456>>>>>>>
77456>>>>>>>    End_Object    // oCancel_bn
77457>>>>>>>
77457>>>>>>>    Object oSearch_bn is a Button
77459>>>>>>>        Set Label to "&Search..."
77460>>>>>>>        Set Location to 116 337
77461>>>>>>>        Set peAnchors to anBottomRight
77462>>>>>>>
77462>>>>>>>        Procedure OnClick
77465>>>>>>>            Send Search of oSelList
77466>>>>>>>        End_Procedure
77467>>>>>>>
77467>>>>>>>    End_Object    // oSearch_bn
77468>>>>>>>
77468>>>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOk_bn
77469>>>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_bn
77470>>>>>>>    On_Key Key_Alt+Key_S Send KeyAction of oSearch_bn
77471>>>>>>>
77471>>>>>>>CD_End_Object    // OrderHea_sl
77473>>>>>>>>
77473>>>>>
77473>>>>>
77473>>>Use OrderDtl.DD
Including file: OrderDtl.dd    (C:\Test\Order Entry git\DDSrc\OrderDtl.dd)
77473>>>>>Use  Windows.pkg           // Basic Definitions
77473>>>>>Use  DataDict.pkg          // DataDictionary Class Definition
77473>>>>>Use  DDvalTbl.pkg          // Validation Table Class Definitions
77473>>>>>
77473>>>>>Open OrderDtl
77475>>>>>Open OrderHea
77477>>>>>Open Invt
77479>>>>>
77479>>>>>
77479>>>>>Class OrderDtl_DataDictionary Is A DataDictionary
77480>>>>>
77480>>>>>    Procedure Construct_Object
77482>>>>>        Forward Send Construct_Object
77484>>>>>
77484>>>>>        Set Main_File To OrderDtl.File_Number
77485>>>>>        Set Cascade_Delete_State To False
77486>>>>>
77486>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_FINDREQ to True
77487>>>>>        Set Foreign_Field_Option DD_INDEXFIELD DD_NOPUT to True
77488>>>>>        Set Foreign_Field_Option DD_DEFAULT DD_DISPLAYONLY to True
77489>>>>>
77489>>>>>        Set Add_Server_File to OrderHea.File_Number
77490>>>>>        Set Add_Server_File to Invt.File_Number
77491>>>>>
77491>>>>>        Set Field_Auto_Increment Field OrderDtl.Detail_Number to File_Field OrderHea.Last_Detail_Num
77492>>>>>
77492>>>>>
77492>>>>>        Set Field_Option Field OrderDtl.Order_Number DD_NOPUT to True
77493>>>>>
77493>>>>>        Set Field_Option Field OrderDtl.Detail_Number DD_NOPUT to True
77494>>>>>
77494>>>>>
77494>>>>>        Set Field_Exit_msg Field OrderDtl.Qty_Ordered To Adjust_Display_Total
77495>>>>>        Set Field_Label_Long Field OrderDtl.Qty_Ordered To "Quantity Ordered"
77496>>>>>        Set Field_Label_Short Field OrderDtl.Qty_Ordered To "Quantity"
77497>>>>>        Set Field_Mask_Type Field OrderDtl.Qty_Ordered To MASK_NUMERIC_WINDOW
77498>>>>>        Set Status_Help Field OrderDtl.Qty_Ordered To "Number of items ordered"
77499>>>>>
77499>>>>>        Set Field_Entry_msg Field OrderDtl.Price To Entering_Price
77500>>>>>        Set Field_Exit_msg Field OrderDtl.Price To Adjust_Display_Total
77501>>>>>        Set Field_Label_Long Field OrderDtl.Price To "Price per Unit"
77502>>>>>        Set Field_Label_Short Field OrderDtl.Price To "Price"
77503>>>>>        Set Field_Mask_Type Field OrderDtl.Price To MASK_CURRENCY_WINDOW
77504>>>>>        Set Status_Help Field OrderDtl.Price To "Price per Unit"
77505>>>>>
77505>>>>>        Set Field_Label_Long Field OrderDtl.Extended_Price To "Extended Price"
77506>>>>>        Set Field_Label_Short Field OrderDtl.Extended_Price To "Total"
77507>>>>>        Set Field_Mask_Type Field OrderDtl.Extended_Price To MASK_CURRENCY_WINDOW
77508>>>>>        Set Field_Option Field OrderDtl.Extended_Price DD_DISPLAYONLY to True
77509>>>>>        Set Status_Help Field OrderDtl.Extended_Price To "Total extended price"
77510>>>>>
77510>>>>>    End_Procedure  //  Construct_Object
77511>>>>>
77511>>>>>    // Update and Backout need to adjust the Invt.On_Hand quantity,
77511>>>>>    // the dtl line's extended price and the OrderHea total. We will call
77511>>>>>    // the same procedure (Adjust_Balances) to insure that backout and
77511>>>>>    // update are inverses of each other.
77511>>>>>    // Note that Backout does not need to change the extended_price. This
77511>>>>>    // only gets changed as part of update.
77511>>>>>    Procedure Update
77513>>>>>        Forward Send Update
77515>>>>>        Move (OrderDtl.Price * OrderDtl.Qty_Ordered) To OrderDtl.Extended_Price
77516>>>>>        Send Adjust_Balances OrderDtl.Qty_Ordered OrderDtl.Extended_Price
77517>>>>>    End_Procedure
77518>>>>>    
77518>>>>>    Procedure Backout
77520>>>>>        Forward Send Backout
77522>>>>>        Send Adjust_Balances (-OrderDtl.Qty_Ordered) (-OrderDtl.Extended_Price)
77523>>>>>    End_Procedure
77524>>>>>
77524>>>>>    // Called by Backout and Update passing the quantity
77524>>>>>    // and the extended price. 
77524>>>>>    // Subtract quantity from Invt on-hand and
77524>>>>>    // add extended amnt to order total.
77524>>>>>    Procedure Adjust_Balances Number Qty Number Amt
77526>>>>>        Subtract Qty From Invt.On_Hand
77527>>>>>        Add      Amt To   OrderHea.Order_Total
77528>>>>>    End_Procedure
77529>>>>>
77529>>>>>    // when entering the price field we may wish to update the
77529>>>>>    // current field value with the standard unit price from the
77529>>>>>    // Invt file. Only do this if the current amount is zero and an item was actually picked. If non-
77529>>>>>    // zero or no item picked, we assume the field is being edited (and we make no assumptions). 
77529>>>>>    Procedure Entering_Price Integer Field# Number nAmnt
77531>>>>>        Handle hoInvtDD
77531>>>>>        Boolean bHasRecord
77531>>>>>
77531>>>>>        Get Data_Set Invt.File_Number to hoInvtDD
77532>>>>>
77532>>>>>        If (hoInvtDD) Begin
77534>>>>>            Get HasRecord of hoInvtDD to bHasRecord
77535>>>>>        
77535>>>>>            If (nAmnt=0 and bHasRecord) Begin
77537>>>>>               Get File_Field_Current_Value File_Field Invt.Unit_Price to nAmnt
77538>>>>>               Set Field_Changed_Value Field# to nAmnt
77539>>>>>               Send Adjust_Display_Total
77540>>>>>            End
77540>>>>>>
77540>>>>>        End
77540>>>>>>
77540>>>>>        
77540>>>>>    End_Procedure
77541>>>>>
77541>>>>>    // This updates the extended price field, which will update any 
77541>>>>>    // display balances. This is only done for display purposes. The actual
77541>>>>>    // amount is updated to the field during the save.
77541>>>>>    Procedure Adjust_Display_total Integer iField String sValue
77543>>>>>        Integer iQty
77543>>>>>        Number  nAmnt
77543>>>>>        
77543>>>>>        Get Field_Current_Value Field OrderDtl.Qty_Ordered    To iQty
77544>>>>>        Get Field_Current_Value Field OrderDtl.Price          To nAmnt
77545>>>>>        Set Field_Current_Value Field OrderDtl.Extended_Price To (nAmnt * iQty)
77546>>>>>        // note we set value, but not changed state!
77546>>>>>    End_Procedure
77547>>>>>
77547>>>>>
77547>>>>>    Procedure Field_Defaults
77549>>>>>        Forward Send Field_Defaults
77551>>>>>    End_Procedure    // Field_Defaults
77552>>>>>    
77552>>>>>End_Class    //  OrderDtl_DataDictionary
77553>>>>>
77553>>>Use cDbCJGrid.pkg
77553>>>Use cCJGridColumnRowIndicator.pkg
Including file: cCJGridColumnRowIndicator.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cCJGridColumnRowIndicator.pkg)
77553>>>>>Use cCJGridColumn.pkg
77553>>>>>
77553>>>>>Class cCJGridColumnRowIndicator is a cCJGridColumn
77554>>>>>    
77554>>>>>    Procedure Construct_Object
77556>>>>>        Forward Send Construct_Object
77558>>>>>    
77558>>>>>        Property Integer piImage 0
77559>>>>>        
77559>>>>>        Set psCaption to ""
77560>>>>>        Set piWidth to 20
77561>>>>>        Set pbResizable to False
77562>>>>>        Set pbEditable to False
77563>>>>>        Set pbFocusable to False
77564>>>>>        Set pbAllowDrag to False
77565>>>>>        Set psToolTip to "Row Indicator"
77566>>>>>//        Set Color to (RGB(217,222,243))   //JVH
77566>>>>>    End_Procedure
77567>>>>>    
77567>>>>>    Procedure OnCreateColumn
77569>>>>>        Integer iImage
77569>>>>>        Delegate Get AddImage "GridColumnRowIndicator.bmp" 0 to iImage
77571>>>>>        Set piImage to iImage
77572>>>>>    End_Procedure
77573>>>>>            
77573>>>>>    Procedure OnSetDisplayMetrics Handle hoGridItemMetrics Integer iRow String ByRef sValue
77575>>>>>        Integer iImage iFocusedRow
77575>>>>>        Handle hoDataSource
77575>>>>>        
77575>>>>>        Get phoDataSource to hoDataSource
77576>>>>>        Get SelectedRow of hoDataSource to iFocusedRow
77577>>>>>        Move -1 to iImage
77578>>>>>        If (iRow = iFocusedRow) Begin
77580>>>>>            Get piImage to iImage
77581>>>>>            Set ComItemIcon of hoGridItemMetrics to iImage
77582>>>>>        End
77582>>>>>>
77582>>>>>    End_Procedure
77583>>>>>
77583>>>>>End_Class
77584>>>
77584>>>Use MonthCalendarPrompt.dg
Including file: MonthCalendarPrompt.dg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\MonthCalendarPrompt.dg)
77584>>>>>// Month Calendar Prompt dialog
77584>>>>>
77584>>>>>
77584>>>>>Use cMonthCalendarPrompt.pkg
Including file: cMonthCalendarPrompt.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cMonthCalendarPrompt.pkg)
77584>>>>>>>Use cMonthCalendar.pkg
Including file: cMonthCalendar.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cMonthCalendar.pkg)
77584>>>>>>>>>Use Windows.pkg
77584>>>>>>>>>Use Commctrl.pkg
77584>>>>>>>>>Use tWinStructs.pkg
77584>>>>>>>>>Use cWinControlEx.pkg
Including file: cWinControlEx.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cWinControlEx.pkg)
77584>>>>>>>>>>>Use cWinControl.pkg
77584>>>>>>>>>>>// This adds proper navigation and default button support for
77584>>>>>>>>>>>// external classes
77584>>>>>>>>>>>
77584>>>>>>>>>>>Class cWinControlEx is a cWinControl
77585>>>>>>>>>>>    Import_Class_Protocol Standard_Form_Mixin
77586>>>>>>>>>>>    Procedure Construct_Object
77588>>>>>>>>>>>        Forward Send Construct_Object
77590>>>>>>>>>>>        Send define_standard_Form_Mixin
77591>>>>>>>>>>>    End_Procedure
77592>>>>>>>>>>>    
77592>>>>>>>>>>>    Function item_count Integer iItem Returns Integer
77594>>>>>>>>>>>        Function_Return 1
77595>>>>>>>>>>>    End_Function
77596>>>>>>>>>>>    
77596>>>>>>>>>>>    Procedure External_SetFocus
77598>>>>>>>>>>>        Send notify_focus_change 1
77599>>>>>>>>>>>    End_Procedure
77600>>>>>>>>>>>
77600>>>>>>>>>>>    Procedure External_KillFocus
77602>>>>>>>>>>>        Send notify_focus_change 0
77603>>>>>>>>>>>    End_Procedure
77604>>>>>>>>>>>
77604>>>>>>>>>>>    Procedure End_Construct_Object
77606>>>>>>>>>>>        Forward Send End_Construct_Object
77608>>>>>>>>>>>        Set External_Message WM_SETFOCUS  to External_SetFocus
77609>>>>>>>>>>>        Set External_Message WM_KILLFOCUS to External_KillFocus
77610>>>>>>>>>>>    End_Procedure
77611>>>>>>>>>>>        
77611>>>>>>>>>>>End_Class
77612>>>>>>>>>>>
77612>>>>>>>>>
77612>>>>>>>>>Class cMonthCalendar is a cWinControlEx
77613>>>>>>>>>    Procedure Construct_Object
77615>>>>>>>>>        Integer iResult
77615>>>>>>>>>        tWinInitCommonControlsEX InitCC
77615>>>>>>>>>        tWinInitCommonControlsEX InitCC
77615>>>>>>>>>
77615>>>>>>>>>        Forward Send Construct_Object
77617>>>>>>>>>
77617>>>>>>>>>        Move (SizeOfType (tWinInitCommonControlsEX)) to InitCC.dwSize
77618>>>>>>>>>        Move ICC_DATE_CLASSES to InitCC.dwICC
77619>>>>>>>>>        Move (InitCommonControlsEx(AddressOf(InitCC))) to iResult
77620>>>>>>>>>        
77620>>>>>>>>>        Set External_Class_Name 'cMonthCalendar' to 'SysMonthCal32'
77621>>>>>>>>>        Set External_Message WM_LBUTTONDBLCLK to msg_OnLButtonDblClick
77622>>>>>>>>>        
77622>>>>>>>>>        Set Border_Style to Border_Normal
77623>>>>>>>>>        
77623>>>>>>>>>        Property Boolean pbNoToday False
77624>>>>>>>>>        Property Boolean pbNoTodayCircle False
77625>>>>>>>>>        Property Boolean pbMultiSelect False
77626>>>>>>>>>        Property Boolean pbWeekNumbers False
77627>>>>>>>>>        Property Integer piMaxSelectedCount 90
77628>>>>>>>>>        
77628>>>>>>>>>        // this is minimum Dialog units required for a single picker rectangle
77628>>>>>>>>>        Property Integer piMinWidth 0
77629>>>>>>>>>        Property Integer piMinHeight 0
77630>>>>>>>>>
77630>>>>>>>>>        // stores initial date before control is activated
77630>>>>>>>>>        Property Date pdPrivateDate 
77631>>>>>>>>>        // if multi-select, this is the end range
77631>>>>>>>>>        Property Date pdPrivateDate2 
77632>>>>>>>>>        
77632>>>>>>>>>    End_Procedure
77633>>>>>>>>>    
77633>>>>>>>>>    // returns control's value when single select
77633>>>>>>>>>    Function SelectedDate Returns Date
77635>>>>>>>>>        tWinSystemTime CurrentSystemTime
77635>>>>>>>>>        tWinSystemTime CurrentSystemTime
77635>>>>>>>>>        Integer iRetval
77635>>>>>>>>>        DateTime dtSel
77635>>>>>>>>>        Handle hWnd
77635>>>>>>>>>        Get Window_Handle to hWnd
77636>>>>>>>>>        If (hWnd) Begin
77638>>>>>>>>>            Move (Windows_Message (MCM_GETCURSEL, 0, AddressOf (CurrentSystemTime))) to iRetval
77639>>>>>>>>>            Move (DateSetDay(dtSel,CurrentSystemTime.wDay)) to dtSel
77640>>>>>>>>>            Move (DateSetMonth(dtSel,CurrentSystemTime.wMonth)) to dtSel
77641>>>>>>>>>            Move (DateSetYear(dtSel,CurrentSystemTime.wYear)) to dtSel
77642>>>>>>>>>        End
77642>>>>>>>>>>
77642>>>>>>>>>        Else Begin
77643>>>>>>>>>            Get pdPrivateDate to dtSel
77644>>>>>>>>>        End
77644>>>>>>>>>>
77644>>>>>>>>>        Function_Return (Date(dtSel))
77645>>>>>>>>>    End_Function
77646>>>>>>>>>
77646>>>>>>>>>    // returns control's values when multi select
77646>>>>>>>>>    Function SelectedDateRange Returns Date[]
77648>>>>>>>>>        tWinSystemTime[2] CurrentSystemTime
77648>>>>>>>>>        tWinSystemTime[2] CurrentSystemTime
77649>>>>>>>>>        Integer iRetval
77649>>>>>>>>>        DateTime dtSel1 dtsel2
77649>>>>>>>>>        Date[] dtSel
77650>>>>>>>>>        Handle hWnd
77650>>>>>>>>>        Get Window_Handle to hWnd
77651>>>>>>>>>        If (hWnd) Begin
77653>>>>>>>>>            Move (Windows_Message (MCM_GETSELRANGE, 0, AddressOf (CurrentSystemTime))) to iRetval
77654>>>>>>>>>            
77654>>>>>>>>>            Move (DateSetDay(dtSel1,CurrentSystemTime[0].wDay)) to dtSel1
77655>>>>>>>>>            Move (DateSetMonth(dtSel1,CurrentSystemTime[0].wMonth)) to dtSel1
77656>>>>>>>>>            Move (DateSetYear(dtSel1,CurrentSystemTime[0].wYear)) to dtSel1
77657>>>>>>>>>            
77657>>>>>>>>>            Move (DateSetDay(dtSel2,CurrentSystemTime[1].wDay)) to dtSel2
77658>>>>>>>>>            Move (DateSetMonth(dtSel2,CurrentSystemTime[1].wMonth)) to dtSel2
77659>>>>>>>>>            Move (DateSetYear(dtSel2,CurrentSystemTime[1].wYear)) to dtSel2
77660>>>>>>>>>            
77660>>>>>>>>>            Move dtSel1 to dtSel[0]
77661>>>>>>>>>            Move dtsel2 to dtSel[1]
77662>>>>>>>>>        End
77662>>>>>>>>>>
77662>>>>>>>>>        Else Begin
77663>>>>>>>>>            Get pdPrivateDate to dtSel[0]
77664>>>>>>>>>            Get pdPrivateDate2 to dtSel[1]
77665>>>>>>>>>        End
77665>>>>>>>>>>
77665>>>>>>>>>        Function_Return dtSel
77666>>>>>>>>>    End_Function
77667>>>>>>>>>
77667>>>>>>>>>    // Set control's value when single select
77667>>>>>>>>>    Procedure SetSelectedDate Date dDate
77669>>>>>>>>>        tWinSystemTime CurrentSystemTime
77669>>>>>>>>>        tWinSystemTime CurrentSystemTime
77669>>>>>>>>>        Integer iRetval
77669>>>>>>>>>        Handle hWnd
77669>>>>>>>>>        
77669>>>>>>>>>        Get Window_Handle to hWnd
77670>>>>>>>>>        Set pdPrivateDate to dDate
77671>>>>>>>>>        If (hWnd) Begin
77673>>>>>>>>>            Move (DateGetDay(dDate)) to CurrentSystemTime.wDay
77674>>>>>>>>>            Move (DateGetMonth(dDate)) to CurrentSystemTime.wMonth
77675>>>>>>>>>            Move (DateGetYear(dDate)) to CurrentSystemTime.wYear
77676>>>>>>>>>    
77676>>>>>>>>>           Move (Windows_Message (MCM_SETCURSEL, 0, AddressOf (CurrentSystemTime))) to iRetval        
77677>>>>>>>>>        End
77677>>>>>>>>>>
77677>>>>>>>>>    End_Procedure
77678>>>>>>>>>
77678>>>>>>>>>    // Set control's values when multi select
77678>>>>>>>>>    Procedure SetSelectedDateRange Date dDate Date dDate2
77680>>>>>>>>>        tWinSystemTime[] CurrentSystemTime
77680>>>>>>>>>        tWinSystemTime[] CurrentSystemTime
77681>>>>>>>>>        Integer iRetval
77681>>>>>>>>>        Handle hWnd
77681>>>>>>>>>
77681>>>>>>>>>        Get Window_Handle to hWnd
77682>>>>>>>>>        Set pdPrivateDate to dDate
77683>>>>>>>>>        Set pdPrivateDate2 to dDate2
77684>>>>>>>>>        If (hWnd) Begin
77686>>>>>>>>>            Move (DateGetDay(dDate)) to CurrentSystemTime[0].wDay
77687>>>>>>>>>            Move (DateGetMonth(dDate)) to CurrentSystemTime[0].wMonth
77688>>>>>>>>>            Move (DateGetYear(dDate)) to CurrentSystemTime[0].wYear
77689>>>>>>>>>
77689>>>>>>>>>            Move (DateGetDay(dDate2)) to CurrentSystemTime[1].wDay
77690>>>>>>>>>            Move (DateGetMonth(dDate2)) to CurrentSystemTime[1].wMonth
77691>>>>>>>>>            Move (DateGetYear(dDate2)) to CurrentSystemTime[1].wYear
77692>>>>>>>>>    
77692>>>>>>>>>            Move (Windows_Message (MCM_SETSELRANGE, 0, AddressOf (CurrentSystemTime))) to iRetval        
77693>>>>>>>>>        End
77693>>>>>>>>>>
77693>>>>>>>>>    End_Procedure
77694>>>>>>>>>    
77694>>>>>>>>>    // augment to set dates from control, so they can be accessed after the control is closed
77694>>>>>>>>>    Procedure Remove_Object
77696>>>>>>>>>        Date[] SelDate 
77697>>>>>>>>>        If (pbMultiSelect(Self)) Begin
77699>>>>>>>>>            Get SelectedDateRange to SelDate
77700>>>>>>>>>            Set pdPrivateDate2 to SelDate[1]
77701>>>>>>>>>        End
77701>>>>>>>>>>
77701>>>>>>>>>        Else Begin
77702>>>>>>>>>            Get SelectedDate to SelDate[0]
77703>>>>>>>>>        End
77703>>>>>>>>>>
77703>>>>>>>>>        Set pdPrivateDate to SelDate[0]
77704>>>>>>>>>        Forward Send Remove_Object
77706>>>>>>>>>    End_Procedure
77707>>>>>>>>>
77707>>>>>>>>>    Procedure Page Integer iState
77709>>>>>>>>>        Integer iRetval iSize iHeight iWidth
77709>>>>>>>>>        tWinRect WindowRect
77709>>>>>>>>>        tWinRect WindowRect
77709>>>>>>>>>        Date dDate dDate2
77709>>>>>>>>>        Handle hWnd
77709>>>>>>>>>        Integer  iMaxSelectedCount
77709>>>>>>>>>        Boolean bNoToday bWeekNumbers bMultiSelect bNoTodayCircle
77709>>>>>>>>>        
77709>>>>>>>>>        If (iState<>1) Begin
77711>>>>>>>>>            Forward Send Page iState
77713>>>>>>>>>            Procedure_Return
77714>>>>>>>>>        End
77714>>>>>>>>>>
77714>>>>>>>>>        
77714>>>>>>>>>        Set Icon to 'ActionCalendar.ico'
77715>>>>>>>>>
77715>>>>>>>>>        Get pbNoToday to bNoToday
77716>>>>>>>>>        Get pbNoTodayCircle to bNoTodayCircle
77717>>>>>>>>>        Get pbMultiSelect to bMultiSelect
77718>>>>>>>>>        Get pbWeekNumbers to bWeekNumbers
77719>>>>>>>>>        Get piMaxSelectedCount to iMaxSelectedCount
77720>>>>>>>>>
77720>>>>>>>>>        Set Window_Style MCS_MULTISELECT to bMultiSelect
77721>>>>>>>>>        Set Window_Style MCS_NOTODAY to bNoToday
77722>>>>>>>>>        Set Window_Style MCS_NOTODAYCIRCLE to bNoTodayCircle
77723>>>>>>>>>        Set Window_Style MCS_WEEKNUMBERS to bWeekNumbers
77724>>>>>>>>>        Forward Send Page iState
77726>>>>>>>>>
77726>>>>>>>>>        Get Window_Handle to hWnd
77727>>>>>>>>>        // support double click
77727>>>>>>>>>        Move (SetClassLong(hWnd,GCL_STYLE,CS_DBLCLKS ior CS_GLOBALCLASS)) to iRetval
77728>>>>>>>>>        // set range when multi select
77728>>>>>>>>>        Move (Windows_Message(MCM_SETMAXSELCOUNT,iMaxSelectedCount,0)) to iRetval
77729>>>>>>>>>        
77729>>>>>>>>>        // store minimum size for calendar control and set the size to this by default
77729>>>>>>>>>        Move (Windows_Message (MCM_GETMINREQRECT, 0, AddressOf(WindowRect))) to iRetval
77730>>>>>>>>>        Get GuiToDialog WindowRect.bottom WindowRect.right to iSize
77731>>>>>>>>>        Move (Hi(iSize)) to iHeight
77732>>>>>>>>>        Move (Low(iSize)) to iWidth
77733>>>>>>>>>        Set piMinWidth to iWidth
77734>>>>>>>>>        Set piMinHeight to iHeight
77735>>>>>>>>>        Set Size to iHeight iWidth
77736>>>>>>>>>        
77736>>>>>>>>>        // now that we are activated set starting date or date range
77736>>>>>>>>>        Get pdPrivateDate to dDate
77737>>>>>>>>>        If (pbMultiSelect(Self)) Begin
77739>>>>>>>>>            Get pdPrivateDate2 to dDate2
77740>>>>>>>>>            Send SetSelectedDateRange dDate dDate2
77741>>>>>>>>>        End
77741>>>>>>>>>>
77741>>>>>>>>>        Else Begin
77742>>>>>>>>>            Send SetSelectedDate dDate
77743>>>>>>>>>        End
77743>>>>>>>>>>
77743>>>>>>>>>    End_Procedure
77744>>>>>>>>>
77744>>>>>>>>>    Procedure Notify Integer wParam Integer lParam
77746>>>>>>>>>        Integer iRetval
77746>>>>>>>>>        DateTime dtSel dtSel2
77746>>>>>>>>>        tWintagNMSelChange CalenderInfo
77746>>>>>>>>>        tWintagNMSelChange CalenderInfo
77746>>>>>>>>>        Boolean bMulti
77746>>>>>>>>>        
77746>>>>>>>>>        Move (MemCopy (AddressOf (CalenderInfo), lParam, SizeOfType (tWintagNMSelChange))) to iRetval
77747>>>>>>>>>        If (CalenderInfo.nmHdr.code = MCN_SELCHANGE) Begin
77749>>>>>>>>>            Get pbMultiSelect to bMulti
77750>>>>>>>>>            Move (DateSetDay(dtSel,CalenderInfo.stSelStart.wDay)) to dtSel
77751>>>>>>>>>            Move (DateSetMonth(dtSel,CalenderInfo.stSelStart.wMonth)) to dtSel
77752>>>>>>>>>            Move (DateSetYear(dtSel,CalenderInfo.stSelStart.wYear)) to dtSel
77753>>>>>>>>>            If bMulti Begin
77755>>>>>>>>>                Move (DateSetDay(dtSel,CalenderInfo.stSelEnd.wDay)) to dtSel2
77756>>>>>>>>>                Move (DateSetMonth(dtSel,CalenderInfo.stSelEnd.wMonth)) to dtSel2
77757>>>>>>>>>                Move (DateSetYear(dtSel,CalenderInfo.stSelEnd.wYear)) to dtSel2
77758>>>>>>>>>            End
77758>>>>>>>>>>
77758>>>>>>>>>            Send OnChange (Date(dtSel)) (Date(dtSel2))
77759>>>>>>>>>        End
77759>>>>>>>>>>
77759>>>>>>>>>    End_Procedure
77760>>>>>>>>>
77760>>>>>>>>>    // sent whenever there is a selection change within the calendar
77760>>>>>>>>>    Procedure OnChangeDate Date dDate Date dDate2
77762>>>>>>>>>    End_Procedure
77763>>>>>>>>>
77763>>>>>>>>>    // sent when a click occurs in the calendar 
77763>>>>>>>>>    Procedure OnClick
77765>>>>>>>>>    End_Procedure
77766>>>>>>>>>    
77766>>>>>>>>>    // sent when a double click occurs in the calendar 
77766>>>>>>>>>    Procedure OnDoubleClick
77768>>>>>>>>>    End_Procedure
77769>>>>>>>>>    
77769>>>>>>>>>    // sends OnClick if the double click is on a calendar day
77769>>>>>>>>>    Procedure OnLButtonDblClick Integer wParam Integer lParam
77771>>>>>>>>>        Boolean bDayHit
77771>>>>>>>>>        Get MonthDayHit to bDayHit
77772>>>>>>>>>        If bDayHit Begin
77774>>>>>>>>>            Send OnDoubleClick
77775>>>>>>>>>        End
77775>>>>>>>>>>
77775>>>>>>>>>    End_Procedure
77776>>>>>>>>>
77776>>>>>>>>>    // sends OnClick if the click is on a calendar day
77776>>>>>>>>>    Procedure OnWmLButtonUp Integer wParam Integer lParam
77778>>>>>>>>>        Boolean bDayHit
77778>>>>>>>>>        Get MonthDayHit to bDayHit
77779>>>>>>>>>        If bDayHit Begin
77781>>>>>>>>>            Send OnClick
77782>>>>>>>>>        End
77782>>>>>>>>>>
77782>>>>>>>>>    End_Procedure
77783>>>>>>>>>    
77783>>>>>>>>>    // returns true if the month calander is up and the mouse is over a day
77783>>>>>>>>>    Function MonthDayHit Returns Boolean
77785>>>>>>>>>        Integer iRet
77785>>>>>>>>>        Get Windows_Message MCM_GETCURRENTVIEW 0 0 to iRet
77786>>>>>>>>>        If (iRet=MCMV_MONTH) Begin
77788>>>>>>>>>            Get HitTest to iRet
77789>>>>>>>>>            Function_Return (iRet=MCHT_CALENDARDATE)
77790>>>>>>>>>        End
77790>>>>>>>>>>
77790>>>>>>>>>        Function_Return False
77791>>>>>>>>>    End_Function
77792>>>>>>>>>    
77792>>>>>>>>>    // return what was hit in the control
77792>>>>>>>>>    Function HitTest Returns Integer
77794>>>>>>>>>        tWinMCHitTestInfo HitInfo
77794>>>>>>>>>        tWinMCHitTestInfo HitInfo
77794>>>>>>>>>        Handle hWnd iRet
77794>>>>>>>>>        Integer iVoid
77794>>>>>>>>>        Pointer lpPt
77794>>>>>>>>>        tWinPoint Pt
77794>>>>>>>>>        tWinPoint Pt
77794>>>>>>>>>        Get Window_Handle to hWnd
77795>>>>>>>>>        Move (AddressOf(Pt)) to lpPt
77796>>>>>>>>>        Move (GetCursorPos(lpPt)) to iVoid
77797>>>>>>>>>        Move (ScreenToClient(hWnd, lpPt)) to iVoid
77798>>>>>>>>>        Move Pt to HitInfo.Pt
77799>>>>>>>>>        Move (SizeOfType(tWinMCHitTestInfo)) to HitInfo.cbSize
77800>>>>>>>>>        Get WindowsMessage MCM_HITTEST 0 (AddressOf(HitInfo)) to iRet
77801>>>>>>>>>        Function_Return HitInfo.uHit
77802>>>>>>>>>    End_Function
77803>>>>>>>>>    
77803>>>>>>>>>End_Class
77804>>>>>>>
77804>>>>>>>// peMouseSelectOk choices
77804>>>>>>>Enum_List
77804>>>>>>>    Define msoClick
77804>>>>>>>    Define msoDblClick
77804>>>>>>>    Define msoNone
77804>>>>>>>End_Enum_List
77804>>>>>>>
77804>>>>>>>// It is expected that this class will only be used inside of ModalPanel and
77804>>>>>>>// will be used as a prompt object component in a framework style application.
77804>>>>>>>// If you wish to Use a month calendar in some other non prompt situation, 
77804>>>>>>>// use cMonthCalendar
77804>>>>>>>
77804>>>>>>>Class cMonthCalendarPrompt is a cMonthCalendar
77805>>>>>>>
77805>>>>>>>    Procedure Construct_Object
77807>>>>>>>
77807>>>>>>>        Forward Send Construct_Object
77809>>>>>>>
77809>>>>>>>        Property Integer peUpdateMode umPromptValue
77810>>>>>>>
77810>>>>>>>        Property Integer peMouseSelectOk msoClick
77811>>>>>>>        
77811>>>>>>>        Property Date pdSeedValue
77812>>>>>>>
77812>>>>>>>        // if multi-select, this is the end range
77812>>>>>>>        Property Date pdSeedValue2
77813>>>>>>>
77813>>>>>>>        Property Handle phmPromptUpdateCallback 0
77814>>>>>>>
77814>>>>>>>        Property Integer phoInvokingObject
77815>>>>>>>        
77815>>>>>>>        Property Integer peStoredUpdateMode
77816>>>>>>>        Property Handle  phmStoredPromptUpdateCallback
77817>>>>>>>        Property Boolean pbStoredWeekNumbers
77818>>>>>>>        Property Boolean pbStoredNoToday
77819>>>>>>>        Property Boolean pbStoredNoTodayCircle
77820>>>>>>>        Property Boolean pbStoredMultiSelect
77821>>>>>>>        Property Integer piStoredMaxSelectedCount
77822>>>>>>>        Property Integer peStoredpeMouseSelectOk
77823>>>>>>>
77823>>>>>>>        // internally set by list
77823>>>>>>>        // these must be set upon closing the list and can be used for manual list updates
77823>>>>>>>        Property Boolean pbCanceled
77824>>>>>>>
77824>>>>>>>    End_Procedure
77825>>>>>>>        
77825>>>>>>>    Procedure OnStoreDefaults
77827>>>>>>>        Integer iVal
77827>>>>>>>        Boolean bVal
77827>>>>>>>
77827>>>>>>>        Get peUpdateMode to iVal
77828>>>>>>>        Set peStoredUpdateMode to iVal
77829>>>>>>>        
77829>>>>>>>        Get phmPromptUpdateCallback to iVal       
77830>>>>>>>        Set phmStoredPromptUpdateCallback to iVal       
77831>>>>>>>
77831>>>>>>>        Get pbMultiSelect to bVal       
77832>>>>>>>        Set pbStoredMultiSelect to bVal       
77833>>>>>>>
77833>>>>>>>        Get pbNoToday to bVal       
77834>>>>>>>        Set pbStoredNoToday to bVal       
77835>>>>>>>
77835>>>>>>>        Get pbNoTodayCircle to bVal       
77836>>>>>>>        Set pbStoredNoTodayCircle to bVal       
77837>>>>>>>
77837>>>>>>>        Get pbWeekNumbers to bVal       
77838>>>>>>>        Set pbStoredWeekNumbers to bVal       
77839>>>>>>>
77839>>>>>>>        Get piMaxSelectedCount to iVal       
77840>>>>>>>        Set piStoredMaxSelectedCount to iVal  
77841>>>>>>>        
77841>>>>>>>        Get peMouseSelectOk to iVal       
77842>>>>>>>        Set peStoredpeMouseSelectOk to iVal       
77843>>>>>>>        
77843>>>>>>>    End_Procedure
77844>>>>>>>
77844>>>>>>>    Procedure OnRestoreDefaults
77846>>>>>>>        Integer iVal
77846>>>>>>>        Boolean bVal
77846>>>>>>>
77846>>>>>>>        Get peStoredUpdateMode to iVal
77847>>>>>>>        Set peUpdateMode to iVal
77848>>>>>>>        
77848>>>>>>>        Get phmStoredPromptUpdateCallback to iVal       
77849>>>>>>>        Set phmPromptUpdateCallback to iVal       
77850>>>>>>>
77850>>>>>>>        Get pbStoredMultiSelect to bVal       
77851>>>>>>>        Set pbMultiSelect to bVal       
77852>>>>>>>
77852>>>>>>>        Get pbStoredNoToday to bVal       
77853>>>>>>>        Set pbNoToday to bVal       
77854>>>>>>>
77854>>>>>>>        Get pbStoredNoTodayCircle to bVal       
77855>>>>>>>        Set pbNoTodayCircle to bVal       
77856>>>>>>>
77856>>>>>>>        Get pbStoredWeekNumbers to bVal       
77857>>>>>>>        Set pbWeekNumbers to bVal       
77858>>>>>>>
77858>>>>>>>        Get piStoredMaxSelectedCount to iVal       
77859>>>>>>>        Set piMaxSelectedCount to iVal       
77860>>>>>>>
77860>>>>>>>        Get peStoredpeMouseSelectOk to iVal       
77861>>>>>>>        Set peMouseSelectOk to iVal       
77862>>>>>>>
77862>>>>>>>    End_Procedure
77863>>>>>>>
77863>>>>>>>    Procedure Add_Focus Handle hoParent Returns Integer
77865>>>>>>>        Integer eMode
77865>>>>>>>        Set pbCanceled to True // assume cancel unless changed
77866>>>>>>>        Get peUpdateMode to eMode
77867>>>>>>>        If (eMode<>umPromptNonInvoking) Begin
77869>>>>>>>            Send OnStoreDefaults
77870>>>>>>>        End
77870>>>>>>>>
77870>>>>>>>        Send InitializePrompt
77871>>>>>>>        Forward Send Add_Focus hoParent
77873>>>>>>>    End_Procedure
77874>>>>>>>        
77874>>>>>>>    // augment to send OnRestoreDefaults.
77874>>>>>>>    Procedure Release_Focus
77876>>>>>>>        Integer eUpdateMode
77876>>>>>>>        Get peUpdateMode to eUpdateMode
77877>>>>>>>        Forward Send Release_Focus
77879>>>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
77881>>>>>>>            Send OnRestoreDefaults
77882>>>>>>>        End
77882>>>>>>>>
77882>>>>>>>    End_Procedure
77883>>>>>>>
77883>>>>>>>    // This is only called in a successful close
77883>>>>>>>    Procedure ClosePrompt
77885>>>>>>>        Handle hoInvokingObject
77885>>>>>>>        Handle hmCallBack
77885>>>>>>>        Integer eUpdateMode
77885>>>>>>>        Date[] dDates
77886>>>>>>>        
77886>>>>>>>        Set pbCanceled to False
77887>>>>>>>        
77887>>>>>>>        Get peUpdateMode to eUpdateMode
77888>>>>>>>        // if non-invoking there is by definition, no move value out
77888>>>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
77890>>>>>>>            
77890>>>>>>>            If (eUpdateMode=umPromptValue) Begin
77892>>>>>>>                Send OnMoveValueOutByValue
77893>>>>>>>            End
77893>>>>>>>>
77893>>>>>>>            Else If (eUpdateMode=umPromptCustom) Begin
77896>>>>>>>                Send OnMoveValueOutByCustom
77897>>>>>>>            End
77897>>>>>>>>
77897>>>>>>>            Get phmPromptUpdateCallback to hmCallBack
77898>>>>>>>            If hmCallBack Begin
77900>>>>>>>                Get phoInvokingObject to hoInvokingObject
77901>>>>>>>                If (pbMultiSelect(Self)) Begin
77903>>>>>>>                    Get SelectedDateRange to dDates
77904>>>>>>>                    Send hmCallBack of hoInvokingObject Self dDates[0] dDates[1]
77905>>>>>>>                    
77905>>>>>>>                End
77905>>>>>>>>
77905>>>>>>>                Else Begin
77906>>>>>>>                    Get SelectedDate to dDates[0]
77907>>>>>>>                    Send hmCallBack of hoInvokingObject Self dDates[0]
77908>>>>>>>                End
77908>>>>>>>>
77908>>>>>>>            End
77908>>>>>>>>
77908>>>>>>>        End
77908>>>>>>>>
77908>>>>>>>
77908>>>>>>>        Send Close_Panel
77909>>>>>>>    End_Procedure
77910>>>>>>>
77910>>>>>>>    Procedure OnMoveValueOutByValue
77912>>>>>>>        Handle hoInvokingObject
77912>>>>>>>        Date dSelDate
77912>>>>>>>        Boolean bMulti
77912>>>>>>>        // we can only do an automatic move value out with
77912>>>>>>>        // single select. If multi-select you will probably want to
77912>>>>>>>        // use a callback method (hmCallBack) to update the values. 
77912>>>>>>>        Get pbMultiSelect to bMulti
77913>>>>>>>        If (not(bMulti)) Begin
77915>>>>>>>            Get SelectedDate to dSelDate
77916>>>>>>>            Get phoInvokingObject to hoInvokingObject
77917>>>>>>>            Set Value of hoInvokingObject to dSelDate
77918>>>>>>>            Set Item_Changed_State of hoInvokingObject to True
77919>>>>>>>        End
77919>>>>>>>>
77919>>>>>>>    End_Procedure
77920>>>>>>>
77920>>>>>>>    Procedure OnMoveValueOutByCustom
77922>>>>>>>    End_Procedure
77923>>>>>>>        
77923>>>>>>>    // called before the list is activated. 
77923>>>>>>>    Procedure InitializePrompt
77925>>>>>>>        Handle hoInvokingObject
77925>>>>>>>        Integer eUpdateMode
77925>>>>>>>        Boolean bMulti 
77925>>>>>>>        Date dValue
77925>>>>>>>
77925>>>>>>>        Get peUpdateMode to eUpdateMode
77926>>>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
77928>>>>>>>
77928>>>>>>>            Get Focus of Desktop to hoInvokingObject
77929>>>>>>>            If (hoInvokingObject<=Desktop) Begin
77931>>>>>>>                Error DFERR_PROGRAM "Calendar Prompt has no invoking object"
77932>>>>>>>>
77932>>>>>>>                Procedure_Return
77933>>>>>>>            End
77933>>>>>>>>
77933>>>>>>>
77933>>>>>>>            Set phoInvokingObject to hoInvokingObject
77934>>>>>>>            Send Prompt_Callback to hoInvokingObject Self
77935>>>>>>>            Get peUpdateMode to eUpdateMode
77936>>>>>>>        End
77936>>>>>>>>
77936>>>>>>>
77936>>>>>>>        Get pdSeedValue to dValue
77937>>>>>>>        Get pbMultiSelect to bMulti
77938>>>>>>>        If (not(bMulti) and eUpdateMode=umPromptValue and dValue=0) Begin
77940>>>>>>>            Get Value of hoInvokingObject to dValue
77941>>>>>>>            Set pdSeedValue to dValue
77942>>>>>>>        End
77942>>>>>>>>
77942>>>>>>>        Send OnSeedData
77943>>>>>>>        Set pdSeedValue to 0
77944>>>>>>>        Set pdSeedValue2 to 0
77945>>>>>>>    End_Procedure
77946>>>>>>>    
77946>>>>>>>    Procedure OnSeedData 
77948>>>>>>>        Boolean bMulti
77948>>>>>>>        Date dValue dValue2
77948>>>>>>>        Integer iMax iRange
77948>>>>>>>        DateTime dt1 dt2
77948>>>>>>>        Get pbMultiSelect to bMulti
77949>>>>>>>        Get pdSeedValue to dValue
77950>>>>>>>        If (not(bMulti)) Begin
77952>>>>>>>            // if no date, use current date
77952>>>>>>>            If (dValue=0) Begin
77954>>>>>>>                Move (CurrentDateTime()) to dValue
77955>>>>>>>            End
77955>>>>>>>>
77955>>>>>>>            Send SetSelectedDate dValue    
77956>>>>>>>        End
77956>>>>>>>>
77956>>>>>>>        Else Begin
77957>>>>>>>            Get pdSeedValue2 to dValue2 
77958>>>>>>>            // if no dates, use current date
77958>>>>>>>            If (dValue=0 and dValue2=0) Begin
77960>>>>>>>                Move (CurrentDateTime()) to dValue
77961>>>>>>>            End
77961>>>>>>>>
77961>>>>>>>            // if only one date, make that the range
77961>>>>>>>            If (dValue=0) Begin
77963>>>>>>>                Move dValue2 to dValue
77964>>>>>>>            End
77964>>>>>>>>
77964>>>>>>>            Else If (dValue2=0) Begin
77967>>>>>>>                Move dValue to dValue2
77968>>>>>>>            End
77968>>>>>>>>
77968>>>>>>>            
77968>>>>>>>            // test for valid range
77968>>>>>>>            Get piMaxSelectedCount to iMax
77969>>>>>>>            Move dValue to dt1
77970>>>>>>>            Move dValue2 to dt2
77971>>>>>>>            Move (SpanTotalDays(dt1 - dt2)) to iRange
77972>>>>>>>            If (iRange>iMax) Begin
77974>>>>>>>                Error DFERR_OPERATOR (SFormat(C_$DateRangeExceeded,iMax))
77975>>>>>>>>
77975>>>>>>>                Move dValue to dValue2
77976>>>>>>>            End
77976>>>>>>>>
77976>>>>>>>            
77976>>>>>>>            Send SetSelectedDateRange dValue dValue2
77977>>>>>>>        End
77977>>>>>>>>
77977>>>>>>>    End_Procedure
77978>>>>>>>
77978>>>>>>>    Procedure OnDoubleClick
77980>>>>>>>        Integer eSelectOn
77980>>>>>>>        Get peMouseSelectOk to eSelectOn
77981>>>>>>>        If (eSelectOn=msoDblClick) Begin
77983>>>>>>>            Send Ok
77984>>>>>>>        End
77984>>>>>>>>
77984>>>>>>>    End_Procedure
77985>>>>>>>    
77985>>>>>>>    Procedure OnClick
77987>>>>>>>        Integer eSelectOn
77987>>>>>>>        Get peMouseSelectOk to eSelectOn
77988>>>>>>>        If (eSelectOn=msoClick) Begin
77990>>>>>>>            Send Ok
77991>>>>>>>        End
77991>>>>>>>>
77991>>>>>>>    End_Procedure
77992>>>>>>>
77992>>>>>>>    Procedure Ok Returns Integer
77994>>>>>>>        Send ClosePrompt
77995>>>>>>>    End_Procedure
77996>>>>>>>
77996>>>>>>>    Procedure Cancel Returns Integer
77998>>>>>>>        Send Close_Panel
77999>>>>>>>    End_Procedure
78000>>>>>>>        
78000>>>>>>>End_Class
78001>>>>>>>
78001>>>>>>>
78001>>>>>Use Dfclient.pkg
78001>>>>>
78001>>>>>Cd_Popup_Object oMonthCalendarPrompt is a ModalPanel
78019>>>>>>
78019>>>>>    Set Location to 10 10
78020>>>>>    Set Size to 145 145
78021>>>>>    // resizable
78021>>>>>    Set Border_Style to Border_Thick
78022>>>>>
78022>>>>>    Set Label to C_$DateSelector
78023>>>>>
78023>>>>>    Set piMinSize to 0 0 // set this dynamically // 145 145
78024>>>>>    Set piMaxSize to 310 460
78025>>>>>
78025>>>>>    // tells us if this been activated and sized yet
78025>>>>>    Property Boolean pbSizeInited False
78027>>>>>        
78027>>>>>    Object oCalendar is a cMonthCalendarPrompt
78029>>>>>        Set Size to 120 135 // not real size, will be assigned
78030>>>>>        Set Location to 5 5
78031>>>>>        Set Border_Style to Border_None
78032>>>>>    End_Object
78033>>>>>
78033>>>>>    Object oOKButton is a Button
78035>>>>>        Set Label to C_$OK
78036>>>>>        Set Default_State to True
78037>>>>>        Set Location to 129 34
78038>>>>>        Set peAnchors to anBottomRight
78039>>>>>        
78039>>>>>        Procedure OnClick
78042>>>>>            Send Ok of oCalendar
78043>>>>>        End_Procedure
78044>>>>>    End_Object
78045>>>>>
78045>>>>>    Object oCancelButton is a Button
78047>>>>>        Set Label to C_$Cancel
78048>>>>>        Set Location to 129 89
78049>>>>>        Set peAnchors to anBottomRight
78050>>>>>        
78050>>>>>        Procedure OnClick
78053>>>>>            Send Cancel of oCalendar
78054>>>>>        End_Procedure
78055>>>>>    End_Object
78056>>>>>
78056>>>>>    Procedure OnResize 
78059>>>>>        Integer iSize iHeight iWidth iMinSize
78059>>>>>        Boolean bInited
78059>>>>>
78059>>>>>        Get piMinHeight of oCalendar to iHeight
78060>>>>>        // when 0, the control has not yet been created. Nothing to do.
78060>>>>>        If (iHeight=0) Begin
78062>>>>>            Procedure_Return
78063>>>>>        End
78063>>>>>>
78063>>>>>
78063>>>>>        Get pbSizeInited to bInited
78064>>>>>        
78064>>>>>        Get piMinWidth of oCalendar to iWidth
78065>>>>>        Get piMinSize to iMinSize
78066>>>>>        // Minumum size of panel - add 1 to each to each for wiggle room
78066>>>>>        Move (iHeight+25+1) to iHeight
78067>>>>>        Move (iWidth+10+1) to iWidth
78068>>>>>         
78068>>>>>        Set piMinSize to iHeight iWidth
78069>>>>>
78069>>>>>        If (not(bInited))  Begin
78071>>>>>            Set Size to iHeight iWidth
78072>>>>>            Set pbSizeInited to True
78073>>>>>        End
78073>>>>>>
78073>>>>>        Else Begin
78074>>>>>            Send Adjust_Logicals
78075>>>>>            Get Size to iSize
78076>>>>>            If (Hi(iSize)<iHeight or Low(iSize)<iWidth) Begin
78078>>>>>                Set Size to (iHeight max Hi(iSize)) (iWidth max Low(iSize))
78079>>>>>                Get Size to iSize
78080>>>>>            End
78080>>>>>>
78080>>>>>            Set Size of oCalendar to (Hi(iSize) - 25) (Low(iSize) - 10)
78081>>>>>        End
78081>>>>>>
78081>>>>>        
78081>>>>>    End_Procedure
78082>>>>>    
78082>>>>>    Procedure Add_Focus Handle hoParent Returns Integer
78085>>>>>        Forward Send Add_Focus hoParent
78087>>>>>        Send OnResize
78088>>>>>    End_Procedure
78089>>>>>
78089>>>>>    On_Key kCancel Send KeyAction to oCancelButton
78090>>>>>
78090>>>>>Cd_End_Object
78092>>>>>>
78092>>>
78092>>>Activate_View Activate_oOrderEntryView for oOrderEntryView
78102>>>>
78102>>>Object oOrderEntryView is a dbView
78104>>>    Set Border_Style to Border_Thick
78105>>>    Set Maximize_Icon to True
78106>>>    Set Label to "Order Entry"
78107>>>    Set Location to 2 3
78108>>>    Set Size to 174 383
78109>>>    Set piMinSize to 174 383
78110>>>    Set pbAutoActivate to True
78111>>>    
78111>>>
78111>>>    Object Vendor_DD is a Vendor_DataDictionary
78113>>>    End_Object    // Vendor_DD
78114>>>
78114>>>    Object Invt_DD is a Invt_DataDictionary
78116>>>        Set DDO_Server to Vendor_DD
78117>>>    End_Object    // Invt_DD
78118>>>
78118>>>    Object Customer_DD is a Customer_DataDictionary
78120>>>    End_Object    // Customer_DD
78121>>>
78121>>>    Object SalesP_DD is a Salesp_DataDictionary
78123>>>    End_Object    // SalesP_DD
78124>>>
78124>>>    Object OrderHea_DD is a OrderHea_DataDictionary
78126>>>        Set DDO_Server to Customer_DD
78127>>>        Set DDO_Server to SalesP_DD
78128>>>        
78128>>>        // this lets you save a new OrderHea from within OrderDtl.
78128>>>        Set Allow_Foreign_New_Save_State to True
78129>>>        
78129>>>    End_Object    // OrderHea_DD
78130>>>    
78130>>>    Object OrderDtl_DD is a OrderDtl_DataDictionary
78132>>>        Set DDO_Server to OrderHea_DD
78133>>>        Set DDO_Server to Invt_DD
78134>>>        Set Constrain_File to OrderHea.File_Number
78135>>>    End_Object    // OrderDtl_DD
78136>>>
78136>>>    Set Main_DD to OrderHea_DD
78137>>>    Set Server to OrderHea_DD
78138>>>    
78138>>>    Object oDbContainer3d1 is a dbContainer3d
78140>>>        Set Size to 85 377
78141>>>        Set Location to 2 3
78142>>>        Set peAnchors to anTopLeftRight
78143>>>        
78143>>>        
78143>>>        Object oOrderHea_Order_Number is a dbForm
78145>>>            Entry_Item OrderHea.Order_Number
78146>>>            Set Label to "Order Number:"
78147>>>            Set Size to 13 42
78148>>>            Set Location to 4 63
78149>>>            Set peAnchors to anTopLeft
78150>>>            Set Label_Col_Offset to 2
78151>>>            Set Label_Justification_Mode to jMode_Right
78152>>>            
78152>>>        End_Object    // oOrderHea_Order_Number
78153>>>
78153>>>        Object oOrderHea_Customer_Number is a dbForm
78155>>>            Entry_Item Customer.Customer_Number
78156>>>            Set Label to "Customer Number:"
78157>>>            Set Size to 13 42
78158>>>            Set Location to 4 201
78159>>>            Set peAnchors to anTopRight
78160>>>            Set Label_Col_Offset to 2
78161>>>            Set Label_Justification_Mode to jMode_Right
78162>>>        End_Object    // oOrderHea_Customer_Number
78163>>>
78163>>>        Object oOrderHea_Order_Date is a dbForm
78165>>>            Entry_Item OrderHea.Order_Date
78166>>>            Set Label to "Order Date:"
78167>>>            Set Size to 13 67
78168>>>            Set Location to 4 299
78169>>>            Set peAnchors to anTopRight
78170>>>            Set Label_Col_Offset to 2
78171>>>            Set Label_Justification_Mode to jMode_Right
78172>>>            
78172>>>            Set Prompt_Object to oMonthCalendarPrompt
78173>>>            Set Prompt_Button_Mode to PB_PromptOn
78174>>>        End_Object    // oOrderHea_Order_Date
78175>>>
78175>>>        Object oCustomer_Name is a dbForm
78177>>>            Entry_Item Customer.Name
78178>>>            Set Label to "Customer Name:"
78179>>>            Set Size to 13 180
78180>>>            Set Location to 18 63
78181>>>            Set peAnchors to anTopLeftRight
78182>>>            Set Label_Col_Offset to 2
78183>>>            Set Label_Justification_Mode to jMode_Right
78184>>>        End_Object    // oCustomer_Name
78185>>>
78185>>>        Object oCustomer_Address is a dbForm
78187>>>            Entry_Item Customer.Address
78188>>>            Set Label to "Street Address:"
78189>>>            Set Size to 13 180
78190>>>            Set Location to 34 63
78191>>>            Set peAnchors to anTopLeftRight
78192>>>            Set Label_Col_Offset to 2
78193>>>            Set Label_Justification_Mode to jMode_Right
78194>>>        End_Object    // oCustomer_Address
78195>>>
78195>>>        Object oCustomer_City is a dbForm
78197>>>            Entry_Item Customer.City
78198>>>            Set Label to "City/State/Zip:"
78199>>>            Set Size to 13 84
78200>>>            Set Location to 49 63
78201>>>            Set peAnchors to anTopLeftRight
78202>>>            Set Label_Col_Offset to 2
78203>>>            Set Label_Justification_Mode to jMode_Right
78204>>>        End_Object    // oCustomer_City
78205>>>
78205>>>        Object oCustomer_State is a dbForm
78207>>>            Entry_Item Customer.State
78208>>>            Set Size to 13 20
78209>>>            Set Location to 49 155
78210>>>            Set peAnchors to anTopRight
78211>>>        End_Object    // oCustomer_State
78212>>>
78212>>>        Object oCustomer_Zip is a dbForm
78214>>>            Entry_Item Customer.Zip
78215>>>            Set Size to 13 60
78216>>>            Set Location to 49 183
78217>>>            Set peAnchors to anTopRight
78218>>>        End_Object    // oCustomer_Zip
78219>>>
78219>>>        Object oOrderHea_Ordered_By is a dbForm
78221>>>            Entry_Item OrderHea.Ordered_By
78222>>>            Set Label to "Ordered By:"
78223>>>            Set Size to 13 67
78224>>>            Set Location to 34 299
78225>>>            Set peAnchors to anTopRight
78226>>>            Set Label_Col_Offset to 2
78227>>>            Set Label_Justification_Mode to jMode_Right
78228>>>        End_Object    // oOrderHea_Ordered_By
78229>>>
78229>>>        Object oOrderHea_Salesperson_ID is a dbForm
78231>>>            Entry_Item Salesp.Id
78232>>>            Set Label to "Salesperson ID:"
78233>>>            Set Size to 13 40
78234>>>            Set Location to 49 299
78235>>>            Set peAnchors to anTopRight
78236>>>            Set Label_Col_Offset to 2
78237>>>            Set Label_Justification_Mode to jMode_Right
78238>>>        End_Object    // oOrderHea_Salesperson_ID
78239>>>
78239>>>        Object oOrderHea_Terms is a dbComboForm
78241>>>            Entry_Item OrderHea.Terms
78242>>>            Set Label to "Terms:"
78243>>>            Set Size to 13 85
78244>>>            Set Location to 64 63
78245>>>            Set peAnchors to anTopLeft
78246>>>            Set Form_Border to 0
78247>>>            Set Label_Col_Offset to 2
78248>>>            Set Label_Justification_Mode to jMode_Right
78249>>>
78249>>>        End_Object    // oOrderHea_Terms
78250>>>
78250>>>        Object oOrderHea_Ship_Via is a dbComboForm
78252>>>            Entry_Item OrderHea.Ship_Via
78253>>>            Set Label to "Ship Via:"
78254>>>            Set Size to 13 103
78255>>>            Set Location to 64 183
78256>>>            Set peAnchors to anTopRight
78257>>>            Set Form_Border to 0
78258>>>            Set Label_Col_Offset to 2
78259>>>            Set Label_Justification_Mode to jMode_Right
78260>>>
78260>>>        End_Object    // oOrderHea_Ship_Via
78261>>>
78261>>>        Object oTextBox1 is a TextBox
78263>>>            Set Size to 10 31
78264>>>            Set Location to 4 4
78265>>>            Set Label to "Hallo!!"
78266>>>            Set Justification_Mode to JMode_Right
78267>>>            Set FontWeight to fw_Bold
78268>>>            Set FontPointHeight to 90
78269>>>        End_Object
78270>>>
78270>>>    End_Object    // oDbContainer3d1
78271>>>
78271>>>    Object oOrderDtl_Grid is a cDbCJGrid
78273>>>        Set Server to OrderDtl_DD
78274>>>        Set Ordering to 1
78275>>>        Set Size to 63 377
78276>>>        Set Location to 90 3
78277>>>        Set peAnchors to anAll
78278>>>        Set pbAllowInsertRow to False
78279>>>        Set pbRestoreLayout to False
78280>>>        Set psLayoutSection to "OrderView_oOrderDtl_Grid2"
78281>>>        Set piLayoutBuild to 6
78282>>>        Set pbHeaderPrompts to True
78283>>>
78283>>>        On_Key Key_F11 Send Request_InsertRow
78284>>>
78284>>>        Object oMark is a cCJGridColumnRowIndicator
78286>>>        End_Object
78287>>>        
78287>>>        Object oInvt_Item_ID is a cDbCJGridColumn
78289>>>            Entry_Item Invt.Item_ID
78290>>>            Set piWidth to 91
78291>>>            Set psCaption to "Item ID"
78292>>>            Set psImage to "ActionPrompt.ico"
78293>>>        End_Object
78294>>>
78294>>>        Object oInvt_Description is a cDbCJGridColumn
78296>>>            Entry_Item Invt.Description
78297>>>            Set piWidth to 213
78298>>>            Set psCaption to "Description"
78299>>>        End_Object
78300>>>
78300>>>        Object oInvt_Unit_Price is a cDbCJGridColumn
78302>>>            Entry_Item Invt.Unit_Price
78303>>>            Set piWidth to 53
78304>>>            Set psCaption to "Unit Price"
78305>>>        End_Object
78306>>>
78306>>>        Object oOrderDtl_Qty_Ordered is a cDbCJGridColumn
78308>>>            Entry_Item OrderDtl.Qty_Ordered
78309>>>            Set piWidth to 50
78310>>>            Set psCaption to "Quantity"
78311>>>        End_Object
78312>>>
78312>>>        Object oOrderDtl_Price is a cDbCJGridColumn
78314>>>            Entry_Item OrderDtl.Price
78315>>>            Set piWidth to 62
78316>>>            Set psCaption to "Price"
78317>>>        End_Object
78318>>>
78318>>>        Object oOrderDtl_Extended_Price is a cDbCJGridColumn
78320>>>            Entry_Item OrderDtl.Extended_Price
78321>>>            Set piWidth to 81
78322>>>            Set psCaption to "Total"
78323>>>        End_Object
78324>>>        
78324>>>    End_Object    // oOrderDtl_Grid
78325>>>
78325>>>    Object oOrderHea_Order_Total is a dbForm
78327>>>        Entry_Item OrderHea.Order_Total
78328>>>        Set Label to "Order Total:"
78329>>>        Set Size to 13 60
78330>>>        Set Location to 156 307
78331>>>        Set peAnchors to anBottomRight
78332>>>        Set Label_Col_Offset to 3
78333>>>        Set Label_Justification_Mode to jMode_Right
78334>>>    End_Object    // oOrderHea_Order_Total
78335>>>
78335>>>    Object oPrintBtn is a Button
78337>>>        Set Label to "Print Order"
78338>>>        Set Location to 156 3
78339>>>        Set peAnchors to anBottomLeft
78340>>>        Set psToolTip to "Print preview of current order"
78341>>>
78341>>>        Procedure OnClick
78344>>>            Delegate Send PrintCurrentOrder // defined in view object
78346>>>        End_Procedure  // OnClick
78347>>>        
78347>>>    End_Object    // oPrintBtn
78348>>>
78348>>>
78348>>>    // Change:   Create custom confirmation messages for save and delete
78348>>>    //           We must create the new functions and assign verify messages
78348>>>    //           to them.
78348>>>    Function Confirm_Delete_Order Returns Integer
78351>>>        Integer iRetVal
78351>>>        Get Confirm "Delete Entire Order?" to iRetVal
78352>>>        Function_Return iRetVal
78353>>>    End_Function
78354>>>    
78354>>>    // Only confirm on the saving of new records
78354>>>    Function Confirm_Save_Order Returns Integer
78357>>>        Integer iNoSave iSrvr
78357>>>        Boolean bOld
78357>>>        Get Server to iSrvr
78358>>>        Get HasRecord of iSrvr to bOld
78359>>>        If not bOld Begin
78361>>>            Get Confirm "Save this NEW order header?" to iNoSave
78362>>>        End
78362>>>>
78362>>>        Function_Return iNoSave
78363>>>    End_Function
78364>>>    
78364>>>    // Define alternate confirmation Messages
78364>>>    Set Verify_Save_MSG       to (RefFunc(Confirm_Save_Order))
78365>>>    Set Verify_Delete_MSG     to (RefFunc(Confirm_Delete_Order))
78366>>>    Set Auto_Clear_DEO_State  to False // don't clear Header on save
78367>>>    
78367>>>    
78367>>>    // print the current order. This message will be sent
78367>>>    // by the print button
78367>>>    Procedure PrintCurrentOrder
78370>>>        Integer hDD iNum
78370>>>        Get Server to hDD // this will be the OrderHea DD
78371>>>        If (HasRecord(hDD)) Begin // only do this if record exists
78373>>>            Get Field_Current_Value of hDD Field OrderHea.Order_Number to iNum
78374>>>//            Send PrintOrder of oOrder_Report iNum
78374>>>            Send Info_Box "This is just a stub and this invoice is not actually being printed" ("Print Order " + String(iNum))
78375>>>        End
78375>>>>
78375>>>    End_Procedure
78376>>>    
78376>>>    // refresh is sent to containers. We will use that to control the print button and only
78376>>>    // enable it when an order exists
78376>>>    Procedure Refresh Integer eMode
78379>>>        Boolean bRec
78379>>>        Handle hoServer
78379>>>        Get Server to hoServer
78380>>>        Get HasRecord of hoServer to bRec
78381>>>        Set Enabled_State of oPrintBtn to bRec
78382>>>    End_Procedure
78383>>>
78383>>>End_Object
78384>        Use SalesP.vw
Including file: Salesp.vw    (C:\Test\Order Entry git\AppSrc\Salesp.vw)
78384>>>Use dfClient.pkg
78384>>>Use DataDict.pkg
78384>>>Use dfEntry.pkg
78384>>>Use SalesP.DD
78384>>>
78384>>>DEFERRED_VIEW Activate_oSalesPersonView FOR ;;Object oSalesPersonView is a dbView
78409>>>    Set Border_Style to Border_None
78410>>>    Set Label to "Sales Person Entry View"
78411>>>    Set Location to 6 6
78412>>>    Set Size to 51 245
78413>>>
78413>>>    Object SalesP_DD is a Salesp_DataDictionary
78415>>>    End_Object    // Salesp_DD
78416>>>
78416>>>    Set Main_DD to SalesP_DD
78417>>>    Set Server to SalesP_DD
78418>>>
78418>>>    Object oContainer1 is a dbContainer3d
78420>>>        Set Size to 40 233
78421>>>        Set Location to 5 6
78422>>>        Object oSalesP_ID is a dbForm
78424>>>            Entry_Item SalesP.ID
78425>>>            Set Label to "Sales Person ID:"
78426>>>            Set Size to 13 46
78427>>>            Set Location to 4 70
78428>>>            Set Label_Col_Offset to 2
78429>>>            Set Label_Justification_Mode to jMode_Right
78430>>>        End_Object    // oSalesP_ID
78431>>>
78431>>>        Object oSalesP_Name is a dbForm
78433>>>            Entry_Item SalesP.Name
78434>>>            Set Label to "Sales Person Name:"
78435>>>            Set Size to 13 156
78436>>>            Set Location to 20 70
78437>>>            Set Label_Col_Offset to 2
78438>>>            Set Label_Justification_Mode to jMode_Right
78439>>>        End_Object    // oSalesP_Name
78440>>>
78440>>>    End_Object    // oContainer1
78441>>>
78441>>>CD_End_Object    // oSalesPersonView
78443>>>>
78443>        Use Vendor.vw
Including file: Vendor.vw    (C:\Test\Order Entry git\AppSrc\Vendor.vw)
78443>>>Use dfClient.pkg
78443>>>Use DataDict.pkg
78443>>>Use dfEntry.pkg
78443>>>Use dfCEntry.pkg
78443>>>Use Vendor.DD
78443>>>
78443>>>DEFERRED_VIEW Activate_oVendorView FOR ;;Object oVendorView is a dbView
78468>>>    Set Border_Style to Border_Thick
78469>>>    Set Label to "Vendor Entry View"
78470>>>    Set Location to 6 6
78471>>>    Set Size to 137 281
78472>>>    Set piMaxSize to 137 350
78473>>>    Set piMinSize to 137 215
78474>>>
78474>>>    Object Vendor_DD is a Vendor_DataDictionary
78476>>>    End_Object    // Vendor_DD
78477>>>
78477>>>    Set Main_DD to Vendor_DD
78478>>>    Set Server to Vendor_DD
78479>>>
78479>>>    Object oContainer1 is a dbContainer3d
78481>>>        Set Size to 129 273
78482>>>        Set Location to 4 4
78483>>>        Set peAnchors to anAll
78484>>>        Object oVendor_Id is a dbForm
78486>>>            Entry_Item Vendor.ID
78487>>>            Set Label to "Vendor ID:"
78488>>>            Set Size to 13 42
78489>>>            Set Location to 4 67
78490>>>            Set peAnchors to anTopLeft
78491>>>            Set Label_Col_Offset to 2
78492>>>            Set Label_Justification_Mode to jMode_Right
78493>>>        End_Object    // oVendor_ID
78494>>>
78494>>>        Object oVendor_Name is a dbForm
78496>>>            Entry_Item Vendor.Name
78497>>>            Set Label to "Vendor Name:"
78498>>>            Set Size to 13 186
78499>>>            Set Location to 18 67
78500>>>            Set peAnchors to anTopLeftRight
78501>>>            Set Label_Col_Offset to 2
78502>>>            Set Label_Justification_Mode to jMode_Right
78503>>>        End_Object    // oVendor_Name
78504>>>
78504>>>        Object oVendor_Address is a dbForm
78506>>>            Entry_Item Vendor.Address
78507>>>            Set Label to "Street Address:"
78508>>>            Set Size to 13 186
78509>>>            Set Location to 34 67
78510>>>            Set peAnchors to anTopLeftRight
78511>>>            Set Label_Col_Offset to 2
78512>>>            Set Label_Justification_Mode to jMode_Right
78513>>>        End_Object    // oVendor_Address
78514>>>
78514>>>        Object oVendor_City is a dbForm
78516>>>            Entry_Item Vendor.City
78517>>>            Set Label to "City:"
78518>>>            Set Size to 13 90
78519>>>            Set Location to 49 67
78520>>>            Set peAnchors to anTopLeft
78521>>>            Set Label_Col_Offset to 2
78522>>>            Set Label_Justification_Mode to jMode_Right
78523>>>        End_Object    // oVendor_City
78524>>>
78524>>>        Object oVendor_State is a dbComboForm
78526>>>            Entry_Item Vendor.State
78527>>>            Set Label to "State:"
78528>>>            Set Size to 13 32
78529>>>            Set Location to 64 67
78530>>>            Set peAnchors to anTopLeft
78531>>>            Set Form_Border to 0
78532>>>            Set Label_Col_Offset to 2
78533>>>            Set Label_Justification_Mode to jMode_Right
78534>>>            Set Entry_State to False
78535>>>            Set Code_Display_Mode to cb_code_display_code
78536>>>        End_Object    // oVendor_State
78537>>>
78537>>>        Object oVendor_Zip is a dbForm
78539>>>            Entry_Item Vendor.Zip
78540>>>            Set Label to "Zip/Postal Code:"
78541>>>            Set Size to 13 66
78542>>>            Set Location to 79 67
78543>>>            Set peAnchors to anTopLeft
78544>>>            Set Label_Col_Offset to 2
78545>>>            Set Label_Justification_Mode to jMode_Right
78546>>>        End_Object    // oVendor_Zip
78547>>>
78547>>>        Object oVendor_Phone_Number is a dbForm
78549>>>            Entry_Item Vendor.Phone_Number
78550>>>            Set Label to "Phone Number:"
78551>>>            Set Size to 13 126
78552>>>            Set Location to 94 67
78553>>>            Set peAnchors to anTopLeftRight
78554>>>            Set Label_Col_Offset to 2
78555>>>            Set Label_Justification_Mode to jMode_Right
78556>>>        End_Object    // oVendor_Phone_Number
78557>>>
78557>>>        Object oVendor_Fax_Number is a dbForm
78559>>>            Entry_Item Vendor.Fax_Number
78560>>>            Set Label to "Fax Number:"
78561>>>            Set Size to 13 126
78562>>>            Set Location to 108 67
78563>>>            Set peAnchors to anTopLeftRight
78564>>>            Set Label_Col_Offset to 2
78565>>>            Set Label_Justification_Mode to jMode_Right
78566>>>        End_Object    // oVendor_Fax_Number
78567>>>
78567>>>    End_Object    // oContainer1
78568>>>
78568>>>CD_End_Object    // oVendorView
78570>>>>
78570>        
78570>        Use Basic\CustomerListBR.rv
Including file: Basic\CustomerListBR.rv    (C:\Test\Order Entry git\AppSrc\Basic\CustomerListBR.rv)
78570>>>Use DFAllRpt.pkg
78570>>>Use Basic\CustBasicRptImages.inc  // contains the images for the report
Including file: Basic\CustBasicRptImages.inc    (C:\Test\Order Entry git\AppSrc\Basic\CustBasicRptImages.inc)
78570>>>>>// CustBasicRptImages.pkg - images for CustomerListBR.rv
78570>>>>>// Since report images, such as the one used here, are not fully supported by
78570>>>>>// the Studio, we have placed the images for this report in a separate package.
78570>>>>>
/CUSTHDR
Image 2, CUSTHDR
                             Customer Listing                      Page:___.
Number  Name
----------------------------------------------------------------------------
/CustBody
Image 3, CUSTBODY
_____.  ______________________________
/Footer
Image 4, FOOTER
Date printed:  __/__/____
/*
78570>>>
78570>>>Open Customer
78572>>>Use dfrptvw.pkg
78572>>>Use dfRadio.pkg
Including file: Dfradio.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\Dfradio.pkg)
78572>>>>>Use windows.pkg // this now lives here. (you don't need to ever use this). 
78572>>>>>
78572>>>Use Windows.pkg
78572>>>
78572>>>DEFERRED_VIEW Activate_oCustomerListBR FOR ;;Object oCustomerListBR is a ReportView
78597>>>
78597>>>    Property Integer piSortIndex Public 1
78599>>>
78599>>>    Set Label to "Customer List"
78600>>>    Set Location to 6 6
78601>>>    Set Size to 80 180
78602>>>
78602>>>    Object oDestination is a RadioGroup
78604>>>        Set Size to 50 80
78605>>>        Set Location to 5 5
78606>>>        Set Label to "Output Device:"
78607>>>        Object oScreen is a Radio
78609>>>            Set Label to "Screen"
78610>>>            Set Size to 10 39
78611>>>            Set Location to 15 10
78612>>>            Set Status_Help to "Preview the report to screen"
78613>>>        End_Object    // oScreen
78614>>>
78614>>>        Object oPrinter is a Radio
78616>>>            Set Label to "Printer"
78617>>>            Set Size to 10 37
78618>>>            Set Location to 30 10
78619>>>            Set Status_Help to "Send the report to the default printer"
78620>>>        End_Object    // oPrinter
78621>>>
78621>>>        // set the Output_Device_Mode each time the radio button changes
78621>>>        Procedure Notify_Select_State Integer iNewItem Integer iOldItem
78624>>>            Forward Send Notify_Select_State iNewItem iOldItem
78626>>>        
78626>>>            If (iNewItem=0) Set Output_Device_Mode To PRINT_TO_WINDOW
78629>>>            Else            Set Output_Device_Mode To PRINT_TO_PRINTER
78631>>>        End_Procedure
78632>>>
78632>>>    End_Object    // oDestination
78633>>>
78633>>>    Object oOrderRadio is a RadioGroup
78635>>>        Set Size to 50 80
78636>>>        Set Location to 5 95
78637>>>        Set Label to "Report Order:"
78638>>>        Object oNumber is a Radio
78640>>>            Set Label to "Number"
78641>>>            Set Size to 10 41
78642>>>            Set Location to 15 10
78643>>>            Set Status_Help to "Sort by customer number"
78644>>>        End_Object    // oNumber
78645>>>
78645>>>        Object oName is a Radio
78647>>>            Set Label to "Name"
78648>>>            Set Size to 10 35
78649>>>            Set Location to 30 10
78650>>>            Set Status_Help to "Sort by customer name"
78651>>>        End_Object    // oName
78652>>>
78652>>>        // set the piSortIndex each time the radio button changes
78652>>>        Procedure Notify_Select_State Integer iNewItem Integer iOldItem
78655>>>            Forward Send Notify_Select_State iNewItem iOldItem
78657>>>        
78657>>>            Set piSortIndex  To (iNewItem + 1)
78658>>>        End_Procedure
78659>>>
78659>>>    End_Object    // oOrderRadio
78660>>>
78660>>>    Object oOkButton is a Button
78662>>>        Set Label to "OK"
78663>>>        Set Size to 14 51
78664>>>        Set Location to 62 71
78665>>>        Set Default_State to True
78666>>>
78666>>>        Procedure OnClick
78669>>>            Send StartReport
78670>>>        End_Procedure
78671>>>
78671>>>    End_Object    // oOkButton
78672>>>
78672>>>    Object oCancelButton is a Button
78674>>>        Set Label to "Cancel"
78675>>>        Set Location to 62 125
78676>>>
78676>>>        Procedure OnClick
78679>>>            Send Request_Cancel
78680>>>        End_Procedure
78681>>>
78681>>>    End_Object    // oCancelButton
78682>>>
78682>>>    Procedure StartReport
78685>>>        Integer iOutputDevice
78685>>>        Handle hoThisWorkspace
78685>>>        String sCurDir sDataPath 
78685>>>        String sFileName
78685>>>                    
78685>>>        Get Output_Device_Mode to iOutputDevice
78686>>>
78686>>>        If (iOutputDevice=PRINT_TO_WINDOW) Begin
78688>>>            // save current location
78688>>>            Get_Current_Directory to sCurDir
78689>>>
78689>>>            // get workspace data path (all users must have r/w rights to it) to output the temp file there
78689>>>            Get phoWorkspace of ghoApplication to hoThisWorkspace
78690>>>            Get psDataPath of hoThisWorkspace to sDataPath
78691>>>            Get PathAtIndex of hoThisWorkspace sDataPath 1 to sDataPath
78692>>>            
78692>>>            // set current directory to DataPath
78692>>>            Set_Directory sDataPath
78693>>>        
78693>>>            Make_Temp_File "TXT" sFileName
78694>>>            Move (".\" - sFileName) to sFileName
78695>>>            Set Output_Device_Name to sFileName
78696>>>        End
78696>>>>
78696>>>        Else Begin
78697>>>           Set Output_Device_Name to "WinLST:"
78698>>>        End
78698>>>>
78698>>>    
78698>>>        Send Run_Report
78699>>>    
78699>>>        If (iOutputDevice=PRINT_TO_WINDOW) Begin
78701>>>           Runprogram background "NotePad" sFileName
78702>>>           EraseFile sFileName
78703>>>>
78703>>>        End
78703>>>>
78703>>>        
78703>>>        // restore previous location
78703>>>        Set_Directory sCurDir
78704>>>        
78704>>>    End_Procedure   // StartReport
78705>>>    
78705>>>    Object oCustomer_BasicReport is a BasicReport
78707>>>    
78707>>>        Report_Main_File Customer
78708>>>    
78708>>>        Set Report_Title to "Printing Customer Names"
78709>>>    
78709>>>        Function Starting_Main_Report Returns Integer
78712>>>            Integer iRetVal
78712>>>            Integer iIndex
78712>>>    
78712>>>            Forward Get Starting_Main_Report to iRetVal
78714>>>    
78714>>>            Get piSortIndex To iIndex
78715>>>            Report_Index BY iIndex    // set the sort order
78717>>>            Sysdate Footer.1         // set date for report
78718>>>            
78718>>>            Function_Return iRetVal
78719>>>        End_Function
78720>>>    
78720>>>        Procedure_Section Page_Top as CustHdr
78725>>>            Integer iPage
78725>>>            Get Page_Count To iPage
78726>>>            Print iPage
78727>>>            OutPut_PageCheck
78728>>>        End_Procedure
78729>>>    
78729>>>        Procedure_Section Body as CustBody
78734>>>            Send Update_Status (String(Customer.Customer_Number)- ":" * Customer.Name )
78735>>>            Print Customer.Customer_number
78736>>>            Print Customer.Name
78737>>>            OutPut_PageCheck
78738>>>        End_Procedure
78739>>>    
78739>>>        Procedure_Section Page_Bottom as Footer
78749>>>            OutPut_PageCheck
78750>>>        End_Procedure
78751>>>    
78751>>>    End_Object    // Customer_BasicReport
78752>>>
78752>>>CD_End_Object    // oCustomerListBR
78754>>>>
78754>        Use WinPrint\CustomerListWP.rv
Including file: WinPrint\CustomerListWP.rv    (C:\Test\Order Entry git\AppSrc\WinPrint\CustomerListWP.rv)
78754>>>Use dfrptvw.pkg
78754>>>Use DataDict.pkg
78754>>>Use dfRadio.pkg
78754>>>Use Windows.pkg
78754>>>Use cWinReport2.pkg
Including file: cWinReport2.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cWinReport2.pkg)
78754>>>>>// cWinReport2.pkg
78754>>>>>
78754>>>>>// defines support for new Winprint2 cWinReport2 class
78754>>>>>
78754>>>>>
78754>>>>>Use DFRpt.pkg              // BasicReport RO Class for VDF
78754>>>>>Use WinPrint2.pkg          // WinPrint2 engine
Including file: Winprint2.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\Winprint2.pkg)
78754>>>>>>>// WinPrint2.pkg
78754>>>>>>>//
78754>>>>>>>Use windows.pkg
78754>>>>>>>Use LanguageText.pkg
78754>>>>>>>Use DLL.pkg
78754>>>>>>>Use WinPrint2_Api.pkg
Including file: WinPrint2_API.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\WinPrint2_API.pkg)
78754>>>>>>>>>//WinPrint2_API.pkg
78754>>>>>>>>>
78754>>>>>>>>>Use DLL.pkg
78754>>>>>>>>>
78754>>>>>>>>>External_Function WP_IsPrinterValid "IsPrinterValid" WinPrint.dll ;Returns Boolean // True if the the current printer is a valid one. False, otherwise.
78755>>>>>>>>>
78755>>>>>>>>>External_Function WP_ArePrintersInstalled "ArePrintersInstalled" WinPrint.dll ; // determines whether at least one printer is installedReturns Boolean // True, if a printer is installed, False if it is not.
78756>>>>>>>>>
78756>>>>>>>>>External_Function WP_ExecutePrinterSetupDialog "ExecutePrinterSetupDialog" WinPrint.dll ; // displays the "printer setup" dialog   Handle hWndParent; // window handle of the parent windowReturns Boolean // True if the OK button pressed; False, otherwise.
78757>>>>>>>>>
78757>>>>>>>>>External_Function WP_ExecutePrintDialog "ExecutePrintDialog" WinPrint.dll ; // displays the "Print" dialog   Handle hWndParent; // window handle of the parent windowReturns Boolean // True if the OK button pressed; False, otherwise.
78758>>>>>>>>>
78758>>>>>>>>>External_Function WP_GetCurrentDevice "GetCurrentDevice" WinPrint.dll ; // retrieves the name of the current printer device    Address aDevice ; // address of the string (255 chars) that will hold the device name upon returnReturns Boolean // True, if success; False if error occurred
78759>>>>>>>>>
78759>>>>>>>>>External_Function WP_GetPrintDialogFlags "GetPrintDialogFlags" WinPrint.dll ; // retrieves the current print optionsReturns UInteger // array of flags representing print-related options that are currently set
78760>>>>>>>>>
78760>>>>>>>>>External_Function WP_GetUserDefinedPapersize "GetUserDefinedPapersize" WinPrint.dll ;  // gets the size of user-defined paperReturns UInteger // // hi-word=length; lo-word=width
78761>>>>>>>>>
78761>>>>>>>>>External_Function WP_IsPrintDialogFlagSet "IsPrintDialogFlagSet" WinPrint.dll ; // determines whether a specific print-flag is set    UInteger iFlag ; // the printer flagReturns Boolean // True, if the flag is set; False, if it isn't
78762>>>>>>>>>
78762>>>>>>>>>External_Function WP_SelectPrinter "SelectPrinter" WinPrint.dll ; // selects a printer programatically    String sDevice; // the name of the printerReturns Boolean // True, if success; False, if error (such as an invalid printer name)
78763>>>>>>>>>
78763>>>>>>>>>External_Function WP_SetFirstPagePaperSource "SetFirstPagePaperSource"  WinPrint.dll ;        Integer iBin ; // the bim constantReturns Boolean // True if success, false if error
78764>>>>>>>>>
78764>>>>>>>>>External_Function WP_SetNumberOfPrintCopies "SetNumberOfPrintCopies" WinPrint.dll ; // sets the number of copies to print    UInteger iNumCopies; // number of copies to makeReturns Boolean // Always True
78765>>>>>>>>>
78765>>>>>>>>>External_Function WP_SetSpecificPrintDialogFlag "SetSpecificPrintDialogFlag" WinPrint.dll; // Sets/unsets one printer flag    UInteger fFlag; // printer flagReturns Boolean // True, if success; False if error occurred
78766>>>>>>>>>
78766>>>>>>>>>External_Function WP_SetPrintDialogFlags "SetPrintDialogFlags" WinPrint.dll; // Sets/unsets all printer flags in one call    UInteger fFlags; // printer flagsReturns Boolean // True, if success; False if error occurred
78767>>>>>>>>>
78767>>>>>>>>>External_Function WP_SetUserDefinedPapersize "SetUserDefinedPapersize" WinPrint.dll ;  // sets the size of user-defined paper    UInteger iPaperSize ; // hi-word=length; lo-word=widthReturns Boolean; // True, if success; False if error occurred
78768>>>>>>>>>External_Function WP_SetFontStyle "SetFontStyle" WinPrint.dll ; // sets multiple font attributes    Integer iStyles ; // series of flagsReturns Boolean // always True
78769>>>>>>>>>
78769>>>>>>>>>External_Function WP_SetFontBold "SetFontBold" WinPrint.dll ; // toggles the bold attribute of the current font    Boolean bBold ; // True to switch bold attribute on; False to switch it offReturns Boolean // always True
78770>>>>>>>>>
78770>>>>>>>>>External_Function WP_SetFontItalic "SetFontItalic" WinPrint.dll ; // toggles the italic attribute of the current font    Boolean bItalic ; // True to switch italic attribute on; False to switch it offReturns Boolean  // always True
78771>>>>>>>>>
78771>>>>>>>>>External_Function WP_SetFontUnderline "SetFontUnderline" WinPrint.dll ; // toggles the underline attribute of the current font    Boolean bUnderline ; // True to switch underline attribute on; False to switch it offReturns Boolean  // always True
78772>>>>>>>>>
78772>>>>>>>>>External_Function WP_SetFontStrikeout "SetFontStrikeout" WinPrint.dll ; // toggles the strikeout attribute of the current font    Boolean bStrikeout ; // True to switch strikeout attribute on; False to switch it offReturns Boolean  // always True
78773>>>>>>>>>
78773>>>>>>>>>External_Function WP_SetFontColor "SetFontColor" WinPrint.dll ; // sets the color of the current font    Integer iColor ; // color of the fontReturns Boolean  // always True
78774>>>>>>>>>
78774>>>>>>>>>External_Function WP_SetFontHeight "SetFontHeight" WinPrint.dll ; // sets the height of the font    UInteger iHeight ; // height of the font in points (multiplied by 100. Eg 12.5 point should be sent as 1250)Returns Boolean  // always True
78775>>>>>>>>>
78775>>>>>>>>>External_Function WP_SetFontName "SetFontName" WinPrint.dll ; // Sets the name of the font to use    String sFontName ; // name of the font to useReturns Boolean  // always True
78776>>>>>>>>>
78776>>>>>>>>>External_Function WP_DrawBitmap "DrawBitmap" WinPrint.dll ; // Draws a bitmap (BMP, JPG)    String  sBitmap;                 // Name of the bitmap    Integer iLeft;                   // distance from left edge to draw bitmap    Integer iTop;                    // distance from top edge to draw bitmap    Integer iWidth;                  // width of the bitmap    Integer iHeight;                 // height of the bitmap    Boolean bUpdateCurrentPosition;  // after drawing, should the current position be updated?Returns Boolean // True, if OK; False, if an error occurred.
78777>>>>>>>>>
78777>>>>>>>>>External_Function WP_DrawEllipse "DrawEllipse" WinPrint.dll ; // draws an elipse within a bounding rectangle    Integer iLeft;                   // distance from left edge to draw the ellipse    Integer iTop;                    // distance from top edge to draw the ellipse    Integer iWidth;                  // width of the bounding rectangle    Integer iHeight;                 // height of the bounding rectangle    Integer iBorderColor;            // color of the ellipse's edge    Integer iFillColor;              // internal color of the ellipse    Boolean  bFill;                  // should the ellipse be filled? (False=transparent)    UInteger iThickness;             // thickness of the elipse    Boolean  bUpdateCurrentPosition; // after drawing, should the current position be updated?    Boolean  bWrap;                  // Should the ellipse be drawn on future soft-page breaks?Returns Boolean // True, if OK; False, if an error occurred.
78778>>>>>>>>>
78778>>>>>>>>>External_Function WP_DrawLine "DrawLine" WinPrint.dll ; // draws a line from the current position    Integer iLeft;                   // distance from left edge to draw the line    Integer iTop;                    // distance from top edge to draw the line    Integer iLength;                 // length of the line    Boolean  bHorizontal;            // draw horizontal? (False=vertical)    Integer iColor;                  // color of the line    UInteger iThickness;             // thickness of the line    Boolean  bUpdateCurrentPosition; // after drawing, should the current position be updated?Returns Boolean // True, if OK; False, if an error occurred.
78779>>>>>>>>>
78779>>>>>>>>>External_Function WP_DrawRectangle "DrawRectangle" WinPrint.dll ; // draws a rectangle    Integer iLeft;                   // distance from left edge to draw the rectangle    Integer iTop;                    // distance from top edge to draw the rectangle    Integer iWidth;                  // width of the rectangle    Integer iHeight;                 // height of the rectangle    Integer iBorderColor;            // color of the rectangle's border    Integer iFillColor;              // internal color of the rectangle    Boolean  bFill;                  // should the rectangle be filled? (False=transparent)    UInteger iThickness;             // thickness of the rectangle's border    Boolean  bUpdateCurrentPosition; // after drawing, should the current position be updated?    Boolean  bWrap;                  // Should the rectangle be drawn on future soft-page breaks?Returns Boolean // True, if OK; False, if an error occurred.
78780>>>>>>>>>
78780>>>>>>>>>External_Function WP_DrawXYLine "DrawXYLine" WinPrint.dll ; // draws a line between two points    Integer iLeftStart;              // distance from left edge to draw from    Integer iTopStart;               // distance from top edge to draw from    Integer iLeftEnd;                // distance from left edge to draw to    Integer iTopEnd;                 // distance from top edge to draw to    Integer iColor;                  // color of the line    UInteger iThickness;             // thickness of the line    Boolean  bUpdateCurrentPosition; // after drawing, should the current position be updated?    Boolean  bWrap;                  // Should the line be drawn on future soft-page breaks?Returns Boolean // True, if OK; False, if an error occurred.
78781>>>>>>>>>
78781>>>>>>>>>External_Function WP_SetAbsoluteMargins "SetAbsoluteMargins" WinPrint.dll ; // modifies the top/bottom non-printable margin    UInteger iTop;      // the top margin offset    UInteger iBottom;   // the bottom margin offset    Boolean  bAllPages; // should all pages be affected? True=AllPages; False=first page onlyReturns Boolean // always True
78782>>>>>>>>>
78782>>>>>>>>>External_Function WP_SetMargins "SetMargins" WinPrint.dll ; // Sets the user-margins    UInteger iLeft;   // the left margin    UInteger iTop;    // the top margin    UInteger iRight;  // the right margin    UInteger iBottom; // the bottom marginReturns Boolean // always True
78783>>>>>>>>>
78783>>>>>>>>>External_Function WP_CreateDiagram "CreateDiagram" WinPrint.dll ; // Creates a new diagram    UInteger eType;       // type of diagram (Bar, Line, Pie)    UInteger eEffect;     // how it is drawn (2d or 3d, etc)    UInteger iWidth;      // width of the diagram    UInteger iHeight;     // height of the diagram    Boolean  bDrawXyAxis; // draw the xy-axis (for bar charts only)?Returns Handle // unique id for the diagram used in other diagram funtions
78784>>>>>>>>>
78784>>>>>>>>>External_Function WP_AddDiagramEntry "AddDiagramEntry" WinPrint.dll ; // Adds an item into a diagram    Handle   hDiagram;          // diagram handle returned by CreateDiagram()    String   sValueDescription; // description of the item    String   sValue;            // value of the item    Integer iBorderColor;       // color of the item's border    Integer iFillColor;         // color of the item's interior    Boolean  bFilled;           // should the item be drawn filled (with iFillColor), or transparent?    UInteger iNumDecimals;      // Number of decimals in the sValue argument    UInteger eValueOrPercent;   // How the value should be displayed (as value or percentage, etc)    Boolean  bExploded;         // should the value be "pulled out" (pie charts only)Returns Boolean // True, if success; False, if error
78785>>>>>>>>>
78785>>>>>>>>>External_Function WP_DrawDiagram "DrawDiagram" WinPrint.dll ; // draws a diagram    Handle   hDiagram;               // diagram handle returned by CreateDiagram()    UInteger iLeft;                  // x-coordinate to draw the diagram    UInteger iTop;                   // y-coordinate to draw the diagram    Boolean  bUpdateCurrentPosition; // after drawing, should the current position be updated?Returns Boolean // True, if success; False, if error
78786>>>>>>>>>
78786>>>>>>>>>External_Function WP_LockDiagram "LockDiagram" WinPrint.dll ; // Locks a diagram so that no more entries can be added    Handle hDiagram; // diagram handle returned by CreateDiagram()Returns Boolean // True, if success; False, if error
78787>>>>>>>>>
78787>>>>>>>>>External_Function WP_SetDiagramCaption "SetDiagramCaption" WinPrint.dll ; // Sets the caption of a diagram    Handle hDiagram; // diagram handle returned by CreateDiagram()    String sCaption; // the diagram's captionReturns Boolean // True, if success; False, if error
78788>>>>>>>>>
78788>>>>>>>>>External_Function WP_SetDiagramXText "SetDiagramXText" WinPrint.dll ; // Sets the horizontal label of a diagram    Handle hDiagram; // diagram handle returned by CreateDiagram()    String sText;    // the diagram's horizonal labelReturns Boolean // True, if success; False, if error
78789>>>>>>>>>
78789>>>>>>>>>External_Function WP_SetDiagramYText "SetDiagramYText" WinPrint.dll ; // Sets the vertical label of a diagram    Handle  hDiagram;      // diagram handle returned by CreateDiagram()    String  sText;         // the diagram's vertical label    Boolean bVerticalText; // should the text be drawn vertically (False=horizontally)Returns Boolean // True, if success; False, if error
78790>>>>>>>>>
78790>>>>>>>>>External_Function WP_BeginHeader "BeginHeader" WinPrint.dll ; // creates a new header    UInteger iHeaderType; // the type of header    UInteger iSubHeaderNum; // for subheaders, then number (1-0)Returns Boolean // always True
78791>>>>>>>>>
78791>>>>>>>>>External_Function WP_EndHeader "EndHeader" WinPrint.dll ; // declares the end of the current headerReturns Boolean // always True
78792>>>>>>>>>
78792>>>>>>>>>External_Function WP_SetExtraLineCheck "SetExtraLineCheck" WinPrint.dll ; // forces a soft page break if header plus number of lines don't fit on page    UInteger iNumLines; // number of lines in addition to header required before forcing a soft page-breakReturns Boolean; // always True
78793>>>>>>>>>External_Function WP_SetHeaderFrame "SetHeaderFrame" WinPrint.dll ; // sets the style, color and frame of a header    UInteger eFrame;     // style of frame (margin-to-margin, etc)    Integer iColor;      // color of the frame's edge    UInteger iThickness; // thickness of the frame    Integer iFillCol;    // the internal color of the frame (only used if bBilled=True)    Boolean  bFilled;    // True, if the frame should be filled with the iFillColor (False=Transparent)Returns Boolean // Always True
78794>>>>>>>>>
78794>>>>>>>>>External_Function WP_SetHeaderMargin "SetHeaderMargin" WinPrint.dll ; // Sets a margin of space on the inside and outside of the current header    UInteger eType;      // Specifies which margin areas is being set.    Integer  iSize;      // Size of the margin setting in the current report metricsReturns Boolean  // False if document is not started
78795>>>>>>>>>
78795>>>>>>>>>External_Function WP_SetHeaderPlacement "SetHeaderPlacement" WinPrint.dll ; // placement (left, center or right) of the header    UInteger ePlacement; // placed left, center or rightReturns Boolean //always True
78796>>>>>>>>>
78796>>>>>>>>>External_Function WP_SetHeaderWrap "SetHeaderWrap" WinPrint.dll ; // determines whether the current header is drawn on soft page-breaks    Boolean bWrap; // True, to wrap onto following pages; False, for current page onlyReturns Boolean // always True
78797>>>>>>>>>
78797>>>>>>>>>External_Function WP_WriteHeader "WriteHeader" WinPrint.dll ; // writes a header to the current page    UInteger eHeaderType;   // type of header    UInteger iSubHeaderNum; // for subheaders, the number (1-9)Returns Boolean // True, if success; False, if error
78798>>>>>>>>>
78798>>>>>>>>>External_Function WP_RGBToDFPrintColor "RGBToDFPrintColor" WinPrint.dll ; // converts R, G, and B values into a composite color that WinPrint expects    UInteger iRed;   // red component (1-255)    UInteger iGreen; // green component (1-255)    UInteger iBlue;  // blue component (1-255)Returns Integer // composite color
78799>>>>>>>>>
78799>>>>>>>>>External_Function WP_GetMetrics "GetMetrics" WinPrint.dll ; // gets the current unit of measurementReturns UInteger // unit of measurement (Inch or CM)
78800>>>>>>>>>
78800>>>>>>>>>External_Function WP_SetMetrics "SetMetrics" WinPrint.dll ; // sets the unit of measurement   UInteger eMetrics; // Inch or CMReturns Boolean // always True
78801>>>>>>>>>
78801>>>>>>>>>External_Function WP_ClearDocument "ClearDocument" WinPrint.dll ; // clears the resources of the document from memoryReturns Boolean // always True
78802>>>>>>>>>
78802>>>>>>>>>External_Function WP_NewDocument "NewDocument" WinPrint.dll ; // starts a new document, but preserves the printer settings   Boolean bAutoPreview ; // Should the Previewer be displayed immediatelyReturns Boolean // True, if success; False, if an error occurred
78803>>>>>>>>>
78803>>>>>>>>>External_Function WP_EndDocument "EndDocument" WinPrint.dll ; // Indicates that the document is finishedReturns Boolean // always True
78804>>>>>>>>>
78804>>>>>>>>>External_Function WP_ClearPrinter "ClearPrinter" WinPrint.dll ; // clears all printer and document resourcesReturns Boolean // True, if success; False, if an error occurred
78805>>>>>>>>>
78805>>>>>>>>>External_Function WP_ConfirmLines "ConfirmLines" WinPrint.dll ; // ensures that a specified number of lines will fit on the page; if not, a soft page-break is performed automatically    UInteger iNumLines; // number of lines that must fit on the pageReturns Boolean // True, if success; False, if an error occurred
78806>>>>>>>>>
78806>>>>>>>>>External_Function WP_CreatePage "CreatePage" WinPrint.dll ; // creates a new page of specified columns   UInteger iNumColumns; // number of columns (zero= no columns)Returns UInteger; // page number that was created
78807>>>>>>>>>External_Function WP_PreviewDocument "PreviewDocument" WinPrint.dll ; // previews the current document    Boolean bPrintDialog; // Determines whether the Print Dialog (range, etc) is displayed when the "print" button is clicked in the preview window.    Boolean bPrintSetup;  // Determines whether the Print Setup button is enabled (allows to change orientation, etc)    Boolean bPrint;       // Determines whether the Print button is enabledReturns Handle // non-zero = hViewerProcess; zero= error
78808>>>>>>>>>
78808>>>>>>>>>External_Function WP_ClosePreview "ClosePreview" WinPrint.dll ; // closes the preview windowReturns Boolean // True, if closed; False, if an error occurred (such as it not being already open)
78809>>>>>>>>>
78809>>>>>>>>>External_Function WP_PrintDocument "PrintDocument" WinPrint.dll ; // prints the current document    Handle hWndParent; // window handle of object to use for any modal outputReturns Boolean // True, if success; False, if an error occurred
78810>>>>>>>>>
78810>>>>>>>>>External_Function WP_SetAlign "SetAlign" WinPrint.dll ; // align future text    UInteger eAlign; // left, center or rightReturns Boolean // always True
78811>>>>>>>>>
78811>>>>>>>>>External_Function WP_WriteText "WriteText" WinPrint.dll ; // write text to the current position or column    String sText;               // the text to write    Boolean bNewLineAfterPrint; // should a "CR" be written after the text    UInteger iColumnNum;        // number of the column to write to (zero=no column, use current position)    Integer iNumDecimals;       // number of decimals in the text (-1 means sText is a string)    UInteger iWidth;            // width of text before truncatingReturns Boolean // True, if success; False, if an error occurred
78812>>>>>>>>>
78812>>>>>>>>>External_Function WP_WriteTextAtPosition "WriteTextAtPosition" WinPrint.dll ; // writes text to a specific position    String sText;               // the text to write    Boolean bNewLineAfterPrint; // should a "CR" be written after the text    UInteger iPosition;         // horizontal position to write the text    Integer iNumDecimals;       // number of decimals in the text (-1 means sText is a string)    UInteger iWidth;            // width of text before truncatingReturns Boolean // True, if success; False, if an error occurred
78813>>>>>>>>>
78813>>>>>>>>>External_Function WP_SetProgressCaption "SetProgressCaption" WinPrint.dll ;    String sProgressCaption ;Returns Boolean
78814>>>>>>>>>
78814>>>>>>>>>External_Function WP_SetReportTitle     "SetReportTitle"     WinPrint.dll ;    String sCaption ;Returns Boolean
78815>>>>>>>>>
78815>>>>>>>>>External_Function WP_ViewerWantsToClose "ViewerWantsToClose" WinPrint.dll ;Returns Integer
78816>>>>>>>>>
78816>>>>>>>>>External_Function WP_DisplayMessageBox  "DisplayMessageBox"  WinPrint.dll ;    String sCaption String sText ;Returns Integer
78817>>>>>>>>>
78817>>>>>>>>>External_Function WP_GetViewerWindow "GetViewerWindow" Winprint.dll ;Returns Handle
78818>>>>>>>>>
78818>>>>>>>>>External_Function WP_GetDocumentStatus "GetDocumentStatus" Winprint.dll ;Returns Integer // returns dsNotStarted, dsStarted, or dsFinished
78819>>>>>>>>>
78819>>>>>>>Use WinPrint_Constants.pkg
78819>>>>>>>Use Rgb.pkg
78819>>>>>>>Use GlobalFunctionsProcedures.pkg
78819>>>>>>>
78819>>>>>>>DEFINE INFINITE for -1
78819>>>>>>>DEFINE WAIT_TIMEOUT for |CI$00000102
78819>>>>>>>
78819>>>>>>>
78819>>>>>>>DEFINE QS_KEY            for |CI$0001
78819>>>>>>>DEFINE QS_MOUSEMOVE      for |CI$0002
78819>>>>>>>DEFINE QS_MOUSEBUTTON    for |CI$0004
78819>>>>>>>DEFINE QS_POSTMESSAGE    for |CI$0008
78819>>>>>>>DEFINE QS_TIMER          for |CI$0010
78819>>>>>>>DEFINE QS_PAINT          for |CI$0020
78819>>>>>>>DEFINE QS_SENDMESSAGE    for |CI$0040
78819>>>>>>>DEFINE QS_HOTKEY         for |CI$0080
78819>>>>>>>DEFINE QS_ALLPOSTMESSAGE for |CI$0100
78819>>>>>>>DEFINE QS_MOUSE          for (QS_MOUSEMOVE ior QS_MOUSEBUTTON)
78819>>>>>>>DEFINE QS_INPUT          for (QS_MOUSE ior QS_KEY)
78819>>>>>>>DEFINE QS_ALLEVENTS      for (QS_INPUT ior QS_POSTMESSAGE ior QS_TIMER ior QS_PAINT ior QS_HOTKEY)
78819>>>>>>>DEFINE QS_ALLINPUT       for (QS_INPUT ior QS_POSTMESSAGE ior QS_TIMER ior QS_PAINT ior QS_HOTKEY ior QS_SENDMESSAGE)
78819>>>>>>>
78819>>>>>>>External_Function WaitForSingleObject "WaitForSingleObject" Kernel32.dll Handle hHandle Dword dwMilliseconds Returns DWord
78820>>>>>>>External_Function GetCurrentProcessId "GetCurrentProcessId" Kernel32.dll Returns DWord
78821>>>>>>>External_Function GetCurrentProcess "GetCurrentProcess" Kernel32.dll Returns DWord
78822>>>>>>>
78822>>>>>>>External_Function MsgWaitForMultipleObjects "MsgWaitForMultipleObjects" User32.dll ;    DWORD nCount;             // number of handles in the object handle array    Address pHandles;     // pointer to the object-handle array    Boolean fWaitAll;     // wait for all or wait for one    DWORD dwMilliseconds; // time-out interval in milliseconds    DWORD dwWakeMask;     // type of input events to wait forReturns Dword
78823>>>>>>>
78823>>>>>>>Use GlobalFunctionsProcedures.pkg
78823>>>>>>>
78823>>>>>>>Class cWinPrint2 is a cObject // JJT: Will we need a windows handle for this like old one
78824>>>>>>>    Procedure Construct_Object
78826>>>>>>>        forward send construct_object
78828>>>>>>>
78828>>>>>>>        //*** internal properties
78828>>>>>>>        Property Integer DFCurrent_Color       0
78829>>>>>>>        Property String  DFCurrent_OutPut      "WinPrint"
78830>>>>>>>        Property Integer DFCurrent_Diagram     0
78831>>>>>>>        Property Integer DFCurrent_HeaderType  0
78832>>>>>>>        Property Integer DFCurrent_HeaderNr    0
78833>>>>>>>        Property Number  DFCurrent_FontSize    10
78834>>>>>>>        Property String  DFCurrent_Font        "Arial"
78835>>>>>>>
78835>>>>>>>        //*** Default values for margins 2.53 CM = 1 inch
78835>>>>>>>        Property Number  DFLeft_Margin    2.53
78836>>>>>>>        Property Number  DFTop_Margin     2.53
78837>>>>>>>        Property Number  DFright_Margin   2.53
78838>>>>>>>        Property Number  DFBottom_Margin  2.53
78839>>>>>>>
78839>>>>>>>        // If WP1 this defaults to false. In 2, it is true which means that the print job
78839>>>>>>>        // dialog appears when you hitprint in previewer.
78839>>>>>>>        Property Integer PrintDlgInPreview   1
78840>>>>>>>         // This does nothing in Wp2 (because you can't to this anyway)
78840>>>>>>>        Property Integer EnablePrintSetupFromPreview  True
78841>>>>>>>        Property Integer EnablePrintFromPreview  1
78842>>>>>>>
78842>>>>>>>        // is the GUI Suspended. This is privately maintained and is used
78842>>>>>>>        // to figure out if a preview panel is up or not
78842>>>>>>>        Property Integer pbIsSuspended False
78843>>>>>>>
78843>>>>>>>        Object oDFColorArray is an Array
78845>>>>>>>           //Moved into array
78845>>>>>>>           Set Value  0  To RGB_WHITE
78846>>>>>>>           Set Value  1  To RGB_RED
78847>>>>>>>           Set Value  2  To RGB_BLUE
78848>>>>>>>           Set Value  3  To RGB_GREEN
78849>>>>>>>           Set Value  4  To RGB_YELLOW
78850>>>>>>>           Set Value  5  To RGB_GREY
78851>>>>>>>           Set Value  6  To RGB_CYAN
78852>>>>>>>           Set Value  7  To RGB_MAGENTA
78853>>>>>>>           Set Value  8  To RGB_DRED
78854>>>>>>>           Set Value  9  To RGB_DBLUE
78855>>>>>>>           Set Value  10 To RGB_DGREEN
78856>>>>>>>           Set Value  11 To RGB_DYELLOW
78857>>>>>>>           Set Value  12 To RGB_DGREY
78858>>>>>>>           Set Value  13 To RGB_DCYAN
78859>>>>>>>           Set Value  14 To RGB_DMAGENTA
78860>>>>>>>           Set Value  15 To RGB_BLACK
78861>>>>>>>        End_Object
78862>>>>>>>
78862>>>>>>>        Object oDiagramArray is an Array
78864>>>>>>>        End_Object
78865>>>>>>>
78865>>>>>>>    End_Procedure
78866>>>>>>>
78866>>>>>>>    Function ViewerWantsToClose returns Boolean
78868>>>>>>>        Function_return (WP_ViewerWantsToClose())
78869>>>>>>>    end_Function
78870>>>>>>>
78870>>>>>>>    Function IsViewerActive returns boolean
78872>>>>>>>        Function_Return (WP_GetViewerWindow()<>0)
78873>>>>>>>    end_function
78874>>>>>>>
78874>>>>>>>    Function IsPrinterValid Returns Boolean
78876>>>>>>>        Function_Return (WP_IsPrinterValid()<>0)
78877>>>>>>>    End_Function
78878>>>>>>>
78878>>>>>>>    Function ArePrintersInstalled returns boolean
78880>>>>>>>        Function_Return (WP_ArePrintersInstalled()<>0)
78881>>>>>>>    End_Function
78882>>>>>>>
78882>>>>>>>
78882>>>>>>>    // returns docucument state: dsNotStarted, dsStarted, dsFinished
78882>>>>>>>    Function DocumentStatus returns Integer
78884>>>>>>>        Function_Return (WP_GetDocumentStatus())
78885>>>>>>>    end_function
78886>>>>>>>
78886>>>>>>>    // Might still be called from report class. Leave dummy stub
78886>>>>>>>    Procedure DFZeroCounters
78888>>>>>>>    End_Procedure
78889>>>>>>>
78889>>>>>>>    //***
78889>>>>>>>    Function DFNewPage Integer Columns Returns Integer
78891>>>>>>>        Integer iPageNum
78891>>>>>>>        // This returns a page number used in report object....(this may change)
78891>>>>>>>        Move (WP_CreatePage(Columns)) To iPageNum
78892>>>>>>>        If (iPageNum=0) Begin
78894>>>>>>>            Error DFERR_WINPRINT DFPrintError900
78895>>>>>>>>
78895>>>>>>>        End
78895>>>>>>>>
78895>>>>>>>        Function_Return iPageNum
78896>>>>>>>    End_Function
78897>>>>>>>
78897>>>>>>>    //***Return handle to use for winprint dialog. If main_window
78897>>>>>>>    //   exists, use it. Else, get object's handle
78897>>>>>>>    Function Report_Window_Handle returns handle
78899>>>>>>>        Handle hWnd
78899>>>>>>>        Handle hoObj
78899>>>>>>>        Get Focus of desktop to hoObj // start with the focus
78900>>>>>>>        Move (gOwnerWindowHandle(hoObj)) to hWnd // global function finds the right handle for us
78901>>>>>>>        function_return hWnd
78902>>>>>>>    End_Function
78903>>>>>>>
78903>>>>>>>
78903>>>>>>>    //***
78903>>>>>>>    Function DFPrintDialog Returns Boolean
78905>>>>>>>        Handle hwnd
78905>>>>>>>        Boolean bOk
78905>>>>>>>
78905>>>>>>>        Get Report_Window_Handle to hWnd
78906>>>>>>>        Move (WP_ExecutePrintDialog(hwnd)) To bOk
78907>>>>>>>
78907>>>>>>>        Function_Return bOk
78908>>>>>>>    End_Function
78909>>>>>>>
78909>>>>>>>
78909>>>>>>>    //*** You can only invoke the print setup if the report is cleared. If you try to to do this in
78909>>>>>>>    //    the wrong state you will get an error.
78909>>>>>>>    Function DFPrintSetupDialog Returns Boolean
78911>>>>>>>        Handle hwnd
78911>>>>>>>        Boolean bOk
78911>>>>>>>        Integer iStatus
78911>>>>>>>        Get ArePrintersInstalled to bOk
78912>>>>>>>        If not bOk Begin
78914>>>>>>>            Error DFERR_WINPRINT C_$NoInstalledPrinters
78915>>>>>>>>
78915>>>>>>>        End
78915>>>>>>>>
78915>>>>>>>        Else Begin
78916>>>>>>>            Get DocumentStatus to iStatus
78917>>>>>>>            
78917>>>>>>>            If (iStatus=dsNotStarted) Begin
78919>>>>>>>                Get Report_Window_Handle to hWnd
78920>>>>>>>                Move (WP_ExecutePrinterSetupDialog(hwnd)) to bOk
78921>>>>>>>                
78921>>>>>>>                // test that the selected printer is valid....
78921>>>>>>>                If bOK Begin
78923>>>>>>>                    Get IsPrinterValid to bOk // if printer not valid, it's not ok
78924>>>>>>>                    If not bOk Begin
78926>>>>>>>                        Error DFERR_WINPRINT DFPrintError936  // could not select a valid printer
78927>>>>>>>>
78927>>>>>>>                    End
78927>>>>>>>>
78927>>>>>>>                End
78927>>>>>>>>
78927>>>>>>>            End
78927>>>>>>>>
78927>>>>>>>            Else Begin
78928>>>>>>>               Error DFERR_WINPRINT DFPrintError966      // cannot change printer when report is active
78929>>>>>>>>
78929>>>>>>>            End
78929>>>>>>>>
78929>>>>>>>        End
78929>>>>>>>>
78929>>>>>>>        Function_Return bOk
78930>>>>>>>    End_Function
78931>>>>>>>
78931>>>>>>>
78931>>>>>>>    //*** Provided for backwards compatibility. DFPrintSetupDialog is more flexible because it returns a
78931>>>>>>>    //    false if cancel was selected.
78931>>>>>>>    Procedure DFPrintSetup
78933>>>>>>>        Boolean bOk
78933>>>>>>>        Get DFPrintSetupDialog to bOk
78934>>>>>>>    End_Procedure
78935>>>>>>>
78935>>>>>>>    //*** This invokes the print job dialog, prints the report, then clears the report document.
78935>>>>>>>    //    This should be called after the report is complete.
78935>>>>>>>    Procedure DFPrint
78937>>>>>>>        Integer bOk
78937>>>>>>>        Get DFPrintDialog To bOk
78938>>>>>>>        If bOk Begin
78940>>>>>>>            Send DFPrintDoc
78941>>>>>>>            Send DFClearDoc
78942>>>>>>>        End
78942>>>>>>>>
78942>>>>>>>    End_Procedure
78943>>>>>>>
78943>>>>>>>    Procedure DFSuspendGui boolean bSuspend
78945>>>>>>>        If (bSuspend<>pbIsSuspended(self)) begin
78947>>>>>>>            Send SuspendGui of Desktop bSuspend
78948>>>>>>>            Set pbIsSuspended to bSuspend
78949>>>>>>>        end
78949>>>>>>>>
78949>>>>>>>    end_procedure
78950>>>>>>>
78950>>>>>>>    // this is protected so that the queue is only pumped if the
78950>>>>>>>    // gui is suspended.
78950>>>>>>>    Procedure PumpMsgQueue
78952>>>>>>>        If (pbIsSuspended(self)) begin
78954>>>>>>>            Send PumpMsgQueue of desktop // permit painting
78955>>>>>>>        end
78955>>>>>>>>
78955>>>>>>>    end_procedure
78956>>>>>>>
78956>>>>>>>
78956>>>>>>>    //*** This does a modeless preview. This is what you'd want during
78956>>>>>>>    //    report generation and it may be what you want for report viewing.
78956>>>>>>>    Procedure DFPreviewNoWait
78958>>>>>>>        Boolean bOk
78958>>>>>>>        Boolean bPrntDlg bPrintSetup bPrint
78958>>>>>>>        integer iStatus
78958>>>>>>>        Get PrintDlgInPreview to bPrntDlg
78959>>>>>>>        Get EnablePrintSetupFromPreview to bPrintSetup
78960>>>>>>>        Get EnablePrintFromPreview to bPrint
78961>>>>>>>        Get DocumentStatus to iStatus
78962>>>>>>>        If (iStatus=dsStarted) begin
78964>>>>>>>            Send DfSuspendGui True
78965>>>>>>>        end
78965>>>>>>>>
78965>>>>>>>        Move (WP_PreviewDocument(bPrntDlg,bPrintSetup,bPrint)) To bOk
78966>>>>>>>        If not bOk Begin
78968>>>>>>>            Error DFERR_WINPRINT DFPrintError901
78969>>>>>>>>
78969>>>>>>>            Send DfSuspendGui False
78970>>>>>>>        End
78970>>>>>>>>
78970>>>>>>>    End_Procedure
78971>>>>>>>
78971>>>>>>>
78971>>>>>>>    //*** This does a modal preview. You might want this for report
78971>>>>>>>    //    viewing as the program knows when the viewer is closed
78971>>>>>>>    // Note that this is a private message and it was never intended that this
78971>>>>>>>    // should be used. We expect winprint reports to use modeless viewers.
78971>>>>>>>    Procedure DFPreviewWait
78973>>>>>>>        Handle hViewerProcess
78973>>>>>>>        Boolean bPrntDlg bPrintSetup bPrint
78973>>>>>>>        Integer iRetVal
78973>>>>>>>        Integer hwMain hMain
78973>>>>>>>
78973>>>>>>>        Get PrintDlgInPreview to bPrntDlg
78974>>>>>>>        Get EnablePrintSetupFromPreview to bPrintSetup
78975>>>>>>>        Get EnablePrintFromPreview to bPrint
78976>>>>>>>
78976>>>>>>>        Send DfSuspendGui True
78977>>>>>>>        Move (WP_PreviewDocument(bPrntDlg,bPrintSetup,bPrint)) To hViewerProcess
78978>>>>>>>
78978>>>>>>>        If (hViewerProcess = 0) Begin
78980>>>>>>>            Error DFERR_WINPRINT DFPrintError901
78981>>>>>>>>
78981>>>>>>>        End
78981>>>>>>>>
78981>>>>>>>        Else Begin
78982>>>>>>>            // We need to wait for either the Viewer to close, or a WM_PAINT message in the thread's queue...
78982>>>>>>>            Repeat
78982>>>>>>>>
78982>>>>>>>               Move (MsgWaitForMultipleObjects(1, AddressOf(hViewerProcess), False, INFINITE, QS_PAINT)) To iRetVal
78983>>>>>>>               Send PumpMsgQueue // permit painting
78984>>>>>>>            Until (iRetVal = 0) // 0 means that the viewer process terminated
78986>>>>>>>        end
78986>>>>>>>>
78986>>>>>>>        Send DfSuspendGui False
78987>>>>>>>
78987>>>>>>>       // Do what we can to force VDF application to the top.
78987>>>>>>>       // As 12.0 dfSuspendGUI actually properly disables the underlying windows. When the viewer
78987>>>>>>>       // is closed it cannot give the focus back to this so it goes elsewhere. This will force it
78987>>>>>>>       // back. 
78987>>>>>>>
78987>>>>>>>       Get main_window of desktop to hMain
78988>>>>>>>       If hMain Begin
78990>>>>>>>          Get window_handle of hMain to hwMain
78991>>>>>>>          If hwMain Begin
78993>>>>>>>              If (GetForegroundWindow()<>hwMain) Begin
78995>>>>>>>                  Move (SetForegroundWindow(hwMain)) to hwMain
78996>>>>>>>              End
78996>>>>>>>>
78996>>>>>>>          End
78996>>>>>>>>
78996>>>>>>>       End
78996>>>>>>>>
78996>>>>>>>
78996>>>>>>>    End_Procedure
78997>>>>>>>
78997>>>>>>>    Procedure DfPreview
78999>>>>>>>        send DfPreviewNoWait
79000>>>>>>>    end_procedure
79001>>>>>>>
79001>>>>>>>
79001>>>>>>>    //***
79001>>>>>>>    Procedure DFPrintDoc
79003>>>>>>>        Handle hwnd
79003>>>>>>>        Boolean bOk
79003>>>>>>>        Get Report_Window_Handle to hWnd
79004>>>>>>>        Move (WP_PrintDocument(hwnd)) To bOk
79005>>>>>>>
79005>>>>>>>        If not bOk Begin
79007>>>>>>>            Error DFERR_WINPRINT DFPrintError902
79008>>>>>>>>
79008>>>>>>>        End
79008>>>>>>>>
79008>>>>>>>    End_Procedure
79009>>>>>>>
79009>>>>>>>
79009>>>>>>>    //***
79009>>>>>>>    Procedure DFClearDoc
79011>>>>>>>        Boolean bOk
79011>>>>>>>        Get ArePrintersInstalled to bOk
79012>>>>>>>        If bOk begin
79014>>>>>>>            Move (WP_ClearDocument()) To bOk
79015>>>>>>>            Send DFSuspendGUI False
79016>>>>>>>            If not bOk Begin
79018>>>>>>>               Error DFERR_WINPRINT DFPrintError903 // error number right?
79019>>>>>>>>
79019>>>>>>>            End
79019>>>>>>>>
79019>>>>>>>        End
79019>>>>>>>>
79019>>>>>>>    End_Procedure
79020>>>>>>>
79020>>>>>>>    Procedure DFNewDoc Boolean bAutoPreview
79022>>>>>>>        Boolean bOk
79022>>>>>>>        // this is the most likely place we will encounter when we start a report. Check for
79022>>>>>>>        // printers and return an explicit error to make it easy to identify the error
79022>>>>>>>        Get ArePrintersInstalled to bOk
79023>>>>>>>        If not bOk begin
79025>>>>>>>            Error DFERR_WINPRINT C_$NoInstalledPrinters
79026>>>>>>>>
79026>>>>>>>        end
79026>>>>>>>>
79026>>>>>>>        else begin
79027>>>>>>>            Send DfClearDoc //JJT - a new doc should always start with a clear
79028>>>>>>>            If bAutoPreview Send DFSuspendGUI True
79031>>>>>>>            Move (WP_NewDocument(bAutoPreview)) To bOk
79032>>>>>>>
79032>>>>>>>            If not bOk Begin
79034>>>>>>>               Error DFERR_WINPRINT DFPrintError902  // could not print document
79035>>>>>>>>
79035>>>>>>>               Send DFSuspendGUI False
79036>>>>>>>            End
79036>>>>>>>>
79036>>>>>>>        end
79036>>>>>>>>
79036>>>>>>>    End_Procedure
79037>>>>>>>
79037>>>>>>>    //***
79037>>>>>>>    Procedure DFSetFont String sFontName
79039>>>>>>>        boolean bOk
79039>>>>>>>        Move (WP_SetFontName(sFontName)) To bOk
79040>>>>>>>
79040>>>>>>>        If not bOK Begin
79042>>>>>>>            Error DFERR_WINPRINT DFPrintError904
79043>>>>>>>>
79043>>>>>>>        End
79043>>>>>>>>
79043>>>>>>>    End_Procedure
79044>>>>>>>
79044>>>>>>>
79044>>>>>>>    //***
79044>>>>>>>    Procedure DFSetFontSize Integer iHeight Integer iWidth
79046>>>>>>>        boolean bOk
79046>>>>>>>        // note that width is ignored in new implementation
79046>>>>>>>        Move (WP_SetFontHeight(iHeight)) To bOk
79047>>>>>>>
79047>>>>>>>        If not bOK Begin
79049>>>>>>>            Error DFERR_WINPRINT  DFPrintError905
79050>>>>>>>>
79050>>>>>>>        End
79050>>>>>>>>
79050>>>>>>>    End_Procedure
79051>>>>>>>
79051>>>>>>>
79051>>>>>>>    //***
79051>>>>>>>    Procedure DFSetFontStyle DWORD dwStyle
79053>>>>>>>        boolean bOk
79053>>>>>>>        Move (WP_SetFontStyle(dwStyle)) To bOk
79054>>>>>>>
79054>>>>>>>        If not bOK Begin
79056>>>>>>>            Error DFERR_WINPRINT DFPrintError906
79057>>>>>>>>
79057>>>>>>>        End
79057>>>>>>>>
79057>>>>>>>    End_Procedure
79058>>>>>>>
79058>>>>>>>
79058>>>>>>>    //***
79058>>>>>>>    Procedure DFSetUnderline boolean bUnderline
79060>>>>>>>        boolean bOk
79060>>>>>>>
79060>>>>>>>        Move (WP_SetFontUnderline(bUnderline)) To bOk
79061>>>>>>>
79061>>>>>>>        If not bOK Begin
79063>>>>>>>            Error DFERR_WINPRINT DFPrintError907
79064>>>>>>>>
79064>>>>>>>        End
79064>>>>>>>>
79064>>>>>>>    End_Procedure
79065>>>>>>>
79065>>>>>>>
79065>>>>>>>    //***
79065>>>>>>>    Procedure DFSetBold Boolean bBold
79067>>>>>>>        Boolean bOk
79067>>>>>>>
79067>>>>>>>        Move (WP_SetFontBold(bBold)) To bOk
79068>>>>>>>
79068>>>>>>>        If not bOK Begin
79070>>>>>>>            Error DFERR_WINPRINT DFPrintError908
79071>>>>>>>>
79071>>>>>>>        End
79071>>>>>>>>
79071>>>>>>>    End_Procedure
79072>>>>>>>
79072>>>>>>>
79072>>>>>>>    //***
79072>>>>>>>    Procedure DFSetItalic Boolean bItalic
79074>>>>>>>        Boolean bOk
79074>>>>>>>
79074>>>>>>>        Move (WP_SetFontItalic(bItalic)) To bOk
79075>>>>>>>
79075>>>>>>>        If not bOK Begin
79077>>>>>>>            Error DFERR_WINPRINT DFPrintError909
79078>>>>>>>>
79078>>>>>>>        End
79078>>>>>>>>
79078>>>>>>>    End_Procedure
79079>>>>>>>
79079>>>>>>>
79079>>>>>>>    //***
79079>>>>>>>    Procedure DFSetStrikeout Boolean bStrikeout
79081>>>>>>>        Boolean bOk
79081>>>>>>>
79081>>>>>>>        Move (WP_SetFontStrikeout(bStrikeout)) To bOk
79082>>>>>>>
79082>>>>>>>        If not bOK Begin
79084>>>>>>>            Error DFERR_WINPRINT DFPrintError910
79085>>>>>>>>
79085>>>>>>>        End
79085>>>>>>>>
79085>>>>>>>    End_Procedure
79086>>>>>>>
79086>>>>>>>
79086>>>>>>>    //***
79086>>>>>>>    Procedure DFSetMargins Number nLeft Number nTop Number nRight Number nBottom
79088>>>>>>>        Boolean bOk
79088>>>>>>>        integer iLeft iRight iTop iBottom
79088>>>>>>>
79088>>>>>>>        Move (nLeft   * 100) to iLeft
79089>>>>>>>        Move (nRight  * 100) to iRight
79090>>>>>>>        Move (nTop    * 100) to iTop
79091>>>>>>>        Move (nBottom * 100) to iBottom
79092>>>>>>>
79092>>>>>>>        Move (WP_SetMargins(iLeft,iTop,iRight,iBottom)) To bOk
79093>>>>>>>
79093>>>>>>>        If bOk Begin
79095>>>>>>>            Set DFLeft_Margin   To nLeft
79096>>>>>>>            Set DFTop_Margin    To nTop
79097>>>>>>>            Set DFRight_Margin  To nRight
79098>>>>>>>            Set DFBottom_Margin To nBottom
79099>>>>>>>        End
79099>>>>>>>>
79099>>>>>>>        Else Begin
79100>>>>>>>            Error DFERR_WINPRINT DFPrintError911
79101>>>>>>>>
79101>>>>>>>        End
79101>>>>>>>>
79101>>>>>>>    End_Procedure
79102>>>>>>>
79102>>>>>>>
79102>>>>>>>    //***
79102>>>>>>>    Procedure DFSetLeftMargin Number nLeft
79104>>>>>>>        number  nTop nRight nBottom
79104>>>>>>>        Get DFTop_Margin    To nTop
79105>>>>>>>        Get DFRight_Margin  To nRight
79106>>>>>>>        Get DFBottom_Margin To nBottom
79107>>>>>>>        Send DFSetMargins nLeft nTop nRight nBottom
79108>>>>>>>    End_Procedure
79109>>>>>>>
79109>>>>>>>
79109>>>>>>>    //***
79109>>>>>>>    Procedure DFSetRightMargin Number nRight
79111>>>>>>>        number  nLeft nTop nBottom
79111>>>>>>>        Get DFLeft_Margin   To nLeft
79112>>>>>>>        Get DFTop_Margin    To nTop
79113>>>>>>>        Get DFBottom_Margin To nBottom
79114>>>>>>>        Send DFSetMargins nLeft nTop nRight nBottom
79115>>>>>>>    End_Procedure
79116>>>>>>>
79116>>>>>>>
79116>>>>>>>    //***
79116>>>>>>>    Procedure DFSetTopMargin Number nTop
79118>>>>>>>        number  nLeft nRight nBottom
79118>>>>>>>        Get DFLeft_Margin   To nLeft
79119>>>>>>>        Get DFRight_Margin  To nRight
79120>>>>>>>        Get DFBottom_Margin To nBottom
79121>>>>>>>        Send DFSetMargins nLeft nTop nRight nBottom
79122>>>>>>>    End_Procedure
79123>>>>>>>
79123>>>>>>>
79123>>>>>>>    //***
79123>>>>>>>    Procedure DFSetBottomMargin Number nBottom
79125>>>>>>>        number  nLeft nTop nRight
79125>>>>>>>        Get DFLeft_Margin   To nLeft
79126>>>>>>>        Get DFTop_Margin    To nTop
79127>>>>>>>        Get DFRight_Margin  To nRight
79128>>>>>>>        Send DFSetMargins nLeft nTop nRight nBottom
79129>>>>>>>    End_Procedure
79130>>>>>>>
79130>>>>>>>
79130>>>>>>>    //***
79130>>>>>>>    Procedure DFWriteText String sText Integer iStyle Integer iColumn Integer iDecimal Boolean bNewLineAfterPrint
79132>>>>>>>        Boolean bOk
79132>>>>>>>
79132>>>>>>>        Send DFSetFontStyle iStyle
79133>>>>>>>        Get ToAnsi sText To sText
79134>>>>>>>        Move (WP_WriteText(sText,bNewLineAfterPrint,iColumn,iDecimal,0)) To bOk
79135>>>>>>>        If not bOk Begin
79137>>>>>>>            Error DFERR_WINPRINT DFPrintError918
79138>>>>>>>>
79138>>>>>>>        End
79138>>>>>>>>
79138>>>>>>>        Send PumpMsgQueue // permit painting //JJT!!!!!!!!!!!
79139>>>>>>>    End_Procedure
79140>>>>>>>
79140>>>>>>>    //***
79140>>>>>>>    Procedure DFWrite String sText DWORD iStyle Integer iColumn Integer iDecimal Boolean bTrim
79142>>>>>>>        If (Num_Arguments>=5 and bTrim) Begin
79144>>>>>>>            Move (Rtrim(sText)) to sText
79145>>>>>>>        end
79145>>>>>>>>
79145>>>>>>>        Send DFWriteText sText iStyle iColumn iDecimal False
79146>>>>>>>    End_Procedure
79147>>>>>>>
79147>>>>>>>    //***
79147>>>>>>>    Procedure DFWriteLn String sText DWORD iStyle Integer iColumn Integer iDecimal Boolean bTrim
79149>>>>>>>        If (Num_Arguments>=5 and bTrim) Begin
79151>>>>>>>            Move (Rtrim(sText)) to sText
79152>>>>>>>        end
79152>>>>>>>>
79152>>>>>>>        Send DFWriteText sText iStyle iColumn iDecimal True
79153>>>>>>>    End_Procedure
79154>>>>>>>
79154>>>>>>>
79154>>>>>>>    //***
79154>>>>>>>    Procedure DFWriteTextAtPosition String sText integer iStyle Number nPosition Integer iDecimal ;                                    Number nMaxLength Boolean bNewLineAfterPrint
79156>>>>>>>        Boolean bOk
79156>>>>>>>        Integer iPosition iMaxLength
79156>>>>>>>        Send DFSetFontStyle iStyle
79157>>>>>>>        Get ToAnsi sText To sText
79158>>>>>>>        Move (nPosition * 100) to iPosition
79159>>>>>>>        Move (nMaxLength * 100) to iMaxLength
79160>>>>>>>        Move (WP_WriteTextAtPosition(sText,bNewLineAfterPrint,iPosition,iDecimal,iMaxLength)) To bOk
79161>>>>>>>        If not bOk Begin
79163>>>>>>>            Error DFERR_WINPRINT DFPrintError922
79164>>>>>>>>
79164>>>>>>>        End
79164>>>>>>>>
79164>>>>>>>         Send PumpMsgQueue // permit painting //JJT!!!!!!!!!!!
79165>>>>>>>    End_Procedure
79166>>>>>>>
79166>>>>>>>    //***
79166>>>>>>>    Procedure DFWritePos String sText integer iStyle Number nPosition Integer iDecimal Number nMaxLength boolean bTrim
79168>>>>>>>        Number nMax
79168>>>>>>>        If (Num_Arguments>=6 and bTrim) Begin
79170>>>>>>>            Move (Rtrim(sText)) to sText
79171>>>>>>>        end
79171>>>>>>>>
79171>>>>>>>
79171>>>>>>>        If (Num_Arguments<5) ;            Move 0 to nMax
79174>>>>>>>        Else ;            Move nMaxLength to nMax
79176>>>>>>>        Send DFWriteTextAtPosition sText iStyle nPosition iDecimal nMax False
79177>>>>>>>    End_Procedure
79178>>>>>>>
79178>>>>>>>    //***
79178>>>>>>>    Procedure DFWriteLnPos String sText integer iStyle Number nPosition Integer iDecimal Number nMaxLength boolean bTrim
79180>>>>>>>        Number nMax
79180>>>>>>>        If (Num_Arguments>=6 and bTrim) Begin
79182>>>>>>>            Move (Rtrim(sText)) to sText
79183>>>>>>>        end
79183>>>>>>>>
79183>>>>>>>
79183>>>>>>>        If (Num_Arguments<5) ;            Move 0 to nMax
79186>>>>>>>        Else ;            Move nMaxLength to nMax
79188>>>>>>>        Send DFWriteTextAtPosition sText iStyle nPosition iDecimal nMax True
79189>>>>>>>    End_Procedure
79190>>>>>>>
79190>>>>>>>    Procedure DFSetMetrics String sMetrics
79192>>>>>>>        integer eMetrics
79192>>>>>>>        // for backwards compatibility support both string names and integer enumerations
79192>>>>>>>        // it is better to use the enumeration value
79192>>>>>>>        If (sMetrics="INCH" or sMetrics="CM") Begin
79194>>>>>>>            Set DFCurrent_Metrics to sMetrics
79195>>>>>>>        end
79195>>>>>>>>
79195>>>>>>>        else Begin
79196>>>>>>>            Move sMetrics to eMetrics
79197>>>>>>>            Move (WP_SetMetrics(eMetrics)) To eMetrics
79198>>>>>>>        End
79198>>>>>>>>
79198>>>>>>>    End_Procedure
79199>>>>>>>
79199>>>>>>>    Function DFGetMetrics Returns Integer
79201>>>>>>>        Integer eMetrics
79201>>>>>>>        Move (WP_GetMetrics()) To eMetrics
79202>>>>>>>        Function_return eMetrics
79203>>>>>>>    End_Function
79204>>>>>>>
79204>>>>>>>
79204>>>>>>>    //**** Properties Maintained for compatibility with old Winprint (obsolete)
79204>>>>>>>    Function DFCurrent_Metrics returns string
79206>>>>>>>        Integer eMetrics
79206>>>>>>>        Get DFGetMetrics to eMetrics
79207>>>>>>>        Function_return (if(eMetrics=WPM_INCH,"INCH","CM"))
79208>>>>>>>    end_function
79209>>>>>>>
79209>>>>>>>    Procedure Set DFCurrent_Metrics string sCMorINCH
79211>>>>>>>        Send DFSetMetrics (if(sCMorINCH="INCH", WPM_INCH, WPM_CM))
79212>>>>>>>    End_Procedure
79213>>>>>>>
79213>>>>>>>
79213>>>>>>>
79213>>>>>>>
79213>>>>>>>
79213>>>>>>>    //***
79213>>>>>>>    Procedure DFBeginHeaderType Integer iHeaderNr Integer eHeaderType
79215>>>>>>>        Boolean bOk
79215>>>>>>>
79215>>>>>>>        If (eHeaderType=DFSubHeader or eHeaderType=DFSubTotal) Begin
79217>>>>>>>            //*** Do nothing for the moment
79217>>>>>>>        End
79217>>>>>>>>
79217>>>>>>>        Else ;            Move 0 to iHeaderNr // If the user made a mistake
79219>>>>>>>
79219>>>>>>>        Set DFCurrent_HeaderType To eHeaderType
79220>>>>>>>        Set DFCurrent_HeaderNr   To iHeaderNr
79221>>>>>>>
79221>>>>>>>        Move (WP_BeginHeader(eHeaderType, iHeaderNr)) To bOk
79222>>>>>>>
79222>>>>>>>        If not bOk Begin
79224>>>>>>>            Error DFERR_WINPRINT DFPrintError925
79225>>>>>>>>
79225>>>>>>>        End
79225>>>>>>>>
79225>>>>>>>    End_Procedure
79226>>>>>>>
79226>>>>>>>
79226>>>>>>>    //***
79226>>>>>>>    Procedure DFEndHeaderType
79228>>>>>>>        Boolean bOk
79228>>>>>>>
79228>>>>>>>        Move (WP_EndHeader()) To bOk
79229>>>>>>>
79229>>>>>>>        if not bOk begin
79231>>>>>>>            Error DFERR_WINPRINT DFPrintError926
79232>>>>>>>>
79232>>>>>>>        End
79232>>>>>>>>
79232>>>>>>>    End_Procedure
79233>>>>>>>
79233>>>>>>>
79233>>>>>>>    //***
79233>>>>>>>    Procedure DFWriteHeaderType Integer iHeaderNr Integer eHeaderType
79235>>>>>>>        Boolean bOk
79235>>>>>>>        Move (WP_WriteHeader(eHeaderType, iHeaderNr)) To bOk
79236>>>>>>>        if not bOk begin
79238>>>>>>>            Error DFERR_WINPRINT DFPrintError927
79239>>>>>>>>
79239>>>>>>>        End
79239>>>>>>>>
79239>>>>>>>    End_Procedure
79240>>>>>>>
79240>>>>>>>
79240>>>>>>>    //***
79240>>>>>>>    Procedure DFHeaderPosition Integer ePlace
79242>>>>>>>        Boolean bOk
79242>>>>>>>
79242>>>>>>>         Move (WP_SetHeaderPlacement(ePlace)) To bOk
79243>>>>>>>
79243>>>>>>>         if not bOk begin
79245>>>>>>>            Error DFERR_WINPRINT DFPrintError929
79246>>>>>>>>
79246>>>>>>>        End
79246>>>>>>>>
79246>>>>>>>    End_Procedure
79247>>>>>>>
79247>>>>>>>
79247>>>>>>>    //***
79247>>>>>>>    Procedure DFHeaderFrameType Integer eFrame integer iColor Number nWeight;                                Integer iFillColor Boolean bFillFrame
79249>>>>>>>        Integer iWeight
79249>>>>>>>        Boolean bOk
79249>>>>>>>
79249>>>>>>>        move (nWeight*100) To iWeight
79250>>>>>>>
79250>>>>>>>        Move (WP_SetHeaderFrame(eFrame,iColor,iWeight,iFillColor,bFillFrame)) To bOk
79251>>>>>>>
79251>>>>>>>         if not bOk begin
79253>>>>>>>            Error DFERR_WINPRINT DFPrintError930
79254>>>>>>>>
79254>>>>>>>        End
79254>>>>>>>>
79254>>>>>>>    End_Procedure
79255>>>>>>>
79255>>>>>>>  Procedure DFHeaderMargin Integer eType Number nSize
79257>>>>>>>        Boolean bOk
79257>>>>>>>        Integer iSize
79257>>>>>>>
79257>>>>>>>        move (nSize * 100) to iSize
79258>>>>>>>
79258>>>>>>>        move (WP_SetHeaderMargin(eType, iSize)) To bOk
79259>>>>>>>
79259>>>>>>>        if not bOk begin
79261>>>>>>>            Error DFERR_WINPRINT DFPrintError930
79262>>>>>>>>
79262>>>>>>>        end
79262>>>>>>>>
79262>>>>>>>    End_Procedure
79263>>>>>>>
79263>>>>>>>
79263>>>>>>>    //***
79263>>>>>>>    Procedure DFHeaderWrap Integer eOnOff
79265>>>>>>>         Boolean bOk
79265>>>>>>>
79265>>>>>>>         Move (WP_SetHeaderWrap(eOnOff)) To bOk
79266>>>>>>>
79266>>>>>>>         if not bOk begin
79268>>>>>>>            Error DFERR_WINPRINT DFPrintError931
79269>>>>>>>>
79269>>>>>>>        End
79269>>>>>>>>
79269>>>>>>>    End_Procedure
79270>>>>>>>
79270>>>>>>>    //***
79270>>>>>>>    Procedure DFWriteBMP String sFileName Number nStartX Number nStartY Number nHeight Number nWidth Boolean bUCp
79272>>>>>>>        Boolean bOk
79272>>>>>>>        Integer iStartX iStartY iHeight iWidth
79272>>>>>>>
79272>>>>>>>        If ((nStartX = -998) or (nStartX = -999));            move nStartX to iStartX
79275>>>>>>>        else ;            move (nStartX*100) To iStartX
79277>>>>>>>
79277>>>>>>>        If ((nStartY = -998) or (nStartY = -999));            move nStartY to iStartY
79280>>>>>>>        else ;            move (nStartY*100) To iStartY
79282>>>>>>>
79282>>>>>>>        If ((nWidth = -998) or (nWidth = -999));            move nWidth To iWidth
79285>>>>>>>        else ;            move (nWidth*100) To iWidth
79287>>>>>>>
79287>>>>>>>        If ((nHeight = -998) or (nHeight = -999));            move nHeight To iHeight
79290>>>>>>>        else ;            move (nHeight*100) To iHeight
79292>>>>>>>
79292>>>>>>>        Get_File_Path sFileName To sFileName
79293>>>>>>>        Move (WP_DrawBitmap(sFileName,iStartX,iStartY,iWidth,iHeight,bUCp)) to bOk
79294>>>>>>>
79294>>>>>>>        If not bOk Begin
79296>>>>>>>            Error DFERR_WINPRINT DFPrintError932
79297>>>>>>>>
79297>>>>>>>        End
79297>>>>>>>>
79297>>>>>>>    End_Procedure
79298>>>>>>>
79298>>>>>>>
79298>>>>>>>    //***
79298>>>>>>>    Procedure DFHeaderLineCheck Integer iLines
79300>>>>>>>        Boolean bOk
79300>>>>>>>
79300>>>>>>>         Move (WP_SetExtraLineCheck(iLines)) To bOk
79301>>>>>>>
79301>>>>>>>        If not bOk begin
79303>>>>>>>            Error DFERR_WINPRINT DFPrintError934
79304>>>>>>>>
79304>>>>>>>        End
79304>>>>>>>>
79304>>>>>>>    End_Procedure
79305>>>>>>>
79305>>>>>>>
79305>>>>>>>    //***
79305>>>>>>>    Procedure DFPrintFlags Integer Flags
79307>>>>>>>        Boolean bOk
79307>>>>>>>
79307>>>>>>>         Move (WP_SetPrintDialogFlags(Flags)) To bOk
79308>>>>>>>
79308>>>>>>>        If not bOk begin
79310>>>>>>>            Error DFERR_WINPRINT DFPrintError935
79311>>>>>>>>
79311>>>>>>>        End
79311>>>>>>>>
79311>>>>>>>    End_Procedure
79312>>>>>>>
79312>>>>>>>
79312>>>>>>>    //*** obsolete and maintained for winprint-I backwards compatibility (maybe should be removed)
79312>>>>>>>    //
79312>>>>>>>    Procedure DFSelectPrinter String sDriver String sDevice String sPort Boolean bUpdate
79314>>>>>>>        Send DFSetDevice sDevice
79315>>>>>>>    End_Procedure
79316>>>>>>>
79316>>>>>>>    //*** Preferred usage for WinprintII
79316>>>>>>>    Procedure DFSetDevice String sDevice
79318>>>>>>>        Boolean bOk
79318>>>>>>>
79318>>>>>>>        Move (WP_SelectPrinter(sDevice)) To bOk
79319>>>>>>>
79319>>>>>>>        If not bOk Begin
79321>>>>>>>            Error DFERR_WINPRINT DFPrintError936
79322>>>>>>>>
79322>>>>>>>        End
79322>>>>>>>>
79322>>>>>>>    End_Procedure
79323>>>>>>>
79323>>>>>>>    Procedure DFPrinterBinFirstPage Integer eBin
79325>>>>>>>        Boolean bOk
79325>>>>>>>
79325>>>>>>>         Move (WP_SetFirstPagePaperSource(eBin)) To bOk
79326>>>>>>>
79326>>>>>>>        If not bOk Begin
79328>>>>>>>            Error DFERR_WINPRINT DFPrintError937
79329>>>>>>>>
79329>>>>>>>        End
79329>>>>>>>>
79329>>>>>>>    End_Procedure
79330>>>>>>>
79330>>>>>>>
79330>>>>>>>    //***
79330>>>>>>>    Function DFGetDFColor Integer iRed Integer iGreen Integer iBlue Returns Integer
79332>>>>>>>        Integer iColor
79332>>>>>>>
79332>>>>>>>         Move (WP_RGBToDFPrintColor(iRed,iGreen,iBlue)) To iColor
79333>>>>>>>
79333>>>>>>>        If (iColor=0) Begin
79335>>>>>>>            Error DFERR_WINPRINT DFPrintError938
79336>>>>>>>>
79336>>>>>>>        End
79336>>>>>>>>
79336>>>>>>>        Function_Return iColor
79337>>>>>>>    End_Function
79338>>>>>>>
79338>>>>>>>
79338>>>>>>>    //***
79338>>>>>>>    Procedure DFSetDFColor Dword dwColor
79340>>>>>>>        Integer bOk
79340>>>>>>>
79340>>>>>>>         Move (WP_SetFontColor(dwColor)) To bOk
79341>>>>>>>
79341>>>>>>>        If not bOk Begin
79343>>>>>>>            Error DFERR_WINPRINT DFPrintError939
79344>>>>>>>>
79344>>>>>>>        End
79344>>>>>>>>
79344>>>>>>>    End_Procedure
79345>>>>>>>
79345>>>>>>>
79345>>>>>>>    //***
79345>>>>>>>    Procedure DFSetTopBottom Number nTop Number nBottom Boolean bAllPages
79347>>>>>>>        Boolean bOk
79347>>>>>>>        Integer iTop iBottom
79347>>>>>>>
79347>>>>>>>        move (nTop*100)    To iTop
79348>>>>>>>        move (nBottom*100) To iBottom
79349>>>>>>>
79349>>>>>>>        Move (WP_SetAbsoluteMargins(iTop,iBottom,bAllPages)) To bOk
79350>>>>>>>
79350>>>>>>>        If Not bOk Begin
79352>>>>>>>            Error DFERR_WINPRINT DFPrintError940
79353>>>>>>>>
79353>>>>>>>        End
79353>>>>>>>>
79353>>>>>>>    End_Procedure
79354>>>>>>>
79354>>>>>>>
79354>>>>>>>    //***
79354>>>>>>>    Procedure DFSetJMode Integer eAlign
79356>>>>>>>        Boolean bOk
79356>>>>>>>
79356>>>>>>>        Move (WP_SetAlign(eAlign)) To bOk
79357>>>>>>>
79357>>>>>>>        If Not bOk Begin
79359>>>>>>>            Error DFERR_WINPRINT DFPrintError941
79360>>>>>>>>
79360>>>>>>>        End
79360>>>>>>>>
79360>>>>>>>    End_Procedure
79361>>>>>>>
79361>>>>>>>
79361>>>>>>>    //***
79361>>>>>>>    Procedure DFWriteEllip Number nStartX Number nStartY Number nHeight Number nWidth ;              Dword dwBColor Dword dwFColor Boolean bFill Number nWeight Boolean bWrap Boolean bUCp
79363>>>>>>>
79363>>>>>>>        Boolean bOk
79363>>>>>>>        Integer iWeight
79363>>>>>>>        Integer iStartX iStartY iHeight iWidth
79363>>>>>>>
79363>>>>>>>        If ((nStartX = -998) or (nStartX = -999));            move nStartX To iStartX
79366>>>>>>>        else ;            move (nStartX*100) To iStartX
79368>>>>>>>
79368>>>>>>>        If ((nStartY = -998) or (nStartY = -999));            move nStartY To iStartY
79371>>>>>>>        else ;            move (nStartY*100) To iStartY
79373>>>>>>>
79373>>>>>>>        If ((nWidth = -998) or (nWidth = -999));            move nWidth To iWidth
79376>>>>>>>        else ;            move (nWidth*100) To iWidth
79378>>>>>>>
79378>>>>>>>        If ((nHeight = -998) or (nHeight = -999));            move nHeight To iHeight
79381>>>>>>>        else ;            move (nHeight*100) To iHeight
79383>>>>>>>
79383>>>>>>>        move (nWeight*100) To iWeight
79384>>>>>>>
79384>>>>>>>
79384>>>>>>>        Move (WP_DrawEllipse(iStartX,iStartY,iWidth,iHeight,;                        dwBColor,dwFColor,bFill,iWeight,bUCp,bWrap)) To bOk
79385>>>>>>>
79385>>>>>>>        If Not bOk Begin
79387>>>>>>>            Error DFERR_WINPRINT DFPrintError942
79388>>>>>>>>
79388>>>>>>>        End
79388>>>>>>>>
79388>>>>>>>    End_Procedure
79389>>>>>>>
79389>>>>>>>
79389>>>>>>>
79389>>>>>>>
79389>>>>>>>    //***
79389>>>>>>>    Procedure DFWriteRect Number nStartX Number nStartY Number nHeight Number nWidth;              Dword dwBColor Dword dwFColor Boolean bFill Number nWeight Boolean bWrap Boolean bUCp
79391>>>>>>>
79391>>>>>>>        Boolean bOk
79391>>>>>>>        Integer iWeight
79391>>>>>>>        Integer iStartX iStartY iHeight iWidth
79391>>>>>>>
79391>>>>>>>        If ((nStartX = -998) or (nStartX = -999));            move nStartX To iStartX
79394>>>>>>>        else ;            move (nStartX*100) To iStartX
79396>>>>>>>
79396>>>>>>>        If ((nStartY = -998) or (nStartY = -999));            move nStartY To iStartY
79399>>>>>>>        else ;            move (nStartY*100) To iStartY
79401>>>>>>>
79401>>>>>>>        If ((nWidth = -998) or (nWidth = -999));            move nWidth To iWidth
79404>>>>>>>        else ;            move (nWidth*100) To iWidth
79406>>>>>>>
79406>>>>>>>        If ((nHeight = -998) or (nHeight = -999));            move nHeight To iHeight
79409>>>>>>>        else ;            move (nHeight*100) To iHeight
79411>>>>>>>
79411>>>>>>>        move (nWeight*100) To iWeight
79412>>>>>>>
79412>>>>>>>        Move (WP_DrawRectangle(iStartX,iStartY,iWidth,iHeight,;                            dwBColor,dwFColor,bFill,iWeight,bUCp,bWrap)) To bOk
79413>>>>>>>
79413>>>>>>>        If Not bOk Begin
79415>>>>>>>            Error DFERR_WINPRINT DFPrintError944
79416>>>>>>>>
79416>>>>>>>        End
79416>>>>>>>>
79416>>>>>>>    End_Procedure
79417>>>>>>>
79417>>>>>>>
79417>>>>>>>
79417>>>>>>>
79417>>>>>>>    //***
79417>>>>>>>    Procedure DFLineCheck Integer iLines
79419>>>>>>>        Boolean bOk
79419>>>>>>>
79419>>>>>>>        Move (WP_ConfirmLines(iLines)) To bOk
79420>>>>>>>
79420>>>>>>>        If Not bOk Begin
79422>>>>>>>            Error DFERR_WINPRINT DFPrintError946
79423>>>>>>>>
79423>>>>>>>        End
79423>>>>>>>>
79423>>>>>>>    End_Procedure
79424>>>>>>>
79424>>>>>>>
79424>>>>>>>    //***
79424>>>>>>>    Procedure DFCreateDiagram Integer eType Integer eFx Number nHeight Number nWidth Integer bXyAxis
79426>>>>>>>        Handle hDiagram
79426>>>>>>>        Integer iWidth iHeight
79426>>>>>>>
79426>>>>>>>        move (nHeight*100) To iHeight
79427>>>>>>>        move (nWidth*100)  To iWidth
79428>>>>>>>
79428>>>>>>>        Set DFCurrent_Color To 0
79429>>>>>>>
79429>>>>>>>        Move (WP_CreateDiagram(eType,eFx,iWidth,iHeight,bXyAxis)) To hDiagram
79430>>>>>>>
79430>>>>>>>        If (hDiagram) Begin
79432>>>>>>>            Error DFERR_WINPRINT DFPrintError947
79433>>>>>>>>
79433>>>>>>>        End
79433>>>>>>>>
79433>>>>>>>        Else Begin
79434>>>>>>>            Set DFCurrent_Diagram To hDiagram
79435>>>>>>>        end
79435>>>>>>>>
79435>>>>>>>    End_Procedure
79436>>>>>>>
79436>>>>>>>
79436>>>>>>>    //***
79436>>>>>>>    Procedure DFDiagram_Item handle hDiagram String sLabel Number nValue;                             Dword dwBColor Dword dwFColor Integer eFill;                             Integer iDec Integer eValueOrPercent Integer eExt
79438>>>>>>>
79438>>>>>>>        Boolean bOk
79438>>>>>>>        Integer iCurrColor iValue
79438>>>>>>>
79438>>>>>>>        If (dwFColor = -1) Begin
79440>>>>>>>            Get DFCurrent_Color To iCurrColor
79441>>>>>>>            Increment iCurrColor
79442>>>>>>>            If (iCurrColor>15) Move 1 To iCurrColor
79445>>>>>>>            Set DFCurrent_Color To iCurrColor
79446>>>>>>>            Get DFGetColor iCurrColor To dwFColor
79447>>>>>>>        End
79447>>>>>>>>
79447>>>>>>>
79447>>>>>>>        Move (nValue *100) to iValue
79448>>>>>>>
79448>>>>>>>        Get ToAnsi sLabel To sLabel
79449>>>>>>>
79449>>>>>>>        Move (WP_AddDiagramEntry(hDiagram,sLabel,iValue,dwBColor,dwFColor,eFill,iDec,eValueorPercent,eExt)) To bOk
79450>>>>>>>
79450>>>>>>>        If not bOk Begin
79452>>>>>>>            Error DFERR_WINPRINT DFPrintError948
79453>>>>>>>>
79453>>>>>>>        End
79453>>>>>>>>
79453>>>>>>>    End_Procedure
79454>>>>>>>
79454>>>>>>>
79454>>>>>>>    //***
79454>>>>>>>    Procedure DFLockDiagram Handle hDiagram
79456>>>>>>>        Boolean bOk
79456>>>>>>>
79456>>>>>>>        Move (WP_LockDiagram(hDiagram)) To bOk
79457>>>>>>>
79457>>>>>>>        If not bOk Begin
79459>>>>>>>            Error DFERR_WINPRINT DFPrintError949
79460>>>>>>>>
79460>>>>>>>        End
79460>>>>>>>>
79460>>>>>>>    End_Procedure
79461>>>>>>>
79461>>>>>>>
79461>>>>>>>
79461>>>>>>>    //***
79461>>>>>>>    Procedure DFDrawDiagram Handle hDiagram Number nYPos Number nXPos Boolean bUCp
79463>>>>>>>        Boolean bOk
79463>>>>>>>        Integer iXPos
79463>>>>>>>        Integer iYPos
79463>>>>>>>
79463>>>>>>>        move (nXPos*100) To iXPos
79464>>>>>>>        move (nYPos*100) To iYPos
79465>>>>>>>
79465>>>>>>>        If nYPos Eq -999 Move -999 To iYPos
79468>>>>>>>
79468>>>>>>>        Move (WP_DrawDiagram(hDiagram,iXPos,iYPos,bUCp)) To bOk
79469>>>>>>>
79469>>>>>>>        If not bOk Begin
79471>>>>>>>            Error DFERR_WINPRINT DFPrintError950
79472>>>>>>>>
79472>>>>>>>        End
79472>>>>>>>>
79472>>>>>>>    End_Procedure
79473>>>>>>>
79473>>>>>>>
79473>>>>>>>
79473>>>>>>>    //***
79473>>>>>>>    Procedure DFDiagramLabel handle hDiagram String sLabel
79475>>>>>>>        Boolean bOk
79475>>>>>>>        Integer iLabelLen
79475>>>>>>>
79475>>>>>>>        Get ToAnsi sLabel To sLabel
79476>>>>>>>
79476>>>>>>>        Move (WP_SetDiagramCaption(hDiagram,sLabel)) To bOk
79477>>>>>>>
79477>>>>>>>        if not bOk Begin
79479>>>>>>>            Error DFERR_WINPRINT DFPrintError952
79480>>>>>>>>
79480>>>>>>>        End
79480>>>>>>>>
79480>>>>>>>    End_Procedure
79481>>>>>>>
79481>>>>>>>
79481>>>>>>>    //***
79481>>>>>>>    Procedure DFDiagramXLabel handle hDiagram String sLabel
79483>>>>>>>        Boolean bOk
79483>>>>>>>        Get ToAnsi sLabel To sLabel
79484>>>>>>>
79484>>>>>>>        Move (WP_SetDiagramXText(hDiagram,sLabel)) To bOk
79485>>>>>>>
79485>>>>>>>        if not bOk Begin
79487>>>>>>>            Error DFERR_WINPRINT DFPrintError953
79488>>>>>>>>
79488>>>>>>>        End
79488>>>>>>>>
79488>>>>>>>    End_Procedure
79489>>>>>>>
79489>>>>>>>
79489>>>>>>>    //***
79489>>>>>>>    Procedure DFDiagramYLabel handle hDiagram String sLabel Boolean bVertical
79491>>>>>>>        Boolean bOk
79491>>>>>>>        Get ToAnsi sLabel To sLabel
79492>>>>>>>
79492>>>>>>>        Move (WP_SetDiagramYText(hDiagram,sLabel,bVertical)) To bOk
79493>>>>>>>
79493>>>>>>>        if not bOk Begin
79495>>>>>>>            Error DFERR_WINPRINT DFPrintError954
79496>>>>>>>>
79496>>>>>>>        End
79496>>>>>>>>
79496>>>>>>>    End_Procedure
79497>>>>>>>
79497>>>>>>>
79497>>>>>>>    //***
79497>>>>>>>    Procedure DFWriteXYLine Number nStartX Number nStartY Number nStopX Number nStopY;              Dword dwColor Number nWeight Boolean bWrap Boolean bUCp
79499>>>>>>>
79499>>>>>>>        Boolean bOk
79499>>>>>>>        Integer iStartX iStartY iStopX iStopY
79499>>>>>>>        Integer iWeight
79499>>>>>>>
79499>>>>>>>        move (nStartX*100)  To iStartX
79500>>>>>>>        move (nStartY*100)  To iStartY
79501>>>>>>>        move (nStopX*100)   To iStopX
79502>>>>>>>        move (nStopY*100)   To iStopY
79503>>>>>>>
79503>>>>>>>        move (nWeight*100) To iWeight
79504>>>>>>>
79504>>>>>>>        If (nStopY  = -998) Move -998 To iStopY
79507>>>>>>>        If (nStopX  = -998) Move -998 To iStopX
79510>>>>>>>
79510>>>>>>>        If (nStartY  = -999) Move -999 To iStartY
79513>>>>>>>        If (nStartX  = -999) Move -999 To iStartX
79516>>>>>>>
79516>>>>>>>        Move (WP_DrawXYLine(iStartX,iStartY,iStopX,iStopY,dwColor,iWeight,bUCp,bWrap)) To bOk
79517>>>>>>>
79517>>>>>>>        if not bOk Begin
79519>>>>>>>            Error DFERR_WINPRINT DFPrintError955
79520>>>>>>>>
79520>>>>>>>        End
79520>>>>>>>>
79520>>>>>>>    End_Procedure
79521>>>>>>>
79521>>>>>>>
79521>>>>>>>    //***
79521>>>>>>>    Procedure DFWriteLine Number nStartX Number nStartY Number nLength;                          Boolean bHorizontal Dword dwColor Number nWeight Boolean bUCp
79523>>>>>>>
79523>>>>>>>        Boolean bOk
79523>>>>>>>        Integer iStartX iStartY iLength
79523>>>>>>>        Integer iWeight
79523>>>>>>>
79523>>>>>>>        move (nStartX*100)  To iStartX
79524>>>>>>>        move (nStartY*100)  To iStartY
79525>>>>>>>        move (nLength*100)  To iLength
79526>>>>>>>        move (nWeight*100)  To iWeight
79527>>>>>>>
79527>>>>>>>        If (nStartY = -999) Move -999 To iStartY
79530>>>>>>>        If (nStartX = -999) Move -999 To iStartX
79533>>>>>>>        If (nLength = -998) Move -998 To iLength
79536>>>>>>>
79536>>>>>>>        Move (WP_DrawLine(iSTartX,iStartY,iLength,bHorizontal,dwColor,iWeight,bUCp)) To bOk
79537>>>>>>>
79537>>>>>>>        if not bOk Begin
79539>>>>>>>            Error DFERR_WINPRINT DFPrintError956
79540>>>>>>>>
79540>>>>>>>        End
79540>>>>>>>>
79540>>>>>>>    End_Procedure
79541>>>>>>>
79541>>>>>>>
79541>>>>>>>    //***
79541>>>>>>>    Procedure DFClearPrinter
79543>>>>>>>        Boolean bOk
79543>>>>>>>
79543>>>>>>>        Move (WP_ClearPrinter()) To bOk
79544>>>>>>>
79544>>>>>>>        If not bOk Begin
79546>>>>>>>            Error DFERR_WINPRINT DFPrintError957
79547>>>>>>>>
79547>>>>>>>        End
79547>>>>>>>>
79547>>>>>>>    End_Procedure
79548>>>>>>>
79548>>>>>>>
79548>>>>>>>
79548>>>>>>>    //***
79548>>>>>>>     Function DFGetCurrentDevice Returns String
79550>>>>>>>        Boolean bOk
79550>>>>>>>        String  sDFStr
79550>>>>>>>        Address pDFStr
79550>>>>>>>
79550>>>>>>>        Move (Repeat( Character(0), 255 )) to sDFStr
79551>>>>>>>        GetAddress of sDFStr to pDFStr
79552>>>>>>>
79552>>>>>>>        Move (WP_GetCurrentDevice(pDFStr)) To bOk
79553>>>>>>>
79553>>>>>>>        If not bOk Begin
79555>>>>>>>            Error DFERR_WINPRINT DFPrintError959
79556>>>>>>>>
79556>>>>>>>        End
79556>>>>>>>>
79556>>>>>>>
79556>>>>>>>        Move (CString(sDFStr)) To sDFStr
79557>>>>>>>        Function_Return sDFStr
79558>>>>>>>     End_Function
79559>>>>>>>
79559>>>>>>>
79559>>>>>>>    // Note: DfGetCurrentPort and DFGetCurrentDriver do not exist in winprint2. Trying to
79559>>>>>>>    //       use these will result in a runtime error (which is good - don't use them)
79559>>>>>>>
79559>>>>>>>
79559>>>>>>>    //***
79559>>>>>>>     Function DFGetPrintDialogFlags Returns Dword
79561>>>>>>>        Dword dwRetVal
79561>>>>>>>
79561>>>>>>>        Move (WP_GetPrintDialogFlags()) To dwRetVal
79562>>>>>>>
79562>>>>>>>        Function_Return dwRetVal
79563>>>>>>>     End_Function
79564>>>>>>>
79564>>>>>>>
79564>>>>>>>    //***
79564>>>>>>>    //*** Returns PRN_TRUE=  if the flag is set     (1)
79564>>>>>>>    //*** Returns PRN_FALSE= If the flag not is set (0)
79564>>>>>>>    //***
79564>>>>>>>     Function DFCheckPrintDialogFlag Dword dwPDFlag Returns Boolean
79566>>>>>>>        Boolean bIsSet
79566>>>>>>>
79566>>>>>>>        Move (WP_IsPrintDialogFlagSet(dwPDFlag)) To bIsSet
79567>>>>>>>
79567>>>>>>>        Function_Return bIsSet
79568>>>>>>>     End_Function
79569>>>>>>>
79569>>>>>>>
79569>>>>>>>    //***
79569>>>>>>>     Procedure DFSetSpecPrintFlag Dword dwPDFlag
79571>>>>>>>        Boolean bOk
79571>>>>>>>
79571>>>>>>>        Move (WP_SetSpecificPrintDialogFlag(dwPDFlag)) To bOk
79572>>>>>>>
79572>>>>>>>        If not bOk Begin
79574>>>>>>>            Error DFERR_WINPRINT DFPrintError961
79575>>>>>>>>
79575>>>>>>>        End
79575>>>>>>>>
79575>>>>>>>     End_Procedure
79576>>>>>>>
79576>>>>>>>
79576>>>>>>>    //***
79576>>>>>>>     Function DFGetUserDefinedLength Returns Number
79578>>>>>>>        Integer iRetVal
79578>>>>>>>        Number  nRetVal
79578>>>>>>>
79578>>>>>>>        Move (WP_GetUserDefinedPapersize()) To iRetVal
79579>>>>>>>
79579>>>>>>>        If (iRetVal=0) Begin
79581>>>>>>>            Error DFERR_WINPRINT DFPrintError962
79582>>>>>>>>
79582>>>>>>>            Function_Return 0
79583>>>>>>>        End
79583>>>>>>>>
79583>>>>>>>
79583>>>>>>>        Move (Hi(iRetVal)) To nRetVal
79584>>>>>>>        move (nRetVal/100) To nRetVal //Returns CM
79585>>>>>>>
79585>>>>>>>        Function_Return nRetVal
79586>>>>>>>     End_Function
79587>>>>>>>
79587>>>>>>>
79587>>>>>>>    //***
79587>>>>>>>     Function DFGetUserDefinedWidth Returns Number
79589>>>>>>>        Integer iRetVal
79589>>>>>>>        Number  nRetVal
79589>>>>>>>
79589>>>>>>>        Move (WP_GetUserDefinedPapersize()) To iRetVal
79590>>>>>>>
79590>>>>>>>        If (iRetVal=0) Begin
79592>>>>>>>            Error DFERR_WINPRINT DFPrintError963
79593>>>>>>>>
79593>>>>>>>            Function_Return 0
79594>>>>>>>        End
79594>>>>>>>>
79594>>>>>>>
79594>>>>>>>        Move (Low(iRetVal)) To nRetVal
79595>>>>>>>        Move (nRetVal/100) To nRetVal //Returns CM
79596>>>>>>>
79596>>>>>>>        Function_Return nRetVal
79597>>>>>>>     End_Function
79598>>>>>>>
79598>>>>>>>
79598>>>>>>>    //*** To be set in CM
79598>>>>>>>     Procedure DFSetUserDefinedPapersize Number nLength Number nWidth
79600>>>>>>>        Integer bOk
79600>>>>>>>        Integer iLength iWidth iSize
79600>>>>>>>
79600>>>>>>>        move (nLength*100) To iLength
79601>>>>>>>        move (nWidth*100)  To iWidth
79602>>>>>>>        move ((iLength*65536)+iWidth) To iSize
79603>>>>>>>
79603>>>>>>>        Move (WP_SetUserDefinedPapersize(iSize)) To bOk
79604>>>>>>>
79604>>>>>>>        If not bOk Begin
79606>>>>>>>            Error DFERR_WINPRINT DFPrintError964
79607>>>>>>>>
79607>>>>>>>        End
79607>>>>>>>>
79607>>>>>>>     End_Procedure
79608>>>>>>>
79608>>>>>>>     Procedure DFSetNumberOfCopies Integer iNrOfCopies
79610>>>>>>>        Boolean bOk
79610>>>>>>>
79610>>>>>>>        Move (WP_SetNumberOfPrintCopies(iNrOfCopies)) to bOk
79611>>>>>>>
79611>>>>>>>        If not bOk Begin
79613>>>>>>>            Error DFERR_WINPRINT DFPrintError965
79614>>>>>>>>
79614>>>>>>>        end
79614>>>>>>>>
79614>>>>>>>     End_Procedure
79615>>>>>>>
79615>>>>>>>
79615>>>>>>>
79615>>>>>>>
79615>>>>>>>    //*************************************************************
79615>>>>>>>    //*** This procedures and functions are used when building  ***
79615>>>>>>>    //*** complex graphics when you need to change value of the ***
79615>>>>>>>    //*** current diagram, so you can mix diagrams within each  ***
79615>>>>>>>    //*** other.                                                ***
79615>>>>>>>    //*************************************************************
79615>>>>>>>
79615>>>>>>>
79615>>>>>>>    Function DFGetCurrentDiagram Returns Integer
79617>>>>>>>        Integer iRetVal
79617>>>>>>>        Get DFCurrent_Diagram To iRetVal
79618>>>>>>>        Function_Return iRetVal
79619>>>>>>>    End_Function
79620>>>>>>>
79620>>>>>>>    Procedure DFSetCurrentDiagram Integer iDiagram
79622>>>>>>>        Set DFCurrent_Diagram To iDiagram
79623>>>>>>>    End_Procedure
79624>>>>>>>
79624>>>>>>>    Procedure DFSetDiagramList Integer iItem Integer iDiagram
79626>>>>>>>        Set Value of oDiagramArray iItem To iDiagram
79627>>>>>>>    End_Procedure
79628>>>>>>>
79628>>>>>>>    Function DFGetDiagramList Integer iItem Returns Integer
79630>>>>>>>        Integer iRetVal
79630>>>>>>>        Get Value of oDiagramArray iItem To iRetVal
79631>>>>>>>        Function_Return iRetVal
79632>>>>>>>    End_Function
79633>>>>>>>
79633>>>>>>>    Procedure DFClearDiagramList
79635>>>>>>>        Send Delete_Data To oDiagramArray
79636>>>>>>>    End_Procedure
79637>>>>>>>
79637>>>>>>>
79637>>>>>>>    Function DFGetColor Integer iColor Returns Dword
79639>>>>>>>        Dword   dwRetVal
79639>>>>>>>        Get Value of oDFColorArray iColor To dwRetVal
79640>>>>>>>        Function_Return dwRetVal
79641>>>>>>>    End_Function
79642>>>>>>>
79642>>>>>>>    Function DFGetCurrentColor Returns Dword
79644>>>>>>>        Dword   dwRetVal
79644>>>>>>>        Integer iCurrColor
79644>>>>>>>
79644>>>>>>>        Get DFCurrent_Color To iCurrColor
79645>>>>>>>        Get DFGetColor iCurrColor To dwRetVal
79646>>>>>>>
79646>>>>>>>        Function_Return dwRetVal
79647>>>>>>>    End_Function
79648>>>>>>>
79648>>>>>>>    Procedure DFEndDocument
79650>>>>>>>        integer iVoid
79650>>>>>>>        Move (WP_EndDocument()) To iVoid
79651>>>>>>>        Send DfSuspendGui False
79652>>>>>>>    End_procedure
79653>>>>>>>
79653>>>>>>>    Procedure DFClosePreview
79655>>>>>>>        integer iVoid
79655>>>>>>>        Move (WP_ClosePreview()) To iVoid
79656>>>>>>>        Send DfSuspendGui False
79657>>>>>>>    End_procedure
79658>>>>>>>
79658>>>>>>>    Procedure SetProgressCaption string sCaption
79660>>>>>>>        integer iVoid
79660>>>>>>>        Move (ToAnsi(sCaption)) to sCaption
79661>>>>>>>        Move (WP_SetProgressCaption(sCaption)) To iVoid
79662>>>>>>>    End_procedure
79663>>>>>>>
79663>>>>>>>    Procedure SetReportTitle string sTitle
79665>>>>>>>        integer iVoid
79665>>>>>>>        Move (ToAnsi(sTitle)) to sTitle
79666>>>>>>>        Move (WP_SetReportTitle(sTitle)) To iVoid
79667>>>>>>>    End_procedure
79668>>>>>>>
79668>>>>>>>    Function PreviewYesNoBox string sCaption string sText returns integer
79670>>>>>>>        integer eResult
79670>>>>>>>        Move (ToAnsi(sCaption)) to sCaption
79671>>>>>>>        Move (ToAnsi(sText))    to sText
79672>>>>>>>        Move (WP_DisplayMessageBox(sCaption, sText)) To eResult
79673>>>>>>>        Function_return eResult
79674>>>>>>>    end_function
79675>>>>>>>
79675>>>>>>>    // internal function, used to extract different printer flags ranges based on
79675>>>>>>>    // the print flag integer. These flags use a decimal style of packing information
79675>>>>>>>    // where different printer options (paper, bin, etc) use different ranges and
79675>>>>>>>    // different steps. Everything above iTopVal is removed and everything that is not
79675>>>>>>>    // within the iStep range is removed.
79675>>>>>>>    Function PrintFlagRange integer iTopVal integer iStep returns integer
79677>>>>>>>        integer iFgs iFg
79677>>>>>>>        Get DFGetPrintDialogFlags to iFg
79678>>>>>>>        Move (mod(iFg,iTopVal) / iStep * iStep ) to iFg
79679>>>>>>>        function_return iFg
79680>>>>>>>    end_Function
79681>>>>>>>
79681>>>>>>>    Procedure DFSetPrinterPaper integer ePaperType
79683>>>>>>>        Send DFSetSpecPrintFlag ePaperType
79684>>>>>>>    End_Procedure
79685>>>>>>>
79685>>>>>>>    Function DFGetPrinterPaper returns integer //ePaperType
79687>>>>>>>        integer ePaperType
79687>>>>>>>        Get PrintFlagRange 500 10 to ePaperType // 10-490 in steps of 10
79688>>>>>>>        function_return ePaperType
79689>>>>>>>    End_Function
79690>>>>>>>
79690>>>>>>>
79690>>>>>>>    Procedure DFSetPrinterBin integer eBinType
79692>>>>>>>        Send DFSetSpecPrintFlag eBinType
79693>>>>>>>    End_Procedure
79694>>>>>>>
79694>>>>>>>    Function DFGetPrinterBin returns integer //eBinType
79696>>>>>>>        integer eBinType
79696>>>>>>>        Get PrintFlagRange 10000 500 to eBinType // 1000-9000 steps 500
79697>>>>>>>        function_return eBinType
79698>>>>>>>    End_Function
79699>>>>>>>
79699>>>>>>>
79699>>>>>>>    Procedure DFSetPrinterResolution integer eResType
79701>>>>>>>        Send DFSetSpecPrintFlag eResType
79702>>>>>>>    End_Procedure
79703>>>>>>>
79703>>>>>>>    Function DFGetPrinterResolution returns integer //eResType
79705>>>>>>>        integer eResType
79705>>>>>>>        Get PrintFlagRange 50000 10000 to eResType // 10000-500000 steps 10000
79706>>>>>>>        function_return eResType
79707>>>>>>>    End_Function
79708>>>>>>>
79708>>>>>>>
79708>>>>>>>    Procedure DFSetLandscape boolean bIsLandscape
79710>>>>>>>        Send DFSetSpecPrintFlag (If(bIsLandscape,DF_Landscape,DF_Portrait))
79711>>>>>>>    End_Procedure
79712>>>>>>>
79712>>>>>>>    Function DFGetLandscape returns boolean // bIsLandscape
79714>>>>>>>        boolean bIsLandscape
79714>>>>>>>        Get DFCheckPrintDialogFlag DF_Landscape to bIsLandscape
79715>>>>>>>        function_return bIsLandscape
79716>>>>>>>    End_Function
79717>>>>>>>
79717>>>>>>>    Function RGBToWPColor integer iRgb returns integer
79719>>>>>>>        integer iRed iGreen iBlue
79719>>>>>>>        integer iWPColor
79719>>>>>>>        Move (R_from_rgb(iRGB)) to iRed
79720>>>>>>>        Move (G_from_rgb(iRGB)) to iGreen
79721>>>>>>>        Move (B_from_rgb(iRGB)) to iBlue
79722>>>>>>>        Get DfGetDfColor iRed iGreen iBlue to iWPColor
79723>>>>>>>        function_Return iWPColor
79724>>>>>>>    end_function
79725>>>>>>>
79725>>>>>>>
79725>>>>>>>
79725>>>>>>>End_Class
79726>>>>>>>
79726>>>>>>>Global_Variable Integer ghoWinPrint2
79726>>>>>>>
79726>>>>>>>Get Create of desktop U_cWinPrint2 to ghoWinPrint2
79727>>>>>>>
79727>>>>>>>
79727>>>>>Use Winprint_Commands.pkg  // commands used by this class
79727>>>>>
79727>>>>>Class cWinReport2 is a BasicReport
79728>>>>>
79728>>>>>    Procedure Construct_Object
79730>>>>>        Forward send construct_object
79732>>>>>
79732>>>>>        Date Today
79732>>>>>        Sysdate Today
79733>>>>>
79733>>>>>        // should use built in DF function CurrentDateTime()
79733>>>>>        Property Date  RptToday    Today
79734>>>>>
79734>>>>>        Object RptTotal is an Array
79736>>>>>        End_Object
79737>>>>>
79737>>>>>        // If true, report is output upon completion. Either preview
79737>>>>>        // or printer depending on output_device_mode
79737>>>>>        Property Boolean AutoOutput_State True
79738>>>>>
79738>>>>>        // When a new page is created (DFNew_Page) and the number
79738>>>>>        // of columns is not passed, this is used.
79738>>>>>        Property Integer Print_Columns 0
79739>>>>>
79739>>>>>        // This determines if a DFNew_Page should be executed when the
79739>>>>>        // report starts. In some rare cases, you would not want this to
79739>>>>>        // occur until a subheader
79739>>>>>        Property Boolean AutoNew_Page_State True
79740>>>>>
79740>>>>>        // Output device (print or preview). Normally this is delegated to
79740>>>>>        // the report view.
79740>>>>>        //
79740>>>>>
79740>>>>>        Property Integer Private.Output_Device_Mode PRINT_TO_UNDEFINED
79741>>>>>
79741>>>>>        Property Handle phoWinPrint  ghoWinPrint2 // the report engine to use.
79742>>>>>
79742>>>>>        // JJT: For now this is for testing.
79742>>>>>        Property boolean pbModalViewer False
79743>>>>>
79743>>>>>        Property boolean pbMultiReports False
79744>>>>>
79744>>>>>        Property boolean pbFirstPagePrinted false
79745>>>>>
79745>>>>>    End_Procedure
79746>>>>>
79746>>>>>    // returns the current status of Winprint Document object. dsNotStarted, dsStarted, dsFinished
79746>>>>>    // note that the status can reflect a status from a different report. The winprint object is global.
79746>>>>>    Function DocumentStatus returns Boolean
79748>>>>>        integer iStatus
79748>>>>>        Get DocumentStatus of (phoWinprint(self)) to iStatus
79749>>>>>        function_return iStatus
79750>>>>>    End_function
79751>>>>>
79751>>>>>    Function IsViewerActive Returns Boolean
79753>>>>>        Boolean bIsActive
79753>>>>>        Get IsViewerActive of (phoWinPrint(Self)) to bIsActive
79754>>>>>        Function_Return bIsActive
79755>>>>>    End_Function
79756>>>>>
79756>>>>>    Function IsPrinterValid Returns Boolean
79758>>>>>        Function_Return (WP_IsPrinterValid()<>0)
79759>>>>>    End_Function
79760>>>>>
79760>>>>>    Function ArePrintersInstalled Returns Boolean
79762>>>>>        Function_Return (WP_ArePrintersInstalled()<>0)
79763>>>>>    End_Function
79764>>>>>
79764>>>>>
79764>>>>>    // All subtotal commands use the outer main report. This makes it easier to keep
79764>>>>>    // track of these numbers
79764>>>>>
79764>>>>>    Procedure Add_SubTotal Integer iCounter Number nData
79766>>>>>        Number nValue
79766>>>>>        Integer iObj
79766>>>>>        Move (RptTotal(Main_Report_Id(Self))) to iObj
79767>>>>>        Get Number_Value of iObj iCounter To nValue
79768>>>>>        Add nData To nValue
79769>>>>>        Set Array_Value of iObj iCounter To nValue
79770>>>>>    End_Procedure
79771>>>>>
79771>>>>>    Procedure Clr_SubTotal Integer iCounter
79773>>>>>        Set Array_Value of (RptTotal(Main_Report_Id(Self))) iCounter To 0
79774>>>>>    End_Procedure
79775>>>>>
79775>>>>>    Procedure Clr_AllSubTotals
79777>>>>>        Send Delete_Data of (RptTotal(Main_Report_Id(Self)))
79778>>>>>    End_Procedure
79779>>>>>
79779>>>>>    Function Sum_SubTotal Integer iTotal Returns Number
79781>>>>>        Number nRetVal
79781>>>>>        Get Number_Value of (RptTotal(Main_Report_Id(Self))) iTotal To nRetVal
79782>>>>>        Function_Return nRetVal
79783>>>>>    End_Function
79784>>>>>
79784>>>>>    //Return sub-total and clear accumulator
79784>>>>>    //
79784>>>>>    Function SubTotal Integer iTotal Returns Number
79786>>>>>        Number nRetVal
79786>>>>>        Get Sum_SubTotal  iTotal to nRetVal
79787>>>>>        Send Clr_SubTotal iTotal
79788>>>>>        Function_Return nRetVal
79789>>>>>    End_Function
79790>>>>>
79790>>>>>
79790>>>>>    // Note: Cols is optional. If no argument is passed it will use
79790>>>>>    //       the object's property Print_Columns (0 by default)
79790>>>>>    //
79790>>>>>    Procedure DFNew_Page Integer Cols
79792>>>>>        Integer PageNumber Columns
79792>>>>>        Boolean bFirstPagePrinted
79792>>>>>        // If no args passed used default setting
79792>>>>>        If (Num_Arguments=0) ;           Move (Print_Columns(Main_Report_id(Self))) to Columns
79795>>>>>        Else ;           Move Cols to Columns
79797>>>>>        Set Page_Feed   to -2   // No FormFeed
79798>>>>>        If (Child_Rpt_State(self)) ;            Send DFNew_Page of (Main_Report_Id(Self)) Columns
79801>>>>>        Else Begin
79802>>>>>            // we only want to print report_header once. When report starts
79802>>>>>            // this is set true, after the first print it is false. You can set
79802>>>>>            // this to true before and explicit dfNew_page to force a header
79802>>>>>            Get pbFirstPagePrinted to bFirstPagePrinted
79803>>>>>            Get  DFNewPage of (phoWinPrint(self)) Columns To PageNumber
79804>>>>>            If (PageNumber<>0) begin // if 0, it failed
79806>>>>>                Set No_PageCheck_State to True
79807>>>>>
79807>>>>>                //Top section
79807>>>>>                Send Page_Top
79808>>>>>                If Not bFirstPagePrinted Send Report_Header
79811>>>>>                Send Page_Header
79812>>>>>                Send Page_Title
79813>>>>>
79813>>>>>                Set New_Page_State to False
79814>>>>>                Set Page_End_State to False
79815>>>>>                Set No_PageCheck_State to False        // No longer Paging
79816>>>>>                Set pbFirstPagePrinted to True
79817>>>>>            End
79817>>>>>>
79817>>>>>        End
79817>>>>>>
79817>>>>>
79817>>>>>        // Footer section
79817>>>>>        //
79817>>>>>        // DO NOT CHANGE THE ORDER OF BOTTOM SECTIONS !!!!!
79817>>>>>        //
79817>>>>>
79817>>>>>        Send Page_Bottom
79818>>>>>
79818>>>>>        // in WinPrint it is not possible to replace Page_Footer
79818>>>>>        // with Report_Footer. If you use Report_Footer you will
79818>>>>>        // have both Page_Footer and Report_Footer
79818>>>>>        //
79818>>>>>        //If LastTime eq 0 Send Page_Footer
79818>>>>>        //else             Send Report_Footer
79818>>>>>
79818>>>>>        Send Page_Footer
79819>>>>>        Send Page_Total
79820>>>>>    End_Procedure
79821>>>>>
79821>>>>>    Procedure Ending_Main_Report
79823>>>>>        Boolean bCancel bMultiReports
79823>>>>>
79823>>>>>        Get Cancelled_state to bCancel
79824>>>>>        Get pbMultiReports to bMultiReports
79825>>>>>
79825>>>>>        Forward Send Ending_Main_Report
79827>>>>>
79827>>>>>        If bCancel Begin
79829>>>>>            Send DFEndDocument
79830>>>>>            Send DFClearDoc // this will also close the previewer
79831>>>>>        end
79831>>>>>>
79831>>>>>        Else Begin
79832>>>>>            Send Report_Footer
79833>>>>>
79833>>>>>            // if multi-reports, we don't do an end of report yet. The programmer must
79833>>>>>            // manually end the report by sending EndMultiReport
79833>>>>>            If (not(bMultiReports)) begin
79835>>>>>                Send EndWinPrintReport
79836>>>>>            end
79836>>>>>>
79836>>>>>
79836>>>>>        end
79836>>>>>>
79836>>>>>
79836>>>>>    End_Procedure
79837>>>>>
79837>>>>>    // This must get called when you are running multiple reports (pbMultiReport).
79837>>>>>    // Send this when the last report is complete.
79837>>>>>    Procedure EndMultiReport
79839>>>>>        Send EndWinPrintReport
79840>>>>>    End_procedure
79841>>>>>
79841>>>>>
79841>>>>>    Procedure EndWinPrintReport
79843>>>>>        Boolean bAutoOutput
79843>>>>>        integer iStatus eMode
79843>>>>>        Get DocumentStatus to iStatus
79844>>>>>        If (iStatus<>dsStarted) procedure_return
79847>>>>>
79847>>>>>        // this tells winprint that the report is complete
79847>>>>>        Send DFEndDocument
79848>>>>>        // if auto-output we print or display automatically.
79848>>>>>        // for winprint2, if in preview mode you must do this so the previewer can enter
79848>>>>>        // a modal state (which it may or may not need to do).
79848>>>>>        Get AutoOutput_state to bAutoOutput
79849>>>>>        Get Output_device_mode to eMode
79850>>>>>        If (bAutoOutput or eMode=PRINT_TO_WINDOW) begin
79852>>>>>            Send PrintReport
79853>>>>>            // if auto output, we assume that you are done when it is all over
79853>>>>>            // we only can do this with the modal viewer
79853>>>>>            If (bAutoOutput and pbModalViewer(self)) begin
79855>>>>>                Send DFClearDoc
79856>>>>>            end
79856>>>>>>
79856>>>>>        end
79856>>>>>>
79856>>>>>
79856>>>>>    End_Procedure
79857>>>>>
79857>>>>>
79857>>>>>    Function Setup_Report Returns Integer
79859>>>>>        Integer iErr iStatus eMode
79859>>>>>        Boolean bActiveViewer bChildReport bMultiReports bOk
79859>>>>>
79859>>>>>        Get Child_rpt_state to bChildReport
79860>>>>>
79860>>>>>        If not bChildReport Begin
79862>>>>>
79862>>>>>            // This makes sure that we are pointing to the new winprint2 engine object.
79862>>>>>            // normally this will be the new winprint, but it can be redirected
79862>>>>>            Get phoWinPrint to WinPrintID
79863>>>>>
79863>>>>>            // winprint must have installed printer. If not installed, generate error and stop the report
79863>>>>>            Get ArePrintersInstalled to bOk
79864>>>>>            If not bOk Begin
79866>>>>>                Error DFERR_WINPRINT C_$NoInstalledPrinters
79867>>>>>>
79867>>>>>                Function_Return 1
79868>>>>>            End
79868>>>>>>
79868>>>>>
79868>>>>>            // check if selected printer is valid. If not, generate error and stop the report
79868>>>>>            Get IsPrinterValid to bOk
79869>>>>>            If not bOk Begin
79871>>>>>                Error DFERR_WINPRINT DFPrintError936    // Could not select a valid printer
79872>>>>>>
79872>>>>>                Function_Return 1
79873>>>>>            End
79873>>>>>>
79873>>>>>
79873>>>>>            // make sure it is ok to start a new report but try to be smart about it.
79873>>>>>            // if a report is active (dsstarted or dsFinished) check to see if it is
79873>>>>>            // finished w/ no viewer. If so, assume the user closed the report and is done
79873>>>>>            // so just clear the report. If a viewer is present, declare an error.
79873>>>>>            Get DocumentStatus to iStatus
79874>>>>>            Get pbMultiReports to bMultiReports
79875>>>>>            // multi-report only in-progress is multi and it is started
79875>>>>>            Move (bMultiReports and iStatus=dsStarted) to bMultiReports
79876>>>>>            If not bMultiReports Begin
79878>>>>>                If (iStatus<>dsNotStarted) Begin
79880>>>>>                    Get IsViewerActive to bActiveViewer
79881>>>>>                    If (iStatus=dsFinished and not(bActiveViewer)) Begin
79883>>>>>                        Send DfClearDoc
79884>>>>>                    End
79884>>>>>>
79884>>>>>                    Else Begin
79885>>>>>                        Error DFERR_WINPRINT DFPrintError967
79886>>>>>>
79886>>>>>                        Function_Return 1
79887>>>>>                    End
79887>>>>>>
79887>>>>>                End
79887>>>>>>
79887>>>>>
79887>>>>>                // all new reports by default allow printing from viewer and they have the print job set up when you select print
79887>>>>>                // if you need to change these defaults, you can change these inside of Starting_main_report
79887>>>>>                // We only do this with non-multi-reports.
79887>>>>>                Send DFSetPrintDlgInPreview      True
79888>>>>>                Send DFSetEnablePrintFromPreview True
79889>>>>>
79889>>>>>            End
79889>>>>>>
79889>>>>>
79889>>>>>            // In the new winprint, this message is not needed and is a stub. For
79889>>>>>            // now it is in here for compatibility purposes
79889>>>>>            //You MUST always start a new report with this procedure
79889>>>>>            Send DFZeroCounters of (phoWinPrint(Self))
79890>>>>>            Send Clr_AllSubTotals
79891>>>>>
79891>>>>>        End
79891>>>>>>
79891>>>>>
79891>>>>>        Forward Get Setup_report to iErr
79893>>>>>
79893>>>>>        If (iErr=0) Begin
79895>>>>>            If not bChildReport Begin
79897>>>>>                // if part of a multi-report we don't do a new doc
79897>>>>>                If not bMultiReports Begin
79899>>>>>                    Get Output_Device_Mode to eMode
79900>>>>>                    Send DFNewDoc of (phoWinPrint(Self))  (eMode = PRINT_TO_WINDOW) // pass True of display while printing
79901>>>>>                End
79901>>>>>>
79901>>>>>                // Do new page if not part of a multi-report and we say don't do a new page
79901>>>>>                If (not(bMultiReports) or AutoNew_Page_State(Self)) Begin
79903>>>>>                    Set pbFirstPagePrinted to False // tells new page that this is the first time for this report
79904>>>>>                    Send DFNew_page
79905>>>>>                End
79905>>>>>>
79905>>>>>            End
79905>>>>>>
79905>>>>>        End
79905>>>>>>
79905>>>>>        Function_Return iErr
79906>>>>>    End_Function
79907>>>>>
79907>>>>>
79907>>>>>
79907>>>>>    // Cancel RO behavior - there is no device to close
79907>>>>>    //
79907>>>>>    Procedure Close_Output_Device
79909>>>>>    End_Procedure
79910>>>>>
79910>>>>>    // Cancel RO Behavior
79910>>>>>    //
79910>>>>>    Procedure Initialize_Output_Device
79912>>>>>    End_procedure
79913>>>>>
79913>>>>>
79913>>>>>    Function Output_Device_Mode Returns Integer
79915>>>>>        Integer hoId
79915>>>>>        String DevMode
79915>>>>>        Get Private.Output_Device_Mode to DevMode
79916>>>>>        If (DevMode=PRINT_TO_UNDEFINED) Begin
79918>>>>>            Get Report_View_Id to hoId
79919>>>>>            If hoID ;                Get OutPut_Device_Mode of hoID to DevMode
79922>>>>>            If (DevMode=PRINT_TO_UNDEFINED) ;                Move PRINT_TO_WINDOW to DevMode
79925>>>>>        End
79925>>>>>>
79925>>>>>        Function_Return DevMode
79926>>>>>    End_Function // Output_Destination
79927>>>>>
79927>>>>>    Procedure Set Output_Device_Mode Integer DevMode
79929>>>>>        Set Private.Output_Device_Mode to DevMode
79930>>>>>    End_Procedure // Set Output_Device
79931>>>>>
79931>>>>>    // displays a metric ruler in .5 increments. This can be
79931>>>>>    // sent to make it easy to see how fields and labels should
79931>>>>>    // be moved for alignment.
79931>>>>>    //
79931>>>>>    Procedure ShowRuler
79933>>>>>        integer i
79933>>>>>        number n
79933>>>>>        for i from 0 to 30
79939>>>>>>
79939>>>>>            Send DFWritePos of (phoWinPrint(self)) (String(i)) FONT_DEFAULT i -1 0
79940>>>>>            Move (i+.5) to n
79941>>>>>            Send DFWritePos of (phoWinPrint(self)) "." FONT_DEFAULT n -1 0
79942>>>>>        Loop
79943>>>>>>
79943>>>>>        Send DFWriteln of (phoWinPrint(self)) ''  FONT_DEFAULT FONT_DEFAULT -1
79944>>>>>    End_procedure
79945>>>>>
79945>>>>>      // status panel related agumentations to handle the auto-previewer
79945>>>>>
79945>>>>>      Procedure Update_Status string sVal
79947>>>>>         Integer eMode
79947>>>>>         Get Output_device_mode to eMode
79948>>>>>         If (eMode=PRINT_TO_WINDOW) Begin
79950>>>>>            Send SetProgressCaption  of (phoWinPrint(self)) sVal
79951>>>>>         End
79951>>>>>>
79951>>>>>         Else Begin
79952>>>>>            forward Send Update_Status sVal
79954>>>>>         end
79954>>>>>>
79954>>>>>      End_Procedure
79955>>>>>
79955>>>>>      Procedure Start_Status
79957>>>>>         Integer eMode
79957>>>>>         string sTitle sCaption
79957>>>>>         Get Output_device_mode to eMode
79958>>>>>         If (eMode=PRINT_TO_WINDOW) Begin
79960>>>>>            Get Report_Caption to sCaption
79961>>>>>            Get Report_Title to sTitle
79962>>>>>            If (sTitle<>"" and sCaption<>"") begin
79964>>>>>                Move ( sCaption- ":" * sTitle) to sTitle
79965>>>>>            end
79965>>>>>>
79965>>>>>            else begin
79966>>>>>                Move (sCaption - sTitle) to sTitle
79967>>>>>            end
79967>>>>>>
79967>>>>>            Send SetReportTitle of (phoWinPrint(self)) sTitle
79968>>>>>         End
79968>>>>>>
79968>>>>>         Else Begin
79969>>>>>            forward Send Start_status
79971>>>>>         end
79971>>>>>>
79971>>>>>      End_Procedure
79972>>>>>
79972>>>>>      Procedure Resume_Status
79974>>>>>         Integer eMode
79974>>>>>         Get Output_device_mode to eMode
79975>>>>>         If (eMode=PRINT_TO_WINDOW) Begin
79977>>>>>            Send DfPreviewNoWait of (phoWinPrint(self))
79978>>>>>         End
79978>>>>>>
79978>>>>>         Else Begin
79979>>>>>            forward Send Resume_Status
79981>>>>>         end
79981>>>>>>
79981>>>>>      End_Procedure
79982>>>>>
79982>>>>>      Procedure End_Status
79984>>>>>         Integer eMode
79984>>>>>         Get Output_device_mode to eMode
79985>>>>>         If (error_processing_state(self)) Begin
79987>>>>>            Send DFClosePreview
79988>>>>>         end
79988>>>>>>
79988>>>>>         If (eMode=PRINT_TO_WINDOW) Begin
79990>>>>>         End
79990>>>>>>
79990>>>>>         Else Begin
79991>>>>>            forward Send End_Status
79993>>>>>         end
79993>>>>>>
79993>>>>>      End_Procedure
79994>>>>>
79994>>>>>    Function Report_Interrupt Returns Integer
79996>>>>>         integer eStat
79996>>>>>         String sMess
79996>>>>>         Boolean bActiveViewer
79996>>>>>         Get IsViewerActive to bActiveViewer
79997>>>>>         If (Error_Check_State(self)) begin
79999>>>>>            Move C_$AnErrorWishToCancel to sMess
80000>>>>>         end
80000>>>>>>
80000>>>>>         Else begin
80001>>>>>            Move  C_$CancelThisReport to sMess
80002>>>>>         end
80002>>>>>>
80002>>>>>         If bActiveViewer Begin
80004>>>>>            Get PreviewYesNoBox of (phoWinPrint(self)) C_$ReportInterrupt sMess to eStat
80005>>>>>         end
80005>>>>>>
80005>>>>>         Else Begin
80006>>>>>            Get YesNo_Box sMess C_$ReportInterrupt to eStat
80007>>>>>         End
80007>>>>>>
80007>>>>>
80007>>>>>         Function_Return (eStat=MBR_YES)
80008>>>>>
80008>>>>>  End_Function
80009>>>>>
80009>>>>>  Function Test_KeyPressed Returns Integer
80011>>>>>     Boolean bStop bError bActiveViewer
80011>>>>>     integer eMode
80011>>>>>     // winreport will do this also, but this makes sure that this gets called
80011>>>>>     // for each body loop -- even if the body loop prints nothing
80011>>>>>     Send PumpMsgQueue of (phoWinPrint(self)) // permit painting
80012>>>>>     Get IsViewerActive to bActiveViewer
80013>>>>>     Get Output_device_mode to eMode
80014>>>>>     If bActiveViewer Begin
80016>>>>>        Get ViewerWantsToClose of (phoWinPrint(self)) to bStop
80017>>>>>        Get Error_Check_State to bError
80018>>>>>        if (bStop or bError) begin
80020>>>>>            Get Report_Interrupt to bStop
80021>>>>>        end
80021>>>>>>
80021>>>>>     end
80021>>>>>>
80021>>>>>     Else Begin
80022>>>>>        Forward Get Test_KeyPressed to bStop
80024>>>>>        If (eMode=PRINT_TO_WINDOW and not(bStop)) Begin
80026>>>>>            Send DfPreviewNoWait
80027>>>>>        end
80027>>>>>>
80027>>>>>     End
80027>>>>>>
80027>>>>>
80027>>>>>     Function_Return bStop
80028>>>>>  End_Function
80029>>>>>
80029>>>>>    Procedure OnClosingView
80031>>>>>        Send DFClearDoc
80032>>>>>    end_procedure
80033>>>>>
80033>>>>>
80033>>>>>    // Attempt to make this as intuitive as possible. You cannot invoke this when a
80033>>>>>    // report is active. If a report is not finished, you cannot do this.
80033>>>>>    // If a report is finsihed it may or may not have a viewer present.
80033>>>>>    // If a viewer is not present, we will clear the exising report (making the assumption
80033>>>>>    // that a modeless viewer was closed and the report will not be invoked again). If a viewer
80033>>>>>    // is active, we will pass this through to the winprint object which will show an error
80033>>>>>
80033>>>>>    Function DFPrintSetupDialog Returns Boolean// invoke printer setup dialog
80035>>>>>        Integer iStatus
80035>>>>>        Boolean bActiveViewer bOk
80035>>>>>        // we must have printers installed for this to work
80035>>>>>        Get ArePrintersInstalled to bOk
80036>>>>>        If not bOk Begin
80038>>>>>            Error DFERR_WINPRINT C_$NoInstalledPrinters
80039>>>>>>
80039>>>>>        End
80039>>>>>>
80039>>>>>        Else Begin
80040>>>>>            Get DocumentStatus to iStatus
80041>>>>>            If (iStatus=dsFinished) Begin
80043>>>>>                Get IsViewerActive to bActiveViewer
80044>>>>>                If not bActiveViewer Begin
80046>>>>>                    Send DfClearDoc
80047>>>>>                End
80047>>>>>>
80047>>>>>            End
80047>>>>>>
80047>>>>>            // the winprint object will generate an error if the status is not dsNotStarted.
80047>>>>>            // we want those errors
80047>>>>>            Get DFPrintSetupDialog of (phoWinPrint(Self)) to bOk
80048>>>>>        End
80048>>>>>>
80048>>>>>        Function_Return bOk
80049>>>>>    End_Procedure
80050>>>>>
80050>>>>>    // It is better to use DFPrintSetupDialog which tells you if the dialog was canceled
80050>>>>>    Procedure DFPrintSetup // invoke printer setup dialog
80052>>>>>        Boolean bOk
80052>>>>>        Get DFPrintSetupDialog to bOk
80053>>>>>    End_Procedure
80054>>>>>
80054>>>>>    Procedure DFClearDoc // clear document, remove viewer
80056>>>>>        Send DFClearDoc of (phoWinPrint(self))
80057>>>>>    end_procedure
80058>>>>>
80058>>>>>    Procedure DFEndDocument // tell winprint that the report is complete
80060>>>>>        Send DfEndDocument of (phoWinPrint(self))
80061>>>>>    end_procedure
80062>>>>>
80062>>>>>    Procedure DFClosePreview //close the previewer, does not clear the document
80064>>>>>        Send DfClosePreview of (phoWinPrint(self))
80065>>>>>    end_procedure
80066>>>>>
80066>>>>>    Procedure DFPrintDialog // popup print job dialog
80068>>>>>        Send DFPrintDialog of (phoWinPrint(self))
80069>>>>>    End_procedure
80070>>>>>
80070>>>>>    Procedure DFPrint // print with printer dialog
80072>>>>>        Send DFPrint of (phoWinPrint(self))
80073>>>>>    End_procedure
80074>>>>>
80074>>>>>    Procedure DFPrintDoc // print without printer dialog
80076>>>>>        Send DFPrintDoc of (phoWinPrint(self))
80077>>>>>    End_Procedure
80078>>>>>
80078>>>>>    Procedure DFPreviewWait // invoke previewer in modal mode
80080>>>>>       Send DFPreviewWait of (phoWinPrint(self))
80081>>>>>    End_Procedure
80082>>>>>
80082>>>>>    Procedure DFPreviewNoWait // invoke previwer in modeless mode
80084>>>>>       Send DFPreviewNoWait of (phoWinPrint(self))
80085>>>>>    End_Procedure
80086>>>>>
80086>>>>>    Procedure DFPreview // invokde previewer based on pbModalViewer property
80088>>>>>       Boolean bModalViewer
80088>>>>>       Get pbModalViewer to bModalViewer
80089>>>>>       If bModalViewer Begin
80091>>>>>           Send DFPreviewWait
80092>>>>>       end
80092>>>>>>
80092>>>>>       else Begin
80093>>>>>           Send DFPreviewNoWait
80094>>>>>       end
80094>>>>>>
80094>>>>>   End_Procedure
80095>>>>>
80095>>>>>    // Print report to appropriate device (printer, preview) based
80095>>>>>    // on output_device_mode
80095>>>>>    //
80095>>>>>    Procedure PrintReport
80097>>>>>        Integer eMode
80097>>>>>        Get OutPut_Device_Mode to eMode
80098>>>>>        If ((eMode=PRINT_TO_WINDOW) or (eMode=DEFERRED_PRINT_TO_WINDOW)) Begin
80100>>>>>           Send DFPreview
80101>>>>>        end
80101>>>>>>
80101>>>>>        Else If (eMode=PRINT_TO_PRINTER_NO_DIALOG) Begin
80104>>>>>           Send DFPrintDoc // print, no print job dialog
80105>>>>>        end
80105>>>>>>
80105>>>>>        Else Begin // (eMode=PRINT_TO_PRINTER)
80106>>>>>           Send DFPrint // print with print job dialog
80107>>>>>        end
80107>>>>>>
80107>>>>>    End_Procedure
80108>>>>>
80108>>>>>
80108>>>>>    Procedure DFSetPrinterPaper integer ePaperType
80110>>>>>        Send DFSetPrinterPaper of (phoWinPrint(self)) ePaperType
80111>>>>>    End_Procedure
80112>>>>>
80112>>>>>    Function DFGetPrinterPaper returns integer //ePaperType
80114>>>>>        integer ePaperType
80114>>>>>        Get DFGetPrinterPaper of (phoWinPrint(self)) to ePaperType
80115>>>>>        Function_return ePaperType
80116>>>>>    end_function
80117>>>>>
80117>>>>>
80117>>>>>    Procedure DFSetPrinterBin integer eBinType
80119>>>>>        Send DFSetPrinterBin of (phoWinPrint(self)) eBinType
80120>>>>>    End_Procedure
80121>>>>>
80121>>>>>    Function DFGetPrinterBin returns integer //eBinType
80123>>>>>        integer eBinType
80123>>>>>        Get DFGetPrinterBin of (phoWinPrint(self)) to eBinType
80124>>>>>        Function_return eBinType
80125>>>>>    end_function
80126>>>>>
80126>>>>>
80126>>>>>    Procedure DFSetPrinterResolution integer eResType
80128>>>>>        Send DFSetPrinterResolution of (phoWinPrint(self)) eResType
80129>>>>>    End_Procedure
80130>>>>>
80130>>>>>    Function DFGetPrinterResolution returns integer //eResType
80132>>>>>        Boolean eResType
80132>>>>>        Get DFGetPrinterResolution of (phoWinPrint(self)) to eResType
80133>>>>>        Function_return eResType
80134>>>>>    end_function
80135>>>>>
80135>>>>>
80135>>>>>    Procedure DFSetLandscape boolean bIsLandscape
80137>>>>>        Send DFSetLandscape of (phoWinPrint(self)) bIsLandscape
80138>>>>>    End_Procedure
80139>>>>>
80139>>>>>    Function DFGetLandscape returns boolean // bIsLandscape
80141>>>>>        Boolean bIsLandscape
80141>>>>>        Get DFGetLandscape of (phoWinPrint(self)) to bIsLandscape
80142>>>>>        Function_return bIsLandscape
80143>>>>>    end_function
80144>>>>>
80144>>>>>    Procedure DFSetMetrics integer eType
80146>>>>>        Send DFSetMetrics of (phoWinPrint(self)) eType
80147>>>>>    End_Procedure
80148>>>>>
80148>>>>>    Function DFGetMetrics returns integer
80150>>>>>        integer eType
80150>>>>>        Get DFGetMetrics of (phoWinPrint(self)) to eType
80151>>>>>        Function_return eType
80152>>>>>    end_function
80153>>>>>
80153>>>>>
80153>>>>>    Procedure DFSetPrintDlgInPreview boolean bShowDialog
80155>>>>>        Set PrintDlgInPreview of (phoWinPrint(self)) to bShowDialog
80156>>>>>    End_Procedure
80157>>>>>
80157>>>>>    Function DFGetPrintDlgInPreview returns boolean
80159>>>>>        boolean bShowDialog
80159>>>>>        Get PrintDlgInPreview of (phoWinPrint(self)) to bShowDialog
80160>>>>>        Function_return bShowDialog
80161>>>>>    end_function
80162>>>>>
80162>>>>>
80162>>>>>    Procedure DFSetEnablePrintFromPreview boolean bEnablePrint
80164>>>>>        Set EnablePrintFromPreview of (phoWinPrint(self)) to bEnablePrint
80165>>>>>    End_Procedure
80166>>>>>
80166>>>>>    Function DFGetEnablePrintFromPreview returns boolean
80168>>>>>        boolean bEnablePrint
80168>>>>>        Get EnablePrintFromPreview of (phoWinPrint(self)) to bEnablePrint
80169>>>>>        Function_return bEnablePrint
80170>>>>>    end_function
80171>>>>>
80171>>>>>
80171>>>>>
80171>>>>>    Procedure DFSetMargins number nLeft number nTop number nRight number nBottom
80173>>>>>        Send DFSetMargins of (phoWinPrint(self)) nLeft nTop nRight nBottom
80174>>>>>    End_Procedure
80175>>>>>
80175>>>>>    Procedure DFSetTopBottom number nTop number nBottom Boolean bAllPages
80177>>>>>        Send DFSetTopBottom of (phoWinPrint(self)) nTop nBottom bAllPages
80178>>>>>    End_Procedure
80179>>>>>
80179>>>>>
80179>>>>>    Procedure DFSetDevice string sPrinterName
80181>>>>>        Send DFSetDevice of (phoWinPrint(self)) sPrinterName
80182>>>>>    End_Procedure
80183>>>>>
80183>>>>>    Function DFGetCurrentDevice returns string // sPrinterName
80185>>>>>        String sPrinterName
80185>>>>>        Get DFGetCurrentDevice of (phoWinPrint(self)) to sPrinterName
80186>>>>>        Function_return sPrinterName
80187>>>>>    end_function
80188>>>>>
80188>>>>>
80188>>>>>    Procedure DFSetUserDefinedPapersize number nLength number nWidth
80190>>>>>        Send DFSetUserDefinedPapersize of (phoWinPrint(self)) nLength nWidth
80191>>>>>    End_Procedure
80192>>>>>
80192>>>>>    Function DFGetUserDefinedLength returns number
80194>>>>>        number nSize
80194>>>>>        Get DFGetUserDefinedLength of (phoWinPrint(self)) to nSize
80195>>>>>        Function_return nSize
80196>>>>>    end_function
80197>>>>>
80197>>>>>    Function DFGetUserDefinedWidth returns number
80199>>>>>        number nSize
80199>>>>>        Get DFGetUserDefinedWidth of (phoWinPrint(self)) to nSize
80200>>>>>        Function_return nSize
80201>>>>>    end_function
80202>>>>>
80202>>>>>
80202>>>>>    Procedure DFSetNumberOfCopies integer iCopies
80204>>>>>        Send DFSetNumberOfCopies of (phoWinPrint(self)) iCopies
80205>>>>>    End_Procedure
80206>>>>>
80206>>>>>    Procedure DFPrinterBinFirstPage integer eBinType
80208>>>>>        Send DFPrinterBinFirstPage of (phoWinPrint(self)) eBinType
80209>>>>>    End_Procedure
80210>>>>>
80210>>>>>    Procedure DFClearPrinter
80212>>>>>        Send DFClearPrinter of (phoWinPrint(self))
80213>>>>>    End_Procedure
80214>>>>>
80214>>>>>    Function DFGetDFColor integer iRed integer iGreen integer iBlue returns integer
80216>>>>>        integer iWPColor
80216>>>>>        Get DFGetDFColor of (phoWinPrint(self)) iRed iGreen iBlue to iWPColor
80217>>>>>        Function_return iWPColor
80218>>>>>    end_function
80219>>>>>
80219>>>>>    Function RGBToWPColor integer iRgb returns integer
80221>>>>>        integer iWPColor
80221>>>>>        Get RGBToWPColor of (phoWinPrint(self)) iRGB to iWPColor
80222>>>>>        Function_return iWPColor
80223>>>>>    end_function
80224>>>>>
80224>>>>>
80224>>>>>End_Class
80225>>>Use CUSTOMER.DD
80225>>>
80225>>>ACTIVATE_VIEW Activate_oCustomerListWP FOR oCustomerListWP
80235>>>>
80235>>>
80235>>>Object oCustomerListWP is a ReportView
80237>>>
80237>>>    Property Boolean pbComments False
80239>>>    
80239>>>    Set Label to "Customer List"
80240>>>    Set Location to 6 6
80241>>>    Set Size to 95 180
80242>>>
80242>>>    Object Customer_DD is a Customer_DataDictionary
80244>>>    End_Object    // Customer_DD
80245>>>
80245>>>    Set Main_DD to Customer_DD
80246>>>    Set Server to Customer_DD
80247>>>
80247>>>    Object oPrintTo is a RadioGroup
80249>>>        Set Size to 50 80
80250>>>        Set Location to 5 5
80251>>>        Set Label to "Send Report to"
80252>>>        Object oScreenRadio is a Radio
80254>>>            Set Label to "Report Viewer"
80255>>>            Set Size to 10 61
80256>>>            Set Location to 15 10
80257>>>            Set Status_Help to "Preview the report to screen"
80258>>>        End_Object    // oScreenRadio
80259>>>
80259>>>        Object oPrinterRadio is a Radio
80261>>>            Set Label to "Printer"
80262>>>            Set Size to 10 37
80263>>>            Set Location to 30 10
80264>>>            Set Status_Help to "Send the report to the default printer"
80265>>>        End_Object    // oPrinterRadio
80266>>>
80266>>>        Function IsToPrinter Returns boolean
80269>>>            integer iRadio
80269>>>            Get Current_radio to iRadio
80270>>>            Function_return (iRadio=1)
80271>>>        End_Function // IsToPrinter
80272>>>
80272>>>    End_Object    // oPrintTo
80273>>>
80273>>>    Object oOrder is a RadioGroup
80275>>>        Set Size to 50 80
80276>>>        Set Location to 5 95
80277>>>        Set Label to "Report Order"
80278>>>        Object oNumberRadio is a Radio
80280>>>            Set Label to "Number"
80281>>>            Set Size to 10 41
80282>>>            Set Location to 15 10
80283>>>            Set Status_Help to "Sort by customer number"
80284>>>        End_Object    // oNumberRadio
80285>>>
80285>>>        Object oNameRadio is a Radio
80287>>>            Set Label to "Name"
80288>>>            Set Size to 10 35
80289>>>            Set Location to 30 10
80290>>>            Set Status_Help to "Sort by customer name"
80291>>>        End_Object    // oNameRadio
80292>>>
80292>>>        Function IsSortedByNumber Returns boolean
80295>>>            integer iRadio
80295>>>            Get Current_radio to iRadio
80296>>>            Function_return (iRadio=1)
80297>>>        End_Function // IsSortedByNumber
80298>>>
80298>>>    End_Object    // oOrder
80299>>>
80299>>>    Object oCommentsCkBx is a CheckBox
80301>>>        Set Label to "Print Comments"
80302>>>        Set Size to 10 65
80303>>>        Set Location to 59 95
80304>>>
80304>>>    End_Object    // oCommentsCkBx
80305>>>
80305>>>    Object oBtnPrint is a Button
80307>>>        Set Label to "Print"
80308>>>        Set Location to 76 7
80309>>>
80309>>>        Procedure OnClick
80312>>>            Send StartReport
80313>>>        End_Procedure
80314>>>
80314>>>    End_Object    // oBtnPrint
80315>>>
80315>>>    Object oBtnCancel is a Button
80317>>>        Set Label to "Cancel"
80318>>>        Set Location to 76 65
80319>>>
80319>>>        Procedure OnClick
80322>>>            Send Close_Panel
80323>>>        End_Procedure
80324>>>
80324>>>    End_Object    // oBtnCancel
80325>>>
80325>>>    Object oBtnPrinterSetup is a Button
80327>>>        Set Label to "Printer Setup"
80328>>>        Set Location to 76 123
80329>>>
80329>>>        Procedure OnClick
80332>>>            Boolean bSetupOk
80332>>>            Get DFPrintSetupDialog of oReport to bSetupOk
80333>>>        End_Procedure
80334>>>
80334>>>    End_Object    // oBtnPrinterSetup
80335>>>
80335>>>    Object oReport is a cWinReport2
80337>>>        Set Report_Title to "Customer List"
80338>>>
80338>>>        // Set DDO, Index and breaks for the report
80338>>>        Set Server to Customer_DD
80339>>>        Set Ordering to 1
80340>>>
80340>>>        // Report_Breaks file.field // no breaks in this report
80340>>>        
80340>>>        Property Boolean pbLandscape false
80342>>>        
80342>>>        Function Starting_Main_Report Returns Integer
80345>>>            Integer iIndex
80345>>>            Boolean bOn bErr
80345>>>        
80345>>>            Send DFSetMetrics wpm_cm
80346>>>            Send DFSetmargins 1 1 1 1
80347>>>        
80347>>>            Get pbComments to bOn
80348>>>            Send DFSetLandscape (if(bOn,True,false))  // This can be used to force a page orientation
80349>>>            Get DFGetLandscape to bOn
80350>>>            Set pbLandscape to bOn
80351>>>        
80351>>>            Forward Get Starting_Main_Report To bErr
80353>>>        
80353>>>            Function_return bErr
80354>>>        End_Function
80355>>>        
80355>>>        // Page_Top is printed first at the top margin of each page
80355>>>        Procedure Page_Top
80358>>>            string sFont
80358>>>            integer iFontSize iStyle
80358>>>        
80358>>>            Move "arial" to sFont
80359>>>            Move 8 to iFontSize
80360>>>            Move (Font_Default) to iStyle
80361>>>        
80361>>>            DFFont sFont
80362>>>            DFFontSize iFontSize
80363>>>            DFBeginHeader DFPageTop
80364>>>                DFHeaderFrame Hdr_NoFrame
80365>>>                DFHeaderPos   Hdr_Left
80366>>>                DFWriteLn ("Page:" * "#pagecount#") iStyle
80367>>>            DFEndHeader
80369>>>        
80369>>>        End_Procedure
80370>>>        
80370>>>        Procedure Page_Header
80373>>>            integer iFill iBorder iStyle
80373>>>            string  sFont sReportTitle
80373>>>            integer iFontSize
80373>>>        
80373>>>            Move "arial" to sFont
80374>>>            Move 16 to iFontSize
80375>>>            Move (Font_bold + rgb_White) to iStyle
80376>>>            Move (rgb_dGrey) to iFill
80377>>>            Move (rgb_dGrey) to iBorder
80378>>>            Get Report_Title to sReportTitle
80379>>>        
80379>>>            DFFont sFont
80380>>>            DFFontSize iFontSize
80381>>>            DFBeginHeader DFPageHeader
80382>>>                DFHeaderPos   Hdr_Left
80383>>>                DFHeaderFrame Hdr_Margins 0.01 iBorder iFill
80384>>>                DFWritelnPos sReportTitle 0.1 iStyle
80385>>>                DFHeaderMargin HM_BottomOuter 0.08
80386>>>            DFEndHeader
80388>>>        
80388>>>        End_Procedure // Page_Header
80389>>>        
80389>>>        Procedure Page_Title
80392>>>            string  sFont
80392>>>            integer iFontSize iHeaderStyle iFill iBorder
80392>>>            Boolean bOn
80392>>>        
80392>>>            Get pbLandscape to bOn
80393>>>        
80393>>>            Move "arial" to sFont
80394>>>            Move 8 to iFontSize
80395>>>            Move (Font_Bold + rgb_dBlue) to iHeaderStyle
80396>>>            Move (rgb_Grey) to iFill
80397>>>            Move (rgb_Grey) to iBorder
80398>>>        
80398>>>            DFFont sFont
80399>>>            DFFontSize iFontSize
80400>>>            DFBeginHeader DFPageTitle
80401>>>                DFHeaderPos   Hdr_Left
80402>>>                DFHeaderFrame Hdr_Margins 0 iBorder iFill
80403>>>                DfHeaderMargin HM_TopInner    0.01
80404>>>                DfHeaderMargin HM_BottomInner 0.01
80405>>>                DFHeaderMargin HM_BottomOuter 0.16
80406>>>        
80406>>>                DfWritePos "Number"                        0.1 (iHeaderStyle)
80407>>>                DfWritePos "Customer Name"                   2 (iHeaderStyle)
80408>>>                DfWritePos "Address"                         7 (iHeaderStyle)
80409>>>                DfWritePos "City"                           12 (iHeaderStyle)
80410>>>                DfWritePos "St."                            15 (iHeaderStyle)
80411>>>                DfWritePos "Zip"                            17 (iHeaderStyle)
80412>>>        
80412>>>                If bOn begin
80414>>>                   DfWritePos "Comments"                    19 (iHeaderStyle)
80415>>>                end
80415>>>>
80415>>>                DfWriteln
80416>>>            DFEndHeader
80418>>>        
80418>>>        End_Procedure // Page_Title
80419>>>        
80419>>>        Procedure Body
80422>>>            string  sFont
80422>>>            integer iFontSize iStyle
80422>>>            Boolean bOn
80422>>>        
80422>>>            Send Update_Status (String(Customer.Customer_number))
80423>>>        
80423>>>            Get pbLandscape to bOn
80424>>>        
80424>>>            Move "arial" to sFont
80425>>>            Move 8 to iFontSize
80426>>>            Move (font_default) to iStyle
80427>>>        
80427>>>            DFFont sFont
80428>>>            DFFontSize iFontSize
80429>>>            DFLineCheck 5
80430>>>        
80430>>>            DfWritePos Customer.Customer_Number       0.8 (iStyle + Font_Right) 0
80431>>>            DfWritePos Customer.Name                    2 iStyle -1 4.98
80432>>>            DfWritePos Customer.Address                 7 iStyle -1 4.98
80433>>>            DfWritePos Customer.City                   12 iStyle -1 3.98
80434>>>            DfWritePos Customer.State                  15 iStyle -1 0.98
80435>>>            DfWritePos Customer.Zip                    17 iStyle -1 1.98
80436>>>        
80436>>>            If bOn begin
80438>>>                DfWritePos Customer.Comments           19 iStyle -1 0
80439>>>                dfWriteln
80440>>>            end
80440>>>>
80440>>>            dfWriteln
80441>>>        End_Procedure  // Body
80442>>>        
80442>>>        // Page_Bottom is printed last at the bottom margin of each page
80442>>>        Procedure Page_Bottom
80445>>>            string sFont
80445>>>            integer iFontSize iBorder iStyle iFill
80445>>>            DateTime dtDT
80445>>>        
80445>>>            Move (CurrentDateTime()) to dtDT
80446>>>        
80446>>>            Move "arial" to sFont
80447>>>            Move 8 to iFontSize
80448>>>            Move (font_default) to iStyle
80449>>>            Move (rgb_dGrey) to iBorder
80450>>>            Move (rgb_White) to iFill
80451>>>        
80451>>>            DFFont sFont
80452>>>            DFFontSize iFontSize
80453>>>            DFBeginHeader DFPageBottom
80454>>>                DFHeaderFrame Hdr_Margins 0 iBorder iFill
80455>>>                DFHeaderPos Hdr_Center  // Write data in center
80456>>>                DFWriteln ("Report Printed on" * string(dtDT)) (iStyle)
80457>>>            DFEndHeader
80459>>>        
80459>>>        End_Procedure // Page_Bottom
80460>>>        
80460>>>    End_Object    // oReport
80461>>>
80461>>>    Procedure StartReport
80464>>>        Boolean bToPrinter bComments bSortByNumber
80464>>>    
80464>>>        // determine if direct print
80464>>>        Get IsToPrinter of oPrintTo to bToPrinter
80465>>>        Set OutPut_Device_Mode of oReport to (If(bToPrinter, PRINT_TO_PRINTER, PRINT_TO_WINDOW))
80466>>>    
80466>>>        // determine if sort order is by number or name
80466>>>        Get IsSortedByNumber of oOrder to bSortByNumber
80467>>>        Set Ordering of oReport to (if(bSortByNumber, 2, 1))
80468>>>    
80468>>>        Get Checked_State of oCommentsCkBx to bComments
80469>>>        Set pbComments to bComments
80470>>>    
80470>>>        // run the report
80470>>>        Send Run_Report of oReport
80471>>>    
80471>>>    End_Procedure // StartReport
80472>>>
80472>>>End_Object    // oCustomerListWP
80473>        Use WinPrint\ItemsPerOrderWP.rv
Including file: WinPrint\ItemsPerOrderWP.rv    (C:\Test\Order Entry git\AppSrc\WinPrint\ItemsPerOrderWP.rv)
80473>>>Use dfrptvw.pkg
80473>>>Use DataDict.pkg
80473>>>Use dfRadio.pkg
80473>>>Use Windows.pkg
80473>>>Use cWinReport2.pkg
80473>>>Use VENDOR.DD
80473>>>Use INVT.DD
80473>>>Use CUSTOMER.DD
80473>>>Use SALESP.DD
80473>>>Use ORDERHEA.DD
80473>>>Use ORDERDTL.DD
80473>>>
80473>>>ACTIVATE_VIEW Activate_oItemsPerOrderWP FOR oItemsPerOrderWP
80483>>>>
80483>>>
80483>>>Object oItemsPerOrderWP is a ReportView
80485>>>    Set Label to "Items per Order"
80486>>>    Set Location to 6 6
80487>>>    Set Size to 84 140
80488>>>
80488>>>    Object Vendor_DD is a Vendor_DataDictionary
80490>>>    End_Object    // Vendor_DD
80491>>>
80491>>>    Object Invt_DD is a Invt_DataDictionary
80493>>>        Set DDO_Server to Vendor_DD
80494>>>    End_Object    // Invt_DD
80495>>>
80495>>>    Object Customer_DD is a Customer_DataDictionary
80497>>>    End_Object    // Customer_DD
80498>>>
80498>>>    Object SalesP_DD is a Salesp_DataDictionary
80500>>>    End_Object    // SalesP_DD
80501>>>
80501>>>    Object Orderhea_DD is a Orderhea_DataDictionary
80503>>>        Set DDO_Server to Customer_DD
80504>>>        Set DDO_Server to SalesP_DD
80505>>>    End_Object    // Orderhea_DD
80506>>>
80506>>>    Object Orderdtl_DD is a Orderdtl_DataDictionary
80508>>>        Set DDO_Server to Orderhea_DD
80509>>>        Set DDO_Server to Invt_DD
80510>>>    End_Object    // Orderdtl_DD
80511>>>
80511>>>    Object oPrintTo is a RadioGroup
80513>>>        Set Size to 38 131
80514>>>        Set Location to 5 5
80515>>>        Set Label to "Print to"
80516>>>        Object oRadio1 is a Radio
80518>>>            Set Label to "Preview"
80519>>>            Set Size to 10 42
80520>>>            Set Location to 12 6
80521>>>            Set Status_Help to "Prints the report to screen"
80522>>>        End_Object    // oRadio1
80523>>>
80523>>>        Object oRadio2 is a Radio
80525>>>            Set Label to "Printer"
80526>>>            Set Size to 10 42
80527>>>            Set Location to 24 6
80528>>>            Set Status_Help to "Prints the report to printer"
80529>>>        End_Object    // oRadio2
80530>>>
80530>>>    End_Object    // oPrintTo
80531>>>
80531>>>    Object oBtnPrint is a Button
80533>>>        Set Label to "Print"
80534>>>        Set Location to 48 85
80535>>>        Set Status_Help to "Print the Selected report"
80536>>>        Set Default_State to True
80537>>>
80537>>>        Procedure OnClick
80540>>>            Send StartReport
80541>>>        End_Procedure
80542>>>
80542>>>    End_Object    // oBtnPrint
80543>>>
80543>>>    Object oBtnCancel is a Button
80545>>>        Set Label to "Cancel"
80546>>>        Set Location to 66 85
80547>>>        Set Status_Help to "Close this Panel"
80548>>>
80548>>>        Procedure OnClick
80551>>>            Send Close_Panel
80552>>>        End_Procedure
80553>>>
80553>>>    End_Object    // oBtnCancel
80554>>>
80554>>>    Object oOrders is a cWinReport2
80556>>>        Set Report_Title to "Customer Report"
80557>>>
80557>>>        //Main File for the report
80557>>>        Set Server to Orderdtl_DD
80558>>>
80558>>>        //Breaks and Index for the report
80558>>>        Report_Breaks ORDERHEA.ORDER_NUMBER
80572>>>        Set Ordering to 1
80573>>>
80573>>>        Function Starting_Main_Report Returns Integer
80576>>>            Integer iRetVal
80576>>>            Send DFSetMetrics WPM_CM
80577>>>            Send DFSetmargins 1 1 1 1
80578>>>            Forward Get Starting_Main_Report To iRetVal
80580>>>            If iRetVal Function_return iRetVal
80583>>>        End_Function
80584>>>
80584>>>        Procedure Page_Top
80587>>>            DFFont "Arial" //  Use Arial
80588>>>            DFFontSize 8
80589>>>            DFBeginHeader DFPageTop
80590>>>                DFHeaderPos   HDR_RIGHT
80591>>>                DFHeaderFrame HDR_NOFRAME
80592>>>                DFWriteLn ("Page:" * "#pagecount#")
80593>>>            DFEndHeader
80595>>>        End_Procedure
80596>>>
80596>>>        Procedure Page_Header
80599>>>            DFFont "Arial"
80600>>>            DFFontSize 14
80601>>>            DFBeginHeader DFPageHeader
80602>>>                DFHeaderFrame HDR_MARGINs 0 RGB_DGREY RGB_DGREY
80603>>>                DFHEADERPOS HDR_LEFT
80604>>>                DFHeaderMargin HM_BottomOuter 0.08
80605>>>                DFWritelnPos "Orders by Order Number Report" 0.10 (FONT_BOLD+RGB_WHITE)
80606>>>            DFEndHeader
80608>>>        End_Procedure
80609>>>
80609>>>        Procedure Page_Title
80612>>>            DFFont "Arial"
80613>>>            DFFontSize 8
80614>>>            DFBeginHeader DFPageTitle
80615>>>                DFHeaderFrame HDR_MARGINs 0 RGB_GREY RGB_GREY
80616>>>                DFHEADERPOS HDR_LEFT
80617>>>                DFWritePos    "Item Id"                 0.1     (FONT_BOLD+RGB_DBLUE)            -1 1.36
80618>>>                DFWritePos    "Description"             4.00    (FONT_BOLD+RGB_DBLUE)            -1 4.77
80619>>>                DFWritePos    "Qty Ordered"             11.5     (FONT_BOLD+FONT_RIGHT+RGB_DBLUE) -1 1.87
80620>>>                DFWritePos    "Price"                   13.22   (FONT_BOLD+FONT_RIGHT+RGB_DBLUE) -1 1.22
80621>>>                DFWritePos    "Extended Price"          16.0    (FONT_BOLD+FONT_RIGHT+RGB_DBLUE) -1 2.38
80622>>>                DFWriteln
80623>>>            DFEndHeader
80625>>>        End_Procedure
80626>>>
80626>>>        Procedure SubHeader1
80629>>>
80629>>>            DFFont "Arial" //  Use Arial
80630>>>            DFFontSize 10
80631>>>
80631>>>            DFBeginHeader DFSubHeader 1    //Header of type DFSubHeader
80632>>>
80632>>>                Send Update_Status ("Order:" * String(OrderHea.Order_number))
80633>>>
80633>>>                DFHeaderWrap HDR_WRAP
80634>>>                DFHeaderLineCheck 5            //Check that the header + 5 lines fits on the page, if not wrap
80635>>>
80635>>>                DFHeaderPos   HDR_LEFT         //Write data from left margin in the header
80636>>>                DFHeaderFrame HDR_NoFrame      //Set the box from margin to margin using size 0.05
80637>>>
80637>>>                DFWriteLnPos    ("Order: "+string(Orderhea.ORDER_NUMBER)) 0.1 (FONT_BOLD)
80638>>>
80638>>>              DFEndHeader                     //End and print header
80640>>>
80640>>>        End_Procedure
80641>>>
80641>>>        Procedure Body
80644>>>
80644>>>            DFFont "Arial" //  Use Arial
80645>>>            DFFontSize 8
80646>>>
80646>>>            DFLineCheck 5
80647>>>
80647>>>            DFWritePos    Invt.ITEM_ID                0.1     (FONT_DEFAULT)            -1 2.28
80648>>>            DFWritePos    Invt.DESCRIPTION            4.00    (FONT_DEFAULT)            -1 4.77
80649>>>            DFWritePos    Orderdtl.QTY_ORDERED        11.5     (FONT_DEFAULT+FONT_RIGHT)  0 1.87
80650>>>            DFWritePos    Orderdtl.PRICE              13.22   (FONT_DEFAULT+FONT_RIGHT)  2 1.22
80651>>>            DFWritePos    Orderdtl.EXTENDED_PRICE     16.0    (FONT_DEFAULT+FONT_RIGHT)  2 2.38
80652>>>            DFWriteln ""
80653>>>
80653>>>            // Using SubTotal in WinPrint.
80653>>>            Send Add_SubTotal 1 (Orderdtl.EXTENDED_PRICE)
80654>>>
80654>>>        End_Procedure
80655>>>
80655>>>        Procedure SubTotal1
80658>>>            Number nAmount
80658>>>            Get SubTotal 1 to nAmount
80659>>>            Send Add_SubTotal 2 nAmount // subtotal 2 is total
80660>>>
80660>>>            DFFont "Arial" //  Use Arial
80661>>>            DFFontSize 8
80662>>>            DFBeginHeader DFSubTotal 1
80663>>>
80663>>>                DFHEADERPOS HDR_LEFT
80664>>>                DFHEADERFRAME HDR_NOFRAME
80665>>>
80665>>>                DFWritelnPos  nAmount         16.0      (FONT_BOLD+FONT_RIGHT) 2 0
80666>>>                DFWriteLine DFGR_CURRLINE DFGR_CURRLINE DFGR_RB_MARGIN DFGR_HORI Rgb_dGrey
80667>>>
80667>>>            DFEndHeader
80669>>>
80669>>>        End_Procedure
80670>>>
80670>>>        Procedure Total
80673>>>            Number nTotal
80673>>>            Get SubTotal 2 to nTotal
80674>>>
80674>>>            DFFont "Arial" //  Use Arial
80675>>>            DFFontSize 8
80676>>>            DFBeginHeader DFTotal           //Header of type DFTotal
80677>>>
80677>>>              DFHeaderPos   HDR_LEFT         //Write data from left margin in the header
80678>>>              DFHeaderFrame HDR_MARGINs 0 RGB_DGREY RGB_GREY //rgb_Cyan rgb_Cyan
80679>>>
80679>>>              DFWritelnPos   nTotal         16.0      (FONT_BOLD+FONT_RIGHT) 2
80680>>>
80680>>>            DFEndHeader                     //End and print header
80682>>>
80682>>>        End_Procedure
80683>>>
80683>>>        Procedure Page_Bottom
80686>>>            DateTime dtDT
80686>>>            Move (CurrentDateTime()) to dtDT
80687>>>
80687>>>            DFFont "Arial" //  Use Arial
80688>>>            DFFontSize 8
80689>>>            DFBeginHeader DFPageBottom
80690>>>                DFHeaderPos   HDR_CENTER       //Write data in center
80691>>>                DFHeaderFrame HDR_MARGINS 0.01 rgb_dGrey
80692>>>                DFWriteLn   ("Report Printed on: " +string(dtDT)) (rgb_dBlue)
80693>>>            DFEndHeader
80695>>>
80695>>>        End_Procedure
80696>>>
80696>>>    End_Object    // oOrders
80697>>>
80697>>>    // Procedures and functions used by the user interface
80697>>>
80697>>>    //This function is called by the procedure StartReport
80697>>>    Function Print_to_Screen_State Returns Integer
80700>>>        Integer iRad
80700>>>        Get Current_Radio of oPrintTo To iRad
80701>>>        Function_Return (iRad=1)
80702>>>    End_Function
80703>>>
80703>>>    // Use this procedure to do print setup
80703>>>    Procedure SetupReport
80706>>>        Boolean bSetupOk
80706>>>        Get DFPrintSetupDialog of (Report_Object_Id(Self)) to bSetupOk
80707>>>    End_Procedure
80708>>>
80708>>>    // Use this procedure to start the report
80708>>>    Procedure StartReport
80711>>>        Integer iToPrinter iRepObj
80711>>>        String sVal
80711>>>        Get Report_Object_Id To iRepObj
80712>>>
80712>>>        Get Print_to_Screen_State to iToPrinter
80713>>>        If iToPrinter Set OutPut_Device_Mode to PRINT_TO_PRINTER
80716>>>        Else Set OutPut_Device_Mode to PRINT_TO_WINDOW
80718>>>
80718>>>        Send Run_Report to iRepObj
80719>>>
80719>>>    End_Procedure
80720>>>
80720>>>End_Object    // oItemsPerOrderWP
80721>        Use WinPrint\OrdersWP.rv
Including file: WinPrint\OrdersWP.rv    (C:\Test\Order Entry git\AppSrc\WinPrint\OrdersWP.rv)
80721>>>Use dfrptvw.pkg
80721>>>Use DataDict.pkg
80721>>>Use dfRadio.pkg
80721>>>Use Windows.pkg
80721>>>Use cWinReport2.pkg
80721>>>Use VENDOR.DD
80721>>>Use INVT.DD
80721>>>Use CUSTOMER.DD
80721>>>Use SALESP.DD
80721>>>Use ORDERHEA.DD
80721>>>Use ORDERDTL.DD
80721>>>
80721>>>ACTIVATE_VIEW Activate_oOrdersWP FOR oOrdersWP
80731>>>>
80731>>>
80731>>>Object oOrdersWP is a ReportView
80733>>>    Set Label to "Orders by Order Number"
80734>>>    Set Location to 6 6
80735>>>    Set Size to 46 175
80736>>>
80736>>>    Object Vendor_DD is a Vendor_DataDictionary
80738>>>    End_Object    // Vendor_DD
80739>>>
80739>>>    Object Invt_DD is a Invt_DataDictionary
80741>>>        Set DDO_Server to Vendor_DD
80742>>>    End_Object    // Invt_DD
80743>>>
80743>>>    Object Customer_DD is a Customer_DataDictionary
80745>>>    End_Object    // Customer_DD
80746>>>
80746>>>    Object SalesP_DD is a Salesp_DataDictionary
80748>>>    End_Object    // SalesP_DD
80749>>>
80749>>>    Object Orderhea_DD is a Orderhea_DataDictionary
80751>>>        Set DDO_Server to Customer_DD
80752>>>        Set DDO_Server to SalesP_DD
80753>>>    End_Object    // Orderhea_DD
80754>>>
80754>>>    Object Orderdtl_DD is a Orderdtl_DataDictionary
80756>>>        Set DDO_Server to Orderhea_DD
80757>>>        Set DDO_Server to Invt_DD
80758>>>    End_Object    // Orderdtl_DD
80759>>>
80759>>>    Object oPrintTo is a RadioGroup
80761>>>        Set Size to 38 105
80762>>>        Set Location to 4 5
80763>>>        Set Label to "Print to"
80764>>>        Object oRadio1 is a Radio
80766>>>            Set Label to "Preview"
80767>>>            Set Size to 10 42
80768>>>            Set Location to 12 6
80769>>>            Set Status_Help to "Prints the report to screen"
80770>>>        End_Object    // oRadio1
80771>>>
80771>>>        Object oRadio2 is a Radio
80773>>>            Set Label to "Printer"
80774>>>            Set Size to 10 42
80775>>>            Set Location to 24 6
80776>>>            Set Status_Help to "Prints the report to printer"
80777>>>        End_Object    // oRadio2
80778>>>
80778>>>    End_Object    // oPrintTo
80779>>>
80779>>>    Object oBtnPrint is a Button
80781>>>        Set Label to "Print"
80782>>>        Set Location to 10 120
80783>>>        Set Status_Help to "Print the Selected report"
80784>>>        Set Default_State to True
80785>>>
80785>>>        Procedure OnClick
80788>>>            Send StartReport
80789>>>        End_Procedure
80790>>>
80790>>>    End_Object    // oBtnPrint
80791>>>
80791>>>    Object oBtnCancel is a Button
80793>>>        Set Label to "Cancel"
80794>>>        Set Location to 28 120
80795>>>        Set Status_Help to "Close this Panel"
80796>>>
80796>>>        Procedure OnClick
80799>>>            Send Close_Panel
80800>>>        End_Procedure
80801>>>
80801>>>    End_Object    // oBtnCancel
80802>>>
80802>>>    Object oOrders is a cWinReport2
80804>>>        Set Report_Title to "Customer Report"
80805>>>
80805>>>        //Main File for the report
80805>>>        Set Server to Orderdtl_DD
80806>>>
80806>>>        //Breaks and Index for the report
80806>>>        Report_Breaks ORDERHEA.ORDER_NUMBER
80820>>>        Report_Index By 1
80822>>>
80822>>>        Function Starting_Main_Report Returns Integer
80825>>>            Integer iRetVal
80825>>>            Set PrintDlgInPreview of WinprintId to True
80826>>>            Send DFSetMetrics To WinPrintId "CM"
80827>>>            Send DFSetmargins To WinPrintId 1 1 1 1
80828>>>            Forward Get Starting_Main_Report To iRetVal
80830>>>            If iRetVal Function_return iRetVal
80833>>>        End_Function
80834>>>
80834>>>        Procedure Page_Top
80837>>>            DFFont "Arial" //  Use Arial
80838>>>            DFFontSize 8
80839>>>            DFBeginHeader DFPageTop
80840>>>                DFHeaderPos   HDR_RIGHT
80841>>>                DFHeaderFrame HDR_NOFRAME
80842>>>                DFWriteLn ("Page:" * "#pagecount#")
80843>>>            DFEndHeader
80845>>>        End_Procedure
80846>>>
80846>>>        Procedure Page_Title
80849>>>            DFFont "Arial"
80850>>>            DFFontSize 14
80851>>>            DFBeginHeader DFPageTitle
80852>>>                DFHeaderFrame HDR_MARGINs 0 RGB_DGREY RGB_DGREY
80853>>>                DFHEADERPOS HDR_LEFT
80854>>>                DFWritelnPos "Orders by Order Number Report" 0.10 (FONT_BOLD+RGB_WHITE)
80855>>>            DFEndHeader
80857>>>        End_Procedure
80858>>>
80858>>>        Procedure SubHeader1
80861>>>
80861>>>            DFFont "Arial" //  Use Arial
80862>>>            DFFontSize 8
80863>>>
80863>>>            DFBeginHeader DFSubHeader 1    //Header of type DFSubHeader
80864>>>
80864>>>                Send Update_Status ("Order:" * String(OrderHea.Order_number))
80865>>>
80865>>>
80865>>>                DFHeaderWrap HDR_WRAP
80866>>>                DFHeaderLineCheck 5            //Check that the header + 5 lines fits on the page, if not wrap
80867>>>
80867>>>                DFHeaderPos   HDR_LEFT         //Write data from left margin in the header
80868>>>                DFHeaderFrame HDR_NoFrame      //Set the box from margin to margin using size 0.05
80869>>>                DFHeaderMargin hm_BottomOuter 0.04
80870>>>
80870>>>                DFWritePos    "Order Number"            0.10  (FONT_BOLD+RGB_DBLUE)
80871>>>                DFWritelnPos  Orderhea.ORDER_NUMBER       4.0   (FONT_DEFAULT)
80872>>>                DFWritePos    "Order Date"              0.10  (FONT_BOLD+RGB_DBLUE)
80873>>>                DFWritelnPos  Orderhea.ORDER_DATE         4.0   (FONT_DEFAULT)
80874>>>                DFWritePos    "Customer Number"         0.10  (FONT_BOLD+RGB_DBLUE)
80875>>>                DFWritelnPos  Customer.CUSTOMER_NUMBER    4.0
80876>>>                DFWritePos    "Name"                    0.10  (FONT_BOLD+RGB_DBLUE)
80877>>>                DFWritelnPos  Customer.NAME               4.0   (FONT_DEFAULT)
80878>>>                DFWritePos    "Address"                 0.10  (FONT_BOLD+RGB_DBLUE)
80879>>>                DFWritelnPos  Customer.ADDRESS            4.0   (FONT_DEFAULT)
80880>>>                DFWritePos    "City"                    0.10  (FONT_BOLD+RGB_DBLUE)
80881>>>                DFWritelnPos  Customer.CITY               4.0   (FONT_DEFAULT)
80882>>>                DFWritePos    "State"                   0.10  (FONT_BOLD+RGB_DBLUE)
80883>>>                DFWritelnPos  Customer.STATE              4.0   (FONT_DEFAULT)
80884>>>                DFWritePos    "Zip"                     0.10  (FONT_BOLD+RGB_DBLUE)
80885>>>                DFWritelnPos  Customer.ZIP                4.0   (FONT_DEFAULT)
80886>>>                DFWritePos    "Terms"                   0.10  (FONT_BOLD+RGB_DBLUE)
80887>>>                DFWritelnPos  Orderhea.TERMS              4.0   (FONT_DEFAULT)
80888>>>                DFWritePos    "Ship Via"                0.10  (FONT_BOLD+RGB_DBLUE)
80889>>>                DFWritelnPos  Orderhea.SHIP_VIA           4.0   (FONT_DEFAULT)
80890>>>                DFFontSize 2
80891>>>                DFWriteLn
80892>>>
80892>>>                DFFontSize 8
80893>>>                DfWriteRect DFGR_CURRLINE 0 0.34 DFGR_RB_MARGIN RGB_GREY 0.0 dfgr_noWrap RGB_GREY
80894>>>                DFWritePos    "Item Id"                 0.1     (FONT_BOLD+RGB_DBLUE)            -1 1.36
80895>>>                DFWritePos    "Description"             4.00    (FONT_BOLD+RGB_DBLUE)            -1 4.77
80896>>>                DFWritePos    "Qty Ordered"             11.5     (FONT_BOLD+FONT_RIGHT+RGB_DBLUE) -1 1.87
80897>>>                DFWritePos    "Price"                   13.22   (FONT_BOLD+FONT_RIGHT+RGB_DBLUE) -1 1.22
80898>>>                DFWritePos    "Extended Price"          16.0    (FONT_BOLD+FONT_RIGHT+RGB_DBLUE) -1 2.40
80899>>>                DFWriteln
80900>>>
80900>>>              DFEndHeader                     //End and print header
80902>>>
80902>>>        End_Procedure
80903>>>
80903>>>        Procedure Body
80906>>>
80906>>>            DFFont "Arial" //  Use Arial
80907>>>            DFFontSize 8
80908>>>
80908>>>            DFLineCheck 5
80909>>>
80909>>>            DFWritePos    Invt.ITEM_ID                0.1     (FONT_DEFAULT)            -1 2.28
80910>>>            DFWritePos    Invt.DESCRIPTION            4.00    (FONT_DEFAULT)            -1 4.77
80911>>>            DFWritePos    Orderdtl.QTY_ORDERED        11.5     (FONT_DEFAULT+FONT_RIGHT)  0 1.87
80912>>>            DFWritePos    Orderdtl.PRICE              13.22   (FONT_DEFAULT+FONT_RIGHT)  2 1.22
80913>>>            DFWritePos    Orderdtl.EXTENDED_PRICE     16.0    (FONT_DEFAULT+FONT_RIGHT)  2 2.40
80914>>>            DFWriteln
80915>>>
80915>>>            // Using SubTotal in WinPrint.
80915>>>            Send Add_SubTotal 1 (Orderdtl.EXTENDED_PRICE)
80916>>>
80916>>>        End_Procedure
80917>>>
80917>>>        Procedure SubTotal1
80920>>>            Number nAmount
80920>>>            Get SubTotal 1 to nAmount
80921>>>            Send Add_SubTotal 2 nAmount // subtotal 2 is total
80922>>>
80922>>>            DFFont "Arial" //  Use Arial
80923>>>            DFFontSize 8
80924>>>            DFBeginHeader DFSubTotal 1
80925>>>
80925>>>                DFHEADERPOS HDR_LEFT
80926>>>                  DFHeaderFrame hdr_margins 0.01 rgb_grey rgb_Grey
80927>>>                  dfHeaderMargin hm_bottomOuter 0.10
80928>>>                  dfHeaderMargin hm_bottomInner 0.01
80929>>>                  dfHeaderMargin hm_TopInner    0.01
80930>>>
80930>>>                DFWritelnPos  nAmount         16.0      (Font_BOLD+FONT_RIGHT) 2 0
80931>>>            DFEndHeader
80933>>>
80933>>>        End_Procedure
80934>>>
80934>>>        Procedure Total
80937>>>            Number nTotal
80937>>>            Get SubTotal 2 to nTotal
80938>>>
80938>>>            DFFont "Arial" //  Use Arial
80939>>>            DFFontSize 8
80940>>>            DFBeginHeader DFTotal           //Header of type DFTotal
80941>>>
80941>>>              DFHeaderPos   HDR_LEFT         //Write data from left margin in the header
80942>>>              DFHeaderFrame HDR_MARGINs 0 RGB_DGREY RGB_GREY //rgb_Cyan rgb_Cyan
80943>>>
80943>>>              DFWritelnPos   nTotal         16.0      (FONT_BOLD+FONT_RIGHT) 2
80944>>>
80944>>>            DFEndHeader                     //End and print header
80946>>>
80946>>>        End_Procedure
80947>>>
80947>>>        Procedure Page_Bottom
80950>>>            DateTime dtDT
80950>>>            Move (CurrentDateTime()) to dtDT
80951>>>
80951>>>            DFFont "Arial" //  Use Arial
80952>>>            DFFontSize 8
80953>>>            DFBeginHeader DFPageBottom
80954>>>                DFHeaderPos   HDR_CENTER       //Write data in center
80955>>>                DFHeaderFrame HDR_MARGINS 0.01 rgb_dGrey
80956>>>                DFWriteLn   ("Report Printed on: " +string(dtDT)) (rgb_dBlue)
80957>>>            DFEndHeader
80959>>>
80959>>>        End_Procedure
80960>>>
80960>>>    End_Object    // oOrders
80961>>>
80961>>>    // Procedures and functions used by the user interface
80961>>>
80961>>>    //This function is called by the procedure StartReport
80961>>>    Function Print_to_Screen_State Returns Integer
80964>>>        Integer iRad
80964>>>        Get Current_Radio of oPrintTo To iRad
80965>>>        Function_Return (iRad=1)
80966>>>    End_Function
80967>>>
80967>>>    // Use this procedure to do print setup
80967>>>    Procedure SetupReport
80970>>>        Boolean bSetupOk
80970>>>        Get DFPrintSetupDialog of (Report_Object_Id(Self)) to bSetupOk
80971>>>    End_Procedure
80972>>>
80972>>>    // Use this procedure to start the report
80972>>>    Procedure StartReport
80975>>>        Integer iToPrinter iRepObj
80975>>>        String sVal
80975>>>        Get Report_Object_Id To iRepObj
80976>>>
80976>>>        Get Print_to_Screen_State to iToPrinter
80977>>>        If iToPrinter Set OutPut_Device_Mode to PRINT_TO_PRINTER
80980>>>        Else Set OutPut_Device_Mode to PRINT_TO_WINDOW
80982>>>
80982>>>        Send Run_Report to iRepObj
80983>>>
80983>>>    End_Procedure
80984>>>
80984>>>End_Object    // oOrdersWP
80985>        Use WinPrint\OrdersByCustomerWP.rv
Including file: WinPrint\OrdersByCustomerWP.rv    (C:\Test\Order Entry git\AppSrc\WinPrint\OrdersByCustomerWP.rv)
80985>>>Use dfrptvw.pkg
80985>>>Use DataDict.pkg
80985>>>Use dfRadio.pkg
80985>>>Use Windows.pkg
80985>>>Use cWinReport2.pkg
80985>>>Use VENDOR.DD
80985>>>Use INVT.DD
80985>>>Use CUSTOMER.DD
80985>>>Use SALESP.DD
80985>>>Use ORDERHEA.DD
80985>>>Use ORDERDTL.DD
80985>>>
80985>>>ACTIVATE_VIEW Activate_oOrdersByCustomerWP FOR oOrdersByCustomerWP
80995>>>>
80995>>>
80995>>>Object oOrdersByCustomerWP is a ReportView
80997>>>
80997>>>    property integer main_dd
80999>>>    Property integer server
81001>>>
81001>>>    Set Label to "Orders by Customer"
81002>>>    Set Location to 6 6
81003>>>    Set Size to 110 174
81004>>>
81004>>>    Object Vendor_DD is a Vendor_DataDictionary
81006>>>    End_Object    // Vendor_DD
81007>>>
81007>>>    Object Invt_DD is a Invt_DataDictionary
81009>>>        Set DDO_Server to Vendor_DD
81010>>>    End_Object    // Invt_DD
81011>>>
81011>>>    Object Customer_DD is a Customer_DataDictionary
81013>>>    End_Object    // Customer_DD
81014>>>
81014>>>    Object SalesP_DD is a Salesp_DataDictionary
81016>>>    End_Object    // SalesP_DD
81017>>>
81017>>>    Object Orderhea_DD is a Orderhea_DataDictionary
81019>>>        Set DDO_Server to Customer_DD
81020>>>        Set DDO_Server to SalesP_DD
81021>>>        Set Constrain_File to Customer.File_Number
81022>>>    End_Object    // Orderhea_DD
81023>>>
81023>>>    Object Orderdtl_DD is a Orderdtl_DataDictionary
81025>>>        Set DDO_Server to Orderhea_DD
81026>>>        Set DDO_Server to Invt_DD
81027>>>        Set Constrain_File to Orderhea.File_Number
81028>>>    End_Object    // Orderdtl_DD
81029>>>
81029>>>    Set Main_DD to Customer_DD
81030>>>    Set Server to Customer_DD
81031>>>
81031>>>    Object oPrintTo is a RadioGroup
81033>>>        Set Size to 38 105
81034>>>        Set Location to 5 5
81035>>>        Set Label to "Print to"
81036>>>        Object oRadio1 is a Radio
81038>>>            Set Label to "Preview"
81039>>>            Set Size to 10 42
81040>>>            Set Location to 12 6
81041>>>            Set Status_Help to "Prints the report to screen"
81042>>>        End_Object    // oRadio1
81043>>>
81043>>>        Object oRadio2 is a Radio
81045>>>            Set Label to "Printer"
81046>>>            Set Size to 10 42
81047>>>            Set Location to 24 6
81048>>>            Set Status_Help to "Prints the report to printer"
81049>>>        End_Object    // oRadio2
81050>>>
81050>>>    End_Object    // oPrintTo
81051>>>
81051>>>    Object oReportOrder is a RadioGroup
81053>>>        Set Size to 38 105
81054>>>        Set Location to 45 5
81055>>>        Set Label to "Report Order"
81056>>>        Object oRadio3 is a Radio
81058>>>            Set Label to "Customer Number"
81059>>>            Set Size to 10 73
81060>>>            Set Location to 12 6
81061>>>            Set Status_Help to "Prints the report to screen"
81062>>>        End_Object    // oRadio3
81063>>>
81063>>>        Object oRadio4 is a Radio
81065>>>            Set Label to "Customer Name"
81066>>>            Set Size to 10 67
81067>>>            Set Location to 24 6
81068>>>            Set Status_Help to "Prints the report to printer"
81069>>>        End_Object    // oRadio4
81070>>>
81070>>>        Function OrderByNumber returns boolean
81073>>>            function_return (current_radio(self)=0)
81074>>>        end_function
81075>>>        
81075>>>    End_Object    // oReportOrder
81076>>>
81076>>>    Object oSetupButton is a Button
81078>>>        Set Label to "Printer Setup"
81079>>>        Set Location to 7 120
81080>>>
81080>>>        Procedure OnClick
81083>>>            Boolean bSetupOk
81083>>>            Get DFPrintSetupDialog of oOrders to bSetupOk
81084>>>        End_Procedure
81085>>>
81085>>>    End_Object    // oSetupButton
81086>>>
81086>>>    Object oBtnPrint is a Button
81088>>>        Set Label to "Print"
81089>>>        Set Location to 49 120
81090>>>        Set Status_Help to "Print the Selected report"
81091>>>        Set Default_State to True
81092>>>
81092>>>        Procedure OnClick
81095>>>            boolean bByNumber
81095>>>            Get OrderByNumber of oReportOrder  to bByNumber
81096>>>            Set Ordering of oOrders to (if(bByNumber,1,2))
81097>>>            Send StartReport
81098>>>        End_Procedure
81099>>>
81099>>>    End_Object    // oBtnPrint
81100>>>
81100>>>    Object oBtnCancel is a Button
81102>>>        Set Label to "Cancel"
81103>>>        Set Location to 67 120
81104>>>        Set Status_Help to "Close this Panel"
81105>>>
81105>>>        Procedure OnClick
81108>>>            Send Close_Panel
81109>>>        End_Procedure
81110>>>
81110>>>    End_Object    // oBtnCancel
81111>>>
81111>>>    Object oOnePageCkBx is a CheckBox
81113>>>        Set Label to "New Page for Each Customer"
81114>>>        Set Size to 10 110
81115>>>        Set Location to 92 6
81116>>>
81116>>>        Procedure OnChange
81119>>>            Boolean bChecked
81119>>>        
81119>>>            Get Checked_State To bChecked
81120>>>        End_Procedure // OnChange
81121>>>
81121>>>    End_Object    // oOnePageCkBx
81122>>>
81122>>>    Object oOrders is a cWinReport2
81124>>>
81124>>>        Property Boolean pbOnePagePerCust False
81126>>>        
81126>>>        Set Report_Title to "Printing all Orders by Customer"
81127>>>        
81127>>>        //Main File for the report
81127>>>        Set Server to Customer_DD
81128>>>        //Breaks and Index for the report
81128>>>        Report_Breaks Customer.Customer_number
81142>>>        
81142>>>        Set Ordering to 2
81143>>>        
81143>>>        Object oOrderHea is a cWinReport2
81145>>>
81145>>>            Set Server to Orderhea_DD
81146>>>            Report_Breaks ORDERHEA.Order_number
81160>>>            set Ordering to 2
81161>>>
81161>>>            Object oOrderDtl is a cWinReport2
81163>>>
81163>>>                Set Server to Orderdtl_DD
81164>>>                Report_Breaks Orderhea.Order_Number
81178>>>                Set Ordering to 1
81179>>>                
81179>>>                Procedure SubHeader1
81182>>>                      Send Update_Status (Customer.Name - '/' - string(Orderhea.Order_number))
81183>>>                
81183>>>                      DFFont "Arial"
81184>>>                      DFFontSize 8
81185>>>                
81185>>>                      DFBeginHeader DFSubHeader 2
81186>>>                        DFHeaderFrame hdr_NoFrame
81187>>>                        DFHeaderPos   hdr_Left
81188>>>                        DFHeaderWrap hdr_Wrap
81189>>>                        DfHeaderMargin hm_BottomOuter 0.04
81190>>>                        DFHeaderLineCheck 5            //Check that the header + 5 lines fits on the page, if not wrap
81191>>>                
81191>>>                        DFWritePos    "Order Number"            0.10  (FONT_BOLD+RGB_DBLUE)
81192>>>                        DFWritelnPos  Orderhea.Order_number       4.0   (FONT_DEFAULT)
81193>>>                        DFWritePos    "Order Date"              0.10  (FONT_BOLD+RGB_DBLUE)
81194>>>                        DFWritelnPos  Orderhea.Order_date         4.0   (FONT_DEFAULT)
81195>>>                        DFWritePos    "Terms"                   0.10  (FONT_BOLD+RGB_DBLUE)
81196>>>                        DFWritelnPos  Orderhea.Terms              4.0   (FONT_DEFAULT)
81197>>>                        DFWritePos    "Ship Via"                0.10  (FONT_BOLD+RGB_DBLUE)
81198>>>                        DFWritelnPos  Orderhea.Ship_via           4.0   (FONT_DEFAULT)
81199>>>                
81199>>>                        DfWriteRect dfgr_CurrLine 0 0.34 dfgr_rb_Margin rgb_Grey 0.0 dfgr_NoWrap rgb_Grey
81200>>>                        DFWritePos    "Item Id"                 0.1     (FONT_BOLD+RGB_DBLUE)            -1 1.36
81201>>>                        DFWritePos    "Description"             4.00    (FONT_BOLD+RGB_DBLUE)            -1 4.77
81202>>>                        DFWritePos    "Qty Ordered"             11.5     (FONT_BOLD+FONT_RIGHT+RGB_DBLUE) -1 1.87
81203>>>                        DFWritePos    "Price"                   13.22   (FONT_BOLD+FONT_RIGHT+RGB_DBLUE) -1 1.22
81204>>>                        DFWritePos    "Extended Price"          16.0    (FONT_BOLD+FONT_RIGHT+RGB_DBLUE) -1 2.50
81205>>>                        DFWriteln
81206>>>                
81206>>>                      DFEndHeader
81208>>>                
81208>>>                End_Procedure
81209>>>                
81209>>>                Procedure Body // order detail body
81212>>>                
81212>>>                    DFFont "Arial"
81213>>>                    DFFontSize 8
81214>>>                
81214>>>                    DFLineCheck 5
81215>>>                
81215>>>                    DFWritePos    Invt.Item_id                0.1     (FONT_DEFAULT)            -1 2.28
81216>>>                    DFWritePos    Invt.Description            4.00    (FONT_DEFAULT)            -1 4.77
81217>>>                    DFWritePos    Orderdtl.Qty_ordered        11.5     (FONT_DEFAULT+FONT_RIGHT)  0 1.87
81218>>>                    DFWritePos    Orderdtl.Price              13.22   (FONT_DEFAULT+FONT_RIGHT)  2 1.22
81219>>>                    DFWritePos    Orderdtl.Extended_price     16.0    (FONT_DEFAULT+FONT_RIGHT)  2 2.50
81220>>>                    DFWriteln
81221>>>                
81221>>>                    // Using rectotal in WinPrint.
81221>>>                    Send Add_SubTotal 1 (Orderdtl.Extended_price)
81222>>>                
81222>>>                End_Procedure
81223>>>                
81223>>>                Procedure SubTotal1 // order total
81226>>>                    Number nAmount
81226>>>                
81226>>>                    Get SubTotal 1 to nAmount
81227>>>                    Send Add_SubTotal 2 nAmount // subtotal 2 is customer total
81228>>>                
81228>>>                    DFFont "Arial"
81229>>>                    DFFontSize 8
81230>>>                    DFBeginHeader DFSubTotal 2
81231>>>                        DFHeaderPos hdr_Left
81232>>>                        DFHeaderFrame hdr_Margins 0.01 rgb_dGrey rgb_Grey
81233>>>                        DfHeaderMargin hm_TopInner 0.02
81234>>>                        DfHeaderMargin hm_BottomInner 0.02
81235>>>                        DfHeaderMargin hm_BottomOuter 0.08
81236>>>                        DfHeaderMargin hm_TopOuter 0.04
81237>>>                
81237>>>                        DFWritePos   "Order Total:"  14.0  (FONT_BOLD+RGB_DBLUE+FONT_RIGHT)
81238>>>                        DFWritelnPos nAmount         16.0   (FONT_RIGHT) 2
81239>>>                    DFEndHeader
81241>>>                
81241>>>                End_Procedure
81242>>>                
81242>>>            End_Object    // oOrderDtl
81243>>>
81243>>>        End_Object    // oOrderHea
81244>>>        
81244>>>        Function Starting_Main_Report Returns Integer
81247>>>            Integer iRetVal bBreak
81247>>>            Get OnePagePerCust to bBreak
81248>>>            Set pbOnePagePerCust to bBreak
81249>>>            Send DFSetMetrics to WinPrintId "CM"
81250>>>            Send DFSetmargins to WinPrintId 1 1 1 1
81251>>>            Forward Get Starting_Main_Report to iRetVal
81253>>>            If iRetVal Function_Return iRetVal
81256>>>        End_Function
81257>>>        
81257>>>        Procedure Page_Top
81260>>>            DFFont "Arial"
81261>>>            DFFontSize 8
81262>>>            DFBeginHeader DFPageTop
81263>>>                DFHeaderFrame hdr_NoFrame
81264>>>                DFHeaderPos   hdr_Right
81265>>>        
81265>>>                DFWriteLn ("Page:" * "#pagecount#")
81266>>>            DFEndHeader
81268>>>        End_Procedure
81269>>>        
81269>>>        Procedure Page_Title
81272>>>            DFFont "Arial"
81273>>>            DFFontSize 14
81274>>>            DFBeginHeader DFPageTitle
81275>>>                DFHeaderFrame hdr_Margins 0.01 rgb_dGrey rgb_dGrey
81276>>>                DFHeaderPos hdr_Left
81277>>>                DFHeaderMargin hm_BottomOuter 0.08
81278>>>        
81278>>>                DFWriteLnPos "Orders by Customer Report" 0.10 (FONT_BOLD+RGB_WHITE)
81279>>>            DFEndHeader
81281>>>        End_Procedure
81282>>>        
81282>>>        Procedure SubHeader1
81285>>>            Integer iClr
81285>>>            DFFont "Arial" //  Use Arial
81286>>>            DFFontSize 8
81287>>>            Get DFGetDFColor of winprintId  242 242 242 to iClr // Move -218959360 to iClr  can be used instead
81288>>>        
81288>>>            DFBeginHeader DFSubHeader 1 // customer sub-header
81289>>>                DFHeaderFrame hdr_Margins 0.01 rgb_dGrey iClr
81290>>>                DFHeaderPos   hdr_Left
81291>>>                DFHeaderWrap hdr_Wrap
81292>>>                DFHeaderLineCheck 10 //Check that the header + 10 lines fits on the page, if not wrap
81293>>>        
81293>>>                DFWritePos    "Customer Number"         0.10  (FONT_BOLD+RGB_DBLUE)
81294>>>                DFWriteLnPos  Customer.Customer_number    4.0
81295>>>                DFWritePos    "Name"                    0.10  (FONT_BOLD+RGB_DBLUE)
81296>>>                DFWriteLnPos  Customer.Name               4.0   (FONT_DEFAULT)
81297>>>                DFWritePos    "Address"                 0.10  (FONT_BOLD+RGB_DBLUE)
81298>>>                DFWriteLnPos  Customer.Address            4.0   (FONT_DEFAULT)
81299>>>                DFWritePos    "City"                    0.10  (FONT_BOLD+RGB_DBLUE)
81300>>>                DFWriteLnPos  Customer.City               4.0   (FONT_DEFAULT)
81301>>>                DFWritePos    "State"                   0.10  (FONT_BOLD+RGB_DBLUE)
81302>>>                DFWriteLnPos  Customer.State              4.0   (FONT_DEFAULT)
81303>>>                DFWritePos    "Zip"                     0.10  (FONT_BOLD+RGB_DBLUE)
81304>>>                DFWriteLnPos  Customer.Zip                4.0   (FONT_DEFAULT)
81305>>>            DFEndHeader
81307>>>        End_Procedure
81308>>>        
81308>>>        Procedure SubTotal1 // customer total
81311>>>            Number nAmount
81311>>>            Integer iClr
81311>>>            Boolean bBreak
81311>>>        
81311>>>            Get SubTotal 2 to nAmount
81312>>>            Send Add_SubTotal 3 nAmount // subtotal 3 is total of all
81313>>>        
81313>>>            Get DFGetDFColor of winprintId  242 242 242 to iClr // Move -218959360 to iClr   can be used instead
81314>>>        
81314>>>            DFFont "Arial" //  Use Arial
81315>>>            DFFontSize 8
81316>>>            DFBeginHeader DFSubTotal 1
81317>>>                DFHeaderPos hdr_Left
81318>>>                DFHeaderFrame hdr_Margins 0.01 rgb_dGrey iClr
81319>>>                DFHeaderMargin hm_BottomOuter 0.16
81320>>>        
81320>>>                DFWritePos   "Customer Total:"  14.0 (FONT_BOLD+RGB_DBLUE+FONT_RIGHT)
81321>>>                DFWriteLnPos nAmount 16.0              (FONT_RIGHT+FONT_Bold) 2 0
81322>>>            DFEndHeader
81324>>>            Get pbOnePagePerCust to bBreak
81325>>>            If bBreak Begin
81327>>>                Send DFNew_Page
81328>>>            End
81328>>>>
81328>>>        End_Procedure
81329>>>        
81329>>>        Procedure Total // total of all customers
81332>>>            Number nTotal
81332>>>            Get SubTotal 3 to nTotal
81333>>>        
81333>>>            DFFont "Arial" //  Use Arial
81334>>>            DFFontSize 10
81335>>>        
81335>>>            DFBeginHeader DFTotal
81336>>>        
81336>>>                DFHeaderPos   hdr_Left
81337>>>                DFHeaderFrame hdr_Margins 0.01 rgb_dGrey rgb_Grey
81338>>>        
81338>>>                DFWritePos    "Grand Total:"  14.0        (FONT_BOLD+RGB_DBLUE+FONT_RIGHT)
81339>>>                DFWriteLnPos   nTotal         16.0      (FONT_BOLD+FONT_RIGHT) 2
81340>>>        
81340>>>            DFEndHeader                     //End and print header
81342>>>        
81342>>>        End_Procedure
81343>>>        
81343>>>        Procedure Page_Bottom
81346>>>            DateTime dtDT
81346>>>            Move (CurrentDateTime()) to dtDT
81347>>>        
81347>>>            DFFont "Arial"
81348>>>            DFFontSize 8
81349>>>            DFBeginHeader DFPageBottom
81350>>>                DFHeaderPos   hdr_Center
81351>>>                DFHeaderFrame hdr_Margins 0.01 rgb_dGrey
81352>>>                DFWriteLn   ("Report Printed on: " +String(dtDT)) (rgb_dBlue)
81353>>>            DFEndHeader
81355>>>        
81355>>>        End_Procedure
81356>>>
81356>>>    End_Object    // oOrders
81357>>>
81357>>>    // Procedures and functions used by the user interface
81357>>>    
81357>>>    //This function is called by the procedure StartReport
81357>>>    Function Print_to_Screen_State Returns Integer
81360>>>        Integer iRad
81360>>>        Get Current_Radio of oPrintTo To iRad
81361>>>        Function_Return (iRad=1)
81362>>>    End_Function
81363>>>    
81363>>>    // Use this procedure to do print setup
81363>>>    Procedure SetupReport
81366>>>        Boolean bSetupOk
81366>>>        Get DFPrintSetupDialog of oOrders to bSetupOk
81367>>>    End_Procedure
81368>>>    
81368>>>    // Use this procedure to start the report
81368>>>    Procedure StartReport
81371>>>        Boolean bToPrinter
81371>>>        String sVal
81371>>>        Get Print_to_Screen_State to bToPrinter
81372>>>        If bToPrinter Set OutPut_Device_Mode to PRINT_TO_PRINTER
81375>>>        Else          Set OutPut_Device_Mode to PRINT_TO_WINDOW
81377>>>    
81377>>>        Send Run_Report of oOrders
81378>>>    
81378>>>    End_Procedure
81379>>>    
81379>>>    Function OnePagePerCust returns boolean
81382>>>        boolean bBreak
81382>>>        Get checked_state of oOnePageCkBx to bBreak
81383>>>        Function_return bBreak
81384>>>    end_function
81385>>>    
81385>>>    // The Report
81385>>>    //    Object oOrders is a cWinReport2
81385>>>    //    //Object oOrders is a WinReport
81385>>>    
81385>>>    //        Property Boolean pbOnePagePerCust False
81385>>>    //        Set Report_Title to "Printing all Orders by Customer"
81385>>>    
81385>>>    //        //Main File for the report
81385>>>    //        Set Server to Customer_DD
81385>>>    //        //Breaks and Index for the report
81385>>>    //        Report_Breaks ORDERHEA.CUSTOMER_NUMBER
81385>>>    //        Set Ordering to 2
81385>>>    
81385>>>    //        Function Starting_Main_Report Returns Integer
81385>>>    //            Integer iRetVal bBreak
81385>>>    //            Get OnePagePerCust to bBreak
81385>>>    //            Set pbOnePagePerCust to bBreak
81385>>>    //            Send DFSetMetrics To WinPrintId "CM"
81385>>>    //            Send DFSetmargins To WinPrintId 1 1 1 1
81385>>>    //            Forward Get Starting_Main_Report To iRetVal
81385>>>    //            If iRetVal Function_return iRetVal
81385>>>    //        End_Function
81385>>>    
81385>>>    //        Procedure Page_Top
81385>>>    //            DFFont "Arial"
81385>>>    //            DFFontSize 8
81385>>>    //            DFBeginHeader DFPageTop
81385>>>    //                DFHeaderFrame HDR_NOFRAME
81385>>>    //                DFHeaderPos   HDR_RIGHT
81385>>>    
81385>>>    //                DFWriteLn ("Page:" * "#pagecount#")
81385>>>    //            DFEndHeader
81385>>>    //        End_Procedure
81385>>>    
81385>>>    //        Procedure Page_Title
81385>>>    //            DFFont "Arial"
81385>>>    //            DFFontSize 14
81385>>>    //            DFBeginHeader DFPageTitle
81385>>>    //                DFHeaderFrame HDR_MARGINs 0.01 RGB_DGREY RGB_DGREY
81385>>>    //                DFHEADERPOS HDR_LEFT
81385>>>    //                DfHeaderMargin hm_BottomOuter 0.08
81385>>>    
81385>>>    //                DFWritelnPos "Orders by Customer Report" 0.10 (FONT_BOLD+RGB_WHITE)
81385>>>    //            DFEndHeader
81385>>>    //        End_Procedure
81385>>>    
81385>>>    //        Procedure SubHeader1
81385>>>    //            integer iClr
81385>>>    //            DFFont "Arial" //  Use Arial
81385>>>    //            DFFontSize 8
81385>>>    //            //Get DFGetDFColor of winprintId  242 242 242 to iClr // doesn't work YET
81385>>>    //            Move -218959360 to iClr
81385>>>    
81385>>>    //            DFBeginHeader DFSubHeader 1 // customer sub-header
81385>>>    //                DFHeaderFrame hdr_Margins 0.01 rgb_dGrey iClr
81385>>>    //                DFHeaderPos   HDR_LEFT
81385>>>    //                DFHeaderWrap HDR_WRAP
81385>>>    //                DFHeaderLineCheck 10 //Check that the header + 10 lines fits on the page, if not wrap
81385>>>    
81385>>>    //                DFWritePos    "Customer Number"         0.10  (FONT_BOLD+RGB_DBLUE)
81385>>>    //                DFWritelnPos  Customer.CUSTOMER_NUMBER    4.0
81385>>>    //                DFWritePos    "Name"                    0.10  (FONT_BOLD+RGB_DBLUE)
81385>>>    //                DFWritelnPos  Customer.NAME               4.0   (FONT_DEFAULT)
81385>>>    //                DFWritePos    "Address"                 0.10  (FONT_BOLD+RGB_DBLUE)
81385>>>    //                DFWritelnPos  Customer.ADDRESS            4.0   (FONT_DEFAULT)
81385>>>    //                DFWritePos    "City"                    0.10  (FONT_BOLD+RGB_DBLUE)
81385>>>    //                DFWritelnPos  Customer.CITY               4.0   (FONT_DEFAULT)
81385>>>    //                DFWritePos    "State"                   0.10  (FONT_BOLD+RGB_DBLUE)
81385>>>    //                DFWritelnPos  Customer.STATE              4.0   (FONT_DEFAULT)
81385>>>    //                DFWritePos    "Zip"                     0.10  (FONT_BOLD+RGB_DBLUE)
81385>>>    //                DFWritelnPos  Customer.ZIP                4.0   (FONT_DEFAULT)
81385>>>    //            DFEndHeader
81385>>>    //        End_Procedure
81385>>>    
81385>>>    //        Object oOrderHea is a cWinReport2
81385>>>    //    //        Object oOrders is a WinReport
81385>>>    
81385>>>    //            Set Server to Orderhea_DD
81385>>>    //            Report_Breaks ORDERHEA.Order_number
81385>>>    //            set Ordering to 2
81385>>>    
81385>>>    //            Object oOrderDtl is a cWinReport2
81385>>>    //    //            Object oOrders is a WinReport
81385>>>    
81385>>>    //                Set Server to Orderdtl_DD
81385>>>    //                Report_Breaks ORDERHEA.Order_Number
81385>>>    //                Set Ordering to 1
81385>>>    
81385>>>    //                Procedure SubHeader1 // order sub-header
81385>>>    //                      Send Update_Status (Customer.Name - '/' - string(Orderhea.order_number))
81385>>>    
81385>>>    //                      DFFont "Arial"
81385>>>    //                      DFFontSize 8
81385>>>    
81385>>>    //                      DFBeginHeader DFSubHeader 2
81385>>>    //                        DFHeaderFrame hdr_NoFrame
81385>>>    //                        DFHeaderPos   HDR_LEFT
81385>>>    //                        DFHeaderWrap HDR_WRAP
81385>>>    //                        DfHeaderMargin hm_BottomOuter 0.04
81385>>>    //                        DFHeaderLineCheck 5            //Check that the header + 5 lines fits on the page, if not wrap
81385>>>    
81385>>>    //                        DFWritePos    "Order Number"            0.10  (FONT_BOLD+RGB_DBLUE)
81385>>>    //                        DFWritelnPos  Orderhea.ORDER_NUMBER       4.0   (FONT_DEFAULT)
81385>>>    //                        DFWritePos    "Order Date"              0.10  (FONT_BOLD+RGB_DBLUE)
81385>>>    //                        DFWritelnPos  Orderhea.ORDER_DATE         4.0   (FONT_DEFAULT)
81385>>>    //                        DFWritePos    "Terms"                   0.10  (FONT_BOLD+RGB_DBLUE)
81385>>>    //                        DFWritelnPos  Orderhea.TERMS              4.0   (FONT_DEFAULT)
81385>>>    //                        DFWritePos    "Ship Via"                0.10  (FONT_BOLD+RGB_DBLUE)
81385>>>    //                        DFWritelnPos  Orderhea.SHIP_VIA           4.0   (FONT_DEFAULT)
81385>>>    
81385>>>    //                        DfWriteRect DFGR_CURRLINE 0 0.34 DFGR_RB_MARGIN RGB_GREY 0.0 dfgr_noWrap RGB_GREY
81385>>>    //                        DFWritePos    "Item Id"                 0.1     (FONT_BOLD+RGB_DBLUE)            -1 1.36
81385>>>    //                        DFWritePos    "Description"             2.36    (FONT_BOLD+RGB_DBLUE)            -1 4.77
81385>>>    //                        DFWritePos    "Qty Ordered"             9.5     (FONT_BOLD+FONT_RIGHT+RGB_DBLUE) -1 1.87
81385>>>    //                        DFWritePos    "Price"                   11.22   (FONT_BOLD+FONT_RIGHT+RGB_DBLUE) -1 1.22
81385>>>    //                        DFWritePos    "Extended Price"          14.1    (FONT_BOLD+FONT_RIGHT+RGB_DBLUE) -1 2.38
81385>>>    //                        DFWriteln
81385>>>    
81385>>>    //                      DFEndHeader
81385>>>    
81385>>>    //                End_Procedure
81385>>>    
81385>>>    //                Procedure Body // order detail body
81385>>>    
81385>>>    //                    DFFont "Arial"
81385>>>    //                    DFFontSize 8
81385>>>    
81385>>>    //                    DFLineCheck 5
81385>>>    
81385>>>    //                    DFWritePos    Invt.ITEM_ID                0.1     (FONT_DEFAULT)            -1 2.24
81385>>>    //                    DFWritePos    Invt.DESCRIPTION            2.36    (FONT_DEFAULT)            -1 4.77
81385>>>    //                    DFWritePos    Orderdtl.QTY_ORDERED        9.5     (FONT_DEFAULT+FONT_RIGHT)  0 1.87
81385>>>    //                    DFWritePos    Orderdtl.PRICE              11.22   (FONT_DEFAULT+FONT_RIGHT)  2 1.22
81385>>>    //                    DFWritePos    Orderdtl.EXTENDED_PRICE     14.1    (FONT_DEFAULT+FONT_RIGHT)  2 2.38
81385>>>    //                    DFWriteln
81385>>>    
81385>>>    //                    // Using rectotal in WinPrint.
81385>>>    //                    Send Add_SubTotal 1 (Orderdtl.EXTENDED_PRICE)
81385>>>    
81385>>>    //                End_Procedure
81385>>>    
81385>>>    //                Procedure SubTotal1 // order total
81385>>>    //                    Number nAmount
81385>>>    
81385>>>    //                    Get SubTotal 1 to nAmount
81385>>>    //                    Send Add_SubTotal 2 nAmount // subtotal 2 is customer total
81385>>>    
81385>>>    //                    DFFont "Arial"
81385>>>    //                    DFFontSize 8
81385>>>    //                    DFBeginHeader DFSubTotal 2
81385>>>    //                        DFHEADERPOS HDR_LEFT
81385>>>    //                        DFHEADERFRAME HDR_Margins 0.01 rgb_dGrey rgb_Grey
81385>>>    //                        DfHeaderMargin hm_TopInner 0.02
81385>>>    //                        DfHeaderMargin hm_BottomInner 0.02
81385>>>    //                        DfHeaderMargin hm_BottomOuter 0.08
81385>>>    //                        DfHeaderMargin hm_TopOuter 0.04
81385>>>    
81385>>>    //                        DFWritePos   "Order Total:"  12.00  (FONT_BOLD+RGB_DBLUE+FONT_RIGHT)
81385>>>    //                        DFWritelnPos nAmount         14.1   (FONT_RIGHT) 2
81385>>>    //                    DFEndHeader
81385>>>    
81385>>>    //                End_Procedure
81385>>>    
81385>>>    //            end_object // orderdtl nested report
81385>>>    
81385>>>    //        end_object // orderhea nested report
81385>>>    
81385>>>    //        Procedure SubTotal1 // customer total
81385>>>    //            Number nAmount
81385>>>    //            integer iClr
81385>>>    //            Boolean bBreak
81385>>>    
81385>>>    //            Get SubTotal 2 to nAmount
81385>>>    //            Send Add_SubTotal 3 nAmount // subtotal 3 is total of all
81385>>>    
81385>>>    //            //Get DFGetDFColor of winprintId  242 242 242 to iClr // doesn't work YET
81385>>>    //            Move -218959360 to iClr
81385>>>    
81385>>>    //            DFFont "Arial" //  Use Arial
81385>>>    //            DFFontSize 8
81385>>>    //            DFBeginHeader DFSubTotal 1
81385>>>    //                DFHEADERPOS HDR_LEFT
81385>>>    //                DFHeaderFrame HDR_Margins 0.01 RGB_DGREY iClr
81385>>>    //                DfHeaderMargin hm_BottomOuter 0.16
81385>>>    
81385>>>    //                DFWritePos   "Customer Total:"  12.00 (FONT_BOLD+RGB_DBLUE+FONT_RIGHT)
81385>>>    //                DFWritelnPos nAmount 14.1              (FONT_RIGHT+FONT_Bold) 2 0
81385>>>    //            DFEndHeader
81385>>>    //            Get pbOnePagePerCust to bBreak
81385>>>    //            If bBreak Begin
81385>>>    //                send DFNew_Page
81385>>>    //            end
81385>>>    //        end_procedure
81385>>>    
81385>>>    //        Procedure Total // total of all customers
81385>>>    //            Number nTotal
81385>>>    //            Get SubTotal 3 to nTotal
81385>>>    
81385>>>    //            DFFont "Arial" //  Use Arial
81385>>>    //            DFFontSize 10
81385>>>    
81385>>>    //            DFBeginHeader DFTotal
81385>>>    
81385>>>    //                DFHeaderPos   HDR_LEFT
81385>>>    //                DFHeaderFrame HDR_MARGINs 0.01 RGB_DGREY RGB_GREY
81385>>>    
81385>>>    //                DFWritePos    "Grand Total:"  12        (FONT_BOLD+RGB_DBLUE+FONT_RIGHT)
81385>>>    //                DFWritelnPos   nTotal         14.1      (FONT_BOLD+FONT_RIGHT) 2
81385>>>    
81385>>>    //            DFEndHeader                     //End and print header
81385>>>    
81385>>>    //        End_Procedure
81385>>>    
81385>>>    //        Procedure Page_Bottom
81385>>>    //            DateTime dtDT
81385>>>    //            Move (CurrentDateTime()) to dtDT
81385>>>    
81385>>>    //            DFFont "Arial"
81385>>>    //            DFFontSize 8
81385>>>    //            DFBeginHeader DFPageBottom
81385>>>    //                DFHeaderPos   HDR_CENTER
81385>>>    //                DFHeaderFrame HDR_MARGINS 0.01 rgb_dGrey
81385>>>    //                DFWriteLn   ("Report Printed on: " +string(dtDT)) (rgb_dBlue)
81385>>>    //            DFEndHeader
81385>>>    
81385>>>    //        End_Procedure
81385>>>    
81385>>>    //    End_Object // customer main report
81385>>>    
81385>>>End_Object    // oOrdersByCustomerWP
81386>
81386>        On_Key Key_Ctrl+Key_1 Send Activate_oCustomerView
81387>        On_Key Key_Ctrl+Key_2 Send Activate_oInventoryView
81388>        On_Key Key_Ctrl+Key_3 Send Activate_oOrderEntryView
81389>        On_Key Key_Ctrl+Key_4 Send Activate_oSalesPersonView
81390>        On_Key Key_Ctrl+Key_5 Send Activate_oVendorView
81391>        On_Key Key_Ctrl+Key_6 Send Activate_oCustomerListWP
81392>        On_Key Key_Ctrl+Key_7 Send Activate_oItemsPerOrderWP
81393>        On_Key Key_Ctrl+Key_8 Send Activate_oOrdersByCustomerWP
81394>        On_Key Key_Ctrl+Key_9 Send Activate_oOrdersWP
81395>
81395>        Use StdAbout.pkg
Including file: StdAbout.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\StdAbout.pkg)
81395>>>//************************************************************************
81395>>>// Confidential Trade Secret.
81395>>>// Copyright (c) 1997 Data Access Corporation, Miami Florida
81395>>>// as an unpublished work.  All rights reserved.
81395>>>// DataFlex is a registered trademark of Data Access Corporation.
81395>>>//
81395>>>//************************************************************************
81395>>>//************************************************************************
81395>>>//
81395>>>// $File name  : StdAbout.pkg
81395>>>// $File title : Standard about object package for VDF
81395>>>// Notice      :
81395>>>// $Author(s)  : John Tuohy
81395>>>//
81395>>>// $Rev History
81395>>>//
81395>>>// JT 06/27/97   File created
81395>>>//************************************************************************
81395>>>
81395>>>// This provides a quick and simple way to create an about package for a program.
81395>>>// You need to create a message inside you client area called Activate_About.
81395>>>// Within this message you should send the message DoAbout passing needed
81395>>>// string information.
81395>>>//
81395>>>//       Procedure Activate_About
81395>>>//           Send DoAbout sTitle sVersion sCopyright sAuthor sBitmap
81395>>>//       End_Procedure
81395>>>//    where: sTitle =     Name of application. If none provided, uses caption
81395>>>//                        bar title
81395>>>//           sVersion   = Version Line. If none provided, will be blank
81395>>>//           sCopyRight = Copyright Line. If none provided, will be blank
81395>>>//           sAuthor    = Author name, blank if none provided
81395>>>//           sBitMap    = Bitmap logo. If none provided, standard VDF bitmap
81395>>>//                        is used.
81395>>>// It is expected that you will place this in your own object package. For
81395>>>// example an order about package may look like this:
81395>>>//
81395>>>//   // OrderAbout.pkg
81395>>>//   Use StdAbout.pkg
81395>>>//   Procedure Activate_About
81395>>>//      String sTitle sCopyright sVersion sAuthor
81395>>>//      Move "My Order Entry System" to sTitle
81395>>>//      Move "Version 2.1" to sVersion
81395>>>//      Move "Copyright 1997, Super Software Inc." to sCopyright
81395>>>//      Move "John Smith"  to sAuthor
81395>>>//      Send DoAbout sTitle sVersion sCopyright sAuthor ""
81395>>>//   end_procedure
81395>>>//   // end of file.
81395>>>
81395>>>Use DfAbout.pkg
Including file: Dfabout.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\Dfabout.pkg)
81395>>>>>//************************************************************************
81395>>>>>// Confidential Trade Secret.
81395>>>>>// Copyright (c) 1997 Data Access Corporation, Miami Florida
81395>>>>>// as an unpublished work.  All rights reserved.
81395>>>>>// DataFlex Is A registered trademark Of Data Access Corporation.
81395>>>>>//
81395>>>>>//************************************************************************
81395>>>>>//************************************************************************
81395>>>>>//
81395>>>>>// $File name  : DfAbout.pkg
81395>>>>>// $File title : About class support
81395>>>>>// Notice      :
81395>>>>>// $Author(s)  : Vincent Oorsprong, Ken Ross
81395>>>>>//
81395>>>>>// $Rev History
81395>>>>>//
81395>>>>>// VOO 02/22/2012 Replaced obsolete code, improved Network_User_Name by asking
81395>>>>>//                Windows for the size first. 
81395>>>>>// VOO 07/25/2003 Removed OnResize procedure for sysinfo dialog. Replaced logic
81395>>>>>//                with anchor technique. Removed unnessary property in the
81395>>>>>//                sysinfo dialog. Changed the size Of the about & sysinfo dialog
81395>>>>>//                object To better look in Windows XP. Repositioned the close
81395>>>>>//                button in the sysinfo dialog To line up with the display area
81395>>>>>//                Replaced obsolete code and techniques. Removed dead code.
81395>>>>>// JJT 10/23/2001 removed all ghoworkspace support. Uses app object or nothing
81395>>>>>// SWB 07/19/01   Added support Of the Application object in preference to
81395>>>>>//                the global Workspace object, if it is present
81395>>>>>// JJT 11/05/98   Added version information
81395>>>>>// VOO 29/10/98   Replaced the GetFreeSystemResources for the Win32 variant
81395>>>>>// JJT 7/31/97    Registered Enumerate Workspace so dfabout can exist without
81395>>>>>//                workspace package.
81395>>>>>// JJT 6/27/97    Turned the sysinfo objects into classes so the AboutDialog
81395>>>>>//                class can create this object.
81395>>>>>//                Cleaned up the interface (used correct classes and messages)
81395>>>>>//                Added workspace reporting support To sys-info.
81395>>>>>//                Turned off wrapping in the sys-info editor.
81395>>>>>// KR  ??/??/96   File created
81395>>>>>//************************************************************************
81395>>>>>Use LanguageText.pkg
81395>>>>>Use Windows.pkg
81395>>>>>Use DFbitmap.pkg
81395>>>>>Use GlobalFunctionsProcedures.pkg
81395>>>>>Use cTextEdit.pkg
81395>>>>>
81395>>>>>Use cli.pkg
Including file: cli.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cli.pkg)
81395>>>>>>>//*****************************************************************************
81395>>>>>>>//*** CLI.PKG                                                               ***
81395>>>>>>>//***                                                                       ***
81395>>>>>>>//*** Author: Ben Weijers                                                   ***
81395>>>>>>>//***         Data Access Nederland                                         ***
81395>>>>>>>//***         10 September 1998                                             ***
81395>>>>>>>//***                                                                       ***
81395>>>>>>>//*** Purpose:                                                              ***
81395>>>>>>>//***   CLI specific functionality. There are several connectivity kits     ***
81395>>>>>>>//***   based on  SQL/92 CLI. Those are:                                    ***
81395>>>>>>>//***    - ODBC_DRV  The Data Access CK for ODBC                            ***
81395>>>>>>>//***    - DB2_DRV   The Data Access CK for DB2                             ***
81395>>>>>>>//***    - MSSQLDRV  The Data Access CK for Microsoft SQL Server            ***
81395>>>>>>>//***                                                                       ***
81395>>>>>>>//***   This package defines the common functionality for all CLI based     ***
81395>>>>>>>//***   drivers.                                                            ***
81395>>>>>>>//***                                                                       ***
81395>>>>>>>//***   Updated:  May 23rd 2008 (Current CK build: 5.0.0.53 )               ***
81395>>>>>>>//***             Added NULLABLE and DEFAULT attributes for DATETIME type   ***
81395>>>>>>>//***   Updated:  Apr  6th 2009 (Current CK build: 5.0.0.61 )               ***
81395>>>>>>>//***             Added DF_DRIVER_MATCH_CLIENT_SERVER_VERSION attribute     ***
81395>>>>>>>//***                   DF_DRIVER_SQLSERVER_CLIENT_VERSION    attribute     ***
81395>>>>>>>//***   Updated:  Mar 30th 2012 (Current CK build: 5.1.0.93 )               ***
81395>>>>>>>//***             Added SQLSERVER2012CLIENT return value for                ***
81395>>>>>>>//***             DF_DRIVER_SQLSERVER_CLIENT_VERSION attribute              ***
81395>>>>>>>//***   Updated:  June 4th 2012 (Current CK build: 5.1.0.96)                ***
81395>>>>>>>//***             Moved SQL Server client constants from cli.pkg to         ***
81395>>>>>>>//***             mssqldrv.pkg                                              ***
81395>>>>>>>//***   Updated:  april 23, 2013 (Current CK build: 6.0.0.4)                ***
81395>>>>>>>//***             Added type mappings attributes                            ***
81395>>>>>>>//***   Updated:  october 11, 2013 (Current CK build: 6.0.0.18)             ***
81395>>>>>>>//***             Added DF_FILE_SQL_FILTER_EQ attribute                     ***
81395>>>>>>>//*****************************************************************************
81395>>>>>>>
81395>>>>>>>//*** We are not using ifndef below because that is not supported in Character Mode
81395>>>>>>>//*** Driver attributes
81395>>>>>>>
81395>>>>>>>
81395>>>>>>>
81395>>>>>>>
81395>>>>>>>
81395>>>>>>>
81395>>>>>>>
81395>>>>>>>
81395>>>>>>>
81395>>>>>>>//------------------------------------------------------------
81395>>>>>>>
81395>>>>>>>
81395>>>>>>>//-------------------------------------
81395>>>>>>>
81395>>>>>>>
81395>>>>>>>
81395>>>>>>>//*** Replacement for logical column number that indicates all columns
81395>>>>>>>
81395>>>>>>>//*** Possible DF_FILE_GENERATE_RECORD_ID_METHOD values
81395>>>>>>>
81395>>>>>>>//*** Possible DF_FIELD_READ_ONLY values
81395>>>>>>>
81395>>>>>>>
81395>>>>>>>//*** Possible DF_DRIVER_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA values
81395>>>>>>>// #Replace MAP_DF_TO_SQL_TYPE_CK5        1       
81395>>>>>>>// #Replace MAP_DF_TO_SQL_TYPE_CK6        2   
81395>>>>>>>
81395>>>>>>>
81395>>>>>>>// Moved to Mssqldrv.pkg
81395>>>>>>>//*** Possible DF_DRIVER_SQLSERVER_CLIENT_VERSION values
81395>>>>>>>//#REPLACE SQLSERVERUNKNOWNCLIENT  0
81395>>>>>>>//#REPLACE SQLSERVER2000CLIENT     8          //   "SQL Server"
81395>>>>>>>//#REPLACE SQLSERVER2005CLIENT     9          //   "SQL Native Client"
81395>>>>>>>//#REPLACE SQLSERVER2008CLIENT    10          //   "SQL Server Native Client 10.0"
81395>>>>>>>//#Replace SQLSERVER2012CLIENT    11          //   "SQL Server Native Client 11.0"
81395>>>>>>>
81395>>>>>>>//*** Possible SQL Column type values
81395>>>>>>>Define SQL_UNKNOWN_TYPE   For    0
81395>>>>>>>Define SQL_CHAR           For    1
81395>>>>>>>Define SQL_NUMERIC        For    2
81395>>>>>>>Define SQL_DECIMAL        For    3
81395>>>>>>>Define SQL_INTEGER        For    4
81395>>>>>>>Define SQL_SMALLINT       For    5
81395>>>>>>>Define SQL_FLOAT          For    6
81395>>>>>>>Define SQL_REAL           For    7
81395>>>>>>>Define SQL_DOUBLE         For    8
81395>>>>>>>Define SQL_DATETIME       For    9
81395>>>>>>>Define SQL_VARCHAR        For   12
81395>>>>>>>Define SQL_TYPE_DATE      For   91
81395>>>>>>>Define SQL_TYPE_TIME      For   92
81395>>>>>>>Define SQL_TYPE_TIMESTAMP for   93
81395>>>>>>>// Moved to mssqldrv.pkg
81395>>>>>>>//Define SQL_TYPE_TIMESTAMP2 for   (-200) //SQL server datetime2 type */
81395>>>>>>>
81395>>>>>>>
81395>>>>>>>Define SQL_DATE           For    9
81395>>>>>>>Define SQL_INTERVAL       For   10
81395>>>>>>>Define SQL_TIME           For   10
81395>>>>>>>Define SQL_TIMESTAMP      For   11
81395>>>>>>>Define SQL_LONGVARCHAR    For  (-1)
81395>>>>>>>Define SQL_BINARY         For  (-2)
81395>>>>>>>Define SQL_VARBINARY      For  (-3)
81395>>>>>>>Define SQL_LONGVARBINARY  For  (-4)
81395>>>>>>>Define SQL_BIGINT         For  (-5)
81395>>>>>>>Define SQL_TINYINT        For  (-6)
81395>>>>>>>Define SQL_BIT            For  (-7)
81395>>>>>>>Define SQL_WCHAR          For  (-8)
81395>>>>>>>Define SQL_WVARCHAR       For  (-9)
81395>>>>>>>Define SQL_WLONGVARCHAR   For (-10)
81395>>>>>>>Define SQL_GUID           For (-11)
81395>>>>>>>
81395>>>>>>>//*** Driver level attributes
81395>>>>>>>
81395>>>>>>>
81395>>>>>>>//*** Error number constants
81395>>>>>>>
81395>>>>>>>
81395>>>>>>>//*** Call driver function identifiers
81395>>>>>>>
81395>>>>>>>
81395>>>>>>>//*** Init data source types
81395>>>>>>>
81395>>>>>>>
81395>>>>>>>//*** Dummy strings used in the commands
81395>>>>>>>    String  CLI$StrDummy 255
81395>>>>>>>    Integer CLI$IntDummy
81395>>>>>>>
81395>>>>>>>
81395>>>>>>>//*****************************************************************************
81395>>>>>>>//*** CLI_SetConstraint <FileNum> <NewState>                                ***
81395>>>>>>>//***                                                                       ***
81395>>>>>>>//***   Setup a constraint for a file.                                      ***
81395>>>>>>>//*****************************************************************************
81395>>>>>>>
81395>>>>>>>
81395>>>>>>>
81395>>>>>>>
81395>>>>>>>//*****************************************************************************
81395>>>>>>>//*** CLI_Set_Driver_Atrtribute / CLI_Get_Driver_Attribute                  ***
81395>>>>>>>//***                                                                       ***
81395>>>>>>>//*** Set or get an attribute at driver level. These attributes, when set,  ***
81395>>>>>>>//*** will be set for the remainder of the session or until set again. To   ***
81395>>>>>>>//*** permanently set driver level attributes change the driver             ***
81395>>>>>>>//*** configuration file.                                                   ***
81395>>>>>>>//*****************************************************************************
81395>>>>>>>
81395>>>>>>>
81395>>>>>>>
81395>>>>>>>
81395>>>>>>>
81395>>>>>>>
81395>>>>>>>
81395>>>>>>>//*****************************************************************************
81395>>>>>>>//*** Class  : cCLIHandler                                                  ***
81395>>>>>>>//*** Purpose: An instance of this class can be used as a broker object to  ***
81395>>>>>>>//***          call several CLI releated methods.                           ***
81395>>>>>>>//*****************************************************************************
81395>>>>>>>
81395>>>>>>>Class cCLIHandler Is An Array
81396>>>>>>>
81396>>>>>>>    Procedure Construct_Object Integer iImage
81398>>>>>>>        Forward Send Construct_object iImage
81400>>>>>>>
81400>>>>>>>        Property String  psDriverID       Public ""
81401>>>>>>>    End_Procedure // Construct_Object
81402>>>>>>>
81402>>>>>>>
81402>>>>>>>
81402>>>>>>>    //***
81402>>>>>>>    //*** Fucntion: CKRevsion
81402>>>>>>>    //*** Purpose : The revsion of a CLI Connectivity Kit
81402>>>>>>>    //***
81402>>>>>>>
81402>>>>>>>    Function CKRevision Returns String
81404>>>>>>>        Local String  sDriverID
81404>>>>>>>        Local String  sRevision
81404>>>>>>>        Local String  sVoid
81404>>>>>>>        Local Integer iRetval
81404>>>>>>>
81404>>>>>>>        Get psDriverID To sDriverID
81405>>>>>>>        If (sDRiverID <> "") Begin
81407>>>>>>>            Move (Repeat(" ", 255)) To sRevision
81408>>>>>>>            Call_Driver 0 sDRiverID Function CLI_CKREVISION Callback 0 Passing sRevision sVoid 0 Result iRetval
81413>>>>>>>        End
81413>>>>>>>>
81413>>>>>>>
81413>>>>>>>        Function_Return sRevision
81414>>>>>>>    End_Function // CKRevision
81415>>>>>>>
81415>>>>>>>
81415>>>>>>>
81415>>>>>>>    //***
81415>>>>>>>    //*** Function: ExtractPartFromRevision
81415>>>>>>>    //*** Purpose : Extarct the Nth part of a a.b.c.d revsion string.
81415>>>>>>>    //***
81415>>>>>>>    //*** Returns : The part version number or -1 if there is no such part number.
81415>>>>>>>    //***
81415>>>>>>>
81415>>>>>>>    Function ExtractPartFromRevision Integer iPartNum String sRevision Returns Integer
81417>>>>>>>        Local Integer iPartRev
81417>>>>>>>        Local Integer iCurrentPart
81417>>>>>>>        Local Integer iSeparatorPos
81417>>>>>>>
81417>>>>>>>        If (iPartNum > 4) ;            Function_Return -1
81420>>>>>>>
81420>>>>>>>        Move 0 To iCurrentPart
81421>>>>>>>        Repeat
81421>>>>>>>>
81421>>>>>>>            Move (Pos(".", sRevision)) To iSeparatorPos
81422>>>>>>>            If (iSeparatorPos > 0) Begin
81424>>>>>>>                Move (Left(sRevision, iSeparatorPos - 1)) To iPartRev
81425>>>>>>>                Move (Right(sRevision, Length(sRevision) - iSeparatorPos)) To sRevision
81426>>>>>>>                Increment iCurrentPart
81427>>>>>>>            End
81427>>>>>>>>
81427>>>>>>>            Else If (sRevision <> "") Begin
81430>>>>>>>                Move sRevision To iPartRev
81431>>>>>>>                Move "" To sRevision
81432>>>>>>>                Increment iCurrentPart
81433>>>>>>>            End
81433>>>>>>>>
81433>>>>>>>            Else ;                Move -1 To iPartRev
81435>>>>>>>        Until (iCurrentPart >= iPartNum Or iPartRev = -1)
81437>>>>>>>
81437>>>>>>>        Function_Return iPartRev
81438>>>>>>>    End_Function // EcxtractPartFromRevision
81439>>>>>>>
81439>>>>>>>
81439>>>>>>>
81439>>>>>>>    //***
81439>>>>>>>    //*** Function: CKMajorRevision
81439>>>>>>>    //*** Purpose : Returns the major revision of the CK
81439>>>>>>>    //***
81439>>>>>>>
81439>>>>>>>    Function CKMajorRevision Returns Integer
81441>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 1, CKRevision(Current_Object)))
81442>>>>>>>    End_Function // CKMajorRevision
81443>>>>>>>
81443>>>>>>>
81443>>>>>>>
81443>>>>>>>    //***
81443>>>>>>>    //*** Function: CKMinorRevision
81443>>>>>>>    //*** Purpose : Returns the minor revision of the CK
81443>>>>>>>    //***
81443>>>>>>>
81443>>>>>>>    Function CKMinorRevision Returns Integer
81445>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 2, CKRevision(Current_Object)))
81446>>>>>>>    End_Function // CKMinorRevision
81447>>>>>>>
81447>>>>>>>
81447>>>>>>>
81447>>>>>>>    //***
81447>>>>>>>    //*** Function: CKReleaseRevision
81447>>>>>>>    //*** Purpose : Returns the release revision of the CK
81447>>>>>>>    //***
81447>>>>>>>
81447>>>>>>>    Function CKReleaseRevision Returns Integer
81449>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 3, CKRevision(Current_Object)))
81450>>>>>>>    End_Function // CKReleaseRevision
81451>>>>>>>
81451>>>>>>>
81451>>>>>>>
81451>>>>>>>    //***
81451>>>>>>>    //*** Function: CKBuildRevision
81451>>>>>>>    //*** Purpose : Returns the major revision of the CK
81451>>>>>>>    //***
81451>>>>>>>
81451>>>>>>>    Function CKBuildRevision Returns Integer
81453>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 4, CKRevision(Current_Object)))
81454>>>>>>>    End_Function // CKBuildRevision
81455>>>>>>>
81455>>>>>>>
81455>>>>>>>
81455>>>>>>>    //***
81455>>>>>>>    //*** Function: IsMinimalRevision
81455>>>>>>>    //*** Purpose : Determines if the CK conforms to a passed minimal revsion.
81455>>>>>>>    //***
81455>>>>>>>
81455>>>>>>>    Function IsMinimalRevision Integer iMajor Integer iMinor Integer iRelease Integer iBuild Returns Integer
81457>>>>>>>        If (iMajor < CKMajorRevision(Current_object)) ;            Function_return (TRUE)
81460>>>>>>>        Else If (iMajor = CKMajorRevision(Current_object)) Begin
81463>>>>>>>            If (iMinor < CKMinorRevision(Current_object)) ;                Function_return (TRUE)
81466>>>>>>>            Else If (iMinor = CKMinorRevision(Current_object)) Begin
81469>>>>>>>                If (iRelease < CKReleaseRevision(Current_object)) ;                    Function_return (TRUE)
81472>>>>>>>                Else If (iRelease = CKReleaseRevision(Current_object) And iBuild <= CKBuildRevision(Current_object)) ;                    Function_return (TRUE)
81476>>>>>>>            End
81476>>>>>>>>
81476>>>>>>>        End
81476>>>>>>>>
81476>>>>>>>
81476>>>>>>>        Function_Return (FALSE)
81477>>>>>>>    End_Function // IsMinimalRevision
81478>>>>>>>
81478>>>>>>>
81478>>>>>>>
81478>>>>>>>    //***
81478>>>>>>>    //*** Function: RegistrationName
81478>>>>>>>    //*** Purpose : Returns the Connectiivty Kit registration name.
81478>>>>>>>    //***
81478>>>>>>>
81478>>>>>>>    Function RegistrationName Returns String
81480>>>>>>>        Local String  sRegistration
81480>>>>>>>        Local String  sDRiverId
81480>>>>>>>        Local String  sVoid
81480>>>>>>>        Local Integer iRetval
81480>>>>>>>
81480>>>>>>>        Get psDriverID To sDriverID
81481>>>>>>>        If (sDRiverID <> "") Begin
81483>>>>>>>            Move (Repeat(" ", 255)) To sRegistration
81484>>>>>>>            Call_Driver 0 sDRiverID Function CLI_GETREGNAME Callback 0 Passing sRegistration sVoid 0 Result iRetval
81489>>>>>>>        End
81489>>>>>>>>
81489>>>>>>>
81489>>>>>>>        Function_Return sRegistration
81490>>>>>>>    End_Function // RegistrationName
81491>>>>>>>
81491>>>>>>>
81491>>>>>>>
81491>>>>>>>    //***
81491>>>>>>>    //*** Function: SerialNumber
81491>>>>>>>    //*** Purpose : Returns the Connectiivty Kit serial number.
81491>>>>>>>    //***
81491>>>>>>>
81491>>>>>>>    Function SerialNumber Returns Integer
81493>>>>>>>        Local String  sDRiverId
81493>>>>>>>        Local String  sVoid
81493>>>>>>>        Local Integer iRetval
81493>>>>>>>
81493>>>>>>>        Get psDriverID To sDriverID
81494>>>>>>>        If (sDRiverID <> "") Begin
81496>>>>>>>            Call_Driver 0 sDRiverID Function CLI_GETSERIALNUM Callback 0 Passing sVoid sVoid 0 Result iRetval
81501>>>>>>>        End
81501>>>>>>>>
81501>>>>>>>
81501>>>>>>>        Function_Return iRetval
81502>>>>>>>    End_Function // SerialNumber
81503>>>>>>>
81503>>>>>>>
81503>>>>>>>
81503>>>>>>>    //***
81503>>>>>>>    //*** Function: MaxUsers
81503>>>>>>>    //*** Purpose : Returns the Connectiivty Kit maximum number of users.
81503>>>>>>>    //***
81503>>>>>>>
81503>>>>>>>    Function MaxUsers Returns Integer
81505>>>>>>>        Local String  sDRiverId
81505>>>>>>>        Local String  sVoid
81505>>>>>>>        Local Integer iRetval
81505>>>>>>>
81505>>>>>>>        Get psDriverID To sDriverID
81506>>>>>>>        If (sDRiverID <> "") Begin
81508>>>>>>>            Call_Driver 0 sDRiverID Function CLI_GETMAXUSERS Callback 0 Passing sVoid sVoid 0 Result iRetval
81513>>>>>>>        End
81513>>>>>>>>
81513>>>>>>>
81513>>>>>>>        Function_Return iRetval
81514>>>>>>>    End_Function // MaxUsers
81515>>>>>>>
81515>>>>>>>
81515>>>>>>>
81515>>>>>>>    //***
81515>>>>>>>    //*** Procedure: DumpStatus
81515>>>>>>>    //*** Purpose  : Dump the current status of the drver in the passed disk file.
81515>>>>>>>    //***
81515>>>>>>>
81515>>>>>>>    Procedure DumpStatus String sFileName
81517>>>>>>>        Local String  sVoid
81517>>>>>>>        Local String  sDriverID
81517>>>>>>>        Local Integer iVoid
81517>>>>>>>
81517>>>>>>>        Get psDriverID To sDriverID
81518>>>>>>>        If (sDriverID <> "") ;            Call_driver 0 sDriverID Function CLI_DUMPSTATUS Callback 0 Passing sFileName sVoid iVoid Result iVoid
81525>>>>>>>    End_Procedure // DumpStatus
81526>>>>>>>
81526>>>>>>>
81526>>>>>>>
81526>>>>>>>    //***
81526>>>>>>>    //*** Procedure: ReadConfiguration
81526>>>>>>>    //*** Purpose  : Reset all driver level configurable attributes to the
81526>>>>>>>    //***            default value and then reread the configuration.
81526>>>>>>>    //***
81526>>>>>>>
81526>>>>>>>    Procedure ReadConfiguration
81528>>>>>>>        Local String  sVoid
81528>>>>>>>        Local String  sDriverID
81528>>>>>>>        Local Integer iVoid
81528>>>>>>>
81528>>>>>>>        Get psDriverID To sDriverID
81529>>>>>>>        If (sDriverID <> "") ;            Call_driver 0 sDriverID Function CLI_READCONFIGURATION Callback 0 Passing sVoid sVoid iVoid Result iVoid
81536>>>>>>>    End_Procedure // ReadConfiguration
81537>>>>>>>
81537>>>>>>>
81537>>>>>>>
81537>>>>>>>    //***
81537>>>>>>>    //*** Function: TextToRIMValue
81537>>>>>>>    //*** Purpose : Convert a text to the corresponding
81537>>>>>>>    //***           Generate_Record_ID_Method attribute value
81537>>>>>>>    //***
81537>>>>>>>
81537>>>>>>>    Function TextToRIMValue String sText Returns Integer
81539>>>>>>>        If (sText = "None") ;            Function_return RIM_NONE
81542>>>>>>>        Else If (sText = "Identity Column") ;            Function_return RIM_IDENTITY_COLUMN
81546>>>>>>>        Else If (sText = "Dispenser Table") ;            Function_return RIM_DISPENSER_TABLE
81550>>>>>>>        Else If (sText = "External") ;            Function_return RIM_EXTERNAL
81554>>>>>>>    End_Function // TextToRIMValue
81555>>>>>>>
81555>>>>>>>
81555>>>>>>>
81555>>>>>>>    //***
81555>>>>>>>    //*** Function: RIMValueTotext
81555>>>>>>>    //*** Purpose : Convert a Generate_Record_ID_Method attribute value to the
81555>>>>>>>    //***           corresponding text.
81555>>>>>>>    //***
81555>>>>>>>
81555>>>>>>>    Function RIMValueToText Integer iAttrValue Returns String
81557>>>>>>>        If (iAttrValue = RIM_NONE) ;            Function_return "None"
81560>>>>>>>        Else If (iAttrValue = RIM_IDENTITY_COLUMN) ;            Function_return "Identity Column"
81564>>>>>>>        Else If (iAttrValue = RIM_DISPENSER_TABLE) ;            Function_return "Dispenser Table"
81568>>>>>>>        Else If (iAttrValue = RIM_EXTERNAL) ;            Function_return "External"
81572>>>>>>>    End_Function // RIMValueToText
81573>>>>>>>
81573>>>>>>>
81573>>>>>>>
81573>>>>>>>    //***
81573>>>>>>>    //*** Function: TextToROValue
81573>>>>>>>    //*** Purpose : Convert a text to the corresponding
81573>>>>>>>    //***           Generate_Record_ID_Method attribute value
81573>>>>>>>    //***
81573>>>>>>>
81573>>>>>>>    Function TextToROValue String sText Returns Integer
81575>>>>>>>        If (sText = "No") ;            Function_return RO_NO
81578>>>>>>>        Else If (sText = "Ignore Change") ;            Function_return RO_IGNORECHANGE
81582>>>>>>>        Else If (sText = "Accept Change") ;            Function_return RO_ACCEPTCHANGE
81586>>>>>>>        Else If (sText = "Error On Change") ;            Function_return RO_ERRORONCHANGE
81590>>>>>>>    End_Function // TextToRIMValue
81591>>>>>>>
81591>>>>>>>
81591>>>>>>>
81591>>>>>>>    //***
81591>>>>>>>    //*** Function: ROValueTotext
81591>>>>>>>    //*** Purpose : Convert a Generate_Record_ID_Method attribute value to the
81591>>>>>>>    //***           corresponding text.
81591>>>>>>>    //***
81591>>>>>>>
81591>>>>>>>    Function ROValueToText Integer iAttrValue Returns String
81593>>>>>>>        If (iAttrValue = RO_NO) ;            Function_return "No"
81596>>>>>>>        Else If (iAttrValue = RO_IGNORECHANGE) ;            Function_return "Ignore Change"
81600>>>>>>>        Else If (iAttrValue = RO_ACCEPTCHANGE) ;            Function_return "Accept Change"
81604>>>>>>>        Else If (iAttrValue = RO_ERRORONCHANGE) ;            Function_return "Error On Change"
81608>>>>>>>    End_Function // RIMValueToText
81609>>>>>>>
81609>>>>>>>
81609>>>>>>>
81609>>>>>>>    //***
81609>>>>>>>    //*** Function: LastDriverError
81609>>>>>>>    //*** Purpose : Return the text f the last error geneated by the driver.
81609>>>>>>>    //***
81609>>>>>>>
81609>>>>>>>    Function LastDriverError Returns String
81611>>>>>>>        Local String  sDriverID
81611>>>>>>>        Local String  sLastError
81611>>>>>>>        Local String  sLastErrorLength
81611>>>>>>>        Local Integer iLastErrorLength
81611>>>>>>>        Local Integer iVoid
81611>>>>>>>
81611>>>>>>>        //*** Initialize
81611>>>>>>>        Move "" To sLastError
81612>>>>>>>
81612>>>>>>>        Get psDriverID To sDriverID
81613>>>>>>>        If (sDriverID <> "") Begin
81615>>>>>>>            //*** Get the text of the last error
81615>>>>>>>            Move (Repeat(Character(" "), 14)) To sLastErrorlength
81616>>>>>>>            Call_driver 0 sDriverID Function CLI_GETDRIVERATTRIBUTE Callback 0 Passing sLastErrorLength iVoid DRVR_LASTERRORTEXTLENGTH Result iVoid
81621>>>>>>>            Move (Left(sLastErrorLength, Pos(Character(0), sLastErrorLength) - 1)) To iLastErrorLength
81622>>>>>>>
81622>>>>>>>            If (iLastErrorLength > 0) Begin
81624>>>>>>>                Move (Repeat(Character(" "), iLastErrorLength + 1)) To sLastError
81625>>>>>>>                Call_driver 0 sDriverID Function CLI_GETDRIVERATTRIBUTE Callback 0 Passing sLastError iVoid DRVR_LASTERRORTEXT Result iVoid
81630>>>>>>>                Move (Left(sLastError, Pos(Character(0), sLastError) - 1)) To sLastError
81631>>>>>>>            End
81631>>>>>>>>
81631>>>>>>>        End
81631>>>>>>>>
81631>>>>>>>
81631>>>>>>>        Function_Return sLastError
81632>>>>>>>    End_Function // LastDriverError
81633>>>>>>>
81633>>>>>>>
81633>>>>>>>
81633>>>>>>>    //***
81633>>>>>>>    //*** Function: EnumerateTables
81633>>>>>>>    //*** Purpose : Enumerate the tables in a database
81633>>>>>>>    //***
81633>>>>>>>
81633>>>>>>>    Function EnumerateTables String sLogin Returns Integer
81635>>>>>>>        Local String  sDriver
81635>>>>>>>        Local String  sVoid
81635>>>>>>>        Local Integer iNumTables
81635>>>>>>>        Local Integer iVoid
81635>>>>>>>
81635>>>>>>>        Get psDriverID To sDriver
81636>>>>>>>        If (sDriver <> "") ;            Call_driver 0 sDriver Function CLI_ENUMERATE_TABLES Callback 0 Passing sLogin sVoid iVoid Result iNumTables
81643>>>>>>>
81643>>>>>>>        Function_Return iNumTables
81644>>>>>>>    End_Function // EnumerateTables
81645>>>>>>>
81645>>>>>>>
81645>>>>>>>
81645>>>>>>>    //***
81645>>>>>>>    //*** Function: TableName
81645>>>>>>>    //*** Purpose : Returns the name of the table enumerated at the given position
81645>>>>>>>    //***
81645>>>>>>>
81645>>>>>>>    Function TableName Integer iIndex Returns String
81647>>>>>>>        Local String  sDriver
81647>>>>>>>        Local String  sTableName
81647>>>>>>>        Local String  sVoid
81647>>>>>>>        Local Integer iVoid
81647>>>>>>>
81647>>>>>>>        Get psDriverID To sDriver
81648>>>>>>>        If (sDriver <> "") Begin
81650>>>>>>>            Move (Repeat(" ", 255)) To sTableName
81651>>>>>>>            Call_driver 0 sDriver Function CLI_TABLENAME Callback 0 Passing sTableName sVoid iIndex Result iVoid
81656>>>>>>>        End
81656>>>>>>>>
81656>>>>>>>
81656>>>>>>>        Function_Return sTableName
81657>>>>>>>    End_Function // TableName
81658>>>>>>>
81658>>>>>>>
81658>>>>>>>
81658>>>>>>>    //***
81658>>>>>>>    //*** Function: SchemaName
81658>>>>>>>    //*** Purpose : Returns the name of the schema of the table enumerated at the given position
81658>>>>>>>    //***
81658>>>>>>>
81658>>>>>>>    Function SchemaName Integer iIndex Returns String
81660>>>>>>>        Local String  sDriver
81660>>>>>>>        Local String  sSchemaName
81660>>>>>>>        Local String  sVoid
81660>>>>>>>        Local Integer iVoid
81660>>>>>>>
81660>>>>>>>        Get psDriverID To sDriver
81661>>>>>>>        If (sDriver <> "") Begin
81663>>>>>>>            Move (Repeat(" ", 255)) To sSchemaName
81664>>>>>>>            Call_driver 0 sDriver Function CLI_TABLESCHEMA Callback 0 Passing sSchemaName sVoid iIndex Result iVoid
81669>>>>>>>        End
81669>>>>>>>>
81669>>>>>>>
81669>>>>>>>        Function_Return sSchemaName
81670>>>>>>>    End_Function // SchemaName
81671>>>>>>>
81671>>>>>>>
81671>>>>>>>
81671>>>>>>>    //***
81671>>>>>>>    //*** Function: TableType
81671>>>>>>>    //*** Purpose : Returns the type of the table enumerated at the given position.
81671>>>>>>>    //***           Types can be "TABLE", "VIEW", "SYSTEM TABLE", "GLOBAL TEMPORARY",
81671>>>>>>>    //***           "LOCAL TEMPORARY", "ALIAS", "SYNONYM"
81671>>>>>>>    //***
81671>>>>>>>
81671>>>>>>>    Function TableType Integer iIndex Returns String
81673>>>>>>>        Local String  sDriver
81673>>>>>>>        Local String  sTableType
81673>>>>>>>        Local String  sVoid
81673>>>>>>>        Local Integer iVoid
81673>>>>>>>
81673>>>>>>>        Get psDriverID To sDriver
81674>>>>>>>        If (sDriver <> "") Begin
81676>>>>>>>            Move (Repeat(" ", 25)) To sTableType
81677>>>>>>>            Call_driver 0 sDriver Function CLI_TABLETYPE Callback 0 Passing sTableType sVoid iIndex Result iVoid
81682>>>>>>>        End
81682>>>>>>>>
81682>>>>>>>
81682>>>>>>>        Function_Return sTableType
81683>>>>>>>    End_Function // TableType
81684>>>>>>>
81684>>>>>>>
81684>>>>>>>
81684>>>>>>>    //***
81684>>>>>>>    //*** Function: TableComment
81684>>>>>>>    //*** Purpose : Returns the comment of the table enumerated at the given position
81684>>>>>>>    //***
81684>>>>>>>
81684>>>>>>>    Function TableComment Integer iIndex Returns String
81686>>>>>>>        Local String  sDriver
81686>>>>>>>        Local String  sTableComment
81686>>>>>>>        Local String  sVoid
81686>>>>>>>        Local Integer iVoid
81686>>>>>>>
81686>>>>>>>        Get psDriverID To sDriver
81687>>>>>>>        If (sDriver <> "") Begin
81689>>>>>>>            Move (Repeat(" ", 255)) To sTableComment
81690>>>>>>>            Call_driver 0 sDriver Function CLI_TABLECOMMENT Callback 0 Passing sTableComment sVoid iIndex Result iVoid
81695>>>>>>>        End
81695>>>>>>>>
81695>>>>>>>
81695>>>>>>>        Function_Return sTableComment
81696>>>>>>>    End_Function // TableComment
81697>>>>>>>
81697>>>>>>>
81697>>>>>>>
81697>>>>>>>    //***
81697>>>>>>>    //*** Function: EnumerateColumns
81697>>>>>>>    //*** Purpose : Enumerate the columns in a table
81697>>>>>>>    //***
81697>>>>>>>
81697>>>>>>>    Function EnumerateColumns String sLogin String sTableName Returns Integer
81699>>>>>>>        Local String  sDriver
81699>>>>>>>        Local Integer iNumColumns
81699>>>>>>>        Local Integer iVoid
81699>>>>>>>
81699>>>>>>>        Get psDriverID To sDriver
81700>>>>>>>        If (sDriver <> "") ;            Call_driver 0 sDriver Function CLI_ENUMERATE_COLUMNS Callback 0 Passing sLogin sTablename iVoid Result iNumColumns
81707>>>>>>>
81707>>>>>>>        Function_Return iNumColumns
81708>>>>>>>    End_Function // EnumerateColumns
81709>>>>>>>
81709>>>>>>>
81709>>>>>>>
81709>>>>>>>    //***
81709>>>>>>>    //*** Function: ColumnName
81709>>>>>>>    //*** Purpose : Returns the name of the column enumerated at the given position
81709>>>>>>>    //***
81709>>>>>>>
81709>>>>>>>    Function ColumnName Integer iIndex Returns String
81711>>>>>>>        Local String  sDriver
81711>>>>>>>        Local String  sColumnName
81711>>>>>>>        Local String  sVoid
81711>>>>>>>        Local Integer iVoid
81711>>>>>>>
81711>>>>>>>        Get psDriverID To sDriver
81712>>>>>>>        If (sDriver <> "") Begin
81714>>>>>>>            Move (Repeat(" ", 255)) To sColumnName
81715>>>>>>>            Call_driver 0 sDriver Function CLI_COLUMNNAME Callback 0 Passing sColumnName sVoid iIndex Result iVoid
81720>>>>>>>        End
81720>>>>>>>>
81720>>>>>>>
81720>>>>>>>        Function_Return sColumnName
81721>>>>>>>    End_Function // ColumnName
81722>>>>>>>
81722>>>>>>>
81722>>>>>>>
81722>>>>>>>    //***
81722>>>>>>>    //*** Function: CLIDFDateToSQLDate
81722>>>>>>>    //*** Purpose : Convert a DataFlex date to a SQL date using the dummy zero date value.
81722>>>>>>>    //***
81722>>>>>>>
81722>>>>>>>    Function CLIDFDateToSQLDate String sDRiver Date dDFDate Returns String
81724>>>>>>>        Local String sSQLDate
81724>>>>>>>        Local Integer iOrgDateFmt
81724>>>>>>>        Local Integer iOrgDateSep
81724>>>>>>>
81724>>>>>>>        //*** Change date format to military, SQL dates are military dates
81724>>>>>>>        Get_Attribute DF_DATE_FORMAT To iOrgDateFmt
81727>>>>>>>        Get_Attribute DF_DATE_SEPARATOR To iOrgDateSep
81730>>>>>>>        Set_Attribute DF_DATE_FORMAT To DF_DATE_MILITARY
81733>>>>>>>        Set_Attribute DF_DATE_SEPARATOR To (Ascii('-'))
81736>>>>>>>
81736>>>>>>>        //*** We only need to convert if the date is 0
81736>>>>>>>        If (Integer(dDFDate = 0)) ;            CLI_Get_Driver_Attribute sDRiver DRVR_DUMMY_ZERO_DATE_VALUE To sSQLDate
81745>>>>>>>        Else ;            Move dDFDate To sSQLDate
81747>>>>>>>
81747>>>>>>>        //*** Change date format back to original
81747>>>>>>>        Set_Attribute DF_DATE_FORMAT To iOrgDateFmt
81750>>>>>>>        Set_Attribute DF_DATE_SEPARATOR To iOrgDateSep
81753>>>>>>>
81753>>>>>>>        Function_Return sSQLDate
81754>>>>>>>    End_Function // CLIDFDateToSQLDate
81755>>>>>>>
81755>>>>>>>
81755>>>>>>>
81755>>>>>>>    //***
81755>>>>>>>    //*** Function: CLISQLDateToDFDate
81755>>>>>>>    //*** Purpose : Convert a SQL date to a DataFlex date using the dummy zero date value.
81755>>>>>>>    //***
81755>>>>>>>
81755>>>>>>>    Function CLISQLDateToDFDate String sDRiver String sSQLDate Returns Date
81757>>>>>>>        Local Date dDFDate
81757>>>>>>>        Local String sDummyDateValue
81757>>>>>>>        Local Integer iOrgDateFmt
81757>>>>>>>        Local Integer iOrgDateSep
81757>>>>>>>
81757>>>>>>>        //*** Change date format to military, SQL dates are military dates
81757>>>>>>>        Get_Attribute DF_DATE_FORMAT To iOrgDateFmt
81760>>>>>>>        Get_Attribute DF_DATE_SEPARATOR To iOrgDateSep
81763>>>>>>>        Set_Attribute DF_DATE_FORMAT To DF_DATE_MILITARY
81766>>>>>>>        Set_Attribute DF_DATE_SEPARATOR To (Ascii('-'))
81769>>>>>>>
81769>>>>>>>        //*** We only need to convert if the date is the dummy zero date value
81769>>>>>>>        CLI_Get_Driver_Attribute sDRiver DRVR_DUMMY_ZERO_DATE_VALUE To sDummyDateValue
81776>>>>>>>        If (sDummyDateValue = sSQLDate) ;            Move 0 To dDFDate
81779>>>>>>>        Else ;            Move sSQLDate To dDFDate
81781>>>>>>>
81781>>>>>>>        //*** Change date format back to original
81781>>>>>>>        Set_Attribute DF_DATE_FORMAT To iOrgDateFmt
81784>>>>>>>        Set_Attribute DF_DATE_SEPARATOR To iOrgDateSep
81787>>>>>>>
81787>>>>>>>        Function_Return dDFDate
81788>>>>>>>    End_Function // CLISQLDateToDFDate
81789>>>>>>>
81789>>>>>>>
81789>>>>>>>
81789>>>>>>>    //***
81789>>>>>>>    //*** Function: RedirectConnection
81789>>>>>>>    //*** Purpose : Redirect an exisitng connection. The existing connection
81789>>>>>>>    //***           will point to another database but all tables will stay
81789>>>>>>>    //***           open!
81789>>>>>>>    //***
81789>>>>>>>
81789>>>>>>>    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
81791>>>>>>>        Local String  sDriver
81791>>>>>>>        Local String  sVoid
81791>>>>>>>        Local Integer iResult
81791>>>>>>>        Local Integer iVoid
81791>>>>>>>
81791>>>>>>>        Get psDriverID To sDriver
81792>>>>>>>        If (sDriver <> "") Begin
81794>>>>>>>            Call_driver 0 sDriver Function CLI_REDIRECTCONNECTION Callback 0 Passing sOldConnection sNewConnection iVoid Result iResult
81799>>>>>>>        End
81799>>>>>>>>
81799>>>>>>>        Function_Return iResult
81800>>>>>>>    End_Function // RedirectConnect
81801>>>>>>>
81801>>>>>>>
81801>>>>>>>
81801>>>>>>>    //***
81801>>>>>>>    //*** Function: CreateConnectionID
81801>>>>>>>    //*** Purpose : Create a DataFlex side connection id that can be used later on.
81801>>>>>>>    //***
81801>>>>>>>
81801>>>>>>>    Function CreateConnectionID String sID String sConnStr Integer iOpt Returns Integer
81803>>>>>>>        Local String  sDriver
81803>>>>>>>        Local Integer iResult
81803>>>>>>>        Local Integer iOptions
81803>>>>>>>
81803>>>>>>>        Get psDriverID to sDriver
81804>>>>>>>        If (Num_Arguments = 2) ;            Move 0 to iOptions
81807>>>>>>>        Else ;            Move iOpt to iOptions
81809>>>>>>>        If (sDriver <> "") Begin
81811>>>>>>>            Call_Driver 0 sDriver Function CLI_CREATECONNECTIONID Callback 0 Passing sID sConnStr iOptions Result iResult
81816>>>>>>>        End
81816>>>>>>>>
81816>>>>>>>        Function_Return iResult
81817>>>>>>>    End_Function // CreateConnectionID
81818>>>>>>>
81818>>>>>>>
81818>>>>>>>
81818>>>>>>>    //***
81818>>>>>>>    //*** Function: DeleteConnectionID
81818>>>>>>>    //*** Purpose : Delete a DataFlex side connection id.
81818>>>>>>>    //***
81818>>>>>>>
81818>>>>>>>    Function DeleteConnectionID String sID Integer iIndex Returns Integer
81820>>>>>>>        Local String  sDriver
81820>>>>>>>        Local Integer iResult
81820>>>>>>>        Local String sVoid
81820>>>>>>>
81820>>>>>>>        Get psDriverID To sDriver
81821>>>>>>>        If (sDriver <> "") Begin
81823>>>>>>>            Call_Driver 0 sDriver Function CLI_DELETECONNECTIONID Callback 0 Passing sID sVoid iIndex Result iResult
81828>>>>>>>        End
81828>>>>>>>>
81828>>>>>>>        Function_Return iResult
81829>>>>>>>    End_Function // DeleteConnectionID
81830>>>>>>>
81830>>>>>>>End_Class // cCLIHandler
81831>>>>>Use DFBTRDRV.PKG
Including file: DFBTRDRV.PKG    (C:\Program Files (x86)\DataFlex 18.2\Pkg\DFBTRDRV.PKG)
81831>>>>>>>//****************************************************************************
81831>>>>>>>//
81831>>>>>>>// $File name  : DFBTRDRV.PKG
81831>>>>>>>// $File title : Package for the DataFlex Connectivity Kit for Pervasive.SQL
81831>>>>>>>// Notice      : This package contains constants and commands, used to call
81831>>>>>>>//               specific functions in the DFBTRDRV.
81831>>>>>>>// $Author(s)  : Eddy Kleinjan
81831>>>>>>>//
81831>>>>>>>// $System     : DataFlex Connectivity Kit for Pervasive.SQL
81831>>>>>>>// Created     : 01-07-97 @ 12:00:00
81831>>>>>>>//
81831>>>>>>>// Changed     : 04-04-2001.
81831>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 1.3.0.145
81831>>>>>>>//
81831>>>>>>>// Changed     : June 6, 2001
81831>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 1.3.0.148
81831>>>>>>>//
81831>>>>>>>//               Added DFBTR_DDF_OWNER command.
81831>>>>>>>//
81831>>>>>>>// Changed     : June 12, 2001
81831>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 1.3.0.149
81831>>>>>>>//
81831>>>>>>>//               Added DF_FIELD_IS_NULL and DF_FIELD_NULL_ALLOWED attributes
81831>>>>>>>//
81831>>>>>>>// Changed     : August 4, 2004
81831>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 3.0.0.1
81831>>>>>>>//
81831>>>>>>>//               Added cDfbtrdrvHandler class.
81831>>>>>>>//               New functions in this class:
81831>>>>>>>//                  Function CKRevision Returns String
81831>>>>>>>//                  Function CkUsesUri Returns Integer
81831>>>>>>>//                  Function PSQLRequesterVersionInfo Integer iFileNum Returns String
81831>>>>>>>//                  Function PSQLLocalEngineVersionInfo Integer iFileNum Returns String
81831>>>>>>>//                  Function PSQLServerEngineVersionInfo Integer iFileNum Returns String
81831>>>>>>>//
81831>>>>>>>// Changed     : September 30, 2005
81831>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 3.0.0.14
81831>>>>>>>//
81831>>>>>>>//               Bugfix: Prevent compiler errors when no (df)error.pkg is used
81831>>>>>>>//****************************************************************************
81831>>>>>>>Use Ui
81831>>>>>>>//
81831>>>>>>>// Driver Indentification
81831>>>>>>>//
81831>>>>>>>
81831>>>>>>>//*** Driver attributes
81831>>>>>>>//
81831>>>>>>>// Call_Driver functions ID's
81831>>>>>>>//
81831>>>>>>>//
81831>>>>>>>// DFBTRFN_CONVERT_FILE options
81831>>>>>>>//
81831>>>>>>>
81831>>>>>>>//
81831>>>>>>>// DFBTRFN_SET_OWNER options
81831>>>>>>>//
81831>>>>>>>
81831>>>>>>>//
81831>>>>>>>// DFBTRFN_SET_TRANSACTION_TYPE options
81831>>>>>>>//
81831>>>>>>>
81831>>>>>>>
81831>>>>>>>//
81831>>>>>>>// Command to create all vars which may be needed
81831>>>>>>>// in other commands.
81831>>>>>>>//
81831>>>>>>>
81831>>>>>>>
81831>>>>>>>
81831>>>>>>>//
81831>>>>>>>// Command to set the owner of a Btrieve file.
81831>>>>>>>// File must have been opened.
81831>>>>>>>// Filenumber needs to be passed.
81831>>>>>>>// To clear set the owner to "".
81831>>>>>>>// Examples:
81831>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret"
81831>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY CALLBACK MyCallBack
81831>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" ENCRYPT
81831>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY ENCRYPT CALLBACK MyCallBack
81831>>>>>>>// To clear:
81831>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to ""
81831>>>>>>>//
81831>>>>>>>
81831>>>>>>>
81831>>>>>>>
81831>>>>>>>//
81831>>>>>>>// Command to parse DFBTR_SET_OWNVER
81831>>>>>>>// options.
81831>>>>>>>//
81831>>>>>>>
81831>>>>>>>
81831>>>>>>>
81831>>>>>>>//
81831>>>>>>>// Command to parse for Callback
81831>>>>>>>//
81831>>>>>>>
81831>>>>>>>
81831>>>>>>>
81831>>>>>>>//
81831>>>>>>>// Command to clear the owner of a Btrieve file.
81831>>>>>>>// File must have been opened.
81831>>>>>>>// Filenumber needs to be passed.
81831>>>>>>>// Examples:
81831>>>>>>>//      DFBTR_CLEAR_OWNER MyFileNumber
81831>>>>>>>//
81831>>>>>>>
81831>>>>>>>
81831>>>>>>>
81831>>>>>>>//
81831>>>>>>>// Command to add a owner name to the internal list of ownernames
81831>>>>>>>// which will be tries when opening files.
81831>>>>>>>//
81831>>>>>>>
81831>>>>>>>
81831>>>>>>>
81831>>>>>>>//
81831>>>>>>>// Command to remove all owners from the internal list of ownernames
81831>>>>>>>//
81831>>>>>>>
81831>>>>>>>
81831>>>>>>>//
81831>>>>>>>// Command to set the owner name to be used when opening the DDF files.
81831>>>>>>>// The DDF owner is required when Pervasive.SQL security is turned on.
81831>>>>>>>// The DDF owner is equal to the password of the Master user in Pervasive.SQL
81831>>>>>>>// This command overwrites the DDF_OWNER setting in DFBTRDRV.INT
81831>>>>>>>//
81831>>>>>>>
81831>>>>>>>//
81831>>>>>>>// Command to change the transaction type.
81831>>>>>>>// Valid types are:
81831>>>>>>>//     DFBTRTT_NONE
81831>>>>>>>//     DFBTRTT_EXCLUSIVE
81831>>>>>>>//     DFBTRTT_CONCURRENT
81831>>>>>>>//
81831>>>>>>>//
81831>>>>>>>
81831>>>>>>>
81831>>>>>>>
81831>>>>>>>//
81831>>>>>>>// Command to get the current transaction type.
81831>>>>>>>//
81831>>>>>>>
81831>>>>>>>//
81831>>>>>>>// Command to set explicit_locking
81831>>>>>>>//
81831>>>>>>>
81831>>>>>>>//
81831>>>>>>>// Command to get explicit locking
81831>>>>>>>//
81831>>>>>>>
81831>>>>>>>//
81831>>>>>>>// Command to set detection for incompatible positive signs in numeric fields
81831>>>>>>>//
81831>>>>>>>
81831>>>>>>>//
81831>>>>>>>// Command to get detection for incompatible positive signs in numeric fields
81831>>>>>>>//
81831>>>>>>>
81831>>>>>>>//*****************************************************************************
81831>>>>>>>//*** Class  : cDfbtrdrvHandler                                                  ***
81831>>>>>>>//*** Purpose: An instance of this class can be used as a broker object to  ***
81831>>>>>>>//***          call several Dfbtrdrv releated methods.                           ***
81831>>>>>>>//*****************************************************************************
81831>>>>>>>
81831>>>>>>>Class cDFBtrDrvHandler Is An Array
81832>>>>>>>
81832>>>>>>>    Procedure Construct_Object Integer iImage
81834>>>>>>>        Forward Send Construct_object iImage
81836>>>>>>>
81836>>>>>>>        Property String  psDriverID       Public "DFBTRDRV"
81837>>>>>>>    End_Procedure // Construct_Object
81838>>>>>>>
81838>>>>>>>
81838>>>>>>>
81838>>>>>>>    //***
81838>>>>>>>    //*** Function: CKRevsion
81838>>>>>>>    //*** Purpose : The revsion of a Dfbtrdrv Connectivity Kit
81838>>>>>>>    //***
81838>>>>>>>
81838>>>>>>>    Function CKRevision Returns String
81840>>>>>>>        Local String  sDriverID
81840>>>>>>>        Local String  sRevision
81840>>>>>>>        Local String  sVoid
81840>>>>>>>        Local Integer iRetval
81840>>>>>>>
81840>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
81840>>>>>>>        // This error would otherwise be raised when we have an older
81840>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
81840>>>>>>>        Send Ignore_error To Error_object_Id 20491
81841>>>>>>>        Get psDriverID To sDriverID
81842>>>>>>>        Move (Repeat(" ", 255)) To sRevision
81843>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKREVISION Callback 0 Passing sRevision sVoid 0 Result iRetval
81848>>>>>>>        Send Trap_Error To Error_object_Id 20491
81849>>>>>>>        If (Trim(sRevision) = "") Begin
81851>>>>>>>            // Unable to get the revision. return all zeroes.
81851>>>>>>>            Move "0.0.0.0" To sRevision
81852>>>>>>>        End
81852>>>>>>>>
81852>>>>>>>        Function_Return sRevision
81853>>>>>>>    End_Function // CKRevision
81854>>>>>>>
81854>>>>>>>    Function CkUsesUri Returns Integer
81856>>>>>>>        Local String  sDriverID
81856>>>>>>>        Local String  sVoid1
81856>>>>>>>        Local String  sVoid2
81856>>>>>>>        Local Integer iRetval
81856>>>>>>>
81856>>>>>>>        Get psDriverID To sDriverID
81857>>>>>>>
81857>>>>>>>        Move 0 To iRetval
81858>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
81858>>>>>>>        // This error would otherwise be raised when we have an older
81858>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKUSESURI function
81858>>>>>>>        Send Ignore_error To Error_object_Id 20491
81859>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKUSESURI Callback 0 Passing sVoid1 sVoid2 0 Result iRetval
81864>>>>>>>        Send Trap_Error To Error_object_Id 20491
81865>>>>>>>
81865>>>>>>>        Function_Return iRetval
81866>>>>>>>    End_Function // CKUsesUri
81867>>>>>>>
81867>>>>>>>
81867>>>>>>>
81867>>>>>>>    //***
81867>>>>>>>    //*** Function: ExtractPartFromRevsion
81867>>>>>>>    //*** Purpose : Extarct the Nth part of a a.b.c.d revsion string.
81867>>>>>>>    //***
81867>>>>>>>    //*** Returns : The part version number or -1 if there is no such part number.
81867>>>>>>>    //***
81867>>>>>>>
81867>>>>>>>    Function ExtractPartFromRevision Integer iPartNum String sRevision Returns Integer
81869>>>>>>>        Local Integer iPartRev
81869>>>>>>>        Local Integer iCurrentPart
81869>>>>>>>        Local Integer iSeparatorPos
81869>>>>>>>
81869>>>>>>>        If (iPartNum > 4) ;            Function_Return -1
81872>>>>>>>
81872>>>>>>>        Move 0 To iCurrentPart
81873>>>>>>>        Repeat
81873>>>>>>>>
81873>>>>>>>            Move (Pos(".", sRevision)) To iSeparatorPos
81874>>>>>>>            If (iSeparatorPos > 0) Begin
81876>>>>>>>                Move (Left(sRevision, iSeparatorPos - 1)) To iPartRev
81877>>>>>>>                Move (Right(sRevision, Length(sRevision) - iSeparatorPos)) To sRevision
81878>>>>>>>                Increment iCurrentPart
81879>>>>>>>            End
81879>>>>>>>>
81879>>>>>>>            Else If (sRevision <> "") Begin
81882>>>>>>>                Move sRevision To iPartRev
81883>>>>>>>                Move "" To sRevision
81884>>>>>>>                Increment iCurrentPart
81885>>>>>>>            End
81885>>>>>>>>
81885>>>>>>>            Else ;                Move -1 To iPartRev
81887>>>>>>>        Until (iCurrentPart >= iPartNum Or iPartRev = -1)
81889>>>>>>>
81889>>>>>>>        Function_Return iPartRev
81890>>>>>>>    End_Function // EcxtractPartFromRevision
81891>>>>>>>
81891>>>>>>>
81891>>>>>>>
81891>>>>>>>    //***
81891>>>>>>>    //*** Function: CKMajorRevision
81891>>>>>>>    //*** Purpose : Returns the major revision of the CK
81891>>>>>>>    //***
81891>>>>>>>
81891>>>>>>>    Function CKMajorRevision Returns Integer
81893>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 1, CKRevision(Current_Object)))
81894>>>>>>>    End_Function // CKMajorRevision
81895>>>>>>>
81895>>>>>>>
81895>>>>>>>
81895>>>>>>>    //***
81895>>>>>>>    //*** Function: CKMinorRevision
81895>>>>>>>    //*** Purpose : Returns the minor revision of the CK
81895>>>>>>>    //***
81895>>>>>>>
81895>>>>>>>    Function CKMinorRevision Returns Integer
81897>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 2, CKRevision(Current_Object)))
81898>>>>>>>    End_Function // CKMinorRevision
81899>>>>>>>
81899>>>>>>>
81899>>>>>>>
81899>>>>>>>    //***
81899>>>>>>>    //*** Function: CKReleaseRevision
81899>>>>>>>    //*** Purpose : Returns the release revision of the CK
81899>>>>>>>    //***
81899>>>>>>>
81899>>>>>>>    Function CKReleaseRevision Returns Integer
81901>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 3, CKRevision(Current_Object)))
81902>>>>>>>    End_Function // CKReleaseRevision
81903>>>>>>>
81903>>>>>>>
81903>>>>>>>
81903>>>>>>>    //***
81903>>>>>>>    //*** Function: CKBuildRevision
81903>>>>>>>    //*** Purpose : Returns the major revision of the CK
81903>>>>>>>    //***
81903>>>>>>>
81903>>>>>>>    Function CKBuildRevision Returns Integer
81905>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 4, CKRevision(Current_Object)))
81906>>>>>>>    End_Function // CKBuildRevision
81907>>>>>>>
81907>>>>>>>
81907>>>>>>>
81907>>>>>>>    //***
81907>>>>>>>    //*** Function: IsMinimalRevision
81907>>>>>>>    //*** Purpose : Determines if the CK conforms to a passed minimal revsion.
81907>>>>>>>    //***
81907>>>>>>>
81907>>>>>>>    Function IsMinimalRevision Integer iMajor Integer iMinor Integer iRelease Integer iBuild Returns Integer
81909>>>>>>>        If (iMajor < CKMajorRevision(Current_object)) ;            Function_return (TRUE)
81912>>>>>>>        Else If (iMajor = CKMajorRevision(Current_object)) Begin
81915>>>>>>>            If (iMinor < CKMinorRevision(Current_object)) ;                Function_return (TRUE)
81918>>>>>>>            Else If (iMinor = CKMinorRevision(Current_object)) Begin
81921>>>>>>>                If (iRelease < CKReleaseRevision(Current_object)) ;                    Function_return (TRUE)
81924>>>>>>>                Else If (iRelease = CKReleaseRevision(Current_object) And iBuild <= CKBuildRevision(Current_object)) ;                    Function_return (TRUE)
81928>>>>>>>            End
81928>>>>>>>>
81928>>>>>>>        End
81928>>>>>>>>
81928>>>>>>>
81928>>>>>>>        Function_Return (FALSE)
81929>>>>>>>    End_Function // IsMinimalRevision
81930>>>>>>>
81930>>>>>>>    //   Functions to query the Pervasive.SQL version:
81930>>>>>>>    //       PSQLRequesterVersionInfo    Integer iFileNum Returns String
81930>>>>>>>    //       PSQLLocalEngineVersionInfo  Integer iFileNum Returns String
81930>>>>>>>    //       PSQLServerEngineVersionInfo Integer iFileNum Returns String
81930>>>>>>>    //
81930>>>>>>>    //   All 3 functions return the version of a Pervasive.SQL component
81930>>>>>>>    //   in the following format:
81930>>>>>>>    //       <version>.<revision>.<type>
81930>>>>>>>    //   possible values for <type>:
81930>>>>>>>    //       9 for 32-bit Windows workstation/workgroup engine or Linux
81930>>>>>>>    //         server using Workgroup authentication mode
81930>>>>>>>    //       C for client cache engine
81930>>>>>>>    //       D for DOS workstation
81930>>>>>>>    //       N for client Requester
81930>>>>>>>    //       S for NetWare server
81930>>>>>>>    //       T for 32-bit Windows server engine
81930>>>>>>>    //       U for Linux server using PAM or BTPASSWD authentication
81930>>>>>>>    //
81930>>>>>>>    //   example:
81930>>>>>>>    //       8.50.T
81930>>>>>>>    //   will be returned for a Pervasive.SQL 8.5 Server Engine running on
81930>>>>>>>    //   32-bits Windows server.
81930>>>>>>>    //
81930>>>>>>>    //   The FileNumber parameter must specify an opened table or 0.
81930>>>>>>>    //   For PSQLServerEngineVersionInfo the FileNumber can not be 0.
81930>>>>>>>    //
81930>>>>>>>    //   If the version information is not available or can not be obtained
81930>>>>>>>    //   the functions will return "0.0.0"
81930>>>>>>>
81930>>>>>>>
81930>>>>>>>    //***
81930>>>>>>>    //*** Function: PSQLRequesterVersionInfo
81930>>>>>>>    //*** Purpose : Returns the version information of the
81930>>>>>>>    //***           Pervasive.SQL Client requester.
81930>>>>>>>
81930>>>>>>>    Function PSQLRequesterVersionInfo Integer iFileNum Returns String
81932>>>>>>>
81932>>>>>>>        Local String  sDriverID
81932>>>>>>>        Local String  sVersion
81932>>>>>>>        Local String  sVoid
81932>>>>>>>        Local Integer iRetval
81932>>>>>>>
81932>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
81932>>>>>>>        // This error would otherwise be raised when we have an older
81932>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
81932>>>>>>>        Send Ignore_error To Error_object_Id 20491
81933>>>>>>>        Get psDriverID To sDriverID
81934>>>>>>>        Move (Repeat(" ", 255)) To sVersion
81935>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLREQUESTERVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
81940>>>>>>>        Send Trap_Error To Error_object_Id 20491
81941>>>>>>>        If (Trim(sVersion) = "") Begin
81943>>>>>>>            // Unable to get the revision. return all zeroes.
81943>>>>>>>            Move "0.0.0" To sVersion
81944>>>>>>>        End
81944>>>>>>>>
81944>>>>>>>        Function_Return sVersion
81945>>>>>>>    End_Function //  PSQLRequesterVersion
81946>>>>>>>
81946>>>>>>>    //***
81946>>>>>>>    //*** Function: PSQLLocalEngineVersionInfo
81946>>>>>>>    //*** Purpose : Returns the version information of the
81946>>>>>>>    //***           Pervasive.SQL Local Engine
81946>>>>>>>
81946>>>>>>>    Function PSQLLocalEngineVersionInfo Integer iFileNum Returns String
81948>>>>>>>
81948>>>>>>>        Local String  sDriverID
81948>>>>>>>        Local String  sVersion
81948>>>>>>>        Local String  sVoid
81948>>>>>>>        Local Integer iRetval
81948>>>>>>>
81948>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
81948>>>>>>>        // This error would otherwise be raised when we have an older
81948>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
81948>>>>>>>        Send Ignore_error To Error_object_Id 20491
81949>>>>>>>        Get psDriverID To sDriverID
81950>>>>>>>        Move (Repeat(" ", 255)) To sVersion
81951>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLLOCALENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
81956>>>>>>>        Send Trap_Error To Error_object_Id 20491
81957>>>>>>>        If (Trim(sVersion) = "") Begin
81959>>>>>>>            // Unable to get the revision. return all zeroes.
81959>>>>>>>            Move "0.0.0" To sVersion
81960>>>>>>>        End
81960>>>>>>>>
81960>>>>>>>        Function_Return sVersion
81961>>>>>>>    End_Function //  PSQLLocalEngineVersion
81962>>>>>>>
81962>>>>>>>    //***
81962>>>>>>>    //*** Function: PSQLServerEngineVersionInfo
81962>>>>>>>    //*** Purpose : Returns the version information of the
81962>>>>>>>    //***           Pervasive.SQL Server Engine
81962>>>>>>>
81962>>>>>>>    Function PSQLServerEngineVersionInfo Integer iFileNum Returns String
81964>>>>>>>
81964>>>>>>>        Local String  sDriverID
81964>>>>>>>        Local String  sVersion
81964>>>>>>>        Local String  sVoid
81964>>>>>>>        Local Integer iRetval
81964>>>>>>>
81964>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
81964>>>>>>>        // This error would otherwise be raised when we have an older
81964>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
81964>>>>>>>        Send Ignore_error To Error_object_Id 20491
81965>>>>>>>        Get psDriverID To sDriverID
81966>>>>>>>        Move (Repeat(" ", 255)) To sVersion
81967>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLSERVERENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
81972>>>>>>>        Send Trap_Error To Error_object_Id 20491
81973>>>>>>>        If (Trim(sVersion) = "") Begin
81975>>>>>>>            // Unable to get the revision. return all zeroes.
81975>>>>>>>            Move "0.0.0" To sVersion
81976>>>>>>>        End
81976>>>>>>>>
81976>>>>>>>        Function_Return sVersion
81977>>>>>>>    End_Function //  PSQLServerEngineVersion
81978>>>>>>>
81978>>>>>>>End_Class // cDfbtrdrvHandler
81979>>>>>>>
81979>>>>>
81979>>>>>
81979>>>>>External_Function WNetGetUser "WNetGetUserA" MPR.DLL Pointer lpName Pointer lpUser_Name Pointer lpLength Returns DWord
81980>>>>>
81980>>>>>Register_Function phoWorkspace Returns Handle
81980>>>>>Register_Function Help_filename Returns String
81980>>>>>Register_Function GetHelpFile Returns String
81980>>>>>Register_Function pbEnterKeyAsTabKey Returns Boolean
81980>>>>>
81980>>>>>//****************************************************************************
81980>>>>>// $Module type: FUNCTION
81980>>>>>// $Module name: Network_User_Name
81980>>>>>// $Author     : AK/VOO/KCR
81980>>>>>// Created     : 09-24-96 @ 19:17
81980>>>>>//
81980>>>>>// Description
81980>>>>>//    This function reads the current username Of windows and returns that
81980>>>>>//    name or an text unknown user
81980>>>>>//
81980>>>>>// $Rev History
81980>>>>>//  02/22/2012  Ask Windows how long the size of the name should be
81980>>>>>//  07/25/2003  Replaced obsolete code
81980>>>>>//  09/24/1996  Module header created
81980>>>>>//****************************************************************************
81980>>>>>Function Network_User_Name for cDesktop Returns String
81982>>>>>    String sName
81982>>>>>    Integer iRetval iLength
81982>>>>>
81982>>>>>    Move 0 to iLength
81983>>>>>    Move (WNetGetUser (0, 0, AddressOf (iLength))) to iRetval
81984>>>>>    ZeroString iLength to sName
81985>>>>>    Move (WNetGetUser (0, AddressOf (sName), AddressOf (iLength))) to iRetval
81986>>>>>
81986>>>>>    If (iRetval = NO_ERROR) Begin
81988>>>>>        Function_Return (CString (sName))
81989>>>>>    End
81989>>>>>>
81989>>>>>    
81989>>>>>    Function_Return "User Unknown"
81990>>>>>End_Function
81991>>>>>
81991>>>>>// OBSOLETE STRUCTURE AND WINDOWS API CALL. KEPT FOR BACKWARDS COMPATIBILITY
81991>>>>>Type MEMORYSTATUS
81991>>>>>   Field MEMORYSTATUS.dwLength         as DWord // sizeof(MEMORYSTATUS)
81991>>>>>   Field MEMORYSTATUS.dwMemoryLoad     as DWord // percent Of memory in use
81991>>>>>   Field MEMORYSTATUS.dwTotalPhys      as DWord // bytes Of physical memory
81991>>>>>   Field MEMORYSTATUS.dwAvailPhys      as DWord // free physical memory bytes
81991>>>>>   Field MEMORYSTATUS.dwTotalPageFile  as DWord // bytes Of paging file
81991>>>>>   Field MEMORYSTATUS.dwAvailPageFile  as DWord // free bytes Of paging file
81991>>>>>   Field MEMORYSTATUS.dwTotalVirtual   as DWord // user bytes Of address space
81991>>>>>   Field MEMORYSTATUS.dwAvailVirtual   as DWord // free user bytes
81991>>>>>End_Type // MEMORYSTATUS
81991>>>>>
81991>>>>>External_Function GlobalMemoryStatus "GlobalMemoryStatus" Kernel32.Dll Pointer lpsMemoryStatus Returns Integer
81992>>>>>
81992>>>>>Struct tWinMemoryStatusEx
81992>>>>>    UInteger dwLength                
81992>>>>>    UInteger dwMemoryLoad          
81992>>>>>    UBigInt ullTotalPhys           
81992>>>>>    UBigInt ullAvailPhys           
81992>>>>>    UBigInt ullTotalPageFile       
81992>>>>>    UBigInt ullAvailPageFile       
81992>>>>>    UBigInt ullTotalVirtual        
81992>>>>>    UBigInt ullAvailVirtual        
81992>>>>>    UBigInt ullAvailExtendedVirtual
81992>>>>>End_Struct
81992>>>>>
81992>>>>>External_Function GlobalMemoryStatusEx "GlobalMemoryStatusEx" Kernel32.Dll Pointer lpMemoryStatus Returns Integer
81993>>>>>
81993>>>>>Class SysinfoDisplay is a cTextEdit
81994>>>>>    Procedure Construct_Object
81996>>>>>        Forward Send Construct_Object
81998>>>>>
81998>>>>>        Set Location To 6 6
81999>>>>>        Set Size To 110 255
82000>>>>>        Set Read_Only_State To True
82001>>>>>        Set pbWrap to False
82002>>>>>    End_Procedure
82003>>>>>
82003>>>>>    //****************************************************************************
82003>>>>>    // $Module type: PROCEDURE
82003>>>>>    // $Module name: Show_Current_Directory
82003>>>>>    // $Author     : VOO
82003>>>>>    // Created     : 06-10-96 @ 15:24
82003>>>>>    //
82003>>>>>    // Description
82003>>>>>    //    This method will show the name Of the current directory in the system
82003>>>>>    //    information box
82003>>>>>    //
82003>>>>>    // $Rev History
82003>>>>>    //    06-10-96  Module header created
82003>>>>>    //****************************************************************************
82003>>>>>    Procedure Show_Current_Directory
82005>>>>>        String sDir
82005>>>>>
82005>>>>>        Get_Current_Directory To sDir
82006>>>>>
82006>>>>>        Send AppendTextLn (SFormat (C_$CurrentDirectory, sDir))
82007>>>>>    End_Procedure
82008>>>>>
82008>>>>>    Procedure Show_Windows_Directory
82010>>>>>        String sWindir
82010>>>>>
82010>>>>>        Get_Windows_Directory To sWindir
82011>>>>>
82011>>>>>        Send AppendTextLn (SFormat (C_$WindowsDirectory, sWindir))
82012>>>>>    End_Procedure
82013>>>>>
82013>>>>>    Procedure Show_Current_User
82015>>>>>        Send AppendTextLn (SFormat (C_$NetworkUserName, Network_User_Name (Self)))
82016>>>>>    End_Procedure
82017>>>>>
82017>>>>>    Procedure Show_Number_Format
82019>>>>>        Integer iFormat
82019>>>>>        String sFormatText
82019>>>>>
82019>>>>>        Get_Attribute DF_THOUSANDS_SEPARATOR to iFormat
82022>>>>>        Move (Character (iFormat)) To sFormatText
82023>>>>>        Send AppendTextLn (SFormat (C_$ThousandsSeparator, sFormatText, iFormat))
82024>>>>>
82024>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iFormat
82027>>>>>        Move (Character (iFormat)) to sFormatText
82028>>>>>        Send AppendTextLn (SFormat (C_$DecimalSeparator, sFormatText))
82029>>>>>    End_Procedure
82030>>>>>
82030>>>>>    Procedure Show_Filelist_Name
82032>>>>>        String sFilename
82032>>>>>
82032>>>>>        Get_Attribute DF_FILELIST_NAME to sFilename
82035>>>>>
82035>>>>>        Send AppendTextLn (SFormat (C_$CurrentFilelist, sFilename))
82036>>>>>        Send AppendTextLn ""
82037>>>>>    End_Procedure
82038>>>>>
82038>>>>>    Procedure Show_Lock_Delay
82040>>>>>        Integer iLockdelay
82040>>>>>
82040>>>>>        Get_Attribute DF_LOCK_DELAY to iLockdelay
82043>>>>>
82043>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingDelay, iLockDelay))
82044>>>>>    End_Procedure
82045>>>>>
82045>>>>>    Procedure Show_Lock_Timeout
82047>>>>>        Integer iLockTimeout
82047>>>>>
82047>>>>>        Get_Attribute DF_LOCK_TIMEOUT to iLockTimeout
82050>>>>>
82050>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingTimeout, iLockTimeOut))
82051>>>>>    End_Procedure
82052>>>>>
82052>>>>>    Procedure Show_Screen_Size
82054>>>>>        Integer iYscreensize iXscreensize
82054>>>>>
82054>>>>>        Move (GetSystemMetrics (SM_CXSCREEN)) To iXscreensize
82055>>>>>        Move (GetSystemMetrics (SM_CYSCREEN)) To iYscreensize
82056>>>>>
82056>>>>>        Send AppendTextLn (SFormat (C_$VideoResolution, iXscreensize, iYscreensize))
82057>>>>>    End_Procedure
82058>>>>>
82058>>>>>    Procedure Show_Page_Size
82060>>>>>        Send AppendTextLn (SFormat (C_$PageEndFormFeed, Pageend, Pagefeed))
82061>>>>>    End_procedure
82062>>>>>
82062>>>>>    Procedure Show_Date
82064>>>>>        Date dToday
82064>>>>>
82064>>>>>        Sysdate dToday
82065>>>>>
82065>>>>>        Send AppendTextLn (SFormat (C_$CurrentSystemDate, String (dToday)))
82066>>>>>    End_procedure
82067>>>>>
82067>>>>>    Procedure Show_Date_Format
82069>>>>>        Integer iDateFormat
82069>>>>>        String sDateFormat
82069>>>>>
82069>>>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
82072>>>>>        Case Begin
82072>>>>>            Case (iDateFormat = DF_DATE_USA)
82074>>>>>                Move C_$USA To sDateFormat
82075>>>>>                Case Break
82076>>>>>            Case (iDateFormat = DF_DATE_EUROPEAN)
82079>>>>>                Move C_$European To sDateFormat
82080>>>>>                Case Break
82081>>>>>            Case (iDateFormat = DF_DATE_MILITARY)
82084>>>>>                Move C_$Military To sDateFormat
82085>>>>>                Case Break
82086>>>>>            Case Else
82086>>>>>                Move C_$UnknownDateType To sDateFormat
82087>>>>>                Case Break
82088>>>>>        Case End
82088>>>>>
82088>>>>>        Send AppendTextLn (SFormat (C_$DateFormat, sDateformat))
82089>>>>>    End_Procedure
82090>>>>>
82090>>>>>    Procedure Show_Systemresources
82092>>>>>        tWinMemoryStatusEx MemoryStatusInfo
82092>>>>>        tWinMemoryStatusEx MemoryStatusInfo
82092>>>>>        Integer iRetval
82092>>>>>
82092>>>>>        Move (SizeOfType (tWinMemoryStatusEx)) to MemoryStatusInfo.dwLength
82093>>>>>        Move (GlobalMemoryStatusEx (AddressOf (MemoryStatusInfo))) to iRetval
82094>>>>>        If (iRetval = 0) Begin
82096>>>>>            Move (ShowLastError ()) to iRetval
82097>>>>>        End
82097>>>>>>
82097>>>>>
82097>>>>>        Send AppendTextLn (SFormat (C_$AvailableMemory, MemoryStatusInfo.ullTotalPhys))
82098>>>>>        Send AppendTextLn (SFormat (C_$MemoryUtilization, MemoryStatusInfo.dwMemoryLoad))
82099>>>>>        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, Real (MemoryStatusInfo.ullAvailPhys) / Real (MemoryStatusInfo.ullTotalPhys) * 100.0))
82100>>>>>        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, Real (MemoryStatusInfo.ullAvailPageFile) / Real (MemoryStatusInfo.ullTotalPageFile) * 100.0))
82101>>>>>        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, Real (MemoryStatusInfo.ullAvailVirtual) / Real (MemoryStatusInfo.ullTotalVirtual) * 100.0))
82102>>>>>    End_Procedure
82103>>>>>
82103>>>>>    Procedure Show_Registration
82105>>>>>        String sRegName
82105>>>>>        Integer iSN iMaxUsers
82105>>>>>
82105>>>>>        Registration sRegName iSN
82106>>>>>>
82106>>>>>        
82106>>>>>        Get_Licensed_Max_Users to iMaxUsers
82107>>>>>
82107>>>>>        Send AppendTextLn ""
82108>>>>>        Send AppendTextLn (SFormat (C_$Serial, iSN))
82109>>>>>        Send AppendTextLn (SFormat (C_$RegName, sRegName))
82110>>>>>        Send AppendTextLn (SFormat (C_$MaxNumUsers, iMaxUsers))
82111>>>>>    End_Procedure
82112>>>>>
82112>>>>>    //****************************************************************************
82112>>>>>    // If workspaces are used, we will send the message EnumerateWorkspaceData
82112>>>>>    // To the workspace object passing the an object and message To send back
82112>>>>>    // To this object. It is expected that the workspace object will send this
82112>>>>>    // message for every line Of information it wants displayed (passing the
82112>>>>>    // information To be displayed
82112>>>>>    //****************************************************************************
82112>>>>>    Register_Procedure EnumerateWorkspaceData Integer hObjId Integer hmMessId
82112>>>>>
82112>>>>>    Procedure Show_ServicePack
82114>>>>>        String sKey sVersionDescription sVersion 
82114>>>>>        Handle hoRegistry
82114>>>>>        Boolean bExists bOpened
82114>>>>>        
82114>>>>>        Get Create (RefClass (cRegistry)) to hoRegistry
82115>>>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
82116>>>>>        Set pfAccessRights of hoRegistry to KEY_READ
82117>>>>>
82117>>>>>        Move C_DFVersionRegistryRoot to sKey
82118>>>>>        Get KeyExists of hoRegistry sKey to bExists
82119>>>>>        If (bExists) Begin
82121>>>>>            Get OpenKey of hoRegistry sKey to bOpened
82122>>>>>            If (bOpened) Begin
82124>>>>>                Get ValueExists of hoRegistry "CurrentVersionDescription" to bExists
82125>>>>>                If (bExists) Begin
82127>>>>>                    Get ReadString of hoRegistry "CurrentVersionDescription" to sVersionDescription
82128>>>>>                End
82128>>>>>>
82128>>>>>                
82128>>>>>                Get ValueExists of hoRegistry "CurrentVersion" to bExists
82129>>>>>                If (bExists) Begin
82131>>>>>                    Get ReadString of hoRegistry "CurrentVersion" to sVersion
82132>>>>>                End                
82132>>>>>>
82132>>>>>                Send CloseKey of hoRegistry
82133>>>>>            End
82133>>>>>>
82133>>>>>        End
82133>>>>>>
82133>>>>>        Send Destroy of hoRegistry
82134>>>>>
82134>>>>>        If (sVersionDescription <> "") Begin
82136>>>>>           Send AppendTextLn (sVersionDescription * "-" * sVersion)
82137>>>>>           Send AppendTextLn ""
82138>>>>>        End
82138>>>>>>
82138>>>>>    End_Procedure
82139>>>>>    
82139>>>>>
82139>>>>>    Procedure Show_WorkspaceInformation
82141>>>>>        Integer hoWorkspace
82141>>>>>
82141>>>>>        If (ghoApplication <> 0) Begin
82143>>>>>            Get phoWorkspace of ghoApplication to hoWorkspace
82144>>>>>            If (hoWorkspace <> 0) Begin
82146>>>>>                Send EnumerateWorkspaceData of hoWorkspace Self (Refproc (AppendTextLn))
82147>>>>>                Send AppendTextLn ""
82148>>>>>            End
82148>>>>>>
82148>>>>>        End
82148>>>>>>
82148>>>>>    End_Procedure
82149>>>>>
82149>>>>>    Function VersionStr Integer iVer Integer iRev Integer iBld Returns String
82151>>>>>        Function_Return (String (iVer) - "." - String (iRev) - "." - String (iBld))
82152>>>>>    End_Function
82153>>>>>
82153>>>>>    Procedure Show_Versions
82155>>>>>        Integer iVersion iRevision iBuild
82155>>>>>
82155>>>>>        Version_Information iVersion iRevision iBuild
82157>>>>>
82157>>>>>        Send AppendTextLn (SFormat (C_$RuntimeVersion, VersionStr(Self,iVersion,iRevision,iBuild) ))
82158>>>>>        Send AppendTextLn (SFormat (C_$PackageVersion, VersionStr(Self,PKG_VERSION, PKG_REVISION, PKG_BUILD) ))
82159>>>>>        Send AppendTextLn (SFormat (C_$FMACVersion, VersionStr(Self,FMAC_VERSION, FMAC_REVISION, FMAC_BUILD) ))
82160>>>>>    End_Procedure
82161>>>>>    
82161>>>>>    Function CKRevisionNumber String sDriverID Returns String
82163>>>>>        Handle hoCLIHandler
82163>>>>>        Handle hoDFBtrDrvHandler
82163>>>>>        String sCKRevision
82163>>>>>
82163>>>>>
82163>>>>>        If (sDriverID = "MSSQLDRV" or sDriverID = "ODBC_DRV" or sDriverID = "DB2_DRV") Begin
82165>>>>>            Get Create (RefClass(cCLIHandler)) to hoCLIHandler
82166>>>>>            Set psDriverID of hoCLIHandler to sDriverID
82167>>>>>            Move (CKRevision(hoCLIHandler)) to sCKRevision
82168>>>>>            Send Destroy of hoCLIHandler
82169>>>>>        End
82169>>>>>>
82169>>>>>        Else Begin
82170>>>>>            If (sDriverID = "DFBTRDRV") Begin
82172>>>>>                Get Create (RefClass(cDFBtrDrvHandler)) to hoDFBtrDrvHandler
82173>>>>>                Set psDriverID of hoDFBtrDrvHandler to sDriverID
82174>>>>>                Move (CKRevision(hoDFBtrDrvHandler)) to sCKRevision
82175>>>>>                Send Destroy of hoDFBtrDrvHandler
82176>>>>>            End
82176>>>>>>
82176>>>>>        End
82176>>>>>>
82176>>>>>        
82176>>>>>        Function_Return sCKRevision
82177>>>>>    End_Function
82178>>>>>    
82178>>>>>    
82178>>>>>    Function IsDataAccessCK String sDriverID Returns Boolean
82180>>>>>        
82180>>>>>        If (sDriverID = "DATAFLEX") Begin
82182>>>>>            Function_Return False
82183>>>>>        End
82183>>>>>>
82183>>>>>    
82183>>>>>        Function_Return (sDriverID = "MSSQLDRV" or sDriverID = "ODBC_DRV" or sDriverID = "DB2_DRV" or sDriverID = "DFBTRDRV")
82184>>>>>    End_Function    
82185>>>>>
82185>>>>>
82185>>>>>    //***
82185>>>>>    //*** BW
82185>>>>>    //*** Procedure: Show_Drivers
82185>>>>>    //*** Purpose  : Show loaded database drivers
82185>>>>>    //***
82185>>>>>
82185>>>>>    Procedure Show_Drivers
82187>>>>>        String sCurrentDriver sRevNumber
82187>>>>>        String sLoadedDrivers
82187>>>>>        Integer iNumberOfDrivers iCount
82187>>>>>        Boolean bOK
82187>>>>>
82187>>>>>        Move "" To sLoadedDrivers
82188>>>>>        Get_Attribute DF_NUMBER_DRIVERS To iNumberOfDrivers
82191>>>>>        For iCount From 1 To iNumberOfDrivers
82197>>>>>>
82197>>>>>            Get_Attribute DF_DRIVER_NAME Of iCount To sCurrentDriver
82200>>>>>            If (sLoadedDrivers <> "") Begin
82202>>>>>                Move (Append (sLoadedDrivers, ", ")) To sLoadedDrivers
82203>>>>>            End
82203>>>>>>
82203>>>>>            Get IsDataAccessCK sCurrentDriver to bOK
82204>>>>>            If (bOK) Begin
82206>>>>>                Get CKRevisionNumber sCurrentDriver to sRevNumber
82207>>>>>                Move (sCurrentDriver * "(" + sRevNumber + ")") to sCurrentDriver
82208>>>>>            End
82208>>>>>>
82208>>>>>            Move (Append (sLoadedDrivers, sCurrentDriver)) To sLoadedDrivers
82209>>>>>        Loop
82210>>>>>>
82210>>>>>        Send AppendTextLn (SFormat (C_$DatabaseDriver, sLoadedDrivers))
82211>>>>>    End_Procedure
82212>>>>>
82212>>>>>    Procedure Show_HelpFile
82214>>>>>        String sHelpFile
82214>>>>>        Integer eHelpType
82214>>>>>
82214>>>>>        If (ghoApplication <> 0) Begin
82216>>>>>            Get peHelpType Of ghoApplication To eHelpType
82217>>>>>            If (eHelpType = htHtmlHelp and ghoHtmlHelp) Begin
82219>>>>>                Get GetHelpFile Of ghoHtmlHelp To sHelpFile
82220>>>>>            End
82220>>>>>>
82220>>>>>            Else If (eHelpType = htWinHelp and Help_object_id) Begin
82223>>>>>                Get Help_filename Of Help_object_id To sHelpFile
82224>>>>>            End
82224>>>>>>
82224>>>>>            Else Begin
82225>>>>>                Move C_$ThereIsNoHelpfileDefined To sHelpFile
82226>>>>>            End
82226>>>>>>
82226>>>>>
82226>>>>>            Send AppendTextLn ""
82227>>>>>            Send AppendTextLn (SFormat (C_$HelpFile, sHelpFile))
82228>>>>>        End
82228>>>>>>
82228>>>>>    End_Procedure
82229>>>>>
82229>>>>>    Procedure Show_EnterAsTab
82231>>>>>        Boolean bEnterKeyAsTabKey
82231>>>>>        String sText
82231>>>>>
82231>>>>>        If (ghoApplication <> 0) Begin
82233>>>>>            Get pbEnterKeyAsTabKey Of ghoApplication To bEnterKeyAsTabKey
82234>>>>>            If (bEnterKeyAsTabKey) Begin
82236>>>>>                Move "True" To sText
82237>>>>>            End
82237>>>>>>
82237>>>>>            Else Begin
82238>>>>>                Move "False" To sText
82239>>>>>            End
82239>>>>>>
82239>>>>>            Send AppendTextLn (SFormat (C_$EnterKeyNavForward, sText))
82240>>>>>        End
82240>>>>>>
82240>>>>>    End_Procedure
82241>>>>>
82241>>>>>    //****************************************************************************
82241>>>>>    // $Module type: PROCEDURE
82241>>>>>    // $Module name: Add_Focus
82241>>>>>    // $Author     : VOO
82241>>>>>    // Created     : 24-09-96 @ 19:43
82241>>>>>    //
82241>>>>>    // Description
82241>>>>>    //    During activation we will remove the old information and add the newly
82241>>>>>    //    found systeminformation
82241>>>>>    //
82241>>>>>    // $Rev History
82241>>>>>    //    24-09-96  Module header created
82241>>>>>    //****************************************************************************
82241>>>>>    Procedure Add_Focus Integer hoRoot
82243>>>>>        Forward Send Add_Focus hoRoot
82245>>>>>
82245>>>>>        Send Delete_Data
82246>>>>>
82246>>>>>        Set Changed_State To False
82247>>>>>        Set Read_Only_State To True
82248>>>>>
82248>>>>>        Send Show_ServicePack
82249>>>>>        Send Show_Versions   
82250>>>>>        Send Show_Drivers         
82251>>>>>        Send Show_HelpFile
82252>>>>>        Send Show_Current_Directory
82253>>>>>        Send Show_Filelist_Name          
82254>>>>>        If (ghoApplication <> 0) Begin
82256>>>>>            Send Show_WorkSpaceInformation // added To show WS info
82257>>>>>        End
82257>>>>>>
82257>>>>>        Send Show_Current_User 
82258>>>>>        Send Show_Windows_Directory 
82259>>>>>        Send Show_Screen_Size
82260>>>>>        Send Show_Page_Size
82261>>>>>        Send Show_EnterAsTab        
82262>>>>>        Send Show_Number_Format
82263>>>>>        Send Show_Date_Format
82264>>>>>        Send Show_Lock_Delay
82265>>>>>        Send Show_Lock_Timeout
82266>>>>>        Send Show_Date
82267>>>>>        Send Show_Systemresources
82268>>>>>        Send Show_Registration
82269>>>>>        Send Beginning_of_Data
82270>>>>>
82270>>>>>        Set Icon to 'default.ico'
82271>>>>>    End_Procedure
82272>>>>>End_Class
82273>>>>>
82273>>>>>//****************************************************************************
82273>>>>>// $Module type: OBJECT
82273>>>>>// $Module name: Sysinfo_Dialog
82273>>>>>// $Author     : VOO
82273>>>>>// Created     : 24-09-96 @ 18:47
82273>>>>>//
82273>>>>>// Description
82273>>>>>//    This object shows the systeminformation on the screen
82273>>>>>//
82273>>>>>// $Rev History
82273>>>>>//    24-09-96  Module header created
82273>>>>>//****************************************************************************
82273>>>>>Class SysInfoDialog Is A ModalPanel
82274>>>>>    Procedure Construct_Object
82276>>>>>        Forward Send Construct_Object
82278>>>>>
82278>>>>>        Set Label to C_$SystemInformation
82279>>>>>        Set Size to 140 267
82280>>>>>        Set piMinSize to 140 267
82281>>>>>        Set Locate_Mode To CENTER_ON_SCREEN
82282>>>>>        Set Border_Style to Border_Thick
82283>>>>>
82283>>>>>        Object oSysinfoDisplay Is A SysInfoDisplay
82285>>>>>            Set peAnchors to anAll
82286>>>>>        End_Object
82287>>>>>
82287>>>>>        Object oCloseButton Is A Button
82289>>>>>            Set Label To C_$Close
82290>>>>>            Set Location To 120 210
82291>>>>>            Set Message Item 0 To (Refproc (Close_Panel))
82292>>>>>            Set Default_State To True
82293>>>>>            Set peAnchors to anBottomRight
82294>>>>>        End_Object
82295>>>>>
82295>>>>>        On_Key kCancel Send Close_Panel
82296>>>>>    End_Procedure
82297>>>>>End_Class
82298>>>>>
82298>>>>>// Purpose:
82298>>>>>//
82298>>>>>// Ken Ross 12/17/96 5:16PM
82298>>>>>//
82298>>>>>Class AboutDialog Is A ModalPanel
82299>>>>>    Procedure Construct_Object
82301>>>>>        String sVdfRootDir
82301>>>>>
82301>>>>>        Forward Send Construct_Object
82303>>>>>
82303>>>>>        Set Label To C_$About
82304>>>>>        Set Size to 89 212
82305>>>>>        Set Locate_Mode To CENTER_ON_SCREEN
82306>>>>>
82306>>>>>        Object oSysInfoDialog Is A SysInfoDialog
82308>>>>>        End_Object
82309>>>>>
82309>>>>>        Object oBox Is A Container3d
82311>>>>>            Set Border_Style To Border_StaticEdge
82312>>>>>            Set Size to 63 202
82313>>>>>            Set Location To 4 5
82314>>>>>
82314>>>>>            Object oAboutGraphic Is A BitmapContainer
82316>>>>>                Set Border_Style To Border_None
82317>>>>>                Set Bitmap_Style To Bitmap_Center
82318>>>>>                Set Size To 48 48
82319>>>>>                Set Location To 7 2
82320>>>>>            End_Object
82321>>>>>
82321>>>>>            Object oProductName Is A TextBox
82323>>>>>                Set Label To C_$ProductName
82324>>>>>                Set Size To 10 45
82325>>>>>                Set Location To 8 53
82326>>>>>            End_Object
82327>>>>>
82327>>>>>            Object oVersion Is A TextBox
82329>>>>>                Set Label To C_$Version
82330>>>>>                Set Size To 10 25
82331>>>>>                Set Location To 21 53
82332>>>>>            End_Object
82333>>>>>
82333>>>>>            Object oCopyright Is A TextBox
82335>>>>>                Set Label To C_$Copyright
82336>>>>>                Set Size To 10 31
82337>>>>>                Set Location To 34 53
82338>>>>>            End_Object
82339>>>>>
82339>>>>>            Object oAuthor Is A TextBox
82341>>>>>                Set Label To C_$Author
82342>>>>>                Set Size To 10 22
82343>>>>>                Set Location To 46 53
82344>>>>>            End_Object
82345>>>>>        End_Object
82346>>>>>
82346>>>>>        Object oOKButton Is A Button
82348>>>>>            On_Item C_$OK Send Close_Panel
82349>>>>>            Set Size To 14 50
82350>>>>>            Set Location To 71 157
82351>>>>>        End_Object
82352>>>>>
82352>>>>>        Object oSysInfoButton Is A Button
82354>>>>>            On_Item C_$SystemInfo Send Show_Sysinfo
82355>>>>>            Set Size To 14 50
82356>>>>>            Set Location To 71 101
82357>>>>>        End_Object
82358>>>>>
82358>>>>>        On_Key Kcancel Send KeyAction Of oOKButton
82359>>>>>
82359>>>>>        Set Logo To "DacAbout.bmp"  // square bitmaps Of 42x42 work best
82360>>>>>    End_Procedure
82361>>>>>
82361>>>>>    Procedure Set ProductName String sProductName
82363>>>>>        Set Label Of oProductName To sProductName
82364>>>>>    End_Procedure
82365>>>>>
82365>>>>>    Procedure Set Version String sVersion
82367>>>>>        Set Label Of oVersion To sVersion
82368>>>>>    End_Procedure
82369>>>>>
82369>>>>>    Procedure Set Copyright string sCopyright
82371>>>>>        Set Label Of oCopyright To sCopyright
82372>>>>>    End_Procedure
82373>>>>>
82373>>>>>    Procedure Set Author String sAuthor
82375>>>>>        Set Label Of oAuthor To sAuthor
82376>>>>>    End_Procedure
82377>>>>>
82377>>>>>    Procedure Set Logo string sLogo
82379>>>>>        // square bitmaps Of 42x42 work best
82379>>>>>        Set Bitmap Of oAboutGraphic To sLogo
82380>>>>>    End_Procedure
82381>>>>>
82381>>>>>    Procedure Show_Sysinfo
82383>>>>>        Send Popup_Modal Of oSysinfoDialog
82384>>>>>    End_Procedure
82385>>>>>
82385>>>>>    Procedure End_Construct_Object
82387>>>>>        Handle hoVersionInfo
82387>>>>>        Boolean bIncluded
82387>>>>>        Integer iMajor iMinor iRelease iBuild
82387>>>>>        String sLabel
82387>>>>>
82387>>>>>        Get Label Of oVersion To sLabel
82388>>>>>        If (sLabel = C_$VERSION) Begin
82390>>>>>            // set it To the version info Of the program, if available
82390>>>>>            If (ghoApplication <> 0) Begin
82392>>>>>                Get phoVersionInfo of ghoApplication to hoVersionInfo
82393>>>>>                If (hoVersionInfo <> 0) Begin
82395>>>>>                    Get pbIncluded of hoVersionInfo to bIncluded
82396>>>>>                    If (bIncluded) Begin
82398>>>>>                        Get piVersionMajor of hoVersionInfo to iMajor
82399>>>>>                        Get piVersionMinor of hoVersionInfo to iMinor
82400>>>>>                        Get piVersionRelease of hoVersionInfo to iRelease
82401>>>>>                        Get piVersionBuild of hoVersionInfo to iBuild
82402>>>>>                        Move (SFormat (C_$VERSION + ": %1.%2.%3.%4", iMajor, iMinor, iRelease, iBuild)) to sLabel
82403>>>>>                        Set Version to sLabel
82404>>>>>                    End
82404>>>>>>
82404>>>>>                End
82404>>>>>>
82404>>>>>            End
82404>>>>>>
82404>>>>>        End
82404>>>>>>
82404>>>>>
82404>>>>>        Forward Send End_Construct_Object
82406>>>>>    End_Procedure
82407>>>>>End_Class
82408>>>
82408>>>// *************************************************************************
82408>>>//  Public message. This is the default message. It is expected that you will
82408>>>//   create your own message to override this
82408>>>// *************************************************************************
82408>>>
82408>>>Procedure Activate_About
82411>>>   Send DoAbout "" "" "" "" ""
82412>>>End_Procedure
82413>>>
82413>>>// *************************************************************************
82413>>>//  Public message. It is expected that you will send this message (most
82413>>>//  likely from Activate_About. This creates an about object, activates it
82413>>>//  and destroys it when done. It is not exepected that you will augment this.
82413>>>// *************************************************************************
82413>>>
82413>>>Procedure DoAbout string sTitle string sVersion string sCopyRight string sAuthor string sBitmap
82416>>>        integer hoObj hoMain
82416>>>
82416>>>        // create object
82416>>>        Object About is an AboutDialog
82418>>>            // if no title passed use the label of the main panel
82418>>>            // (if a main panel exists).
82418>>>            if sTitle     eq '' Begin
82420>>>                Get Main_Window of desktop to hoMain
82421>>>                if hoMain Get Label of hoMain to sTitle
82424>>>            end
82424>>>>
82424>>>            set productname to sTitle
82425>>>            set version     to sVersion
82426>>>            set copyright   to sCopyRight
82427>>>            set author      to sAuthor
82428>>>            If sBitmap    ne '' ;               set logo to sBitMap // square bitmaps of 42x42 work best
82431>>>            Move self to hoObj // object Id
82432>>>        End_Object
82433>>>        Send Popup   of hoObj    // popup the about object
82434>>>        Send Destroy of hoObj // when done, it will be destroyed
82435>>>End_procedure
82436>        Use DemoSuggestionForm.vw
Including file: DemoSuggestionForm.vw    (C:\Test\Order Entry git\AppSrc\DemoSuggestionForm.vw)
82436>>>Use Windows.pkg
82436>>>Use DFClient.pkg
82436>>>Use dbSuggestionForm.pkg
Including file: dbSuggestionForm.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\dbSuggestionForm.pkg)
82436>>>>>Use Dfentry.pkg
82436>>>>>Use WinSuggestion.pkg
Including file: WinSuggestion.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\WinSuggestion.pkg)
82436>>>>>>>// 
82436>>>>>>>
82436>>>>>>>Use Windows.pkg
82436>>>>>>>Use tWinStructs.pkg
82436>>>>>>>Use tSuggestion.pkg
Including file: tSuggestion.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\tSuggestion.pkg)
82436>>>>>>>>>// struct used for suggestion forms, representing an item of data
82436>>>>>>>>>Enum_List 
82436>>>>>>>>>    Define smFind
82436>>>>>>>>>    Define smValidationTable
82436>>>>>>>>>    Define smCustom
82436>>>>>>>>>End_Enum_List
82436>>>>>>>>>
82436>>>>>>>>>Struct tSuggestion
82436>>>>>>>>>    String sRowId
82436>>>>>>>>>    String[] aValues
82436>>>>>>>>>End_Struct
82436>>>>>>>>>
82436>>>>>>>Use cTimer.pkg
Including file: cTimer.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cTimer.pkg)
82436>>>>>>>>>// cTimer class
82436>>>>>>>>>//
82436>>>>>>>>>// This supercedes the DFTimer class. 
82436>>>>>>>>>// It is simpler and more flexible
82436>>>>>>>>>
82436>>>>>>>>>Use Dftimer.pkg // we still use the Timer Manager classes and global objects
Including file: Dftimer.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\Dftimer.pkg)
82436>>>>>>>>>>>//************************************************************************
82436>>>>>>>>>>>//--- DFTimer   Timer package for DataFlex programs
82436>>>>>>>>>>>//
82436>>>>>>>>>>>// Copyright (c) 1983-2002 Data Access Corporation, Miami Florida,
82436>>>>>>>>>>>// All rights reserved.
82436>>>>>>>>>>>// DataFlex is a registered trademark of Data Access Corporation.
82436>>>>>>>>>>>//
82436>>>>>>>>>>>//************************************************************************
82436>>>>>>>>>>>//  Description:
82436>>>>>>>>>>>//      This package contains all components needed to implement timers
82436>>>>>>>>>>>//      in a DataFlex 4 program.
82436>>>>>>>>>>>//
82436>>>>>>>>>>>//
82436>>>>>>>>>>>//  Author: Eddy Kleinjan, Data Access Nederland
82436>>>>>>>>>>>//************************************************************************
82436>>>>>>>>>>>// 03/03/2001 EK  Fixed Timer_Active_State to check for valid windows
82436>>>>>>>>>>>//                handle before trying to set or kill a timer.
82436>>>>>>>>>>>//                Fixed Kill_All_Timers to check for valid windows
82436>>>>>>>>>>>//                handle before trying to kill a timer.
82436>>>>>>>>>>>//                The windows handle might not exist anymore when the
82436>>>>>>>>>>>//                program is being exited using Exit_Application.
82436>>>>>>>>>>>// 12/13/2001 JJT fixed Timer_Active_State to check for -1 (not 0). Fixed a
82436>>>>>>>>>>>//                a bug where set Timeout started inactive timers.
82436>>>>>>>>>>>//                Added code to force timer object to desktop
82436>>>>>>>>>>>//************************************************************************
82436>>>>>>>>>>>// CLASS DFTimer
82436>>>>>>>>>>>//
82436>>>>>>>>>>>// Usage:
82436>>>>>>>>>>>//    Object MyTimer is a DFTimer
82436>>>>>>>>>>>//
82436>>>>>>>>>>>//        Set Timeout to 2000                             // Default 1000
82436>>>>>>>>>>>//        Set Auto_Start_State to TRUE|FALSE              // Default TRUE
82436>>>>>>>>>>>//        Set Auto_Stop_State to TRUE|FALSE               // Default TRUE
82436>>>>>>>>>>>//        Set Timer_Message to MyMessage                  // Default 0
82436>>>>>>>>>>>//        Set Timer_Object to (MyObject(self))            // Default 0
82436>>>>>>>>>>>//        Set Timer_Active_State to TRUE|FALSE            // Default FALSE
82436>>>>>>>>>>>//
82436>>>>>>>>>>>//        // Augment when no Timer_Message
82436>>>>>>>>>>>//        Procedure OnTimer
82436>>>>>>>>>>>//            Send Info_Box "HEY, WAKE UP!"
82436>>>>>>>>>>>//        End_Procedure
82436>>>>>>>>>>>//
82436>>>>>>>>>>>//    End_Object
82436>>>>>>>>>>>//
82436>>>>>>>>>>>// DESCRIPTION
82436>>>>>>>>>>>//      Objects of this class can be used to trigger an event after a
82436>>>>>>>>>>>//      certain amount of time has passed. You can specify this time
82436>>>>>>>>>>>//      by setting the Timeout property of the object. This timeout
82436>>>>>>>>>>>//      is in miliseconds.
82436>>>>>>>>>>>//
82436>>>>>>>>>>>//      Whenever a timer event happens, it will notify the object by
82436>>>>>>>>>>>//      sending an OnTimer event. You can trap this event to do whatever
82436>>>>>>>>>>>//      you want the timer to do. By default this OnTimer event
82436>>>>>>>>>>>//      will send the Timer_Message to Timer_Object, when these have
82436>>>>>>>>>>>//      been specified.
82436>>>>>>>>>>>//
82436>>>>>>>>>>>//      By default, you have to activate a timer by setting its
82436>>>>>>>>>>>//      Timer_Active_State to TRUE. When the timer has been placed
82436>>>>>>>>>>>//      inside a user-interface object, it can also be activated
82436>>>>>>>>>>>//      automatically when this user-interface object is being
82436>>>>>>>>>>>//      activated. This only happes when it Auto_Start_State is TRUE,
82436>>>>>>>>>>>//      which is the default setting. In such a case, the timer will
82436>>>>>>>>>>>//      also automatically being stopped when the user-interface
82436>>>>>>>>>>>//      object is taken of the screen. This depends on the
82436>>>>>>>>>>>//      Auto_Stop_Timer state to happen.
82436>>>>>>>>>>>//
82436>>>>>>>>>>>//      When you need to set a new timeout value, you can do so
82436>>>>>>>>>>>//      even when the timer is active. It will adjust the timeout
82436>>>>>>>>>>>//      immediately.
82436>>>>>>>>>>>//
82436>>>>>>>>>>>//      Note that timer events depend on Windows for the delivery of
82436>>>>>>>>>>>//      the event. Since timer events get a low priority in Windows,
82436>>>>>>>>>>>//      it might put your program on hold when other programs are very
82436>>>>>>>>>>>//      busy. In such a case, you will only receive one timer event
82436>>>>>>>>>>>//      after the process stopped. There is no way, other than
82436>>>>>>>>>>>//      calculating it yourself, to determine how many time has passed
82436>>>>>>>>>>>//      or how many timer event should have happened since the last
82436>>>>>>>>>>>//      timer event or timer activation.
82436>>>>>>>>>>>//
82436>>>>>>>>>>>// PUBLIC INTERFACE
82436>>>>>>>>>>>//
82436>>>>>>>>>>>//    PROPERTIES
82436>>>>>>>>>>>//
82436>>>>>>>>>>>//    Auto_Start_State When TRUE (default) the timer will be activated
82436>>>>>>>>>>>//                     automatically when the object will be (virtually)
82436>>>>>>>>>>>//                     paged on the screen.
82436>>>>>>>>>>>//                     Example: When a timer object has been placed
82436>>>>>>>>>>>//                     inside a view, then the timer will be activated
82436>>>>>>>>>>>//                     when the view is activated.
82436>>>>>>>>>>>//
82436>>>>>>>>>>>//    Auto_Stop_State  When TRUE (default) the timer will be deactivated
82436>>>>>>>>>>>//                     automatically when the object will be (virtually)
82436>>>>>>>>>>>//                     taken off the screen.
82436>>>>>>>>>>>//
82436>>>>>>>>>>>//    Timeout          The timeout value for the timer to fire. The
82436>>>>>>>>>>>//                     timeout value must be set in miliseconds.
82436>>>>>>>>>>>//                     This property may be set even when the timer is
82436>>>>>>>>>>>//                     active. The new timeout value will be applied
82436>>>>>>>>>>>//                     immediately.
82436>>>>>>>>>>>//                     NOTE: The timeout set here is never precise. It
82436>>>>>>>>>>>//                     depends on Windows to deliver the message to our
82436>>>>>>>>>>>//                     application.
82436>>>>>>>>>>>//                     Default 1000.
82436>>>>>>>>>>>//
82436>>>>>>>>>>>//    Timer_Active_State
82436>>>>>>>>>>>//                     Set to TRUE to activate the timer, to FALSE to
82436>>>>>>>>>>>//                     deactivate the timer.
82436>>>>>>>>>>>//
82436>>>>>>>>>>>//
82436>>>>>>>>>>>//    Timer_Message    This property can be set to a messageID which has
82436>>>>>>>>>>>//                     to be sent whenever a timer event occurs. Default
82436>>>>>>>>>>>//                     this message will be send to the object itself
82436>>>>>>>>>>>//                     unless a Timer_Object as been specified.
82436>>>>>>>>>>>//
82436>>>>>>>>>>>//    Timer_Object     This property can be set to an objectID which has
82436>>>>>>>>>>>//                     to receive the Timer_Message whenever a timer
82436>>>>>>>>>>>//                     event occurs. This value has no meaning when
82436>>>>>>>>>>>//                     no Timer_Message has been set.
82436>>>>>>>>>>>//
82436>>>>>>>>>>>//    METHODS
82436>>>>>>>>>>>//
82436>>>>>>>>>>>//    OnTimer          This event will happen whenever the specified
82436>>>>>>>>>>>//                     amount of time has passed and the timer is
82436>>>>>>>>>>>//                     active. By default it sends the message in
82436>>>>>>>>>>>//                     the Timer_Message property to the object in
82436>>>>>>>>>>>//                     the Timer_Object when these have been specified.
82436>>>>>>>>>>>//                     When you don't need this, you can just override
82436>>>>>>>>>>>//                     the OnTimer event.
82436>>>>>>>>>>>//
82436>>>>>>>>>>>// PUBLIC INTERFACE
82436>>>>>>>>>>>//
82436>>>>>>>>>>>//    Page_Object      Has been augmented to auto_start the timer when
82436>>>>>>>>>>>//                     it becomes active as part or a user-interface
82436>>>>>>>>>>>//                     object.
82436>>>>>>>>>>>//
82436>>>>>>>>>>>//    Page_Delete      Has been augmented to auto_stop the timer when
82436>>>>>>>>>>>//                     it is deactivated as part or a user-interface
82436>>>>>>>>>>>//                     object.
82436>>>>>>>>>>>//
82436>>>>>>>>>>>//    Destroy_Object   Has been augmented to deactivate the timer.
82436>>>>>>>>>>>//
82436>>>>>>>>>>>Use LanguageText.pkg
82436>>>>>>>>>>>Use Windows.pkg
82436>>>>>>>>>>>Use WinUser.pkg
82436>>>>>>>>>>>
82436>>>>>>>>>>>External_Function SetTimer "SetTimer" User32.DLL ;    Integer hWnd ;    Integer idTimer ;    Integer idTimeout ;    Pointer tmprc ;    Returns Integer
82437>>>>>>>>>>>
82437>>>>>>>>>>>External_Function KillTimer "KillTimer" User32.DLL ;    Integer hWnd ;    Integer idTimer ;    Returns Integer
82438>>>>>>>>>>>
82438>>>>>>>>>>>// This global integer holds the ID of the object
82438>>>>>>>>>>>// that manages all timers.
82438>>>>>>>>>>>Integer giTimerManager
82438>>>>>>>>>>>
82438>>>>>>>>>>>// This class is used to store the object IDs
82438>>>>>>>>>>>// of the active timer objects. It augments
82438>>>>>>>>>>>// the Destroy_Object procedure to notify
82438>>>>>>>>>>>// the DFTimerManager to kill all its active
82438>>>>>>>>>>>// timers.
82438>>>>>>>>>>>// NOTE: This class looks very much like the
82438>>>>>>>>>>>// Set class. I didn't want to use Set because
82438>>>>>>>>>>>// Remove_Element shifts items which I don't
82438>>>>>>>>>>>// want to happen because item numbers are used
82438>>>>>>>>>>>// as timerIDs.
82438>>>>>>>>>>>
82438>>>>>>>>>>>Class TimersArray is an Array
82439>>>>>>>>>>>
82439>>>>>>>>>>>    Function Find_Object Integer iObj Returns Integer
82441>>>>>>>>>>>        Integer iMax
82441>>>>>>>>>>>        Integer iItem
82441>>>>>>>>>>>        Integer iValue
82441>>>>>>>>>>>        Get Item_count to iMax
82442>>>>>>>>>>>        Decrement iMax
82443>>>>>>>>>>>        For iItem from 1 to iMax
82449>>>>>>>>>>>>
82449>>>>>>>>>>>            Get Integer_Value item iItem to iValue
82450>>>>>>>>>>>            If iValue EQ iObj;                Function_Return iItem
82453>>>>>>>>>>>        Loop
82454>>>>>>>>>>>>
82454>>>>>>>>>>>        Function_Return -1
82455>>>>>>>>>>>    End_Function
82456>>>>>>>>>>>
82456>>>>>>>>>>>    Procedure Add_Object Integer iObj Returns Integer
82458>>>>>>>>>>>        Integer iItem
82458>>>>>>>>>>>        Get Find_Object iObj to iItem
82459>>>>>>>>>>>        If iItem LT 0 Begin
82461>>>>>>>>>>>            Get Find_Object 0 to iItem
82462>>>>>>>>>>>            If iItem LT 0 ;                Get Item_Count to iItem
82465>>>>>>>>>>>        End
82465>>>>>>>>>>>>
82465>>>>>>>>>>>        Set Array_Value item iItem to iObj
82466>>>>>>>>>>>        Procedure_Return iItem
82467>>>>>>>>>>>    End_Procedure
82468>>>>>>>>>>>
82468>>>>>>>>>>>    Procedure Remove_Object Integer iObj
82470>>>>>>>>>>>        Integer iItem
82470>>>>>>>>>>>        Get Find_Object iObj to iItem
82471>>>>>>>>>>>        If iItem GT 0 ;            Set Array_Value item iItem to 0
82474>>>>>>>>>>>    End_Procedure
82475>>>>>>>>>>>
82475>>>>>>>>>>>    Procedure Destroy_Object
82477>>>>>>>>>>>        Delegate Send Kill_All_Timers
82479>>>>>>>>>>>        Forward Send Destroy_Object
82481>>>>>>>>>>>    End_Procedure
82482>>>>>>>>>>>
82482>>>>>>>>>>>End_Class // TimersArray
82483>>>>>>>>>>>
82483>>>>>>>>>>>// This class is the actual timer manager
82483>>>>>>>>>>>// A timer will be created when Message Set_Timer_Active_State
82483>>>>>>>>>>>// has been send. This message needs two arguments. The first
82483>>>>>>>>>>>// is the objectID of the object to receive the timer event,
82483>>>>>>>>>>>// and the second is state. The object which ID has been passed,
82483>>>>>>>>>>>// needs to have a Timeout property to return the timeout for the
82483>>>>>>>>>>>// timer and it also needs to handle the MSG_OnTimer whenever a
82483>>>>>>>>>>>// timer event occurs.
82483>>>>>>>>>>>// The objectID of the Object will be placed in an array which contains
82483>>>>>>>>>>>// the objectIDs of all active timers. The Windows timer ID of a timer
82483>>>>>>>>>>>// is the itemnumber of the object in the array.
82483>>>>>>>>>>>//
82483>>>>>>>>>>>Class DFTimerManager is a DfBaseControl
82484>>>>>>>>>>>
82484>>>>>>>>>>>    Procedure Construct_Object
82486>>>>>>>>>>>
82486>>>>>>>>>>>        Forward Send Construct_Object
82488>>>>>>>>>>>
82488>>>>>>>>>>>        Set Visible_State to FALSE
82489>>>>>>>>>>>
82489>>>>>>>>>>>        Set External_Class_Name "cVdfTimer" to "static"
82490>>>>>>>>>>>        Set External_Message WM_TIMER to OnTimer
82491>>>>>>>>>>>
82491>>>>>>>>>>>        Object TimersArray is a TimersArray
82493>>>>>>>>>>>            Set Array_Value item 0 to -9999 // So we don't use item 0
82494>>>>>>>>>>>        End_Object
82495>>>>>>>>>>>
82495>>>>>>>>>>>        Move self to giTimerManager
82496>>>>>>>>>>>
82496>>>>>>>>>>>    End_Procedure
82497>>>>>>>>>>>
82497>>>>>>>>>>>    Procedure Set Timer_Active_State Integer iObj Integer iState
82499>>>>>>>>>>>        Integer iTimerID
82499>>>>>>>>>>>        Integer iTimeout
82499>>>>>>>>>>>        Integer iResult
82499>>>>>>>>>>>        Integer iSet
82499>>>>>>>>>>>        Dword   nResult
82499>>>>>>>>>>>        Handle  hWnd
82499>>>>>>>>>>>
82499>>>>>>>>>>>        // Get the handle of this object
82499>>>>>>>>>>>        Get Window_Handle to hWnd
82500>>>>>>>>>>>        If (Not(hWnd)) Begin
82502>>>>>>>>>>>            Error DFERR_DFTIMER C_$TimerNoHandle
82503>>>>>>>>>>>>
82503>>>>>>>>>>>            Procedure_Return
82504>>>>>>>>>>>        End
82504>>>>>>>>>>>>
82504>>>>>>>>>>>
82504>>>>>>>>>>>        // Test if handle is valid. If not, we leave.
82504>>>>>>>>>>>        If (Not(IsWindow(hWnd))) ;            Procedure_Return
82507>>>>>>>>>>>
82507>>>>>>>>>>>        Move (TimersArray(self)) to iSet
82508>>>>>>>>>>>
82508>>>>>>>>>>>        If (iSet) Begin
82510>>>>>>>>>>>
82510>>>>>>>>>>>            // Let's create or modify a timer
82510>>>>>>>>>>>            If iState Begin
82512>>>>>>>>>>>
82512>>>>>>>>>>>                // Get the exising to new TimerID
82512>>>>>>>>>>>                Get MSG_Add_Object of iSet iObj to iTimerID
82513>>>>>>>>>>>
82513>>>>>>>>>>>                // Set/Modify the timer
82513>>>>>>>>>>>                Get Timeout of iObj to iTimeout
82514>>>>>>>>>>>                Move (SetTimer(hWnd, iTimerID, iTimeout, 0)) to iResult
82515>>>>>>>>>>>                If Not iResult Begin
82517>>>>>>>>>>>                    Error DFERR_DFTIMER C_$TooManyTimers
82518>>>>>>>>>>>>
82518>>>>>>>>>>>                    Procedure_Return
82519>>>>>>>>>>>                End
82519>>>>>>>>>>>>
82519>>>>>>>>>>>
82519>>>>>>>>>>>            End
82519>>>>>>>>>>>>
82519>>>>>>>>>>>
82519>>>>>>>>>>>            // Let's kill an existing timer
82519>>>>>>>>>>>            Else Begin
82520>>>>>>>>>>>
82520>>>>>>>>>>>                // Look up the object in the set
82520>>>>>>>>>>>                Get Find_Object of iSet iObj to iTimerID
82521>>>>>>>>>>>
82521>>>>>>>>>>>                If iTimerID EQ -1 ;                    Procedure_Return
82524>>>>>>>>>>>
82524>>>>>>>>>>>                // Kill the timer
82524>>>>>>>>>>>                Move (KillTimer(hWnd, iTimerID)) to iResult
82525>>>>>>>>>>>                If Not iResult Begin
82527>>>>>>>>>>>                    Move (GetLastError()) to nResult
82528>>>>>>>>>>>                    Error DFERR_DFTIMER (C_$CantKillTimer * string(nResult) - "!")
82529>>>>>>>>>>>>
82529>>>>>>>>>>>                    Procedure_Return
82530>>>>>>>>>>>                End
82530>>>>>>>>>>>>
82530>>>>>>>>>>>
82530>>>>>>>>>>>                // Remove the objectID
82530>>>>>>>>>>>                Send Remove_Object to iSet iObj
82531>>>>>>>>>>>            End
82531>>>>>>>>>>>>
82531>>>>>>>>>>>        End
82531>>>>>>>>>>>>
82531>>>>>>>>>>>    End_Procedure
82532>>>>>>>>>>>
82532>>>>>>>>>>>    Function Timer_Active_State Integer iObj Returns Integer
82534>>>>>>>>>>>        Integer iResult
82534>>>>>>>>>>>        Get Find_Object of (TimersArray(self)) iObj to iResult
82535>>>>>>>>>>>        Function_Return (iResult<>-1) // note: -1= not found
82536>>>>>>>>>>>    End_Function
82537>>>>>>>>>>>
82537>>>>>>>>>>>    // Will be called by the Set when it is being destroyed.
82537>>>>>>>>>>>    Procedure Kill_All_Timers
82539>>>>>>>>>>>        Integer iMax
82539>>>>>>>>>>>        Integer iSet
82539>>>>>>>>>>>        Integer iItem
82539>>>>>>>>>>>        Integer iObj
82539>>>>>>>>>>>        Integer iResult
82539>>>>>>>>>>>        Handle  hWnd
82539>>>>>>>>>>>
82539>>>>>>>>>>>        // Get the handle of this object
82539>>>>>>>>>>>        Get Window_Handle to hWnd
82540>>>>>>>>>>>        If (Not(hWnd)) Begin
82542>>>>>>>>>>>            Error DFERR_DFTIMER C_$TimerNoHandle
82543>>>>>>>>>>>>
82543>>>>>>>>>>>            Procedure_Return
82544>>>>>>>>>>>        End
82544>>>>>>>>>>>>
82544>>>>>>>>>>>
82544>>>>>>>>>>>        // If the window handle is no longer valid, we
82544>>>>>>>>>>>        // leave this procedure. This can happen when the
82544>>>>>>>>>>>        // program is begin aborted using Exit_Application
82544>>>>>>>>>>>        If (Not(IsWindow(hWnd))) ;            Procedure_Return
82547>>>>>>>>>>>
82547>>>>>>>>>>>        // Scan the set and kill all known timers
82547>>>>>>>>>>>        Move (TimersArray(self)) to iSet
82548>>>>>>>>>>>        If (iSet) Begin
82550>>>>>>>>>>>            Get Item_Count of iSet to iMax
82551>>>>>>>>>>>            Decrement iMax
82552>>>>>>>>>>>            For iItem From 1 to iMax
82558>>>>>>>>>>>>
82558>>>>>>>>>>>                Get Integer_Value of iSet item iItem to iObj
82559>>>>>>>>>>>                If iObj Begin
82561>>>>>>>>>>>                    Move (KillTimer(hWnd, iItem)) to iResult
82562>>>>>>>>>>>                    Set Array_Value of iSet item iItem to 0
82563>>>>>>>>>>>                End
82563>>>>>>>>>>>>
82563>>>>>>>>>>>            Loop
82564>>>>>>>>>>>>
82564>>>>>>>>>>>        End
82564>>>>>>>>>>>>
82564>>>>>>>>>>>
82564>>>>>>>>>>>    End_Procedure
82565>>>>>>>>>>>
82565>>>>>>>>>>>    Procedure OnTimer Integer wParam Integer lParam
82567>>>>>>>>>>>        Integer iObj
82567>>>>>>>>>>>        Get Integer_Value of (TimersArray(self)) item wParam to iObj
82568>>>>>>>>>>>        If Not iObj Begin
82570>>>>>>>>>>>            Error DFERR_DFTIMER C_$TimerWithoutObject
82571>>>>>>>>>>>>
82571>>>>>>>>>>>            Procedure_Return
82572>>>>>>>>>>>        End
82572>>>>>>>>>>>>
82572>>>>>>>>>>>        Send OnTimer to iObj wParam lParam
82573>>>>>>>>>>>    End_Procedure
82574>>>>>>>>>>>
82574>>>>>>>>>>>    Procedure Destroy_Object
82576>>>>>>>>>>>        Send Kill_All_Timers
82577>>>>>>>>>>>        Forward Send Destroy_Object
82579>>>>>>>>>>>        Move 0 to giTimerManager
82580>>>>>>>>>>>    End_Procedure
82581>>>>>>>>>>>
82581>>>>>>>>>>>End_Class // DFTimerManger
82582>>>>>>>>>>>
82582>>>>>>>>>>>
82582>>>>>>>>>>>
82582>>>>>>>>>>>
82582>>>>>>>>>>>// This class acts as a container for the
82582>>>>>>>>>>>// timer manager object. This is needed because
82582>>>>>>>>>>>// A DFTimerManager object created directly at the
82582>>>>>>>>>>>// desktop doesn't have a Window_Handle which we
82582>>>>>>>>>>>// need to create a Windoows timer. By placing
82582>>>>>>>>>>>// this non-visual container around the timer
82582>>>>>>>>>>>// manager, it does get a Window_Handle.
82582>>>>>>>>>>>// The procedure End_Construct_Object has been
82582>>>>>>>>>>>// augmented to create a window and also
82582>>>>>>>>>>>// automatically page all children, which will
82582>>>>>>>>>>>// be the timer manager.
82582>>>>>>>>>>>//
82582>>>>>>>>>>>Class DFTimerManagerPanel is a dfBasePanel
82583>>>>>>>>>>>
82583>>>>>>>>>>>    Procedure Construct_Object
82585>>>>>>>>>>>        Forward Send Construct_Object
82587>>>>>>>>>>>        Set Visible_State to FALSE
82588>>>>>>>>>>>        Object DFTimerManager is a DFTimerManager
82590>>>>>>>>>>>        End_Object
82591>>>>>>>>>>>    End_Procedure
82592>>>>>>>>>>>
82592>>>>>>>>>>>    Procedure End_Construct_Object
82594>>>>>>>>>>>        Forward Send End_Construct_Object
82596>>>>>>>>>>>        Send Page_Object TRUE
82597>>>>>>>>>>>        Broadcast Send Page_Object TRUE
82599>>>>>>>>>>>    End_Procedure
82600>>>>>>>>>>>
82600>>>>>>>>>>>End_Class
82601>>>>>>>>>>>
82601>>>>>>>>>>>// This is the class the user uses to create DFTimer objects
82601>>>>>>>>>>>
82601>>>>>>>>>>>
82601>>>>>>>>>>>//{ OverrideProperty=Skip_State DesignTime=False }
82601>>>>>>>>>>>//{ OverrideProperty=TypeFace DesignTime=False }
82601>>>>>>>>>>>Class DFTimer is a Textbox
82602>>>>>>>>>>>
82602>>>>>>>>>>>    Procedure Construct_Object
82604>>>>>>>>>>>        Forward Send Construct_Object
82606>>>>>>>>>>>
82606>>>>>>>>>>>        // Make sure this object never appears
82606>>>>>>>>>>>        Set Visible_State to FALSE
82607>>>>>>>>>>>
82607>>>>>>>>>>>        Property Integer Private.Timeout    1000
82608>>>>>>>>>>>
82608>>>>>>>>>>>        Property Integer Timer_Message      0
82609>>>>>>>>>>>        Property Integer Timer_Object       0
82610>>>>>>>>>>>        Property Integer Auto_Start_State   True
82611>>>>>>>>>>>        Property Integer Auto_Stop_State    True
82612>>>>>>>>>>>    End_Procedure
82613>>>>>>>>>>>
82613>>>>>>>>>>>    Procedure Set Timer_Active_State Integer iState
82615>>>>>>>>>>>        Integer iObj
82615>>>>>>>>>>>        Move self to iObj
82616>>>>>>>>>>>        If giTimerManager ;            Set Timer_Active_State of giTimerManager iObj to iState
82619>>>>>>>>>>>    End_Procedure
82620>>>>>>>>>>>
82620>>>>>>>>>>>    Function Timer_Active_State Returns Integer
82622>>>>>>>>>>>        Integer iState
82622>>>>>>>>>>>        Integer iObj
82622>>>>>>>>>>>        Move self to iObj
82623>>>>>>>>>>>        If giTimerManager ;            Get Timer_Active_State of giTimerManager iObj to iState
82626>>>>>>>>>>>        Function_Return iState
82627>>>>>>>>>>>    End_Function
82628>>>>>>>>>>>
82628>>>>>>>>>>>    Procedure Set Timeout Integer iTimeout
82630>>>>>>>>>>>        Integer iActive
82630>>>>>>>>>>>        Set Private.Timeout to iTimeout
82631>>>>>>>>>>>        Get Timer_Active_State to iActive
82632>>>>>>>>>>>        If iActive ;            Set Timer_Active_State to TRUE
82635>>>>>>>>>>>    End_Procedure
82636>>>>>>>>>>>
82636>>>>>>>>>>>    Function Timeout Returns Integer
82638>>>>>>>>>>>        Integer iTimeout
82638>>>>>>>>>>>        Get Private.Timeout to iTimeout
82639>>>>>>>>>>>        Function_Return iTimeout
82640>>>>>>>>>>>    End_Function
82641>>>>>>>>>>>
82641>>>>>>>>>>>    Procedure OnTimer Integer iwParam Integer ilParam
82643>>>>>>>>>>>        Integer iMsg
82643>>>>>>>>>>>        Integer iObj
82643>>>>>>>>>>>        Get Timer_Message to iMsg
82644>>>>>>>>>>>        If (iMsg) Begin
82646>>>>>>>>>>>            Get Timer_Object  to iObj
82647>>>>>>>>>>>            If iObj ;                Send iMsg to iObj iwParam ilParam
82650>>>>>>>>>>>            Else ;                Send iMsg iwParam ilParam
82652>>>>>>>>>>>        End
82652>>>>>>>>>>>>
82652>>>>>>>>>>>    End_Procedure
82653>>>>>>>>>>>
82653>>>>>>>>>>>    // Augmented to Auto_Start a timer
82653>>>>>>>>>>>    //
82653>>>>>>>>>>>    Procedure Page_Object Integer iState
82655>>>>>>>>>>>        Forward Send Page_Object iState
82657>>>>>>>>>>>        If (iState AND Auto_Start_State(self)) ;            Set Timer_Active_State to TRUE
82660>>>>>>>>>>>    End_Procedure
82661>>>>>>>>>>>
82661>>>>>>>>>>>    // Augmented to Auto_Stop a timer
82661>>>>>>>>>>>    //
82661>>>>>>>>>>>    Procedure Page_Delete
82663>>>>>>>>>>>        If (Auto_Stop_State(self)) ;            Set Timer_Active_State to FALSE
82666>>>>>>>>>>>        Forward Send Page_Delete
82668>>>>>>>>>>>    End_Procedure
82669>>>>>>>>>>>
82669>>>>>>>>>>>    // Augmented to stop the timer
82669>>>>>>>>>>>    //
82669>>>>>>>>>>>    Procedure Destroy_Object
82671>>>>>>>>>>>        Set Timer_Active_State to FALSE
82672>>>>>>>>>>>        Forward Send Destroy_Object
82674>>>>>>>>>>>    End_Procedure
82675>>>>>>>>>>>
82675>>>>>>>>>>>End_Class // DFTimer
82676>>>>>>>>>>>
82676>>>>>>>>>>>//
82676>>>>>>>>>>>// This was moved into a method so it can be reliable created
82676>>>>>>>>>>>// at the desktop. Note that cDesktop adds method to cDesktop class (class of desktop)
82676>>>>>>>>>>>//
82676>>>>>>>>>>>Procedure CreateDfTimerManagerPanel FOR cDesktop
82678>>>>>>>>>>>    // Create the Desktop Timer Manager Object.
82678>>>>>>>>>>>    Object DFTimerManagerPanel is a DFTimerManagerPanel
82680>>>>>>>>>>>    End_Object
82681>>>>>>>>>>>End_Procedure
82682>>>>>>>>>>>
82682>>>>>>>>>>>Send CreateDfTimerManagerPanel of DESKTOP
82683>>>>>>>>>>>
82683>>>>>>>>>
82683>>>>>>>>>Class cTimer is a cObject
82684>>>>>>>>>
82684>>>>>>>>>    Procedure Construct_Object
82686>>>>>>>>>        Forward Send Construct_Object
82688>>>>>>>>>        Property Integer piPrivate_Timeout 1000
82689>>>>>>>>>    End_Procedure
82690>>>>>>>>>
82690>>>>>>>>>    Procedure Set pbEnabled Boolean bEnabled
82692>>>>>>>>>        If giTimerManager Begin
82694>>>>>>>>>            Set Timer_Active_State of giTimerManager Self to bEnabled
82695>>>>>>>>>        End
82695>>>>>>>>>>
82695>>>>>>>>>    End_Procedure
82696>>>>>>>>>
82696>>>>>>>>>    Function pbEnabled Returns Boolean
82698>>>>>>>>>        Boolean bEnabled
82698>>>>>>>>>        If giTimerManager Begin
82700>>>>>>>>>            Get Timer_Active_State of giTimerManager Self to bEnabled
82701>>>>>>>>>        End
82701>>>>>>>>>>
82701>>>>>>>>>        Function_Return bEnabled
82702>>>>>>>>>    End_Function
82703>>>>>>>>>
82703>>>>>>>>>    Procedure Set piTimeout Integer iTimeout
82705>>>>>>>>>        Boolean bEnabled
82705>>>>>>>>>        Set piPrivate_Timeout to iTimeout
82706>>>>>>>>>        Get pbEnabled to bEnabled
82707>>>>>>>>>        If bEnabled Begin
82709>>>>>>>>>            Set pbEnabled to True
82710>>>>>>>>>        End
82710>>>>>>>>>>
82710>>>>>>>>>    End_Procedure
82711>>>>>>>>>
82711>>>>>>>>>    Function piTimeout Returns Integer
82713>>>>>>>>>        Integer iTimeout
82713>>>>>>>>>        Get piPrivate_Timeout to iTimeout
82714>>>>>>>>>        Function_Return iTimeout
82715>>>>>>>>>    End_Function
82716>>>>>>>>>
82716>>>>>>>>>    Procedure OnTimer
82718>>>>>>>>>    End_Procedure
82719>>>>>>>>>    
82719>>>>>>>>>    // this is needed by the timer manager 
82719>>>>>>>>>    Function Timeout Returns Integer
82721>>>>>>>>>        Integer iTimeout
82721>>>>>>>>>        Get piPrivate_Timeout to iTimeout
82722>>>>>>>>>        Function_Return iTimeout
82723>>>>>>>>>    End_Function
82724>>>>>>>>>
82724>>>>>>>>>    Procedure Destroy_Object
82726>>>>>>>>>        Set pbEnabled to False
82727>>>>>>>>>        Forward Send Destroy_Object
82729>>>>>>>>>    End_Procedure
82730>>>>>>>>>
82730>>>>>>>>>End_Class
82731>>>>>>>Use cRichEdit.pkg
Including file: cRichEdit.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cRichEdit.pkg)
82731>>>>>>>>>use Windows.pkg
82731>>>>>>>>>Use cEdit_Mixin.pkg
82731>>>>>>>>>
82731>>>>>>>>>// DFO: cRichEdit.Dfo
82731>>>>>>>>>// DFC: cRichEdit.Dfc
82731>>>>>>>>>
82731>>>>>>>>>// constants used for RichEdit Properties
82731>>>>>>>>>// peAlignment 
82731>>>>>>>>>Enum_List 
82731>>>>>>>>>    Define alLeft   for 1 
82731>>>>>>>>>    Define alRight  for 2 
82731>>>>>>>>>    Define alCenter for 3 
82731>>>>>>>>>End_Enum_List 
82731>>>>>>>>>
82731>>>>>>>>>// peBullets 
82731>>>>>>>>>Enum_List 
82731>>>>>>>>>    Define buNone 
82731>>>>>>>>>    Define buBullets 
82731>>>>>>>>>    Define buArabicNumbers 
82731>>>>>>>>>    Define buLowerLetters 
82731>>>>>>>>>    Define buUpperLetters 
82731>>>>>>>>>    Define buLowerRomans 
82731>>>>>>>>>    Define buUpperRomans 
82731>>>>>>>>>End_Enum_List 
82731>>>>>>>>>
82731>>>>>>>>>// peBulletStyle 
82731>>>>>>>>>Enum_List 
82731>>>>>>>>>    Define busRightParen   for 0 
82731>>>>>>>>>    Define busEncloseParen for 256 
82731>>>>>>>>>    Define busPeriod       for 512 
82731>>>>>>>>>    Define busNumberOnly   for 768 
82731>>>>>>>>>    Define busNoDisplay    for 1024 
82731>>>>>>>>>End_Enum_List
82731>>>>>>>>>    
82731>>>>>>>>>// peLineSpacingType
82731>>>>>>>>>Enum_List 
82731>>>>>>>>>    Define lstSingle
82731>>>>>>>>>    Define lstSingleAndOneHalf
82731>>>>>>>>>    Define lstDouble
82731>>>>>>>>>End_Enum_List
82731>>>>>>>>>
82731>>>>>>>>>Class cRichEdit Is A DFBaseRichEdit
82732>>>>>>>>>
82732>>>>>>>>>    Procedure Construct_Object
82734>>>>>>>>>        Forward Send Construct_Object
82736>>>>>>>>>        Send Define_cEdit_Mixin
82737>>>>>>>>>
82737>>>>>>>>>        On_key Key_Ctrl+Key_B send ToggleBold
82738>>>>>>>>>        On_key Key_Ctrl+Key_I send ToggleItalics
82739>>>>>>>>>        On_key Key_Ctrl+Key_U send ToggleUnderline
82740>>>>>>>>>
82740>>>>>>>>>    End_Procedure // Construct_Object
82741>>>>>>>>>
82741>>>>>>>>>    Import_Class_Protocol cEdit_Mixin
82742>>>>>>>>>    
82742>>>>>>>>>    Procedure ToggleBold
82744>>>>>>>>>        Set pbBold to (not(pbBold(self))) 
82745>>>>>>>>>    end_procedure
82746>>>>>>>>>    
82746>>>>>>>>>    Procedure ToggleItalics
82748>>>>>>>>>        Set pbItalics to (not(pbItalics(self))) 
82749>>>>>>>>>    end_procedure
82750>>>>>>>>>    
82750>>>>>>>>>    Procedure ToggleUnderline
82752>>>>>>>>>       Set pbUnderLine to (not(pbUnderLine(self))) 
82753>>>>>>>>>    end_procedure
82754>>>>>>>>>
82754>>>>>>>>>End_Class
82755>>>>>>>>>
82755>>>>>>>Use sql.pkg
Including file: sql.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\sql.pkg)
82755>>>>>>>>>//*****************************************************************************
82755>>>>>>>>>//*** SQL.pkg                                                               ***
82755>>>>>>>>>//***                                                                       ***
82755>>>>>>>>>//*** Author: Ben Weijers                                                   ***
82755>>>>>>>>>//***         Data Access Wordwide                                          ***
82755>>>>>>>>>//***         14 February 2000                                              ***
82755>>>>>>>>>//***                                                                       ***
82755>>>>>>>>>//*** Purpose:                                                              ***
82755>>>>>>>>>//***       Embedded SQL classes for use with Data Access Worldwide CLI     ***
82755>>>>>>>>>//***       Connectivty Kits.                                               ***
82755>>>>>>>>>//***                                                                       ***
82755>>>>>>>>>//*** Last update:                                                          ***
82755>>>>>>>>>//***       February 2014. Current CLI Connectivity Kit 6.0.0.28            ***
82755>>>>>>>>>//***                                                                       ***
82755>>>>>>>>>//*** !! Please Note !!                                                     ***
82755>>>>>>>>>//***       -This version of sql.pkg will only work with CLI Connectivity   ***
82755>>>>>>>>>//***        Kits 6.0.0.28 or later.                                        ***
82755>>>>>>>>>//***       -This version of sql.pkg will no longer function with DataFlex  ***
82755>>>>>>>>>//***        character mode (DataFlex 3.2). To use embedded SQL with        ***
82755>>>>>>>>>//**         DataFlex character mode, use sqlold.pkg.                       ***
82755>>>>>>>>>//***       -This version of sql.pkg no longer contains the embedded SQL    ***
82755>>>>>>>>>//***        command interface. The command interface is still available    ***
82755>>>>>>>>>//***        in sqlold.pkg                                                  ***
82755>>>>>>>>>//***                                                                       ***
82755>>>>>>>>>//*** Changes:                                                              ***
82755>>>>>>>>>//***       February 2014. CLI Connectivity Kit 6.0.0.28                    ***
82755>>>>>>>>>//***                                                                       ***
82755>>>>>>>>>//***       Several performances improvements to speed up SQLColumnValue    ***
82755>>>>>>>>>//***       and SQLGetData                                                  ***
82755>>>>>>>>>//***                                                                       ***
82755>>>>>>>>>//***       New functions:                                                  ***
82755>>>>>>>>>//***           Function SQLFetchRowValues Returns String[]                 ***
82755>>>>>>>>>//***               Fetches a row and returns all columns in an array.      ***
82755>>>>>>>>>//***                                                                       ***
82755>>>>>>>>>//***           Function SQLFetchResultsetValues Returns String[][]         ***
82755>>>>>>>>>//***               Fetches all rows of a result set and returns the        ***
82755>>>>>>>>>//***               result set as a 2-dimensial array.                      ***
82755>>>>>>>>>//***                                                                       ***
82755>>>>>>>>>//*****************************************************************************
82755>>>>>>>>>
82755>>>>>>>>>Use CLI.pkg
82755>>>>>>>>>
82755>>>>>>>>>//*** Global storage for results
82755>>>>>>>>>Integer SQLResult
82755>>>>>>>>>
82755>>>>>>>>>//*** Embedded SQL function constants
82755>>>>>>>>>Define FUNC_SQLCONNECT             For 1000000
82755>>>>>>>>>Define FUNC_SQLFILECONNECT         For 1000001
82755>>>>>>>>>Define FUNC_SQLDISCONNECT          For 1000002
82755>>>>>>>>>Define FUNC_SQLOPEN                For 1000003
82755>>>>>>>>>Define FUNC_SQLCLOSE               For 1000004
82755>>>>>>>>>Define FUNC_SQLPREPARE             For 1000005
82755>>>>>>>>>Define FUNC_SQLEXECUTE             For 1000006
82755>>>>>>>>>Define FUNC_SQLEXECDIRECT          For 1000007
82755>>>>>>>>>Define FUNC_SQLFETCH               For 1000008
82755>>>>>>>>>Define FUNC_SQLCOLUMNINFO          For 1000009
82755>>>>>>>>>Define FUNC_SQLCOLUMNVALUE         For 1000010
82755>>>>>>>>>Define FUNC_SQLBINDFILE            For 1000011
82755>>>>>>>>>Define FUNC_SQLGETDATA             For 1000012
82755>>>>>>>>>Define FUNC_SQLCOLSTRINGATTRIBLEN  For 1000013
82755>>>>>>>>>Define FUNC_SQLCOLSTRINGATTRIB     For 1000014
82755>>>>>>>>>Define FUNC_SQLCOLINTATTRIB        For 1000015
82755>>>>>>>>>Define FUNC_SQLSTMTINTATTRIB       For 1000016
82755>>>>>>>>>Define FUNC_SQLSETPROCNAME         For 1000017
82755>>>>>>>>>DEfine FUNC_SQLSETPROCARG          For 1000018
82755>>>>>>>>>Define FUNC_SQLCALL                For 1000019
82755>>>>>>>>>Define FUNC_SQLGETPROCARGLEN       For 1000020
82755>>>>>>>>>Define FUNC_SQLGETPROCARG          For 1000021
82755>>>>>>>>>Define FUNC_SQLGETPROCRETVALLEN    For 1000022
82755>>>>>>>>>Define FUNC_SQLGETPROCRETVAL       For 1000023
82755>>>>>>>>>Define FUNC_SQLNEXTRESULTSET       For 1000024
82755>>>>>>>>>Define FUNC_SQLBUFFERSTATUS        For 1000025
82755>>>>>>>>>Define FUNC_SQLSETPROCSCHEMA       For 1000026
82755>>>>>>>>>Define FUNC_SQLGETMESSAGE          For 1000027
82755>>>>>>>>>
82755>>>>>>>>>//*** Embedded SQL statement attribute constants
82755>>>>>>>>>Define SQLSTMTATTRIB_COLUMNCOUNT    For 1
82755>>>>>>>>>Define SQLSTMTATTRIB_ROWCOUNT       For 2
82755>>>>>>>>>Define SQLSTMTATTRIB_ROWCOUNT_TYPE  For 3
82755>>>>>>>>>Define SQLSTMTATTRIB_NUMMESSAGES    For 4
82755>>>>>>>>>
82755>>>>>>>>>//*** Embedded SQL column attribute constants
82755>>>>>>>>>Define SQLCOLATTRIB_SIZE           For 1
82755>>>>>>>>>Define SQLCOLATTRIB_LENGTH         For 1
82755>>>>>>>>>Define SQLCOLATTRIB_PRECISION      For 2
82755>>>>>>>>>Define SQLCOLATTRIB_LABEL          For 3
82755>>>>>>>>>Define SQLCOLATTRIB_BASECOLUMNNAME For 4
82755>>>>>>>>>Define SQLCOLATTRIB_BASETABLENAME  For 5
82755>>>>>>>>>Define SQLCOLATTRIB_SQLTYPE        For 6
82755>>>>>>>>>Define SQLCOLATTRIB_NULLABLE       For 7
82755>>>>>>>>>Define SQLCOLATTRIB_DFTYPE         For 8
82755>>>>>>>>>
82755>>>>>>>>>
82755>>>>>>>>>
82755>>>>>>>>>//*****************************************************************************
82755>>>>>>>>>//*** Class  : cSQLStatement                                                ***
82755>>>>>>>>>//*** Purpose: Statement object for embedded sql                            ***
82755>>>>>>>>>//***                                                                       ***
82755>>>>>>>>>//*** Description:                                                          ***
82755>>>>>>>>>//***   An object is created for each statement. These will be children     ***
82755>>>>>>>>>//***   of cSQLConnection objects which manage the create and destruction   ***
82755>>>>>>>>>//***   of these.                                                           ***
82755>>>>>>>>>//*****************************************************************************
82755>>>>>>>>>
82755>>>>>>>>>// Global variables holding last executed embedded SQL connection and statement handles.
82755>>>>>>>>>Integer giLastSQLhdbc
82755>>>>>>>>>Integer giLastSQLhstmt
82755>>>>>>>>>
82755>>>>>>>>>Move -1 to giLastSQLhdbc
82756>>>>>>>>>Move -1 to giLastSQLhstmt
82757>>>>>>>>>
82757>>>>>>>>>Struct tSQLColumn
82757>>>>>>>>>    Integer iSQLType
82757>>>>>>>>>    Integer iSQLSize
82757>>>>>>>>>    Integer iSQLPrecision
82757>>>>>>>>>    Integer iVariableDataType
82757>>>>>>>>>End_Struct
82757>>>>>>>>>
82757>>>>>>>>>Class cSQLStatement is a cObject
82758>>>>>>>>>
82758>>>>>>>>>    Procedure Construct_object 
82760>>>>>>>>>        Forward Send Construct_object 
82762>>>>>>>>>
82762>>>>>>>>>        Property Handle  phCLIStatementHandle   0
82763>>>>>>>>>        Property Handle  phCLIConnectionHandle  0
82764>>>>>>>>>        Property String  psDriverID             ""
82765>>>>>>>>>        
82765>>>>>>>>>        Property Integer piLastColumn      0
82766>>>>>>>>>        Property Integer piLastArgument    0
82767>>>>>>>>>        Property Integer piBindFile        0
82768>>>>>>>>>        Property Integer piColumnCount     0
82769>>>>>>>>>
82769>>>>>>>>>        // Allocated buffer for SQLColumnValue. 
82769>>>>>>>>>        // Allocated size is size of the largest (not variable length) column
82769>>>>>>>>>        Property String  psMaxColValue     ""
82770>>>>>>>>>
82770>>>>>>>>>        // True if there is at least 1 column with a variable length data type                 
82770>>>>>>>>>        Property Integer piHasVariableDataType  0
82771>>>>>>>>>
82771>>>>>>>>>        // Max size of buffer for variable length data. Default 16000        
82771>>>>>>>>>        Property Integer piMaxVariableBufferLength 16000  
82772>>>>>>>>>
82772>>>>>>>>>        // Allocated buffer for SQLGetData. 
82772>>>>>>>>>        Property String  psVariableBuffer  ""
82773>>>>>>>>>
82773>>>>>>>>>        // Allocated size of psVariableBuffer
82773>>>>>>>>>        Property Integer piVariableBufferLength 0
82774>>>>>>>>>
82774>>>>>>>>>        // Stores column properties of a result set.
82774>>>>>>>>>        Property tSQLColumn[] paSQLColumns
82775>>>>>>>>>        
82775>>>>>>>>>        // piFetchResult is set by SQLFetchRowValues and SQLFetchResultSetValues
82775>>>>>>>>>        //               0    = Fetch returned no data.
82775>>>>>>>>>        //               <> 0 = Row fetched
82775>>>>>>>>>        Property Integer piFetchResult     0
82776>>>>>>>>>
82776>>>>>>>>>
82776>>>>>>>>>        Property String psDummyZeroDate              '0001-01-01'
82777>>>>>>>>>        Property String psDummyZeroDateMssqlDatetime '1753-01-01'        
82778>>>>>>>>>
82778>>>>>>>>>    End_Procedure 
82779>>>>>>>>>
82779>>>>>>>>>    //***
82779>>>>>>>>>    //*** Procedure: StoreStatementInfo
82779>>>>>>>>>    //*** Purpose  : Store basic information about the statement.
82779>>>>>>>>>    //***
82779>>>>>>>>>    Procedure StoreStatementInfo Handle hCLIStatementHandle String sDrvrId Handle hCLIConnectionHandle
82781>>>>>>>>>        
82781>>>>>>>>>        Set phCLIStatementHandle   to hCLIStatementHandle
82782>>>>>>>>>        Set phCLIConnectionHandle  to hCLIConnectionHandle
82783>>>>>>>>>        Set psDriverID             to sDrvrId
82784>>>>>>>>>        
82784>>>>>>>>>    End_Procedure 
82785>>>>>>>>>
82785>>>>>>>>>
82785>>>>>>>>>    //***
82785>>>>>>>>>    //*** Procedure: DestroySQLStatement
82785>>>>>>>>>    //*** Purpose  : Destroy the cSQLStatement object
82785>>>>>>>>>    //***
82785>>>>>>>>>    Procedure DestroySQLStatement
82787>>>>>>>>>        Send Destroy
82788>>>>>>>>>    End_Procedure 
82789>>>>>>>>>
82789>>>>>>>>>    //***
82789>>>>>>>>>    //*** Procedure: HandleError
82789>>>>>>>>>    //*** Puprose  : Handle an error that has occured while checking properties.
82789>>>>>>>>>    //***
82789>>>>>>>>>
82789>>>>>>>>>    Procedure HandleError Integer ihstmt Integer ihdbc String sDrvrId String sOriginMsg
82791>>>>>>>>>        Integer iErrHandle
82791>>>>>>>>>        Integer iErrNum
82791>>>>>>>>>        String  sLocationInfo
82791>>>>>>>>>
82791>>>>>>>>>        //*** Get the DataFlex statement identifier
82791>>>>>>>>>        Move Self To iErrHandle
82792>>>>>>>>>
82792>>>>>>>>>        //*** Determine error number
82792>>>>>>>>>        If (ihstmt = 0) ;            Move CLIERR_SQLINVALID_CLI_STMT_HANDLE To iErrNum
82795>>>>>>>>>        Else If (ihdbc = 0) ;            Move CLIERR_SQLINVALID_CLI_CONN_HANDLE To iErrNum
82799>>>>>>>>>        Else If (sDrvrId = "") ;            Move CLIERR_SQLINVALID_DRIVER_ID To iErrNum
82803>>>>>>>>>        Else ;            Move CLIERR_SQL_ERROR To iErrNum
82805>>>>>>>>>
82805>>>>>>>>>        //*** Create location ifnormation
82805>>>>>>>>>        Move "[" To sLocationInfo
82806>>>>>>>>>        If (sOriginMsg <> "") Begin
82808>>>>>>>>>            Move (Append(sLocationInfo, sOriginMsg)) To sLocationInfo
82809>>>>>>>>>            Move (Append(sLocationInfo, ", "))       To sLocationInfo
82810>>>>>>>>>        End
82810>>>>>>>>>>
82810>>>>>>>>>        Move (Append(sLocationInfo, "DataFlex hstmt = ")) To sLocationInfo
82811>>>>>>>>>        Move (Append(sLocationInfo, iErrHandle))          To sLocationInfo
82812>>>>>>>>>        Move (Append(sLocationInfo, "]"))                 To sLocationInfo
82813>>>>>>>>>
82813>>>>>>>>>        //*** Generate the error
82813>>>>>>>>>        Error iErrNum sLocationInfo
82814>>>>>>>>>>
82814>>>>>>>>>    End_Procedure
82815>>>>>>>>>
82815>>>>>>>>>
82815>>>>>>>>>
82815>>>>>>>>>    //***
82815>>>>>>>>>    //*** Procedure: StmtError
82815>>>>>>>>>    //*** Purpose  : Handle general error not related to the properties
82815>>>>>>>>>    //***
82815>>>>>>>>>
82815>>>>>>>>>    Procedure StmtError Integer iErrNum String sErrText String sOriginMsg
82817>>>>>>>>>        Integer iErrHandle
82817>>>>>>>>>        String  sLocationInfo
82817>>>>>>>>>
82817>>>>>>>>>        //*** Get the DataFlex statement identifier
82817>>>>>>>>>        Move Self to iErrHandle
82818>>>>>>>>>
82818>>>>>>>>>        //*** Create location information
82818>>>>>>>>>        Move "[" To sLocationInfo
82819>>>>>>>>>        If (sOriginMsg <> "") Begin
82821>>>>>>>>>            Move (Append(sLocationInfo, sOriginMsg)) To sLocationInfo
82822>>>>>>>>>            Move (Append(sLocationInfo, ", "))       To sLocationInfo
82823>>>>>>>>>        End
82823>>>>>>>>>>
82823>>>>>>>>>        If (sErrtext <> "") Begin
82825>>>>>>>>>            Move (Append(sLocationInfo, sErrtext)) To sLocationInfo
82826>>>>>>>>>            Move (Append(sLocationInfo, ", "))     To sLocationInfo
82827>>>>>>>>>        End
82827>>>>>>>>>>
82827>>>>>>>>>        Move (Append(sLocationInfo, "DataFlex hstmt = ")) To sLocationInfo
82828>>>>>>>>>        Move (Append(sLocationInfo, iErrHandle))          To sLocationInfo
82829>>>>>>>>>        Move (Append(sLocationInfo, "]"))                 To sLocationInfo
82830>>>>>>>>>
82830>>>>>>>>>        //*** Generate the error
82830>>>>>>>>>        Error iErrNum sLocationInfo
82831>>>>>>>>>>
82831>>>>>>>>>    End_Procedure 
82832>>>>>>>>>
82832>>>>>>>>>
82832>>>>>>>>>
82832>>>>>>>>>    //***
82832>>>>>>>>>    //*** Procedure: SQLIllegalAttribute
82832>>>>>>>>>    //*** Purpose  : Handle an illegal attribute error
82832>>>>>>>>>    //***
82832>>>>>>>>>
82832>>>>>>>>>    Procedure SQLIllegalAttribute String sErrText String sOriginMsg
82834>>>>>>>>>        Integer bReport
82834>>>>>>>>>
82834>>>>>>>>>        Get_attribute DF_REPORT_UNSUPPORTED_ATTRIBUTES To bReport
82837>>>>>>>>>        If (bReport) ;            Send StmtError CLIERR_SQLINVALID_ATTRIBUTE sErrtext sOriginMsg
82840>>>>>>>>>    End_Procedure 
82841>>>>>>>>>
82841>>>>>>>>>
82841>>>>>>>>>
82841>>>>>>>>>    //***
82841>>>>>>>>>    //*** Function: SQLPrivateColumnIsLegal
82841>>>>>>>>>    //*** Purpose : Check if a column number is legal
82841>>>>>>>>>    //***
82841>>>>>>>>>
82841>>>>>>>>>    Function SQLPrivateColumnIsLegal Integer ihdbc String sDrvrId Integer ihstmt Integer iCol Returns Integer
82843>>>>>>>>>        Integer bLegal
82843>>>>>>>>>        Integer iNumColumns
82843>>>>>>>>>
82843>>>>>>>>>        Get SQLPrivateStmtAttribute SQLSTMTATTRIB_COLUMNCOUNT ihdbc sDrvrId ihstmt To iNumColumns
82844>>>>>>>>>        If (iCol > 0 And iCol <= iNumColumns) ;            Move DFTRUE To bLegal
82847>>>>>>>>>        Else ;            Move DFFALSE To bLegal
82849>>>>>>>>>
82849>>>>>>>>>        Function_Return bLegal
82850>>>>>>>>>    End_Function 
82851>>>>>>>>>
82851>>>>>>>>>
82851>>>>>>>>>
82851>>>>>>>>>    //***
82851>>>>>>>>>    //*** Procedure: SQLClose
82851>>>>>>>>>    //*** Purpose  : Close a statement and free all alllocated resources
82851>>>>>>>>>    //***
82851>>>>>>>>>
82851>>>>>>>>>    Procedure SQLClose
82853>>>>>>>>>        Integer ihdbc
82853>>>>>>>>>        Integer ihstmt
82853>>>>>>>>>        Integer iVoid
82853>>>>>>>>>        String  sDrvrId
82853>>>>>>>>>        String  sEmpty
82853>>>>>>>>>
82853>>>>>>>>>        //*** Initialize
82853>>>>>>>>>        Move "" To sEmpty
82854>>>>>>>>>
82854>>>>>>>>>        //*** Get the cli handles
82854>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
82855>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
82856>>>>>>>>>        Get psDriverId            to sDrvrId
82857>>>>>>>>>
82857>>>>>>>>>        //*** Free the CLI handle
82857>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
82859>>>>>>>>>            //*** Call the driver function to close
82859>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLCLOSE ;                        Callback Self ;                        Passing ihdbc sEmpty ihstmt ;                        Result iVoid
82864>>>>>>>>>
82864>>>>>>>>>            Move -1 to giLastSQLhstmt
82865>>>>>>>>>            //*** Free the DataFlex handle
82865>>>>>>>>>            Send DestroySQLStatement
82866>>>>>>>>>        End
82866>>>>>>>>>>
82866>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLClose"
82868>>>>>>>>>    End_Procedure
82869>>>>>>>>>
82869>>>>>>>>>
82869>>>>>>>>>
82869>>>>>>>>>    //***
82869>>>>>>>>>    //*** Procedure: SQLPrepare
82869>>>>>>>>>    //*** Purpose  : Prepare a statement for execution
82869>>>>>>>>>    //***
82869>>>>>>>>>
82869>>>>>>>>>    Procedure SQLPrepare String sStatement
82871>>>>>>>>>        Integer ihdbc
82871>>>>>>>>>        Integer ihstmt
82871>>>>>>>>>        Integer iVoid
82871>>>>>>>>>        String  sDrvrId
82871>>>>>>>>>
82871>>>>>>>>>        //*** Get the cli handles
82871>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
82872>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
82873>>>>>>>>>        Get psDriverId            to sDrvrId
82874>>>>>>>>>
82874>>>>>>>>>        //*** Prepare
82874>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
82876>>>>>>>>>            //*** Call the driver function to prepare
82876>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLPREPARE ;                        Callback Self ;                        Passing ihdbc sStatement ihstmt ;                        Result iVoid
82881>>>>>>>>>        End
82881>>>>>>>>>>
82881>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLPrepare"
82883>>>>>>>>>    End_Procedure
82884>>>>>>>>>
82884>>>>>>>>>    Procedure SQLGetStatementAttributes
82886>>>>>>>>>        Integer ihdbc ihstmt iNumColumns iCol iMaxSize
82886>>>>>>>>>        String sMaxValue
82886>>>>>>>>>        tSQLColumn[] aSQLColumns
82886>>>>>>>>>        tSQLColumn[] aSQLColumns
82887>>>>>>>>>        
82887>>>>>>>>>        Integer iSqlType
82887>>>>>>>>>        Integer iSQLSize
82887>>>>>>>>>        Integer iSQLprecision
82887>>>>>>>>>        Integer iVariableDataType
82887>>>>>>>>>        
82887>>>>>>>>>        String  sDrvrId
82887>>>>>>>>>
82887>>>>>>>>>        Integer iHasVariableDataType
82887>>>>>>>>>
82887>>>>>>>>>        Move 0 to iHasVariableDataType
82888>>>>>>>>>
82888>>>>>>>>>
82888>>>>>>>>>        //*** Get the cli handles
82888>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
82889>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
82890>>>>>>>>>        Get psDriverId            to sDrvrId
82891>>>>>>>>>
82891>>>>>>>>>        Get SQLPrivateStmtAttribute SQLSTMTATTRIB_COLUMNCOUNT ihdbc sDrvrId ihstmt to iNumColumns
82892>>>>>>>>>        
82892>>>>>>>>>        Set piColumnCount to iNumColumns
82893>>>>>>>>>        
82893>>>>>>>>>        // Fill columns array
82893>>>>>>>>>        For iCol from 1 to iNumColumns
82899>>>>>>>>>>
82899>>>>>>>>>            Move 0 to iVariableDataType
82900>>>>>>>>>            
82900>>>>>>>>>            Get SQLPrivateColAttribute iCol SQLCOLATTRIB_SQLTYPE ihdbc sDrvrId ihstmt to iSQLType
82901>>>>>>>>>            Get SQLPrivateColAttribute iCol SQLCOLATTRIB_SIZE ihdbc sDrvrId ihstmt to iSQLSize
82902>>>>>>>>>            Get SQLPrivateColAttribute iCol SQLCOLATTRIB_PRECISION ihdbc sDrvrId ihstmt to iSQLPrecision
82903>>>>>>>>>            
82903>>>>>>>>>            If ( (iSQLType = SQL_LONGVARCHAR) or (iSQLType = SQL_WLONGVARCHAR) ) Begin
82905>>>>>>>>>                 // text type 
82905>>>>>>>>>                Move 1 to iVariableDataType
82906>>>>>>>>>            End
82906>>>>>>>>>>
82906>>>>>>>>>            Else Begin
82907>>>>>>>>>                If (sDrvrId = "MSSQLDRV") Begin
82909>>>>>>>>>                    // SQL Server varchar(max) and nvarchar(max) types return Size = 0                   
82909>>>>>>>>>                    If ( ((iSQLType = SQL_VARCHAR) and (iSQLSize = 0) ) or ;                         ((iSQLType = SQL_WVARCHAR) and (iSQLSize = 0) ) ) Begin
82911>>>>>>>>>                            
82911>>>>>>>>>                        Move 1 to iVariableDataType     
82912>>>>>>>>>                    End
82912>>>>>>>>>>
82912>>>>>>>>>                End
82912>>>>>>>>>>
82912>>>>>>>>>            End
82912>>>>>>>>>>
82912>>>>>>>>>
82912>>>>>>>>>            Move iSqlType           to aSQLColumns[iCol].iSQLType            
82913>>>>>>>>>            Move iSQLSize           to aSQLColumns[iCol].iSQLSize
82914>>>>>>>>>            Move iSQLPrecision      to aSQLColumns[iCol].iSQLPrecision
82915>>>>>>>>>            Move iVariableDataType  to aSQLColumns[iCol].iVariableDataType
82916>>>>>>>>>            
82916>>>>>>>>>            If (not(iVariableDataType)) Begin
82918>>>>>>>>>                If (iSQLSize > iMaxSize) Begin
82920>>>>>>>>>                    Move iSQLSize to iMaxSize
82921>>>>>>>>>                End
82921>>>>>>>>>>
82921>>>>>>>>>            End
82921>>>>>>>>>>
82921>>>>>>>>>            Else Begin
82922>>>>>>>>>                Move 1 to iHasVariableDataType
82923>>>>>>>>>            End
82923>>>>>>>>>>
82923>>>>>>>>>            
82923>>>>>>>>>        Loop
82924>>>>>>>>>>
82924>>>>>>>>>        
82924>>>>>>>>>        Move (Repeat(' ', iMaxSize + 3)) to sMaxValue
82925>>>>>>>>>        Set psMaxColValue to sMaxValue
82926>>>>>>>>>        
82926>>>>>>>>>        Set paSQLColumns   to aSQLColumns        
82927>>>>>>>>>        Set piHasVariableDataType to iHasVariableDataType
82928>>>>>>>>>        
82928>>>>>>>>>    End_Procedure
82929>>>>>>>>>
82929>>>>>>>>>    //***
82929>>>>>>>>>    //*** Procedure: SQLExecute
82929>>>>>>>>>    //*** Purpose  : Execute a prepared statement
82929>>>>>>>>>    //***
82929>>>>>>>>>
82929>>>>>>>>>    Procedure SQLExecute
82931>>>>>>>>>        Integer ihdbc
82931>>>>>>>>>        Integer ihstmt
82931>>>>>>>>>        Integer iVoid
82931>>>>>>>>>        String  sDrvrId
82931>>>>>>>>>        String  sEmpty
82931>>>>>>>>>
82931>>>>>>>>>        //*** Initialize
82931>>>>>>>>>        Move "" To sEmpty
82932>>>>>>>>>
82932>>>>>>>>>        //*** Get the cli handles
82932>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
82933>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
82934>>>>>>>>>        Get psDriverId            to sDrvrId
82935>>>>>>>>>
82935>>>>>>>>>        //*** Execute
82935>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
82937>>>>>>>>>            //*** Call the driver function to execute
82937>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLEXECUTE ;                        Callback Self ;                        Passing ihdbc sEmpty ihstmt ;                        Result iVoid
82942>>>>>>>>>            Send SQLGetStatementAttributes
82943>>>>>>>>>        End
82943>>>>>>>>>>
82943>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLExecute"
82945>>>>>>>>>    End_Procedure
82946>>>>>>>>>
82946>>>>>>>>>
82946>>>>>>>>>
82946>>>>>>>>>    //***
82946>>>>>>>>>    //*** Procedure: SQLExecDirect
82946>>>>>>>>>    //*** Purpose  : Prepare and execute a statement
82946>>>>>>>>>    //***
82946>>>>>>>>>
82946>>>>>>>>>    Procedure SQLExecDirect String sStatement
82948>>>>>>>>>        Integer ihdbc
82948>>>>>>>>>        Integer ihstmt
82948>>>>>>>>>        Integer iVoid
82948>>>>>>>>>        String  sDrvrId
82948>>>>>>>>>
82948>>>>>>>>>        //*** Get the cli handles
82948>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
82949>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
82950>>>>>>>>>        Get psDriverId            to sDrvrId
82951>>>>>>>>>
82951>>>>>>>>>        //*** ExecDirect
82951>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
82953>>>>>>>>>            //*** Call the driver function to execdirect
82953>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLEXECDIRECT ;                        Callback Self ;                        Passing ihdbc sStatement ihstmt ;                        Result iVoid
82958>>>>>>>>>            Send SQLGetStatementAttributes
82959>>>>>>>>>        End
82959>>>>>>>>>>
82959>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLExecDirect"
82961>>>>>>>>>    End_Procedure
82962>>>>>>>>>
82962>>>>>>>>>
82962>>>>>>>>>
82962>>>>>>>>>    //***
82962>>>>>>>>>    //*** Procedure: SQLFetch
82962>>>>>>>>>    //*** Purpose  : Fetch the next row
82962>>>>>>>>>    //*** Returns  : 0   = No more data
82962>>>>>>>>>    //***            <>0 = Success
82962>>>>>>>>>    //***
82962>>>>>>>>>    Function SQLFetch Returns Integer
82964>>>>>>>>>        Integer ihdbc
82964>>>>>>>>>        Integer ihstmt
82964>>>>>>>>>        Integer iResult
82964>>>>>>>>>        String  sDrvrId
82964>>>>>>>>>        String  sEmpty
82964>>>>>>>>>
82964>>>>>>>>>        //*** Initialize
82964>>>>>>>>>        Move "" To sEmpty
82965>>>>>>>>>        Move 0  To iResult
82966>>>>>>>>>
82966>>>>>>>>>        //*** Get the cli handles
82966>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
82967>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
82968>>>>>>>>>        Get psDriverId            to sDrvrId
82969>>>>>>>>>
82969>>>>>>>>>        //*** Fetch
82969>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
82971>>>>>>>>>            Indicate Err False
82972>>>>>>>>>
82972>>>>>>>>>            //*** Call the driver function to fetch
82972>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLFETCH Callback Self Passing ihdbc sEmpty ihstmt Result iResult
82977>>>>>>>>>
82977>>>>>>>>>            //*** If something went wrong, adjust the result
82977>>>>>>>>>            If (Err) Move 0 to iResult
82980>>>>>>>>>
82980>>>>>>>>>            Set piLastcolumn To 0
82981>>>>>>>>>        End
82981>>>>>>>>>>
82981>>>>>>>>>        Else Send HandleError ihstmt ihdbc sDrvrId "SQLFetch"
82983>>>>>>>>>
82983>>>>>>>>>        Function_return iResult
82984>>>>>>>>>    End_Function
82985>>>>>>>>>
82985>>>>>>>>>
82985>>>>>>>>>    //***
82985>>>>>>>>>    //*** Procedure: SQLFetchRowValues
82985>>>>>>>>>    //*** Purpose  : Fetch the next row and return an array with all column values
82985>>>>>>>>>    //*** Returns  : Array of strings with all column values
82985>>>>>>>>>    //***            Sets piFetchResult property 
82985>>>>>>>>>    //***               0    = No more data
82985>>>>>>>>>    //***               <> 0 = Success
82985>>>>>>>>>    //***
82985>>>>>>>>>    Function SQLFetchRowValues Returns String[] 
82987>>>>>>>>>      
82987>>>>>>>>>        String[] asValues
82988>>>>>>>>>
82988>>>>>>>>>        tSQLColumn[] aSQLColumns        
82988>>>>>>>>>        tSQLColumn[] aSQLColumns        
82989>>>>>>>>>        
82989>>>>>>>>>        Integer ihdbc
82989>>>>>>>>>        Integer ihstmt
82989>>>>>>>>>        Integer iResult iVoid
82989>>>>>>>>>        Integer iColCount iCol
82989>>>>>>>>>        String  sDrvrId
82989>>>>>>>>>        String  sEmpty 
82989>>>>>>>>>        String  sResult
82989>>>>>>>>>        String  sVariableResult
82989>>>>>>>>>        Integer iHasVariableDataType
82989>>>>>>>>>        Integer iLen
82989>>>>>>>>>        Integer iVariableBufferLength
82989>>>>>>>>>
82989>>>>>>>>>        //*** Initialize
82989>>>>>>>>>        Move "" to sEmpty
82990>>>>>>>>>        Move 0  to iResult
82991>>>>>>>>>
82991>>>>>>>>>        //*** Get the cli handles
82991>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
82992>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
82993>>>>>>>>>        Get psDriverId            to sDrvrId
82994>>>>>>>>>        
82994>>>>>>>>>        Get paSQLColumns to aSQLColumns
82995>>>>>>>>>        Get piColumnCount to iColCount
82996>>>>>>>>>        Get piHasVariableDataType to iHasVariableDataType
82997>>>>>>>>>        
82997>>>>>>>>>        If (iHasVariableDataType) Begin
82999>>>>>>>>>            
82999>>>>>>>>>            Get piVariableBufferLength      to iVariableBufferLength
83000>>>>>>>>>            Get piMaxVariableBufferLength   to iLen
83001>>>>>>>>>            
83001>>>>>>>>>            If (iLen > iVariableBufferLength) Begin
83003>>>>>>>>>                //*** Allocate
83003>>>>>>>>>                Move (Repeat(' ', iLen)) to sVariableResult
83004>>>>>>>>>               
83004>>>>>>>>>                Set piVariableBufferLength to iLen
83005>>>>>>>>>                Set psVariableBuffer       to sVariableResult
83006>>>>>>>>>                
83006>>>>>>>>>                Get piVariableBufferLength to iVariableBufferLength                
83007>>>>>>>>>            End
83007>>>>>>>>>>
83007>>>>>>>>>        End
83007>>>>>>>>>>
83007>>>>>>>>>
83007>>>>>>>>>        //*** Fetch
83007>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
83009>>>>>>>>>            Move (False) to Err
83010>>>>>>>>>
83010>>>>>>>>>            // FUNC_SQLCOLUMNINFO will tell the driver which hdbc and hstmt to use 
83010>>>>>>>>>            // in the next FUNC_SQLCOLUMNVALUE call.
83010>>>>>>>>>            // If hdbc and hstmt have not changed since the last call we don't have to set it.
83010>>>>>>>>>            If (ihstmt <> giLastSQLhstmt or ihdbc <> giLastSQLhdbc) Begin
83012>>>>>>>>>                //*** Setup function arguments
83012>>>>>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO Callback 0 Passing ihdbc iCol ihstmt Result iVoid
83017>>>>>>>>>                Move ihstmt to giLastSQLhstmt
83018>>>>>>>>>                Move ihdbc to giLastSQLhdbc
83019>>>>>>>>>            End
83019>>>>>>>>>>
83019>>>>>>>>>
83019>>>>>>>>>            //*** Call the driver function to fetch
83019>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLFETCH Callback 0 Passing ihdbc sEmpty ihstmt Result iResult
83024>>>>>>>>>
83024>>>>>>>>>            //*** If something went wrong, adjust the result
83024>>>>>>>>>            If (Err) Move 0 to iResult
83027>>>>>>>>>            
83027>>>>>>>>>            If (iResult) Begin
83029>>>>>>>>>                For iCol from 1 to iColCount
83035>>>>>>>>>>
83035>>>>>>>>>                    
83035>>>>>>>>>                    If (not(aSQLColumns[iCol].iVariableDataType)) Begin
83037>>>>>>>>>                        Get psMaxColValue to sResult
83038>>>>>>>>>                        Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNVALUE Callback 0 Passing sResult sEmpty iCol Result iVoid
83043>>>>>>>>>
83043>>>>>>>>>                        Move sResult to asValues[iCol - 1]
83044>>>>>>>>>                    End
83044>>>>>>>>>>
83044>>>>>>>>>                    Else Begin
83045>>>>>>>>>                        Get psVariableBuffer       to sVariableResult
83046>>>>>>>>>                        Call_Driver 0 sDrvrId Function FUNC_SQLGETDATA ;                                    Callback 0 ;                                    Passing sVariableResult iCol iVariableBufferLength ;                                    Result iVoid
83051>>>>>>>>>                                    
83051>>>>>>>>>                        Move sVariableResult to asValues[iCol - 1]
83052>>>>>>>>>                    End
83052>>>>>>>>>>
83052>>>>>>>>>                    
83052>>>>>>>>>                Loop
83053>>>>>>>>>>
83053>>>>>>>>>            End
83053>>>>>>>>>>
83053>>>>>>>>>        End
83053>>>>>>>>>>
83053>>>>>>>>>        Else Begin    
83054>>>>>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLFetchRowValues"
83055>>>>>>>>>        End
83055>>>>>>>>>>
83055>>>>>>>>>
83055>>>>>>>>>        Set piFetchResult to iResult
83056>>>>>>>>>
83056>>>>>>>>>        Function_Return asValues
83057>>>>>>>>>        
83057>>>>>>>>>    End_Function 
83058>>>>>>>>>
83058>>>>>>>>>    //***
83058>>>>>>>>>    //*** Procedure: SQLFetchResultsetValues
83058>>>>>>>>>    //*** Purpose  : Fetch a complete result set. 
83058>>>>>>>>>    //*** Returns  : 2-dimensional array of strings with result set
83058>>>>>>>>>    //***            Sets piFetchResult property 
83058>>>>>>>>>    //***               0    = No more data
83058>>>>>>>>>    //***               <> 0 = Success
83058>>>>>>>>>    //***
83058>>>>>>>>>    Function SQLFetchResultsetValues Returns String[][] 
83060>>>>>>>>>        
83060>>>>>>>>>        String[][] asValues 
83061>>>>>>>>>        
83061>>>>>>>>>        Integer ihdbc ihstmt iResult iVoid iColCount iCol iRow
83061>>>>>>>>>        String sDrvrId sEmpty sResult sMax
83061>>>>>>>>>
83061>>>>>>>>>        tSQLColumn[] aSQLColumns        
83061>>>>>>>>>        tSQLColumn[] aSQLColumns        
83062>>>>>>>>>        String  sVariableResult
83062>>>>>>>>>        Integer iHasVariableDataType
83062>>>>>>>>>        Integer iLen
83062>>>>>>>>>        Integer iVariableBufferLength
83062>>>>>>>>>
83062>>>>>>>>>        //*** Initialize
83062>>>>>>>>>        Move "" to sEmpty
83063>>>>>>>>>        Move 0  to iResult
83064>>>>>>>>>
83064>>>>>>>>>        //*** Get the cli handles
83064>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
83065>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83066>>>>>>>>>        Get psDriverId            to sDrvrId
83067>>>>>>>>>
83067>>>>>>>>>        //*** Fetch
83067>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
83069>>>>>>>>>            Indicate Err False
83070>>>>>>>>>            
83070>>>>>>>>>            // FUNC_SQLCOLUMNINFO will tell the driver which hdbc and hstmt to use 
83070>>>>>>>>>            // in the next FUNC_SQLCOLUMNVALUE call.
83070>>>>>>>>>            // If hdbc and hstmt have not changed since the last call we don't have to set it.
83070>>>>>>>>>            If (ihstmt <> giLastSQLhstmt or ihdbc <> giLastSQLhdbc) Begin
83072>>>>>>>>>                //*** Setup function arguments
83072>>>>>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO Callback 0 Passing ihdbc iCol ihstmt Result iVoid
83077>>>>>>>>>                Move ihstmt to giLastSQLhstmt
83078>>>>>>>>>                Move ihdbc to giLastSQLhdbc
83079>>>>>>>>>            End
83079>>>>>>>>>>
83079>>>>>>>>>
83079>>>>>>>>>
83079>>>>>>>>>            Get paSQLColumns to aSQLColumns
83080>>>>>>>>>            Get piColumnCount to iColCount
83081>>>>>>>>>            Get piHasVariableDataType to iHasVariableDataType
83082>>>>>>>>>            If (iHasVariableDataType) Begin
83084>>>>>>>>>                Get piVariableBufferLength      to iVariableBufferLength
83085>>>>>>>>>                Get piMaxVariableBufferLength   to iLen
83086>>>>>>>>>                If (iLen > iVariableBufferLength) Begin
83088>>>>>>>>>                    //*** Allocate
83088>>>>>>>>>                    Move (Repeat(' ', iLen)) to sVariableResult
83089>>>>>>>>>                   
83089>>>>>>>>>                    Set piVariableBufferLength to iLen
83090>>>>>>>>>                    Set psVariableBuffer       to sVariableResult
83091>>>>>>>>>                    
83091>>>>>>>>>                    Get piVariableBufferLength to iVariableBufferLength                
83092>>>>>>>>>                End
83092>>>>>>>>>>
83092>>>>>>>>>                Else Begin
83093>>>>>>>>>                   Set psVariableBuffer       to sVariableResult
83094>>>>>>>>>                End
83094>>>>>>>>>>
83094>>>>>>>>>            End
83094>>>>>>>>>>
83094>>>>>>>>>
83094>>>>>>>>>            Get psMaxColValue to sMax
83095>>>>>>>>>
83095>>>>>>>>>            //*** Call the driver function to fetch
83095>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLFETCH Callback Self Passing ihdbc sEmpty ihstmt Result iResult
83100>>>>>>>>>            If (Err) Move 0 to iResult
83103>>>>>>>>>
83103>>>>>>>>>            While (iResult <> 0)
83107>>>>>>>>>
83107>>>>>>>>>                For iCol from 1 to (iColCount)
83113>>>>>>>>>>
83113>>>>>>>>>                    
83113>>>>>>>>>                    If (not(aSQLColumns[iCol].iVariableDataType)) Begin
83115>>>>>>>>>                        Move sMax to sResult
83116>>>>>>>>>                        Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNVALUE ;                                    Callback 0 ;                                    Passing sResult sEmpty iCol ;                                    Result iVoid
83121>>>>>>>>>                        Move sResult to asValues[iRow][iCol - 1]
83122>>>>>>>>>                    End
83122>>>>>>>>>>
83122>>>>>>>>>                    Else Begin
83123>>>>>>>>>                        //Variable data    
83123>>>>>>>>>                        Move sVariableResult to sResult
83124>>>>>>>>>                        Call_Driver 0 sDrvrId Function FUNC_SQLGETDATA ;                                    Callback 0 ;                                    Passing sResult iCol iVariableBufferLength ;                                    Result iVoid
83129>>>>>>>>>                                    
83129>>>>>>>>>                        Move sResult to asValues[iRow][iCol - 1]
83130>>>>>>>>>                    End
83130>>>>>>>>>>
83130>>>>>>>>>                Loop
83131>>>>>>>>>>
83131>>>>>>>>>
83131>>>>>>>>>                Increment iRow
83132>>>>>>>>>
83132>>>>>>>>>                //*** Call the driver function to fetch
83132>>>>>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLFETCH Callback Self Passing ihdbc sEmpty ihstmt Result iResult
83137>>>>>>>>>                If (Err) Move 0 to iResult
83140>>>>>>>>>
83140>>>>>>>>>            Loop
83141>>>>>>>>>>
83141>>>>>>>>>
83141>>>>>>>>>        End
83141>>>>>>>>>>
83141>>>>>>>>>        Else Send HandleError ihstmt ihdbc sDrvrId "SQLFetchResultsetValues"
83143>>>>>>>>>
83143>>>>>>>>>        Set piFetchResult to iResult
83144>>>>>>>>>
83144>>>>>>>>>        Function_Return asValues
83145>>>>>>>>>    End_Function 
83146>>>>>>>>>
83146>>>>>>>>>
83146>>>>>>>>>
83146>>>>>>>>>    //***
83146>>>>>>>>>    //*** Function: SQLNextColumn
83146>>>>>>>>>    //*** Purpose : Get the next column
83146>>>>>>>>>    //***
83146>>>>>>>>>
83146>>>>>>>>>    Function SQLNextColumn Returns String
83148>>>>>>>>>        Integer iCol
83148>>>>>>>>>        String  sResult
83148>>>>>>>>>
83148>>>>>>>>>        Get piLastColumn To iCol
83149>>>>>>>>>        Increment iCol
83150>>>>>>>>>        Get SQLColumnValue iCol To sResult
83151>>>>>>>>>        Set piLastColumn To iCol
83152>>>>>>>>>
83152>>>>>>>>>        Function_return sResult
83153>>>>>>>>>    End_Function 
83154>>>>>>>>>
83154>>>>>>>>>
83154>>>>>>>>>    //***
83154>>>>>>>>>    //*** Function: SQLColumnType
83154>>>>>>>>>    //*** Purpose : Returns the native type of a column
83154>>>>>>>>>    //***
83154>>>>>>>>>    Function SQLColumnType Integer iCol Returns Integer
83156>>>>>>>>>        Integer ihdbc
83156>>>>>>>>>        Integer ihstmt
83156>>>>>>>>>        String  sDrvrId
83156>>>>>>>>>        Integer iSQLType
83156>>>>>>>>>        Integer iColumns
83156>>>>>>>>>        
83156>>>>>>>>>        tSQLColumn[] aSQLColumns
83156>>>>>>>>>        tSQLColumn[] aSQLColumns
83157>>>>>>>>>        
83157>>>>>>>>>        //*** Get the cli handles
83157>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
83158>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83159>>>>>>>>>        Get psDriverId            to sDrvrId
83160>>>>>>>>>
83160>>>>>>>>>        //*** Get the value
83160>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
83162>>>>>>>>>        
83162>>>>>>>>>            Get paSQLColumns   to aSQLColumns        
83163>>>>>>>>>            Move (SizeOfArray(aSQLColumns)) to iColumns
83164>>>>>>>>>            
83164>>>>>>>>>            If (iCol >= 1 and iCol <= iColumns) Begin
83166>>>>>>>>>                Move aSQLColumns[iCol].iSQLType to iSQLType
83167>>>>>>>>>            End
83167>>>>>>>>>>
83167>>>>>>>>>            Else Begin
83168>>>>>>>>>                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLColumnType"        
83169>>>>>>>>>            End
83169>>>>>>>>>>
83169>>>>>>>>>        End
83169>>>>>>>>>>
83169>>>>>>>>>        Else Begin
83170>>>>>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLColumnType"
83171>>>>>>>>>        End
83171>>>>>>>>>>
83171>>>>>>>>>
83171>>>>>>>>>        Function_Return iSQLType
83172>>>>>>>>>    End_Function 
83173>>>>>>>>>
83173>>>>>>>>>    //***
83173>>>>>>>>>    //*** Function: SQLColumnSize
83173>>>>>>>>>    //*** Purpose : Returns the size (max length) of a column
83173>>>>>>>>>    //***
83173>>>>>>>>>    Function SQLColumnSize Integer iCol Returns Integer
83175>>>>>>>>>        Integer ihdbc
83175>>>>>>>>>        Integer ihstmt
83175>>>>>>>>>        String  sDrvrId
83175>>>>>>>>>        Integer iSQLSize
83175>>>>>>>>>        Integer iColumns
83175>>>>>>>>>        
83175>>>>>>>>>        tSQLColumn[] aSQLColumns
83175>>>>>>>>>        tSQLColumn[] aSQLColumns
83176>>>>>>>>>        
83176>>>>>>>>>        //*** Get the cli handles
83176>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
83177>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83178>>>>>>>>>        Get psDriverId            to sDrvrId
83179>>>>>>>>>
83179>>>>>>>>>        //*** Get the value
83179>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
83181>>>>>>>>>        
83181>>>>>>>>>            Get paSQLColumns   to aSQLColumns        
83182>>>>>>>>>            Move (SizeOfArray(aSQLColumns)) to iColumns
83183>>>>>>>>>            
83183>>>>>>>>>            If (iCol >= 1 and iCol <= iColumns) Begin
83185>>>>>>>>>                Move aSQLColumns[iCol].iSQLSize to iSQLSize
83186>>>>>>>>>            End
83186>>>>>>>>>>
83186>>>>>>>>>            Else Begin
83187>>>>>>>>>                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLColumnSize"        
83188>>>>>>>>>            End
83188>>>>>>>>>>
83188>>>>>>>>>        End
83188>>>>>>>>>>
83188>>>>>>>>>        Else Begin
83189>>>>>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLColumnSize"
83190>>>>>>>>>        End
83190>>>>>>>>>>
83190>>>>>>>>>
83190>>>>>>>>>        Function_Return iSQLSize
83191>>>>>>>>>    End_Function 
83192>>>>>>>>>
83192>>>>>>>>>    //***
83192>>>>>>>>>    //*** Function: SQLColumnVariableDatatype
83192>>>>>>>>>    //*** Purpose : Returns 1 for variable length datatypes. 
83192>>>>>>>>>    //***           For example SQL Server varchar(max) or text type
83192>>>>>>>>>    //***           The data of variable length datatype columns should be retrieved with SQLGetData 
83192>>>>>>>>>    Function SQLColumnVariableDatatype Integer iCol Returns Integer
83194>>>>>>>>>        Integer ihdbc
83194>>>>>>>>>        Integer ihstmt
83194>>>>>>>>>        String  sDrvrId
83194>>>>>>>>>        Integer iVariableDataType
83194>>>>>>>>>        Integer iColumns
83194>>>>>>>>>        
83194>>>>>>>>>        tSQLColumn[] aSQLColumns
83194>>>>>>>>>        tSQLColumn[] aSQLColumns
83195>>>>>>>>>        
83195>>>>>>>>>        //*** Get the cli handles
83195>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
83196>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83197>>>>>>>>>        Get psDriverId            to sDrvrId
83198>>>>>>>>>
83198>>>>>>>>>        //*** Get the value
83198>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
83200>>>>>>>>>        
83200>>>>>>>>>            Get paSQLColumns   to aSQLColumns        
83201>>>>>>>>>            Move (SizeOfArray(aSQLColumns)) to iColumns
83202>>>>>>>>>            
83202>>>>>>>>>            If (iCol >= 1 and iCol <= iColumns) Begin
83204>>>>>>>>>                Move aSQLColumns[iCol].iVariableDataType to iVariableDataType
83205>>>>>>>>>            End
83205>>>>>>>>>>
83205>>>>>>>>>            Else Begin
83206>>>>>>>>>                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLColumnVariableDatatype"        
83207>>>>>>>>>            End
83207>>>>>>>>>>
83207>>>>>>>>>        End
83207>>>>>>>>>>
83207>>>>>>>>>        Else Begin
83208>>>>>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLColumnVariableDatatype"
83209>>>>>>>>>        End
83209>>>>>>>>>>
83209>>>>>>>>>
83209>>>>>>>>>        Function_Return iVariableDataType
83210>>>>>>>>>    End_Function 
83211>>>>>>>>>
83211>>>>>>>>>
83211>>>>>>>>>
83211>>>>>>>>>
83211>>>>>>>>>    //***
83211>>>>>>>>>    //*** Function: SQLColumnValue
83211>>>>>>>>>    //*** Purpose : Return the value of a column in a fetched row of a given
83211>>>>>>>>>    //***           statement.
83211>>>>>>>>>    //***
83211>>>>>>>>>    Function SQLColumnValue Integer iCol Returns String
83213>>>>>>>>>        Integer ihdbc
83213>>>>>>>>>        Integer ihstmt
83213>>>>>>>>>        String  sDrvrId
83213>>>>>>>>>        String  sResult
83213>>>>>>>>>
83213>>>>>>>>>        Integer iVoid
83213>>>>>>>>>        Integer iColSize
83213>>>>>>>>>        Integer iColPrecision
83213>>>>>>>>>        String  sEmpty
83213>>>>>>>>>        Integer bLegalColumn
83213>>>>>>>>>
83213>>>>>>>>>        //*** Initialize
83213>>>>>>>>>        Move "" To sResult
83214>>>>>>>>>
83214>>>>>>>>>        //*** Get the cli handles
83214>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
83215>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83216>>>>>>>>>        Get psDriverId            to sDrvrId
83217>>>>>>>>>
83217>>>>>>>>>        // FUNC_SQLCOLUMNINFO will tell the driver which hdbc and hstmt to use 
83217>>>>>>>>>        // in the next FUNC_SQLCOLUMNVALUE call.
83217>>>>>>>>>        // If hdbc and hstmt have not changed since the last call we don't have to set it.
83217>>>>>>>>>        If (ihstmt <> giLastSQLhstmt or ihdbc <> giLastSQLhdbc) Begin
83219>>>>>>>>>            //*** Setup function arguments
83219>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                        Callback 0 ;                        Passing ihdbc iCol ihstmt ;                        Result iVoid
83224>>>>>>>>>            Move ihstmt to giLastSQLhstmt
83225>>>>>>>>>            Move ihdbc to giLastSQLhdbc
83226>>>>>>>>>        End
83226>>>>>>>>>>
83226>>>>>>>>>
83226>>>>>>>>>        If (iCol >= 1 and iCol <= piColumnCount(Self)) Begin
83228>>>>>>>>>            Get psMaxColValue to sResult
83229>>>>>>>>>            //*** Call the driver function to get the value
83229>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNVALUE ;                        Callback 0 ;                        Passing sResult sEmpty iCol ;                        Result iVoid
83234>>>>>>>>>        End
83234>>>>>>>>>>
83234>>>>>>>>>        Else Begin
83235>>>>>>>>>            Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLColumnValue"
83236>>>>>>>>>        End
83236>>>>>>>>>>
83236>>>>>>>>>
83236>>>>>>>>>        Function_Return sResult
83237>>>>>>>>>        
83237>>>>>>>>>    End_Function
83238>>>>>>>>>
83238>>>>>>>>>
83238>>>>>>>>>
83238>>>>>>>>>    //***
83238>>>>>>>>>    //*** Procedure: SQLBindFile
83238>>>>>>>>>    //*** Purpose  : Add a file to the files used to place the statement result in.
83238>>>>>>>>>    //***
83238>>>>>>>>>
83238>>>>>>>>>    Procedure SQLBindFile Integer iFileNum
83240>>>>>>>>>        Integer ihdbc
83240>>>>>>>>>        Integer ihstmt
83240>>>>>>>>>        Integer iVoid
83240>>>>>>>>>        String  sDrvrId
83240>>>>>>>>>        String  sFileType
83240>>>>>>>>>        Integer bIsOpen
83240>>>>>>>>>
83240>>>>>>>>>        //*** Get the cli handles
83240>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
83241>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83242>>>>>>>>>        Get psDriverId            to sDrvrId
83243>>>>>>>>>
83243>>>>>>>>>        //*** If a file number is not passed see if we can use the statement's
83243>>>>>>>>>        //*** default file number which is usually set with SetFileConnection
83243>>>>>>>>>        If (iFileNum = 0) Begin
83245>>>>>>>>>            Get piBindFile To iFileNum
83246>>>>>>>>>            If (iFileNum = 0) Begin
83248>>>>>>>>>                //*** Logic error, if 0 is passed as filenumber, piBindFile should be set.
83248>>>>>>>>>                Send StmtError CLIERR_SQLINVALID_BIND_FILE "piBindFile should be set" "SQLBindFile"
83249>>>>>>>>>
83249>>>>>>>>>                Move 0 to SQLResult
83250>>>>>>>>>                Procedure_Return
83251>>>>>>>>>            End
83251>>>>>>>>>>
83251>>>>>>>>>        End
83251>>>>>>>>>>
83251>>>>>>>>>
83251>>>>>>>>>        //*** Bind the file
83251>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
83253>>>>>>>>>            //*** Chek if the file is open
83253>>>>>>>>>            Get_attribute DF_FILE_OPENED Of iFileNum To bIsOpen
83256>>>>>>>>>            If (bIsOpen) Begin
83258>>>>>>>>>                //*** Check if the file has the correct type
83258>>>>>>>>>                Get_attribute DF_FILE_DRIVER Of iFileNum To sFileType
83261>>>>>>>>>                If (sFileType = sDrvrId) Begin
83263>>>>>>>>>                    //*** Call the driver function to add a file to a statement
83263>>>>>>>>>                    Call_driver 0 sDrvrId Function FUNC_SQLBINDFILE ;                                Callback Self ;                                Passing ihdbc iFileNum ihstmt ;                                Result iVoid
83268>>>>>>>>>                End
83268>>>>>>>>>>
83268>>>>>>>>>                Else ;                    Send StmtError CLIERR_SQLINVALID_BIND_FILE ("File" * String(iFileNum) * "type incompatible with statement ("  + sFileType + ")") "SQLBindFile"
83270>>>>>>>>>            End
83270>>>>>>>>>>
83270>>>>>>>>>            Else ;                Send StmtError CLIERR_SQLINVALID_BIND_FILE ("File not open (number =" * String(iFileNum) + ")") "SQLBindFile"
83272>>>>>>>>>        End
83272>>>>>>>>>>
83272>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLBindFile"
83274>>>>>>>>>    End_Procedure 
83275>>>>>>>>>
83275>>>>>>>>>
83275>>>>>>>>>
83275>>>>>>>>>    //*************************************************************************
83275>>>>>>>>>    //*** Function: SQLGetData                                              ***
83275>>>>>>>>>    //*** Purpose : Get data of a column.                                   ***
83275>>>>>>>>>    //*************************************************************************
83275>>>>>>>>>
83275>>>>>>>>>    Function SQLGetData Integer iCol Integer iLen Returns String
83277>>>>>>>>>        Integer ihdbc
83277>>>>>>>>>        Integer ihstmt
83277>>>>>>>>>        Integer iVoid
83277>>>>>>>>>        Integer iColSize
83277>>>>>>>>>        Integer iResult
83277>>>>>>>>>        String  sDrvrId
83277>>>>>>>>>        String  sResult
83277>>>>>>>>>        String  sEmpty
83277>>>>>>>>>        Integer bLegalColumn
83277>>>>>>>>>        
83277>>>>>>>>>        Integer iVariableBufferLength
83277>>>>>>>>>
83277>>>>>>>>>        //*** Initialize
83277>>>>>>>>>        Move "" To sEmpty
83278>>>>>>>>>        Move 0 To iResult
83279>>>>>>>>>
83279>>>>>>>>>        //*** Get the cli handles
83279>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
83280>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83281>>>>>>>>>        Get psDriverId            to sDrvrId
83282>>>>>>>>>
83282>>>>>>>>>        //*** Get the data
83282>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
83284>>>>>>>>>            //*** Check if the column exists
83284>>>>>>>>>            If (iCol >= 1 and iCol <= piColumnCount(Self)) Begin
83286>>>>>>>>>                If (iLen = 0) Begin
83288>>>>>>>>>                    Get SQLColumnValue iCol to sResult
83289>>>>>>>>>                End
83289>>>>>>>>>>
83289>>>>>>>>>                Else Begin
83290>>>>>>>>>                    // Add 1 for string terminator
83290>>>>>>>>>                    Move (iLen + 1) to iLen
83291>>>>>>>>>
83291>>>>>>>>>                    Get piVariableBufferLength to iVariableBufferLength
83292>>>>>>>>>                    If (iLen > iVariableBufferLength) Begin
83294>>>>>>>>>                        //*** Allocate
83294>>>>>>>>>                        Move (Repeat(' ', iLen)) to sResult
83295>>>>>>>>>                       
83295>>>>>>>>>                        Set piVariableBufferLength to iLen
83296>>>>>>>>>                        Set psVariableBuffer       to sResult
83297>>>>>>>>>                    End
83297>>>>>>>>>>
83297>>>>>>>>>                    Else Begin
83298>>>>>>>>>                        Get psVariableBuffer       to sResult
83299>>>>>>>>>                    End
83299>>>>>>>>>>
83299>>>>>>>>>
83299>>>>>>>>>
83299>>>>>>>>>                    // FUNC_SQLCOLUMNINFO will tell the driver which hdbc and hstmt to use 
83299>>>>>>>>>                    // in the next FUNC_SQLCOLUMNVALUE call.
83299>>>>>>>>>                    // If hdbc and hstmt have not changed since the last call we don't have to set it.
83299>>>>>>>>>                    If (ihstmt <> giLastSQLhstmt or ihdbc <> giLastSQLhdbc) Begin
83301>>>>>>>>>                        //*** Setup function arguments
83301>>>>>>>>>                        Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                                    Callback 0 ;                                    Passing ihdbc iCol ihstmt ;                                    Result iVoid
83306>>>>>>>>>                        Move ihstmt to giLastSQLhstmt
83307>>>>>>>>>                        Move ihdbc to giLastSQLhdbc
83308>>>>>>>>>                    End
83308>>>>>>>>>>
83308>>>>>>>>>
83308>>>>>>>>>                    Indicate Err False
83309>>>>>>>>>                    //*** Call the driver function to get the data
83309>>>>>>>>>                    Call_driver 0 sDrvrId Function FUNC_SQLGETDATA ;                                Callback Self ;                                Passing sResult iCol iLen ;                                Result iResult
83314>>>>>>>>>
83314>>>>>>>>>                    //*** If something went wrong, adjust the result
83314>>>>>>>>>                    If (Err) Begin
83316>>>>>>>>>                        Move 0 to iResult
83317>>>>>>>>>                    End
83317>>>>>>>>>>
83317>>>>>>>>>                End
83317>>>>>>>>>>
83317>>>>>>>>>            End
83317>>>>>>>>>>
83317>>>>>>>>>            Else Begin
83318>>>>>>>>>                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLGetData"
83319>>>>>>>>>            End
83319>>>>>>>>>>
83319>>>>>>>>>        End
83319>>>>>>>>>>
83319>>>>>>>>>        Else Begin
83320>>>>>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLGetData"
83321>>>>>>>>>        End
83321>>>>>>>>>>
83321>>>>>>>>>
83321>>>>>>>>>        //*** Fill global result
83321>>>>>>>>>        Move iResult To SQLResult
83322>>>>>>>>>
83322>>>>>>>>>        Function_Return sResult
83323>>>>>>>>>    End_Function 
83324>>>>>>>>>
83324>>>>>>>>>
83324>>>>>>>>>
83324>>>>>>>>>    //***
83324>>>>>>>>>    //*** Function: SQLColumnMap
83324>>>>>>>>>    //*** Purpose : Map a column name to a number, if the name id not found no
83324>>>>>>>>>    //***           error is generated the returned number will be 0 (zero) in
83324>>>>>>>>>    //***           that case
83324>>>>>>>>>    //***
83324>>>>>>>>>
83324>>>>>>>>>    Function SQLColumnMap String sColname Returns Integer
83326>>>>>>>>>        Integer ihdbc
83326>>>>>>>>>        Integer ihstmt
83326>>>>>>>>>        Integer iNumColumns
83326>>>>>>>>>        Integer iColCount
83326>>>>>>>>>        Integer iColNum
83326>>>>>>>>>        String  sDrvrId
83326>>>>>>>>>        String  sCurColName
83326>>>>>>>>>
83326>>>>>>>>>        //*** Get the cli handles
83326>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
83327>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83328>>>>>>>>>        Get psDriverId            to sDrvrId
83329>>>>>>>>>
83329>>>>>>>>>        //*** Get the number by looping through the column names
83329>>>>>>>>>        Move 0 To iColNum
83330>>>>>>>>>        Get SQLPrivateStmtAttribute SQLSTMTATTRIB_COLUMNCOUNT ihdbc sDrvrId ihstmt To iNumColumns
83331>>>>>>>>>        For iColCount From 1 To iNumColumns
83337>>>>>>>>>>
83337>>>>>>>>>            Get SQLPrivateColAttribute iColCount SQLCOLATTRIB_LABEL ihdbc sDrvrId ihstmt To sCurColName
83338>>>>>>>>>            If (Uppercase(Trim(sColName)) = Uppercase(Trim(sCurColName))) ;                Move iColCount To iColNum
83341>>>>>>>>>
83341>>>>>>>>>            If (iColNum) ;                Break
83344>>>>>>>>>        Loop
83345>>>>>>>>>>
83345>>>>>>>>>
83345>>>>>>>>>        Function_return iColNum
83346>>>>>>>>>    End_Function 
83347>>>>>>>>>
83347>>>>>>>>>
83347>>>>>>>>>
83347>>>>>>>>>    //***
83347>>>>>>>>>    //*** Function: SQLStmtAttribute
83347>>>>>>>>>    //*** Purpose : Get a statement attribute
83347>>>>>>>>>    //***
83347>>>>>>>>>
83347>>>>>>>>>    Function SQLStmtAttribute Integer iAttribId Returns String
83349>>>>>>>>>        Integer ihdbc
83349>>>>>>>>>        Integer ihstmt
83349>>>>>>>>>        String  sResult
83349>>>>>>>>>        String  sDrvrId
83349>>>>>>>>>
83349>>>>>>>>>        //*** Initialize
83349>>>>>>>>>        Move "" To sResult
83350>>>>>>>>>
83350>>>>>>>>>        //*** Get the cli handles
83350>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
83351>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83352>>>>>>>>>        Get psDriverId            to sDrvrId
83353>>>>>>>>>
83353>>>>>>>>>        //*** Get the attribute
83353>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") ;            Get SQLPrivateStmtAttribute iAttribId ihdbc sDrvrId ihstmt To sResult
83356>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLStmtAttribute"
83358>>>>>>>>>
83358>>>>>>>>>        Function_Return sResult
83359>>>>>>>>>    End_Function 
83360>>>>>>>>>
83360>>>>>>>>>    Function SQLPrivateStmtAttribute Integer iAttribId Integer ihdbc String sDrvrId Integer ihstmt Returns String
83362>>>>>>>>>        String  sResult
83362>>>>>>>>>        Integer iLen
83362>>>>>>>>>        Integer bLegalAttrib
83362>>>>>>>>>
83362>>>>>>>>>        //*** Initialize
83362>>>>>>>>>        Move ""     To sResult
83363>>>>>>>>>
83363>>>>>>>>>        //*** Get the attribute
83363>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
83365>>>>>>>>>            Case Begin
83365>>>>>>>>>                Case (iAttribId = SQLSTMTATTRIB_COLUMNCOUNT)
83367>>>>>>>>>                Case (iAttribId = SQLSTMTATTRIB_ROWCOUNT)
83370>>>>>>>>>                Case (iAttribId = SQLSTMTATTRIB_ROWCOUNT_TYPE)
83373>>>>>>>>>                Case (iAttribId = SQLSTMTATTRIB_NUMMESSAGES)
83376>>>>>>>>>                    Move DFTRUE To bLegalAttrib
83377>>>>>>>>>                    Break
83378>>>>>>>>>
83378>>>>>>>>>                Case Else
83378>>>>>>>>>                    Move DFFALSE To bLegalAttrib
83379>>>>>>>>>                    Send SQLIllegalAttribute ("Attribute is = " + String(iAttribId) + ")") "SQLPrivateStmtAttribute"
83380>>>>>>>>>            Case End
83380>>>>>>>>>
83380>>>>>>>>>            If (bLegalAttrib) Begin
83382>>>>>>>>>                //*** Setup function arguments
83382>>>>>>>>>                Call_driver 0 sDrvrId Function FUNC_SQLSTMTINTATTRIB ;                            Callback Self ;                            Passing ihdbc iAttribId ihstmt ;                            Result sResult
83387>>>>>>>>>            End
83387>>>>>>>>>>
83387>>>>>>>>>        End
83387>>>>>>>>>>
83387>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLPrivateStmtAttribute"
83389>>>>>>>>>
83389>>>>>>>>>        Function_Return sResult
83390>>>>>>>>>    End_Function 
83391>>>>>>>>>
83391>>>>>>>>>
83391>>>>>>>>>
83391>>>>>>>>>    //***
83391>>>>>>>>>    //*** Function: SQLColAttribute
83391>>>>>>>>>    //*** Purpose : Get a column's attribute
83391>>>>>>>>>    //***
83391>>>>>>>>>
83391>>>>>>>>>    Function SQLColAttribute Integer iCol Integer iAttribId Returns String
83393>>>>>>>>>        Integer ihdbc
83393>>>>>>>>>        Integer ihstmt
83393>>>>>>>>>        String  sResult
83393>>>>>>>>>        String  sDrvrId
83393>>>>>>>>>
83393>>>>>>>>>        //*** Initialize
83393>>>>>>>>>        Move "" To sResult
83394>>>>>>>>>
83394>>>>>>>>>        //*** Get the cli handles
83394>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
83395>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83396>>>>>>>>>        Get psDriverId            to sDrvrId
83397>>>>>>>>>
83397>>>>>>>>>        //*** Get the attribute
83397>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") ;            Get SQLPrivateColAttribute iCol iAttribId ihdbc sDrvrId ihstmt To sResult
83400>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLColAttribute"
83402>>>>>>>>>
83402>>>>>>>>>        Function_Return sResult
83403>>>>>>>>>    End_Function 
83404>>>>>>>>>
83404>>>>>>>>>    Function SQLPrivateColAttribute Integer iCol Integer iAttribId Integer ihdbc String sDrvrId Integer ihstmt Returns String
83406>>>>>>>>>        String  sResult
83406>>>>>>>>>        String  sEmpty
83406>>>>>>>>>        Integer bIsStringAttribute
83406>>>>>>>>>        Integer iLen
83406>>>>>>>>>        Integer iVoid
83406>>>>>>>>>        Integer bLegalAttrib
83406>>>>>>>>>        Integer bLegalColumn
83406>>>>>>>>>
83406>>>>>>>>>        //*** Initialize
83406>>>>>>>>>        Move "" To sResult
83407>>>>>>>>>        Move "" To sEmpty
83408>>>>>>>>>        MOve 0  To iLen
83409>>>>>>>>>
83409>>>>>>>>>        //*** Get the attribute
83409>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
83411>>>>>>>>>            Get SQLPrivateColumnIsLegal ihdbc sDrvrId ihstmt iCol To bLegalColumn
83412>>>>>>>>>            If (bLegalColumn) Begin
83414>>>>>>>>>                //*** Determine the atributes type
83414>>>>>>>>>                Case Begin
83414>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_SIZE)
83416>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_LENGTH)
83419>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_PRECISION)
83422>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_SQLTYPE)
83425>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_NULLABLE)
83428>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_DFTYPE)
83431>>>>>>>>>                        Move DFFALSE To bIsStringAttribute
83432>>>>>>>>>                        Move DFTRUE To bLegalAttrib
83433>>>>>>>>>                        Break
83434>>>>>>>>>
83434>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_LABEL)
83437>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_BASECOLUMNNAME)
83440>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_BASETABLENAME)
83443>>>>>>>>>                        Move DFTRUE To bIsStringAttribute
83444>>>>>>>>>                        Move DFTRUE To bLegalAttrib
83445>>>>>>>>>                        Break
83446>>>>>>>>>
83446>>>>>>>>>                    Case Else
83446>>>>>>>>>                        Move DFFALSE To bLegalAttrib
83447>>>>>>>>>                        Send SQLIllegalAttribute ("Attribute is = " + String(iAttribId) + ")") "SQLPrivateColAttribute"
83448>>>>>>>>>                Case End
83448>>>>>>>>>
83448>>>>>>>>>                If (bLegalAttrib) Begin
83450>>>>>>>>>                    //*** Setup function arguments
83450>>>>>>>>>                    Call_driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                                Callback Self ;                                Passing ihdbc iCol ihstmt ;                                Result iVoid
83455>>>>>>>>>
83455>>>>>>>>>                    If (bIsStringAttribute) Begin
83457>>>>>>>>>                        //*** Call the driver function to get the data length
83457>>>>>>>>>                        Call_driver 0 sDrvrId Function FUNC_SQLCOLSTRINGATTRIBLEN ;                                    Callback Self ;                                    Passing sEmpty sEmpty iAttribId ;                                    Result iLen
83462>>>>>>>>>
83462>>>>>>>>>                        If (iLen) Begin
83464>>>>>>>>>                            //*** Allocate
83464>>>>>>>>>                            Move (Repeat(' ', iLen)) To sResult
83465>>>>>>>>>
83465>>>>>>>>>                            //*** Call the driver function to get the name
83465>>>>>>>>>                            Call_driver 0 sDrvrId Function FUNC_SQLCOLSTRINGATTRIB ;                                        Callback Self ;                                        Passing sResult sEmpty iAttribId ;                                        Result iVoid
83470>>>>>>>>>                        End
83470>>>>>>>>>>
83470>>>>>>>>>                    End
83470>>>>>>>>>>
83470>>>>>>>>>                    Else Begin
83471>>>>>>>>>                        //*** get the attribute
83471>>>>>>>>>                        Call_driver 0 sDrvrId Function FUNC_SQLCOLINTATTRIB ;                                    Callback Self ;                                    Passing sEmpty sEmpty iAttribId ;                                    Result sResult
83476>>>>>>>>>                    End
83476>>>>>>>>>>
83476>>>>>>>>>                End
83476>>>>>>>>>>
83476>>>>>>>>>            End
83476>>>>>>>>>>
83476>>>>>>>>>            Else ;                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLPrivateColAttribute"
83478>>>>>>>>>        End
83478>>>>>>>>>>
83478>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLPrivateColAttribute"
83480>>>>>>>>>
83480>>>>>>>>>        Function_Return sResult
83481>>>>>>>>>    End_Function 
83482>>>>>>>>>
83482>>>>>>>>>
83482>>>>>>>>>
83482>>>>>>>>>    //***
83482>>>>>>>>>    //*** Procedure: SQLSetProcedureName
83482>>>>>>>>>    //*** Purpsoe  : Preapre for calling a stored procedure, pass the procedure name.
83482>>>>>>>>>    //***
83482>>>>>>>>>
83482>>>>>>>>>    Procedure SQLSetProcedureName String sProcName String sSchemaArg
83484>>>>>>>>>        Integer ihdbc
83484>>>>>>>>>        Integer ihstmt
83484>>>>>>>>>        String  sDrvrId
83484>>>>>>>>>        Integer iVoid
83484>>>>>>>>>        String  sSchema
83484>>>>>>>>>        String  sEmpty
83484>>>>>>>>>
83484>>>>>>>>>        //*** Initialize
83484>>>>>>>>>        Move "" To sEmpty
83485>>>>>>>>>
83485>>>>>>>>>        //*** Get the cli handles
83485>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
83486>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83487>>>>>>>>>        Get psDriverId            to sDrvrId
83488>>>>>>>>>
83488>>>>>>>>>        //*** Call the procedure
83488>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
83490>>>>>>>>>            If (Num_Arguments >= 2) ;                Move sSchemaArg To sSchema
83493>>>>>>>>>            Else ;                Move "" To sSchema
83495>>>>>>>>>
83495>>>>>>>>>            If (sSchema <> "") Begin
83497>>>>>>>>>                Call_driver 0 sDrvrId Function FUNC_SQLSETPROCSCHEMA ;                            Callback Self ;                            Passing ihdbc sSchema ihstmt ;                            Result iVoid
83502>>>>>>>>>            End
83502>>>>>>>>>>
83502>>>>>>>>>
83502>>>>>>>>>            //*** Call the procedure
83502>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLSETPROCNAME ;                        Callback Self ;                        Passing ihdbc sProcName ihstmt ;                        Result iVoid
83507>>>>>>>>>
83507>>>>>>>>>            Set piLastArgument To 0
83508>>>>>>>>>        End
83508>>>>>>>>>>
83508>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLSetProcedurename"
83510>>>>>>>>>    End_Procedure 
83511>>>>>>>>>
83511>>>>>>>>>
83511>>>>>>>>>
83511>>>>>>>>>    //***
83511>>>>>>>>>    //*** Function: SQLSetNextArgument
83511>>>>>>>>>    //*** Purpose : Pass the next argument
83511>>>>>>>>>    //***
83511>>>>>>>>>
83511>>>>>>>>>    Procedure SQLSetNextArgument String sArgument
83513>>>>>>>>>        Integer iArgnum
83513>>>>>>>>>
83513>>>>>>>>>        Get piLastArgument To iArgnum
83514>>>>>>>>>        Increment iArgnum
83515>>>>>>>>>        Send SQLSetArgument iArgnum sArgument
83516>>>>>>>>>        Set piLastArgument To iArgnum
83517>>>>>>>>>    End_Procedure 
83518>>>>>>>>>
83518>>>>>>>>>
83518>>>>>>>>>
83518>>>>>>>>>    //***
83518>>>>>>>>>    //*** Procedure: SQLSetArgument
83518>>>>>>>>>    //*** Purpose  : Set the next argument
83518>>>>>>>>>    //***
83518>>>>>>>>>
83518>>>>>>>>>    Procedure SQLSetArgument Integer iArgnum String sArgument
83520>>>>>>>>>        Integer ihdbc
83520>>>>>>>>>        Integer ihstmt
83520>>>>>>>>>        String  sDrvrId
83520>>>>>>>>>        Integer iVoid
83520>>>>>>>>>        String  sEmpty
83520>>>>>>>>>
83520>>>>>>>>>        //*** Initialize
83520>>>>>>>>>        Move "" To sEmpty
83521>>>>>>>>>
83521>>>>>>>>>        //*** Get the cli handles
83521>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
83522>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83523>>>>>>>>>        Get psDriverId            to sDrvrId
83524>>>>>>>>>
83524>>>>>>>>>        //*** Call the procedure
83524>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
83526>>>>>>>>>            //*** Pass the information
83526>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                        Callback Self ;                        Passing ihdbc iArgnum ihstmt ;                        Result iVoid
83531>>>>>>>>>
83531>>>>>>>>>            //*** Pass the argument
83531>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLSETPROCARG ;                        Callback Self ;                        Passing sArgument sEmpty 0 ;                        Result iVoid
83536>>>>>>>>>        End
83536>>>>>>>>>>
83536>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLSetArgument"
83538>>>>>>>>>    End_Procedure
83539>>>>>>>>>
83539>>>>>>>>>
83539>>>>>>>>>
83539>>>>>>>>>    //***
83539>>>>>>>>>    //*** Procedure: SQLCall
83539>>>>>>>>>    //*** Purpose  : Call a stored procedure
83539>>>>>>>>>    //***
83539>>>>>>>>>
83539>>>>>>>>>    Procedure SQLCall
83541>>>>>>>>>        Integer ihdbc
83541>>>>>>>>>        Integer ihstmt
83541>>>>>>>>>        String  sDrvrId
83541>>>>>>>>>        Integer iVoid
83541>>>>>>>>>        String  sEmpty
83541>>>>>>>>>
83541>>>>>>>>>        //*** Initialize
83541>>>>>>>>>        Move "" To sEmpty
83542>>>>>>>>>
83542>>>>>>>>>        //*** Get the cli handles
83542>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
83543>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83544>>>>>>>>>        Get psDriverId            to sDrvrId
83545>>>>>>>>>
83545>>>>>>>>>        //*** Call the procedure
83545>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
83547>>>>>>>>>            //*** Call the procedure
83547>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLCALL ;                        Callback Self ;                        Passing ihdbc sEmpty ihstmt ;                        Result iVoid
83552>>>>>>>>>                        
83552>>>>>>>>>            Send SQLGetStatementAttributes
83553>>>>>>>>>            Set piLastArgument To 0
83554>>>>>>>>>        End
83554>>>>>>>>>>
83554>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLCall"
83556>>>>>>>>>    End_Procedure 
83557>>>>>>>>>
83557>>>>>>>>>
83557>>>>>>>>>
83557>>>>>>>>>    //***
83557>>>>>>>>>    //*** Function: SQLGetNextArgument
83557>>>>>>>>>    //*** Purpose : Get the next argument
83557>>>>>>>>>    //***
83557>>>>>>>>>
83557>>>>>>>>>    Function SQLGetNextArgument Returns String
83559>>>>>>>>>        Integer iArgnum
83559>>>>>>>>>        String  sResult
83559>>>>>>>>>
83559>>>>>>>>>        Get piLastArgument To iArgnum
83560>>>>>>>>>        Increment iArgnum
83561>>>>>>>>>        Get SQLGetArgument iArgnum To sResult
83562>>>>>>>>>        Set piLastArgument To iArgnum
83563>>>>>>>>>
83563>>>>>>>>>        Function_return sResult
83564>>>>>>>>>    End_Function 
83565>>>>>>>>>
83565>>>>>>>>>
83565>>>>>>>>>
83565>>>>>>>>>    //***
83565>>>>>>>>>    //*** Function: SQLGetArgument
83565>>>>>>>>>    //*** Purpose : Get the specified argument from a procedure
83565>>>>>>>>>    //***
83565>>>>>>>>>
83565>>>>>>>>>    Function SQLGetArgument Integer iArgnum Returns String
83567>>>>>>>>>        Integer ihdbc
83567>>>>>>>>>        Integer ihstmt
83567>>>>>>>>>        String  sDrvrId
83567>>>>>>>>>        Integer iVoid
83567>>>>>>>>>        String  sEmpty
83567>>>>>>>>>        String  sArgument
83567>>>>>>>>>        Integer iLen
83567>>>>>>>>>
83567>>>>>>>>>        //*** Initialize
83567>>>>>>>>>        Move "" To sEmpty
83568>>>>>>>>>        Move "" To sArgument
83569>>>>>>>>>
83569>>>>>>>>>        //*** Get the cli handles
83569>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
83570>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83571>>>>>>>>>        Get psDriverId            to sDrvrId
83572>>>>>>>>>
83572>>>>>>>>>        //*** Call the procedure
83572>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
83574>>>>>>>>>            //*** Pass the information
83574>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                        Callback Self ;                        Passing ihdbc iArgnum ihstmt ;                        Result iVoid
83579>>>>>>>>>
83579>>>>>>>>>            //*** Get the length
83579>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLGETPROCARGLEN ;                        Callback Self ;                        Passing sEmpty sEmpty 0 ;                        Result iLen
83584>>>>>>>>>
83584>>>>>>>>>            If (iLen) Begin
83586>>>>>>>>>                //*** Allocate
83586>>>>>>>>>                Move (Repeat(' ', iLen)) To sArgument
83587>>>>>>>>>
83587>>>>>>>>>                //*** Pass the argument
83587>>>>>>>>>                Call_driver 0 sDrvrId Function FUNC_SQLGETPROCARG ;                            Callback Self ;                            Passing sArgument sEmpty 0 ;                            Result iVoid
83592>>>>>>>>>            End
83592>>>>>>>>>>
83592>>>>>>>>>        End
83592>>>>>>>>>>
83592>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLGetArgument"
83594>>>>>>>>>
83594>>>>>>>>>        Function_Return sArgument
83595>>>>>>>>>    End_Function 
83596>>>>>>>>>
83596>>>>>>>>>
83596>>>>>>>>>
83596>>>>>>>>>    //***
83596>>>>>>>>>    //*** Function: SQLReturnValue
83596>>>>>>>>>    //*** Purpose : Get the return value of a stored function
83596>>>>>>>>>    //***
83596>>>>>>>>>
83596>>>>>>>>>    Function SQLReturnValue Returns String
83598>>>>>>>>>        Integer ihdbc
83598>>>>>>>>>        Integer ihstmt
83598>>>>>>>>>        String  sDrvrId
83598>>>>>>>>>        Integer iVoid
83598>>>>>>>>>        String  sEmpty
83598>>>>>>>>>        String  sRetval
83598>>>>>>>>>        Integer iLen
83598>>>>>>>>>
83598>>>>>>>>>        //*** Initialize
83598>>>>>>>>>        Move "" To sEmpty
83599>>>>>>>>>        Move "" To sRetval
83600>>>>>>>>>
83600>>>>>>>>>        //*** Get the cli handles
83600>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
83601>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83602>>>>>>>>>        Get psDriverId            to sDrvrId
83603>>>>>>>>>
83603>>>>>>>>>        //*** Call the procedure
83603>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
83605>>>>>>>>>            //*** Get the length
83605>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLGETPROCRETVALLEN ;                        Callback Self ;                        Passing ihdbc sEmpty ihstmt  ;                        Result iLen
83610>>>>>>>>>
83610>>>>>>>>>            If (iLen) Begin
83612>>>>>>>>>                //*** Allocate
83612>>>>>>>>>                Move (Repeat(' ', iLen)) To sRetval
83613>>>>>>>>>
83613>>>>>>>>>                //*** Pass the argument
83613>>>>>>>>>                Call_driver 0 sDrvrId Function FUNC_SQLGETPROCRETVAL ;                            Callback Self ;                            Passing ihdbc sRetval ihstmt ;                            Result iVoid
83618>>>>>>>>>            End
83618>>>>>>>>>>
83618>>>>>>>>>        End
83618>>>>>>>>>>
83618>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLReturnValue"
83620>>>>>>>>>
83620>>>>>>>>>        Function_Return sRetval
83621>>>>>>>>>    End_Function 
83622>>>>>>>>>
83622>>>>>>>>>
83622>>>>>>>>>
83622>>>>>>>>>    //***
83622>>>>>>>>>    //*** Function: SQLNextResultSet
83622>>>>>>>>>    //*** Purpose : Switch to the next set
83622>>>>>>>>>    //*** Returns : 0   = No more result sets
83622>>>>>>>>>    //***           <>0 = Switched to next set
83622>>>>>>>>>    //***
83622>>>>>>>>>
83622>>>>>>>>>    Function SQLNextResultSet Returns Integer
83624>>>>>>>>>        Integer ihdbc
83624>>>>>>>>>        Integer ihstmt
83624>>>>>>>>>        String  sDrvrId
83624>>>>>>>>>        Integer iResult
83624>>>>>>>>>        String  sEmpty
83624>>>>>>>>>
83624>>>>>>>>>        //*** Initialize
83624>>>>>>>>>        Move "" To sEmpty
83625>>>>>>>>>        Move 0  To iResult
83626>>>>>>>>>
83626>>>>>>>>>        //*** Get the cli handles
83626>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
83627>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83628>>>>>>>>>        Get psDriverId            to sDrvrId
83629>>>>>>>>>
83629>>>>>>>>>        //*** Call the procedure
83629>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
83631>>>>>>>>>            //*** Get the length
83631>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLNEXTRESULTSET ;                        Callback Self ;                        Passing ihdbc sEmpty ihstmt  ;                        Result iResult
83636>>>>>>>>>                        
83636>>>>>>>>>            Send SQLGetStatementAttributes
83637>>>>>>>>>            Set piLastArgument to 0
83638>>>>>>>>>        End
83638>>>>>>>>>>
83638>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLNextResultSet"
83640>>>>>>>>>
83640>>>>>>>>>        Function_Return iResult
83641>>>>>>>>>    End_Function
83642>>>>>>>>>
83642>>>>>>>>>
83642>>>>>>>>>
83642>>>>>>>>>    //***
83642>>>>>>>>>    //*** Procedure: SQLFetchActivatesBuffer
83642>>>>>>>>>    //*** Purpose  : Setup a file that will be acivated after a succesfull
83642>>>>>>>>>    //***            fetch on the statement
83642>>>>>>>>>    //***
83642>>>>>>>>>
83642>>>>>>>>>    Procedure SQLFetchActivatesBuffer Integer iFileNum Integer bState
83644>>>>>>>>>        Integer ihdbc
83644>>>>>>>>>        Integer ihstmt
83644>>>>>>>>>        String  sDrvrId
83644>>>>>>>>>        Integer iResult
83644>>>>>>>>>        Integer bIsOpen
83644>>>>>>>>>        Integer iVoid
83644>>>>>>>>>        String  sFileType
83644>>>>>>>>>
83644>>>>>>>>>        //*** Check if file is open
83644>>>>>>>>>        Get_attribute DF_FILE_OPENED Of iFileNum To bIsOpen
83647>>>>>>>>>        If (bIsOpen) Begin
83649>>>>>>>>>            //*** Get the cli handles
83649>>>>>>>>>            Get phCLIStatementHandle  to ihstmt
83650>>>>>>>>>            Get phCLIConnectionHandle to ihdbc
83651>>>>>>>>>            Get psDriverId            to sDrvrId
83652>>>>>>>>>
83652>>>>>>>>>            //*** Call the procedure
83652>>>>>>>>>            If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
83654>>>>>>>>>                //*** Check if the file has the correct type
83654>>>>>>>>>                Get_attribute DF_FILE_DRIVER Of iFileNum To sFileType
83657>>>>>>>>>                If (sFileType = sDrvrId) Begin
83659>>>>>>>>>                    //*** Setup the buffer
83659>>>>>>>>>                    Call_driver iFileNum sDrvrId Function FUNC_SQLBUFFERSTATUS ;                                Callback Self ;                                Passing ihdbc bState ihstmt  ;                                Result iVoid
83664>>>>>>>>>                End
83664>>>>>>>>>>
83664>>>>>>>>>                Else ;                    Send StmtError CLIERR_SQLINVALID_BIND_FILE ("File" * String(iFileNum) * "type incompatible with statement ("  + sFileType + ")") "SQLBindFile"
83666>>>>>>>>>            End
83666>>>>>>>>>>
83666>>>>>>>>>            Else ;                Send HandleError ihstmt ihdbc sDrvrId "SQLFetchActivatesBuffer"
83668>>>>>>>>>        End
83668>>>>>>>>>>
83668>>>>>>>>>        Else ;            Send StmtError CLIERR_SQLINVALID_BUFFER ("File not open (number =" * String(iFileNum) + ")") "SQLFetchActivatesBuffer"
83670>>>>>>>>>    End_Procedure 
83671>>>>>>>>>
83671>>>>>>>>>
83671>>>>>>>>>
83671>>>>>>>>>    Function SQLGetMessage Integer iMessageNum Returns String
83673>>>>>>>>>        Integer ihdbc
83673>>>>>>>>>        Integer ihstmt
83673>>>>>>>>>        String  sDrvrId
83673>>>>>>>>>        String  sMessage
83673>>>>>>>>>        Integer iVoid
83673>>>>>>>>>
83673>>>>>>>>>        //*** Initialize
83673>>>>>>>>>        Move "" To sMessage
83674>>>>>>>>>
83674>>>>>>>>>        //*** Get the cli handles
83674>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
83675>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83676>>>>>>>>>        Get psDriverId            to sDrvrId
83677>>>>>>>>>
83677>>>>>>>>>        //*** Call the procedure
83677>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
83679>>>>>>>>>            //*** Setup function arguments
83679>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                        Callback Self ;                        Passing ihdbc iMessageNum ihstmt ;                        Result iVoid
83684>>>>>>>>>
83684>>>>>>>>>            Move (Repeat(' ', 1024)) To sMessage
83685>>>>>>>>>            //*** Get the length
83685>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLGETMESSAGE ;                        Callback Self ;                        Passing iVoid sMessage iVoid ;                        Result iVoid
83690>>>>>>>>>        End
83690>>>>>>>>>>
83690>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLGetDiagRec"
83692>>>>>>>>>
83692>>>>>>>>>        Function_Return sMessage
83693>>>>>>>>>    End_Function 
83694>>>>>>>>>
83694>>>>>>>>>
83694>>>>>>>>>
83694>>>>>>>>>    //***
83694>>>>>>>>>    //*** Function: RemoveComponentIdentifier
83694>>>>>>>>>    //*** Purpose : Remove the component identifier from a diagnostic message
83694>>>>>>>>>    //***
83694>>>>>>>>>
83694>>>>>>>>>    Function RemoveComponentIdentifier String sDiagMessage Returns String
83696>>>>>>>>>        While (Left(sDiagMessage, 1) = "[")
83700>>>>>>>>>            Move (Right(sDiagMessage, Length(sDiagMessage) - Pos("]", sDiagMessage))) To sDiagMessage
83701>>>>>>>>>        End
83702>>>>>>>>>>
83702>>>>>>>>>
83702>>>>>>>>>        Function_Return sDiagMessage
83703>>>>>>>>>    End_Function
83704>>>>>>>>>
83704>>>>>>>>>
83704>>>>>>>>>
83704>>>>>>>>>    //***
83704>>>>>>>>>    //*** Function: DFDateToSQLDate
83704>>>>>>>>>    //*** Purpose : Convert a DataFlex date to a SQL Date. Use dummy zero dates.
83704>>>>>>>>>    //***
83704>>>>>>>>>    Function DFDateToSQLDate Date dDFDate Integer iSQLType Returns String
83706>>>>>>>>>        
83706>>>>>>>>>        Integer iType
83706>>>>>>>>>        String  sSQLDate
83706>>>>>>>>>        Integer iOrgDateFmt
83706>>>>>>>>>        Integer iOrgDateSep
83706>>>>>>>>>
83706>>>>>>>>>        String sDriverId
83706>>>>>>>>>        String sDummyZeroDate
83706>>>>>>>>>        String sDummyZeroDateMssqlDatetime
83706>>>>>>>>>
83706>>>>>>>>>        //*** Change date format to military, SQL dates are military dates
83706>>>>>>>>>        Get_Attribute DF_DATE_FORMAT to iOrgDateFmt
83709>>>>>>>>>        Get_Attribute DF_DATE_SEPARATOR to iOrgDateSep
83712>>>>>>>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_MILITARY
83715>>>>>>>>>        Set_Attribute DF_DATE_SEPARATOR to (Ascii('-'))
83718>>>>>>>>>
83718>>>>>>>>>        //*** We only need to convert if the date is 0
83718>>>>>>>>>        If (Integer(dDFDate = 0)) Begin
83720>>>>>>>>>
83720>>>>>>>>>            If (num_arguments < 2) Begin
83722>>>>>>>>>                Move SQL_TYPE_TIMESTAMP to iType
83723>>>>>>>>>            End
83723>>>>>>>>>>
83723>>>>>>>>>            Else Begin
83724>>>>>>>>>                Move iSQLType to iType
83725>>>>>>>>>            End
83725>>>>>>>>>>
83725>>>>>>>>>
83725>>>>>>>>>            
83725>>>>>>>>>            Get psDriverID to sDriverId
83726>>>>>>>>>            Get psDummyZeroDate to sDummyZeroDate
83727>>>>>>>>>                
83727>>>>>>>>>            If ( (iType = SQL_TYPE_TIMESTAMP) and (sDriverID = 'MSSQLDRV') ) Begin
83729>>>>>>>>>                Get psDummyZeroDateMssqlDatetime to sDummyZeroDateMssqlDatetime
83730>>>>>>>>>                Move sDummyZeroDateMssqlDatetime to sSQLDate
83731>>>>>>>>>            End
83731>>>>>>>>>>
83731>>>>>>>>>            Else Begin
83732>>>>>>>>>                Move sDummyZeroDate to sSQLDate
83733>>>>>>>>>            End
83733>>>>>>>>>>
83733>>>>>>>>>            
83733>>>>>>>>>            //CLI_Get_Driver_Attribute sDRiver DRVR_DUMMY_ZERO_DATE_VALUE to sSQLDate
83733>>>>>>>>>        End
83733>>>>>>>>>>
83733>>>>>>>>>        Else Begin
83734>>>>>>>>>            Move dDFDate to sSQLDate
83735>>>>>>>>>        End
83735>>>>>>>>>>
83735>>>>>>>>>
83735>>>>>>>>>        //*** Change date format back to original
83735>>>>>>>>>        Set_Attribute DF_DATE_FORMAT to iOrgDateFmt
83738>>>>>>>>>        Set_Attribute DF_DATE_SEPARATOR to iOrgDateSep
83741>>>>>>>>>
83741>>>>>>>>>        Function_Return sSQLDate
83742>>>>>>>>>    End_Function 
83743>>>>>>>>>
83743>>>>>>>>>
83743>>>>>>>>>    //***
83743>>>>>>>>>    //*** Function: SQLDateToDFDate
83743>>>>>>>>>    //*** Purpose : Convert a SQL date to a DataFlex Date. Use dummy zero dates.
83743>>>>>>>>>    //***
83743>>>>>>>>>    Function SQLDateToDFDate String sSQLDate Returns Date
83745>>>>>>>>>        
83745>>>>>>>>>        Integer iType
83745>>>>>>>>>        Date    dDFDate
83745>>>>>>>>>        Integer iOrgDateFmt
83745>>>>>>>>>        Integer iOrgDateSep
83745>>>>>>>>>        
83745>>>>>>>>>        String  sDriverId
83745>>>>>>>>>        String  sDummyZeroDate
83745>>>>>>>>>        String  sDummyZeroDateMssqlDatetime
83745>>>>>>>>>        
83745>>>>>>>>>        Get psDriverID to sDriverId
83746>>>>>>>>>        
83746>>>>>>>>>        Get psDummyZeroDate to sDummyZeroDate
83747>>>>>>>>>        Get psDummyZeroDateMssqlDatetime to sDummyZeroDateMssqlDatetime
83748>>>>>>>>>        
83748>>>>>>>>>        Get_Attribute DF_DATE_FORMAT to iOrgDateFmt
83751>>>>>>>>>        Get_Attribute DF_DATE_SEPARATOR to iOrgDateSep
83754>>>>>>>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_MILITARY
83757>>>>>>>>>        Set_Attribute DF_DATE_SEPARATOR to (Ascii('-'))
83760>>>>>>>>>        
83760>>>>>>>>>        Move (Left(sSQLDate,10)) to sSQLDate 
83761>>>>>>>>>
83761>>>>>>>>>        If ( (sSQLDate = sDummyZeroDate) or ;             ( (sDriverId = 'MSSQLDRV') and (sSQLDate = sDummyZeroDateMssqlDatetime) ) )  Begin
83763>>>>>>>>>            Move 0 to dDFDate
83764>>>>>>>>>        End
83764>>>>>>>>>>
83764>>>>>>>>>        Else Begin
83765>>>>>>>>>            Move sSQLDate to dDFDate
83766>>>>>>>>>        End
83766>>>>>>>>>>
83766>>>>>>>>>
83766>>>>>>>>>        //*** Change date format back to original
83766>>>>>>>>>        Set_Attribute DF_DATE_FORMAT to iOrgDateFmt
83769>>>>>>>>>        Set_Attribute DF_DATE_SEPARATOR to iOrgDateSep
83772>>>>>>>>>
83772>>>>>>>>>        Function_Return dDFDate
83773>>>>>>>>>    End_Function 
83774>>>>>>>>>
83774>>>>>>>>>End_Class 
83775>>>>>>>>>
83775>>>>>>>>>
83775>>>>>>>>>//*****************************************************************************
83775>>>>>>>>>//*** Class  : cSQLConnection                                               ***
83775>>>>>>>>>//*** Purpose: Connection object for embedded SQL                           ***
83775>>>>>>>>>//***                                                                       ***
83775>>>>>>>>>//*** Description:                                                          ***
83775>>>>>>>>>//***   This provides the ability to create a connection for a driver.      ***
83775>>>>>>>>>//***   It will contain child statement objects                             ***
83775>>>>>>>>>//*****************************************************************************
83775>>>>>>>>>
83775>>>>>>>>>Class cSQLConnection is a cObject
83776>>>>>>>>>
83776>>>>>>>>>    Procedure Construct_object 
83778>>>>>>>>>        Forward Send Construct_object 
83780>>>>>>>>>
83780>>>>>>>>>        Property Integer phCLIConnectionHandle       0
83781>>>>>>>>>        
83781>>>>>>>>>        Property String  psDriverID        ""
83782>>>>>>>>>        Property Integer piBindFile        0
83783>>>>>>>>>        
83783>>>>>>>>>        Property String psDummyZeroDate              '0001-01-01'
83784>>>>>>>>>        Property String psDummyZeroDateMssqlDatetime '1753-01-01'        
83785>>>>>>>>>
83785>>>>>>>>>    End_Procedure
83786>>>>>>>>>
83786>>>>>>>>>
83786>>>>>>>>>
83786>>>>>>>>>    //***
83786>>>>>>>>>    //*** Procedure: StoreConnectionInfo
83786>>>>>>>>>    //*** Purpose  : Store basic information about the connection
83786>>>>>>>>>    //***
83786>>>>>>>>>    Procedure StoreConnectionInfo Handle hCLIConnectionHandle String sDrvrId 
83788>>>>>>>>>        
83788>>>>>>>>>        String sDummyZeroDate
83788>>>>>>>>>        
83788>>>>>>>>>        Set phCLIConnectionHandle to hCLIConnectionHandle
83789>>>>>>>>>        Set psDriverID            to sDrvrId
83790>>>>>>>>>        
83790>>>>>>>>>        Case Begin
83790>>>>>>>>>            Case (sDrvrId = "MSSQLDRV")
83792>>>>>>>>>                Set psDummyZeroDate to '0001-01-01'
83793>>>>>>>>>                Set psDummyZeroDateMssqlDatetime to '1753-01-01'
83794>>>>>>>>>                Break
83795>>>>>>>>>            Case (sDrvrId = "DB2_DRV")
83798>>>>>>>>>                Set psDummyZeroDate to '0001-01-01'
83799>>>>>>>>>                Break
83800>>>>>>>>>            Case (sDrvrId = "ODBC_DRV")
83803>>>>>>>>>                CLI_Get_Driver_Attribute sDrvrId DRVR_DUMMY_ZERO_DATE_VALUE to sDummyZeroDate
83810>>>>>>>>>                Set psDummyZeroDate to sDummyZeroDate
83811>>>>>>>>>                Break
83812>>>>>>>>>        Case End
83812>>>>>>>>>        
83812>>>>>>>>>    End_Procedure 
83813>>>>>>>>>
83813>>>>>>>>>
83813>>>>>>>>>    //***
83813>>>>>>>>>    //*** Procedure: DestroySQLConnection
83813>>>>>>>>>    //*** Purpose : Destroy the SQLConnection object
83813>>>>>>>>>    //***
83813>>>>>>>>>    Procedure DestroySQLConnection
83815>>>>>>>>>        Send Destroy
83816>>>>>>>>>    End_Procedure 
83817>>>>>>>>>
83817>>>>>>>>>
83817>>>>>>>>>    //***
83817>>>>>>>>>    //*** Function: SQLConnect
83817>>>>>>>>>    //*** Purpose : Connect to a database server
83817>>>>>>>>>    //*** Returns : 1 Succesfully connected
83817>>>>>>>>>    //***           0 Not connected
83817>>>>>>>>>    Function SQLConnect String sDrvrID String sConnect Returns Integer
83819>>>>>>>>>        Integer ihdbc
83819>>>>>>>>>        String  sEmpty
83819>>>>>>>>>
83819>>>>>>>>>        //*** Initialize
83819>>>>>>>>>        Move "" To sEmpty
83820>>>>>>>>>        Move 0  To ihdbc
83821>>>>>>>>>
83821>>>>>>>>>        Indicate Err False
83822>>>>>>>>>
83822>>>>>>>>>        //*** Call the driver function to connect
83822>>>>>>>>>        Call_driver 0 sDrvrId Function FUNC_SQLCONNECT ;                    Callback Self ;                    Passing sConnect sEmpty Self ;                    Result ihdbc
83827>>>>>>>>>
83827>>>>>>>>>        //*** If there was an error, make result invalid
83827>>>>>>>>>        If (Err) ;            Move 0 To ihdbc
83830>>>>>>>>>
83830>>>>>>>>>        //*** Check result and store it
83830>>>>>>>>>        If (ihdbc <> 0) ;            Send StoreConnectionInfo ihdbc sDrvrId
83833>>>>>>>>>
83833>>>>>>>>>        //*** Return success status
83833>>>>>>>>>        Function_Return (ihdbc <> 0)
83834>>>>>>>>>    End_Function 
83835>>>>>>>>>
83835>>>>>>>>>
83835>>>>>>>>>
83835>>>>>>>>>    //***
83835>>>>>>>>>    //*** Function: SQLFileConnect
83835>>>>>>>>>    //*** Purpose : Use a connection of an already open file
83835>>>>>>>>>    //***
83835>>>>>>>>>    Function SQLFileConnect Integer iFileNum Returns Integer
83837>>>>>>>>>        Integer ihdbc
83837>>>>>>>>>        Integer bIsOpen
83837>>>>>>>>>        String  sDrvrId
83837>>>>>>>>>        String  sEmpty
83837>>>>>>>>>
83837>>>>>>>>>        //*** Initialize
83837>>>>>>>>>        Move "" To sEmpty
83838>>>>>>>>>        Move 0  To ihdbc
83839>>>>>>>>>
83839>>>>>>>>>        //*** Check if file is open
83839>>>>>>>>>        Get_attribute DF_FILE_OPENED Of iFileNum To bIsOpen
83842>>>>>>>>>        If (bIsOpen) Begin
83844>>>>>>>>>            //*** Fill the driver id, assume longest is 255 characters
83844>>>>>>>>>            Move (Repeat(' ', 255)) To sDrvrId
83845>>>>>>>>>            Get_attribute DF_FILE_DRIVER Of iFileNum To sDrvrId
83848>>>>>>>>>
83848>>>>>>>>>            Indicate Err False
83849>>>>>>>>>
83849>>>>>>>>>            //*** Call the driver function to connect
83849>>>>>>>>>            Call_driver iFileNum sDrvrId Function FUNC_SQLFILECONNECT ;                        Callback Self ;                        Passing sEmpty sEmpty 0 ;                        Result ihdbc
83854>>>>>>>>>
83854>>>>>>>>>            //*** If there was an error, make result invalid
83854>>>>>>>>>            If (Err) ;                Move 0 To ihdbc
83857>>>>>>>>>
83857>>>>>>>>>            //*** Check result and store it
83857>>>>>>>>>            If (ihdbc <> 0) Begin
83859>>>>>>>>>                //*** Somehow Call_driver overwrites the sDrvrId variable, restore it here
83859>>>>>>>>>                Get_attribute DF_FILE_DRIVER Of iFileNum To sDrvrId
83862>>>>>>>>>                Send StoreConnectionInfo ihdbc sDrvrId
83863>>>>>>>>>
83863>>>>>>>>>                //*** Set filenum so it can be used for fetching
83863>>>>>>>>>                Set piBindFile To iFileNum
83864>>>>>>>>>            End
83864>>>>>>>>>>
83864>>>>>>>>>        End
83864>>>>>>>>>>
83864>>>>>>>>>
83864>>>>>>>>>        //*** Return success status
83864>>>>>>>>>        Function_Return (ihdbc <> 0)
83865>>>>>>>>>    End_Function
83866>>>>>>>>>
83866>>>>>>>>>
83866>>>>>>>>>
83866>>>>>>>>>    //***
83866>>>>>>>>>    //*** Procedure: SQLDisconnect
83866>>>>>>>>>    //*** Purpose  : Disconnect from an embedded SQL server and free allocated
83866>>>>>>>>>    //***            resources
83866>>>>>>>>>    //***
83866>>>>>>>>>    Procedure SQLDisconnect
83868>>>>>>>>>        Integer ihdbc
83868>>>>>>>>>        Integer iVoid
83868>>>>>>>>>        String  sDrvrId
83868>>>>>>>>>        String  sEmpty
83868>>>>>>>>>
83868>>>>>>>>>        //*** Initialize
83868>>>>>>>>>        Move "" To sEmpty
83869>>>>>>>>>
83869>>>>>>>>>        //*** Get the cli handle
83869>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83870>>>>>>>>>        Get psDriverId To sDrvrId
83871>>>>>>>>>
83871>>>>>>>>>        //*** Free the CLI handle
83871>>>>>>>>>        If (ihdbc <> 0) Begin
83873>>>>>>>>>            //*** Call the driver function to disconnect
83873>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLDISCONNECT ;                        Callback Self ;                        Passing sEmpty sEmpty ihdbc ;                        Result iVoid
83878>>>>>>>>>
83878>>>>>>>>>            Move -1 to giLastSQLhdbc
83879>>>>>>>>>
83879>>>>>>>>>            //*** Free the DataFlex handle
83879>>>>>>>>>            Send DestroySQLConnection
83880>>>>>>>>>        End
83880>>>>>>>>>>
83880>>>>>>>>>    End_Procedure 
83881>>>>>>>>>
83881>>>>>>>>>
83881>>>>>>>>>
83881>>>>>>>>>    //***
83881>>>>>>>>>    //*** Function: CreateSQLStatement
83881>>>>>>>>>    //*** Purpose : Create a cSQLStatement object
83881>>>>>>>>>    //***
83881>>>>>>>>>    Function CreateSQLStatement Returns Handle
83883>>>>>>>>>        
83883>>>>>>>>>        Handle hoSQLStatement
83883>>>>>>>>>        Get Create (RefClass(cSQLStatement)) to hoSQLStatement
83884>>>>>>>>>        
83884>>>>>>>>>        //*** If the connection has a default Bind File, assign it to the
83884>>>>>>>>>        //*** statement object. The default is set when you open a file with a
83884>>>>>>>>>        //*** SetFileConnection command.
83884>>>>>>>>>        Set piBindFile of hoSQLStatement to (piBindFile(Self))
83885>>>>>>>>>        
83885>>>>>>>>>        Function_Return hoSQLStatement
83886>>>>>>>>>    End_Function 
83887>>>>>>>>>
83887>>>>>>>>>
83887>>>>>>>>>    //***
83887>>>>>>>>>    //*** Function: SQLOpen
83887>>>>>>>>>    //*** Prupose : Open a statement for use
83887>>>>>>>>>    //***
83887>>>>>>>>>    Function SQLOpen Returns Handle
83889>>>>>>>>>        Handle  hoSQLStatement
83889>>>>>>>>>        Integer ihdbc
83889>>>>>>>>>        Integer ihstmt
83889>>>>>>>>>        Integer iVoid
83889>>>>>>>>>        String  sDrvrId
83889>>>>>>>>>        String  sEmpty
83889>>>>>>>>>        String  sDummyZeroDate
83889>>>>>>>>>        String  sDummyZeroDateMssqlDatetime 
83889>>>>>>>>>
83889>>>>>>>>>        //*** Initialize
83889>>>>>>>>>        Move "" To sEmpty
83890>>>>>>>>>
83890>>>>>>>>>        //*** Get the cli handle to the connection
83890>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83891>>>>>>>>>        Get psDriverId  To sDrvrId
83892>>>>>>>>>
83892>>>>>>>>>        //*** Allocate a new handle and populate it
83892>>>>>>>>>        If (ihdbc <> 0) Begin
83894>>>>>>>>>            //**** Create a new cSQLStatement object
83894>>>>>>>>>            Get CreateSQLStatement to hoSQLStatement
83895>>>>>>>>>
83895>>>>>>>>>            //*** Call the driver function to allocate a cli statement handle
83895>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLOPEN ;                        Callback Self ;                        Passing hoSQLStatement sEmpty ihdbc ;                        Result ihstmt
83900>>>>>>>>>
83900>>>>>>>>>            //*** If unsuccessful destroy hoSQLStatement
83900>>>>>>>>>            If (ihstmt = 0) Begin
83902>>>>>>>>>                Send DestroySQLStatement of hoSQLStatement
83903>>>>>>>>>                Move 0 to hoSQLStatement
83904>>>>>>>>>            End
83904>>>>>>>>>>
83904>>>>>>>>>            Else Begin
83905>>>>>>>>>                Send StoreStatementInfo of hoSQLStatement ihstmt sDrvrId ihdbc
83906>>>>>>>>>
83906>>>>>>>>>                // Store DummyZeroDate of hoSQLConnection in hoSQLStatement
83906>>>>>>>>>                Get psDummyZeroDate              to sDummyZeroDate
83907>>>>>>>>>                Get psDummyZeroDateMssqlDatetime to sDummyZeroDateMssqlDatetime
83908>>>>>>>>>                
83908>>>>>>>>>                Set psDummyZeroDate              of hoSQLStatement to sDummyZeroDate
83909>>>>>>>>>                Set psDummyZeroDateMssqlDatetime of hoSQLStatement to sDummyZeroDateMssqlDatetime
83910>>>>>>>>>                
83910>>>>>>>>>            End
83910>>>>>>>>>>
83910>>>>>>>>>        End
83910>>>>>>>>>>
83910>>>>>>>>>
83910>>>>>>>>>        Function_Return hoSQLStatement
83911>>>>>>>>>    End_Function 
83912>>>>>>>>>
83912>>>>>>>>>End_Class 
83913>>>>>>>>>
83913>>>>>>>>>
83913>>>>>>>>>
83913>>>>>>>>>//*****************************************************************************
83913>>>>>>>>>//*** Class  : cSQLHandlemanager                                            ***
83913>>>>>>>>>//*** Purpose: Manager for embedded SQL handles.                            ***
83913>>>>>>>>>//***                                                                       ***
83913>>>>>>>>>//*** Description:                                                          ***
83913>>>>>>>>>//***   We want to be able to use multiple drivers and multiple             ***
83913>>>>>>>>>//***   connections within a driver and multiple statements within a        ***
83913>>>>>>>>>//***   connection. To allow this we have placed our own handle logic on    ***
83913>>>>>>>>>//***   top of the driver handle logic. This way we can handle the          ***
83913>>>>>>>>>//***   situation where two driver handles may be equal.                    ***
83913>>>>>>>>>//*****************************************************************************
83913>>>>>>>>>
83913>>>>>>>>>Class cSQLHandleManager is a cObject
83914>>>>>>>>>
83914>>>>>>>>>    Procedure Construct_object 
83916>>>>>>>>>        Forward Send Construct_object 
83918>>>>>>>>>
83918>>>>>>>>>        Property String  psDefaultDriver      ""
83919>>>>>>>>>        Property String  psDefaultConnection  ""
83920>>>>>>>>>
83920>>>>>>>>>    End_Procedure 
83921>>>>>>>>>
83921>>>>>>>>>    //***
83921>>>>>>>>>    //*** Function: CreateSQLConnection
83921>>>>>>>>>    //*** Purpose : Create a cSQLConnection object
83921>>>>>>>>>    //***
83921>>>>>>>>>    Function CreateSQLConnection Returns Handle
83923>>>>>>>>>        Handle hoSQLConnection
83923>>>>>>>>>        Get Create (RefClass(cSQLConnection)) to hoSQLConnection
83924>>>>>>>>>        Function_Return hoSQLConnection
83925>>>>>>>>>    End_Function 
83926>>>>>>>>>
83926>>>>>>>>>
83926>>>>>>>>>    //***
83926>>>>>>>>>    //*** Procedure: SQLSetConnect
83926>>>>>>>>>    //*** Purpose  : Store default connection information
83926>>>>>>>>>    //***
83926>>>>>>>>>
83926>>>>>>>>>    Procedure SQLSetConnect String sDriver String sConnect
83928>>>>>>>>>        Set psDefaultDriver      To sDriver
83929>>>>>>>>>        Set psDefaultConnection  To sConnect
83930>>>>>>>>>    End_Procedure 
83931>>>>>>>>>
83931>>>>>>>>>
83931>>>>>>>>>
83931>>>>>>>>>    //***
83931>>>>>>>>>    //*** Function: SQLConnect
83931>>>>>>>>>    //*** Purpose : Make a connection to an embedded SQL server
83931>>>>>>>>>    //*** Returns : The DataFlex handle to the connection
83931>>>>>>>>>    //***
83931>>>>>>>>>    Function SQLConnect String sDrvrID String sConnect Returns integer
83933>>>>>>>>>        Handle hoSQLConnection
83933>>>>>>>>>        Integer bOK
83933>>>>>>>>>
83933>>>>>>>>>        //*** Check arguments
83933>>>>>>>>>        If (sDrvrID = "" And sConnect = "") Begin
83935>>>>>>>>>            Get psDefaultDriver      To sDrvrId
83936>>>>>>>>>            Get psDefaultConnection  To sConnect
83937>>>>>>>>>        End
83937>>>>>>>>>>
83937>>>>>>>>>
83937>>>>>>>>>        //*** Create a cSQLConnection object
83937>>>>>>>>>        Get CreateSQLConnection to hoSQLConnection
83938>>>>>>>>>        //*** Connect to the database 
83938>>>>>>>>>        Get SQLConnect of hoSQLConnection sDrvrID sConnect to bOK
83939>>>>>>>>>
83939>>>>>>>>>        //*** If connection to the database failed, destroy the cSQLConnection object and return a 0 handle
83939>>>>>>>>>        If (not(bOK)) Begin
83941>>>>>>>>>            Send DestroySQLConnection of hoSQLConnection
83942>>>>>>>>>            Move 0 to hoSQLConnection
83943>>>>>>>>>        End
83943>>>>>>>>>>
83943>>>>>>>>>
83943>>>>>>>>>        Function_Return hoSQLConnection
83944>>>>>>>>>    End_Function 
83945>>>>>>>>>
83945>>>>>>>>>
83945>>>>>>>>>
83945>>>>>>>>>    //***
83945>>>>>>>>>    //*** Function: SQLFileConnect
83945>>>>>>>>>    //*** Purpose : Make an existing connection available for use with Embedded SQL.
83945>>>>>>>>>    //***           The connection is identified by the number of a file
83945>>>>>>>>>    //***           that is open for that connection.
83945>>>>>>>>>    //***
83945>>>>>>>>>
83945>>>>>>>>>    Function SQLFileConnect Integer iFileNum Returns Handle
83947>>>>>>>>>        Handle hoSQLConnection
83947>>>>>>>>>        Integer bOK
83947>>>>>>>>>
83947>>>>>>>>>        //*** Create a cSQLConnection object
83947>>>>>>>>>        Get CreateSQLConnection to hoSQLConnection
83948>>>>>>>>>        Get SQLFileConnect of hoSQLConnection iFileNum To bOK
83949>>>>>>>>>
83949>>>>>>>>>        //*** If connection to the database failed, destroy the cSQLConnection object and return a 0 handle
83949>>>>>>>>>        If (not(bOK)) Begin
83951>>>>>>>>>            Send DestroySQLConnection of hoSQLConnection
83952>>>>>>>>>            Move 0 to hoSQLConnection
83953>>>>>>>>>        End
83953>>>>>>>>>>
83953>>>>>>>>>
83953>>>>>>>>>        Function_Return hoSQLConnection
83954>>>>>>>>>    End_Function 
83955>>>>>>>>>
83955>>>>>>>>>End_Class 
83956>>>>>>>>>
83956>>>>>>>
83956>>>>>>>// defines interface for cWindowMesageHook - currently a private runtime class
83956>>>>>>>Define     U_DFWINDOWSMESSAGEHOOK  for |CI0106
83956>>>>>>>Define     GET_ENABLEWINDOWSHOOK   for |CI$0542
83956>>>>>>>Define     MSG_DISABLEWINDOWSHOOK  for |CI$0543
83956>>>>>>>Define     GET_ONWINDOWSHOOK       for |CI$0544
83956>>>>>>>Define     WH_MOUSE for 7
83956>>>>>>>Define     WH_KEYBOARD for 2
83956>>>>>>>
83956>>>>>>>
83956>>>>>>>// suggestion lists use a global timer and a global suggestion list
83956>>>>>>>Global_Variable Handle ghoSuggestionList 
83956>>>>>>>Move 0 to ghoSuggestionList
83957>>>>>>>
83957>>>>>>>Global_Variable Handle ghoSuggestionTimer
83957>>>>>>>Move 0 to ghoSuggestionTimer
83958>>>>>>>
83958>>>>>>>// this will get created the first time it is needed. 
83958>>>>>>>Class cSuggestionTimer is a cTimer
83959>>>>>>>
83959>>>>>>>    Procedure Construct_Object
83961>>>>>>>        Forward Send Construct_Object
83963>>>>>>>        Property Handle phoTimerOwner 0
83964>>>>>>>        Set piTimeout to 50
83965>>>>>>>    End_Procedure
83966>>>>>>>  
83966>>>>>>>    Procedure OnTimer 
83968>>>>>>>        Handle hoOwner
83968>>>>>>>        Get phoTimerOwner to hoOwner
83969>>>>>>>        // do this in case progam close destroys owner before timer
83969>>>>>>>        Get Object_Id of hoOwner to hoOwner
83970>>>>>>>        If hoOwner Begin
83972>>>>>>>            Send OnSuggestionTimer to hoOwner
83973>>>>>>>        End
83973>>>>>>>>
83973>>>>>>>        Else Begin
83974>>>>>>>            // something wrong, shut off timer
83974>>>>>>>            Set pbEnabled to False   
83975>>>>>>>        End                                
83975>>>>>>>>
83975>>>>>>>    End_Procedure
83976>>>>>>>    
83976>>>>>>>End_Class
83977>>>>>>>
83977>>>>>>>Class cSuggestionHookMouse is a DFWindowsMessageHook
83978>>>>>>>    
83978>>>>>>>    // If mouse not in suggestion list or form, close suggestionlist
83978>>>>>>>    Function OnWindowsHook Integer i1 Integer i2 Integer i3 Returns Integer
83980>>>>>>>        tWinMouseHookStruct MouseHook
83980>>>>>>>        tWinMouseHookStruct MouseHook
83980>>>>>>>        Integer ivoid hObj
83980>>>>>>>        Handle hoOwner hoParent
83980>>>>>>>        If (i1=0 and (i2=WM_LBUTTONDOWN or i2=WM_RBUTTONDOWN or i2=WM_MBUTTONDOWN or ;                      i2=WM_NCLBUTTONDOWN or i2=WM_NCRBUTTONDOWN or i2=WM_NCMBUTTONDOWN)) Begin
83982>>>>>>>            Move (CopyMemory(AddressOf(MouseHook), i3, SizeOfType(tWinMouseHookStruct))) to iVoid
83983>>>>>>>            GET_OBJECT_FROM_WINDOW MouseHook.hwnd to hObj
83984>>>>>>>            Get Parent to hoParent
83985>>>>>>>            Get phoOwner of hoParent to hoOwner
83986>>>>>>>            If (not(hObj) or (hObj<>hoParent and hObj<>hoOwner)) Begin
83988>>>>>>>                Send DisableWindowsHook
83989>>>>>>>                Send DeActivateSuggestionList of hoOwner
83990>>>>>>>            End
83990>>>>>>>>
83990>>>>>>>        End
83990>>>>>>>>
83990>>>>>>>    End_Function
83991>>>>>>>
83991>>>>>>>    Procedure End_Construct_Object
83993>>>>>>>        Boolean bOk
83993>>>>>>>        Forward Send End_Construct_Object
83995>>>>>>>        Get EnableWindowsHook WH_MOUSE to bOk 
83996>>>>>>>    End_Procedure
83997>>>>>>>
83997>>>>>>>End_Class
83998>>>>>>>
83998>>>>>>>Class cSuggestionHookKbd is a DFWindowsMessageHook
83999>>>>>>>    
83999>>>>>>>    // If menu key, close suggestionlist
83999>>>>>>>    Function OnWindowsHook Integer i1 Integer i2 Integer i3 Returns Integer
84001>>>>>>>        Handle hoOwner
84001>>>>>>>        If (i1=0 and i2=VK_MENU) Begin
84003>>>>>>>            Delegate Get phoOwner to hoOwner
84005>>>>>>>            Send DisableWindowsHook
84006>>>>>>>            Send DeActivateSuggestionList of hoOwner
84007>>>>>>>        End
84007>>>>>>>>
84007>>>>>>>    End_Function
84008>>>>>>>    
84008>>>>>>>    Procedure End_Construct_Object
84010>>>>>>>        Boolean bOk
84010>>>>>>>        Forward Send End_Construct_Object
84012>>>>>>>        Get EnableWindowsHook WH_KEYBOARD  to bOk  
84013>>>>>>>    End_Procedure
84014>>>>>>>
84014>>>>>>>End_Class
84015>>>>>>>
84015>>>>>>>Class cSuggestionList is a cRichEdit
84016>>>>>>>    
84016>>>>>>>    Procedure Construct_Object
84018>>>>>>>        Handle hoObj
84018>>>>>>>        Forward Send Construct_Object
84020>>>>>>>        Property Handle phoOwner
84021>>>>>>>        Set Focus_Mode to NonFocusable
84022>>>>>>>        Set Attach_Parent_State to True
84023>>>>>>>        Set pbWrap to False
84024>>>>>>>        If (ghoSuggestionList) Begin
84026>>>>>>>            Send Destroy of ghoSuggestionList
84027>>>>>>>        End
84027>>>>>>>>
84027>>>>>>>        Get CreateNamed (RefClass(cSuggestionHookMouse)) "oMouseHook" to hoObj
84028>>>>>>>        Get CreateNamed (RefClass(cSuggestionHookKbd))"oKbdHook" to hoObj
84029>>>>>>>    End_Procedure
84030>>>>>>>    
84030>>>>>>>    Procedure Destroy_Object
84032>>>>>>>        Forward Send Destroy_Object
84034>>>>>>>        Move 0 to ghoSuggestionList
84035>>>>>>>    End_Procedure
84036>>>>>>>    
84036>>>>>>>    Procedure DeactivateList
84038>>>>>>>        Set pbEnabled of ghoSuggestionTimer to False
84039>>>>>>>        Send Deactivate
84040>>>>>>>        Send Destroy
84041>>>>>>>    End_Procedure
84042>>>>>>>    
84042>>>>>>>    Procedure InitList Handle hoForm
84044>>>>>>>        Integer iSize iLoc iLoc2
84044>>>>>>>        Get GuiSize of hoForm to iSize
84045>>>>>>>        Set GuiSize to (Hi(iSize)) (1000)
84046>>>>>>>        Get Absolute_GUIOrigin of hoForm to iLoc
84047>>>>>>>        Delegate Get Absolute_GUIOrigin to iLoc2
84049>>>>>>>        Set GuiLocation to (Hi(iLoc)-Hi(iLoc2)+Hi(iSize)+2) (Low(iLoc)+2-Low(iLoc2))
84050>>>>>>>        Set Visible_State to False
84051>>>>>>>    End_Procedure
84052>>>>>>>    
84052>>>>>>>    // scroll up one line
84052>>>>>>>    Procedure ScrollUp
84054>>>>>>>        Integer iLine
84054>>>>>>>        Get SelectedRow to iLine
84055>>>>>>>        If (iLine) Begin
84057>>>>>>>            Send SelectRow (iLine-1)
84058>>>>>>>        End
84058>>>>>>>>
84058>>>>>>>    End_Procedure
84059>>>>>>>    
84059>>>>>>>    // scroll down one line
84059>>>>>>>    Procedure ScrollDown
84061>>>>>>>        Integer iLine iLines
84061>>>>>>>        Get Line_Count to iLines
84062>>>>>>>        Get SelectedRow to iLine
84063>>>>>>>        // there can be an extra line at the end
84063>>>>>>>        If (iLine<iLines-1) Begin
84065>>>>>>>            Send SelectRow (iLine+1)
84066>>>>>>>        End
84066>>>>>>>>
84066>>>>>>>    End_Procedure
84067>>>>>>>    
84067>>>>>>>    // sets the current line to iLine and highlights it
84067>>>>>>>    Procedure SelectRow Integer iLine
84069>>>>>>>        Integer iPos iLen
84069>>>>>>>        Get FirstCharInLinePos iLine to iPos
84070>>>>>>>        Get LineLength iLine to iLen
84071>>>>>>>        Send SetSel iPos (iPos+iLen)
84072>>>>>>>    End_Procedure
84073>>>>>>>    
84073>>>>>>>    // get the current selected Line
84073>>>>>>>    Function SelectedRow Returns Integer
84075>>>>>>>        Integer iLine
84075>>>>>>>        Get LineFromChar -1 to iLine
84076>>>>>>>        Function_Return iLine
84077>>>>>>>    End_Function
84078>>>>>>>
84078>>>>>>>    // select the current row 
84078>>>>>>>    Procedure Mouse_Up Integer hCell Integer iPos
84080>>>>>>>        Handle hoObj
84080>>>>>>>        Get phoOwner to hoObj
84081>>>>>>>        Send Activate of hoObj // move focus to owner, which will close the list
84082>>>>>>>        Send SelectSuggestion of hoObj
84083>>>>>>>    End_Procedure // Mouse_Up
84084>>>>>>>      
84084>>>>>>>End_Class
84085>>>>>>>
84085>>>>>>>// This contains mixin support for suggestion logic and contains the interface that
84085>>>>>>>// is accessed publicly. This should be mixed into the form or column DEO object
84085>>>>>>>Class cSuggestion_mixin is a Mixin
84086>>>>>>>    
84086>>>>>>>    Procedure Define_cSuggestion_mixin
84088>>>>>>>        
84088>>>>>>>        Property Integer peSuggestionMode smFind
84089>>>>>>>        Property Boolean pbFullText False
84090>>>>>>>        Property Boolean pbCaseSensitive False
84091>>>>>>>        Property Integer piMaxResults 15
84092>>>>>>>        Property Integer piStartAtChar 2
84093>>>>>>>        Property Boolean pbFullWidth True
84094>>>>>>>        Property Integer piFindIndex 0
84095>>>>>>>        Property Boolean pbFindOnSelect True
84096>>>>>>>        Property Integer piPopupTimeout 50
84097>>>>>>>        
84097>>>>>>>        Property tSuggestion[] pSearchResults
84098>>>>>>>
84098>>>>>>>        Property Handle phcSuggestionListClass (RefClass(cSuggestionList))
84099>>>>>>>        
84099>>>>>>>    End_Procedure
84100>>>>>>>    
84100>>>>>>>    // Display one Suggestion Line in Suggestion List. Good for augmentation although
84100>>>>>>>    // this must be done carefully as you must know the suggestionlist interface, which
84100>>>>>>>    // if private
84100>>>>>>>    Procedure ShowSuggestion tSuggestion SuggestionData String sSearch
84102>>>>>>>        Integer i iCols iPos
84102>>>>>>>        String sValue
84102>>>>>>>        Integer eSuggestionMode
84102>>>>>>>        Boolean bFullText
84102>>>>>>>        
84102>>>>>>>        Get peSuggestionMode to eSuggestionMode
84103>>>>>>>        Get pbFullText to bFullText
84104>>>>>>>        
84104>>>>>>>        Move SuggestionData.aValues[0] to sValue
84105>>>>>>>        If (not(bFullText)) Begin
84107>>>>>>>            Set pbBold of ghoSuggestionList to True
84108>>>>>>>            Send AppendText of ghoSuggestionList (Left(sValue,Length(sSearch))) 
84109>>>>>>>            Set pbBold of ghoSuggestionList to False
84110>>>>>>>            Send AppendText of ghoSuggestionList (Mid(sValue,255,Length(sSearch)+1)) 
84111>>>>>>>        End
84111>>>>>>>>
84111>>>>>>>        Else Begin
84112>>>>>>>            Set pbBold of ghoSuggestionList to False
84113>>>>>>>            Move (Pos(Uppercase(sSearch),Uppercase(sValue))) to iPos
84114>>>>>>>            If (iPos) Begin
84116>>>>>>>                Send AppendText of ghoSuggestionList (Left(sValue,iPos-1)) 
84117>>>>>>>                Set pbBold of ghoSuggestionList to True
84118>>>>>>>                Send AppendText of ghoSuggestionList (Mid(sValue,Length(sSearch),iPos)) 
84119>>>>>>>                Set pbBold of ghoSuggestionList to False
84120>>>>>>>            End
84120>>>>>>>>
84120>>>>>>>            Send AppendText of ghoSuggestionList (Mid(sValue,255,iPos+Length(sSearch))) 
84121>>>>>>>        End
84121>>>>>>>>
84121>>>>>>>        
84121>>>>>>>        // if addiitonal columns (usually validation) we assume the first value is the one that is
84121>>>>>>>        // matched and we display all other values (usually just one) to the
84121>>>>>>>        // right of it. 
84121>>>>>>>        Move (SizeOfArray(SuggestionData.aValues)) to iCols
84122>>>>>>>        If (iCols>1) Begin
84124>>>>>>>            Move "" to sValue
84125>>>>>>>            For i from 1 to (iCols-1)
84131>>>>>>>>
84131>>>>>>>                Move (sValue + If(i=1," - ","  ") + SuggestionData.aValues[i]) to sValue
84132>>>>>>>            Loop
84133>>>>>>>>
84133>>>>>>>            Send AppendText of ghoSuggestionList sValue
84134>>>>>>>        End
84134>>>>>>>>
84134>>>>>>>    End_Procedure
84135>>>>>>>    
84135>>>>>>>    // used to catch a set_field_value_Error
84135>>>>>>>    Procedure Error_Report Integer iError Integer iLine String sErr
84137>>>>>>>    End_Procedure
84138>>>>>>>    
84138>>>>>>>    // does a Set_Field_Value with error testing around it.
84138>>>>>>>    Function SafeSetFieldValue Integer iFile Integer iField String sValue Returns Boolean
84140>>>>>>>        Handle hoOldError
84140>>>>>>>        Boolean bErr
84140>>>>>>>        Move Error_Object_Id to hoOldError
84141>>>>>>>        Move Self to Error_Object_Id
84142>>>>>>>        Move False to Err 
84143>>>>>>>        Set_Field_Value iFile iField to sValue
84146>>>>>>>        Move Err to bErr
84147>>>>>>>        Move hoOldError to Error_Object_Id
84148>>>>>>>        Function_Return bErr        
84149>>>>>>>    End_Function
84150>>>>>>>
84150>>>>>>>
84150>>>>>>>    Procedure SuggestionsFindIncremental String sSearch tSuggestion[] ByRef aSuggestions
84152>>>>>>>        Integer iFile iField iIndex iLen iRow iMax eType iLength iDec
84152>>>>>>>        Handle hoServer
84152>>>>>>>        Boolean bContinue bCase bOldRelate bNeedsRelate bInvalid
84152>>>>>>>        String sVal sLowSearch
84152>>>>>>>        RowID riTest
84152>>>>>>>        
84152>>>>>>>        Get Server to hoServer
84153>>>>>>>        Get Data_File  to iFile
84154>>>>>>>        Get Data_Field to iField       
84155>>>>>>>        
84155>>>>>>>        If ((hoServer <> 0) and (iFile <> 0)) Begin
84157>>>>>>>            Get piFindIndex to iIndex
84158>>>>>>>            Get piMaxResults to iMax
84159>>>>>>>            Get pbCaseSensitive to bCase
84160>>>>>>>            
84160>>>>>>>            Get_Attribute DF_FIELD_TYPE of iFile iField to eType
84163>>>>>>>            Get_Attribute DF_FIELD_LENGTH of iFile iField to iLength
84166>>>>>>>            Get_Attribute DF_FIELD_PRECISION of iFile iField to iDec
84169>>>>>>>            
84169>>>>>>>            Move (iLength - iDec) to iLength
84170>>>>>>>            
84170>>>>>>>            If (iIndex <= 0) Begin
84172>>>>>>>                Get_Attribute DF_FIELD_INDEX of iFile iField to iIndex
84175>>>>>>>            End
84175>>>>>>>>
84175>>>>>>>            
84175>>>>>>>            
84175>>>>>>>            
84175>>>>>>>            If (iIndex > 0) Begin
84177>>>>>>>                Get No_Relate_State of hoServer to bOldRelate
84178>>>>>>>                Get DDOConstraintNeedsRelate of hoServer iIndex to bNeedsRelate
84179>>>>>>>                Set No_Relate_State of hoServer to (not(bNeedsRelate))
84180>>>>>>>                                
84180>>>>>>>                Move True to bContinue
84181>>>>>>>                Move (Length(sSearch)) to iLen
84182>>>>>>>                Move (Lowercase(sSearch)) to sLowSearch
84183>>>>>>>                Move 0 to iRow
84184>>>>>>>                
84184>>>>>>>                //  Find first record
84184>>>>>>>                Send Request_Read of hoServer FIRST_RECORD iFile iIndex
84185>>>>>>>                Get SafeSetFieldValue iFile iField sSearch to bInvalid
84186>>>>>>>                If bInvalid Begin
84188>>>>>>>                    Move False to bContinue
84189>>>>>>>                End
84189>>>>>>>>
84189>>>>>>>                
84189>>>>>>>                If (bContinue) Begin
84191>>>>>>>                    Send Request_Read of hoServer GE iFile iIndex
84192>>>>>>>                End
84192>>>>>>>>
84192>>>>>>>                
84192>>>>>>>                While (Found and bContinue)
84196>>>>>>>                    Get_Field_Value iFile iField to sVal
84199>>>>>>>                    
84199>>>>>>>                    If ((not(bCase) and Lowercase(Left(sVal, iLen)) = sLowSearch) or (bCase and Left(sVal, iLen) = sSearch)) Begin
84201>>>>>>>
84201>>>>>>>                        Move (SerializeRowID(GetRowID(iFile)))  to aSuggestions[iRow].sRowId
84202>>>>>>>                        Move (Trim(sVal))                       to aSuggestions[iRow].aValues[0]
84203>>>>>>>                        Increment iRow
84204>>>>>>>                        
84204>>>>>>>                        Move (iRow < iMax) to bContinue
84205>>>>>>>                       
84205>>>>>>>                        Send Request_Read of hoServer GT iFile iIndex  
84206>>>>>>>                    End
84206>>>>>>>>
84206>>>>>>>                    Else Begin
84207>>>>>>>                        If (eType = DF_BCD and Length(sSearch) < iLength) Begin
84209>>>>>>>                            //  For numeric fields we'll jump in the index to the next possible value (for example from 40 to 400)
84209>>>>>>>                            
84209>>>>>>>                            Move (GetRowID(iFile)) to riTest
84210>>>>>>>                            
84210>>>>>>>                            Move (sSearch * 10) to sSearch
84211>>>>>>>                            
84211>>>>>>>                            Get SafeSetFieldValue iFile iField sSearch to bInvalid
84212>>>>>>>                            If bInvalid Begin
84214>>>>>>>                                Move False to bContinue
84215>>>>>>>                            End
84215>>>>>>>>
84215>>>>>>>                            Else Begin
84216>>>>>>>                                Send Request_Read of hoServer GE iFile iIndex
84217>>>>>>>                                Move (not(IsSameRowID(riTest, GetRowID(iFile)))) to bContinue
84218>>>>>>>                            End 
84218>>>>>>>>
84218>>>>>>>                        End
84218>>>>>>>>
84218>>>>>>>                        Else Begin
84219>>>>>>>                            Move False to bContinue
84220>>>>>>>                        End
84220>>>>>>>>
84220>>>>>>>                    End
84220>>>>>>>>
84220>>>>>>>                    
84220>>>>>>>                Loop
84221>>>>>>>>
84221>>>>>>>                Set No_Relate_State of hoServer to bOldRelate
84222>>>>>>>            End
84222>>>>>>>>
84222>>>>>>>        End
84222>>>>>>>>
84222>>>>>>>    End_Procedure
84223>>>>>>>    
84223>>>>>>>    Procedure SuggestionsFindFullText String sSearch tSuggestion[] ByRef aSuggestions
84225>>>>>>>        Integer iFile iField iIndex iRow iMax
84225>>>>>>>        Handle hoServer
84225>>>>>>>        Boolean bContinue bCase  bOldRelate bNeedsRelate
84225>>>>>>>        String sVal sLowSearch
84225>>>>>>>        
84225>>>>>>>        Get Server to hoServer
84226>>>>>>>        Get Data_File  to iFile
84227>>>>>>>        Get Data_Field to iField       
84228>>>>>>>        
84228>>>>>>>        If ((hoServer <> 0) and (iFile <> 0)) Begin
84230>>>>>>>            Get piMaxResults to iMax
84231>>>>>>>            Get pbCaseSensitive to bCase
84232>>>>>>>            
84232>>>>>>>            Get piFindIndex to iIndex
84233>>>>>>>            If (iIndex <= 0) Begin
84235>>>>>>>                Get_Attribute DF_FIELD_INDEX of iFile iField to iIndex
84238>>>>>>>            End
84238>>>>>>>>
84238>>>>>>>            
84238>>>>>>>            Get No_Relate_State of hoServer to bOldRelate
84239>>>>>>>            Get DDOConstraintNeedsRelate of hoServer iIndex to bNeedsRelate
84240>>>>>>>            Set No_Relate_State of hoServer to (not(bNeedsRelate))
84241>>>>>>>            
84241>>>>>>>            
84241>>>>>>>            Move (Lowercase(sSearch)) to sLowSearch
84242>>>>>>>            Move True to bContinue
84243>>>>>>>            Move 0 to iRow
84244>>>>>>>                
84244>>>>>>>            //  Find first record
84244>>>>>>>            Send Request_Read of hoServer FIRST_RECORD iFile iIndex
84245>>>>>>>            
84245>>>>>>>            While (Found and (iRow < iMax))
84249>>>>>>>                Get_Field_Value iFile iField to sVal
84252>>>>>>>                
84252>>>>>>>                If ((bCase and sVal contains sSearch) or (not(bCase) and Lowercase(sVal) contains sLowSearch)) Begin
84254>>>>>>>                    Move (SerializeRowID(GetRowID(iFile)))  to aSuggestions[iRow].sRowId
84255>>>>>>>                    Move (Trim(sVal))                       to aSuggestions[iRow].aValues[0]
84256>>>>>>>                    Increment iRow
84257>>>>>>>                End
84257>>>>>>>>
84257>>>>>>>                
84257>>>>>>>                Send Request_Read of hoServer GT iFile iIndex 
84258>>>>>>>            Loop
84259>>>>>>>>
84259>>>>>>>            Set No_Relate_State of hoServer to bOldRelate
84260>>>>>>>        End
84260>>>>>>>>
84260>>>>>>>    End_Procedure
84261>>>>>>>    
84261>>>>>>>    Procedure SuggestionsSQLFullText String sSearch tSuggestion[] ByRef aSuggestions
84263>>>>>>>        Integer iFile iField iIndex iRow iMax
84263>>>>>>>        Handle hoServer
84263>>>>>>>        Boolean bContinue bOrigActive  bOldRelate bNeedsRelate
84263>>>>>>>        String sVal sOrigFilter sFilter sFile sField
84263>>>>>>>        
84263>>>>>>>        Get Server to hoServer
84264>>>>>>>        Get Data_File  to iFile
84265>>>>>>>        Get Data_Field to iField       
84266>>>>>>>        
84266>>>>>>>        If ((hoServer <> 0) and (iFile <> 0)) Begin
84268>>>>>>>            
84268>>>>>>>            // make sure we send DD messages to owner DDO
84268>>>>>>>            Get Which_Data_Set of hoServer iFile to hoServer
84269>>>>>>>            If (hoServer=0) Begin
84271>>>>>>>                Procedure_Return
84272>>>>>>>            End
84272>>>>>>>>
84272>>>>>>>            
84272>>>>>>>            Get piMaxResults to iMax
84273>>>>>>>            Get piFindIndex to iIndex
84274>>>>>>>            If (iIndex <= 0) Begin
84276>>>>>>>                Get_Attribute DF_FIELD_INDEX of iFile iField to iIndex
84279>>>>>>>            End
84279>>>>>>>>
84279>>>>>>>            
84279>>>>>>>            //  Determine current filter settings
84279>>>>>>>            Get psSQLFilter of hoServer to sOrigFilter
84280>>>>>>>            Get pbUseDDSqlFilters of hoServer to bOrigActive
84281>>>>>>>            
84281>>>>>>>            // generate the Like filter string
84281>>>>>>>            Get SQLStrLike of hoServer iField sSearch to sFilter
84282>>>>>>>            // If filtering was active append this to what's there
84282>>>>>>>            If (bOrigActive) Begin
84284>>>>>>>                Get SQLStrAppend of hoServer sOrigFilter sFilter to sFilter
84285>>>>>>>            End
84285>>>>>>>>
84285>>>>>>>            
84285>>>>>>>            //  Set filter
84285>>>>>>>            Set psSQLFilter of hoServer to sFilter
84286>>>>>>>            Set pbUseDDSqlFilters of hoServer to True
84287>>>>>>>            
84287>>>>>>>            
84287>>>>>>>            // this will optimize No_relate. If your DF constraint does not
84287>>>>>>>            // need a post-relate test, we will disabled relates for this
84287>>>>>>>            Get No_Relate_State of hoServer to bOldRelate
84288>>>>>>>            Get DDOConstraintNeedsRelate of hoServer iIndex to bNeedsRelate
84289>>>>>>>            Set No_Relate_State of hoServer to (not(bNeedsRelate))
84290>>>>>>>
84290>>>>>>>            //  Find records
84290>>>>>>>            Move True to bContinue
84291>>>>>>>            Move 0 to iRow
84292>>>>>>>            
84292>>>>>>>            Send Request_Read of hoServer FIRST_RECORD iFile iIndex
84293>>>>>>>            
84293>>>>>>>            While (bContinue)
84297>>>>>>>                Get_Field_Value iFile iField to sVal
84300>>>>>>>                
84300>>>>>>>                If (Found) Begin // and ((bCase and sVal contains sSearch) or (not(bCase) and Lowercase(sVal) contains sLowSearch))) Begin
84302>>>>>>>                    Move (SerializeRowID(GetRowID(iFile)))  to aSuggestions[iRow].sRowId
84303>>>>>>>                    Move (Trim(sVal))                       to aSuggestions[iRow].aValues[0]
84304>>>>>>>                    Increment iRow
84305>>>>>>>                    
84305>>>>>>>                    Move (iRow < iMax) to bContinue
84306>>>>>>>                   
84306>>>>>>>                    Send Request_Read of hoServer GT iFile iIndex 
84307>>>>>>>                End
84307>>>>>>>>
84307>>>>>>>                Else Begin
84308>>>>>>>                    Move False to bContinue
84309>>>>>>>                End
84309>>>>>>>>
84309>>>>>>>                
84309>>>>>>>            Loop
84310>>>>>>>>
84310>>>>>>>            
84310>>>>>>>            //  Restore filters
84310>>>>>>>            Set psSQLFilter of hoServer to sOrigFilter
84311>>>>>>>            Set pbUseDDSqlFilters of hoServer to bOrigActive
84312>>>>>>>            Set No_Relate_State of hoServer to bOldRelate
84313>>>>>>>        End
84313>>>>>>>>
84313>>>>>>>    End_Procedure
84314>>>>>>>    
84314>>>>>>>    Procedure SuggestionsValidation String sSearch tSuggestion[] ByRef aSuggestions Boolean bFullText
84316>>>>>>>        Handle hoServer hoTable
84316>>>>>>>        Integer iFile iField iRow iCount iFound iMax iLen
84316>>>>>>>        Variant[][] aData
84317>>>>>>>        Boolean bCaseSensitive bContinue
84317>>>>>>>        String sDescr sVal
84317>>>>>>>        
84317>>>>>>>        Get Server to hoServer
84318>>>>>>>        Get Data_File  to iFile
84319>>>>>>>        Get Data_Field to iField       
84320>>>>>>>        
84320>>>>>>>        If ((hoServer <> 0) and (iFile <> 0)) Begin
84322>>>>>>>            Get File_Field_Table_Object of hoServer iFile iField to hoTable
84323>>>>>>>            If (hoTable <> 0) Begin
84325>>>>>>>                Get tabledata of hoTable to aData
84326>>>>>>>        
84326>>>>>>>                Get piMaxResults to iMax
84327>>>>>>>                Get pbCaseSensitive to bCaseSensitive  
84328>>>>>>>            
84328>>>>>>>                If (not(bCaseSensitive)) Begin
84330>>>>>>>                    Move (Lowercase(sSearch)) to sSearch
84331>>>>>>>                End
84331>>>>>>>>
84331>>>>>>>                
84331>>>>>>>                
84331>>>>>>>                Move (SizeOfArray(aData)) to iCount
84332>>>>>>>                Move 0 to iRow
84333>>>>>>>                Move (Length(sSearch)) to iLen
84334>>>>>>>                Move True to bContinue
84335>>>>>>>                
84335>>>>>>>            
84335>>>>>>>                While (iFound < iMax and iRow < iCount and bContinue)
84339>>>>>>>                    If (not(bCaseSensitive)) Begin
84341>>>>>>>                        Move (Lowercase(aData[iRow][0])) to sVal
84342>>>>>>>                        Move (Lowercase(aData[iRow][1])) to sDescr
84343>>>>>>>                    End
84343>>>>>>>>
84343>>>>>>>                    Else Begin
84344>>>>>>>                        Move aData[iRow][0] to sVal
84345>>>>>>>                        Move aData[iRow][1] to sDescr
84346>>>>>>>                    End
84346>>>>>>>>
84346>>>>>>>                    
84346>>>>>>>                    If ((bFullText and (sVal contains sSearch)) or (not(bFullText) and (Left(sVal, iLen) = sSearch))) Begin
84348>>>>>>>                        Move aData[iRow][0] to aSuggestions[iFound].sRowId
84349>>>>>>>                        Move aData[iRow][0] to aSuggestions[iFound].aValues[0]
84350>>>>>>>                        Move aData[iRow][1] to aSuggestions[iFound].aValues[1]
84351>>>>>>>                        Increment iFound
84352>>>>>>>                    End
84352>>>>>>>>
84352>>>>>>>                    Else Begin
84353>>>>>>>                        Move (bFullText or iFound = 0) to bContinue
84354>>>>>>>                    End
84354>>>>>>>>
84354>>>>>>>                    
84354>>>>>>>                    Increment iRow
84355>>>>>>>                Loop
84356>>>>>>>>
84356>>>>>>>            End
84356>>>>>>>>
84356>>>>>>>        End
84356>>>>>>>>
84356>>>>>>>         
84356>>>>>>>    End_Procedure
84357>>>>>>>    
84357>>>>>>>    
84357>>>>>>>    Procedure OnFindSuggestions String sSearch tSuggestion[] ByRef aSuggestions
84359>>>>>>>        Integer iMode iFile
84359>>>>>>>        Boolean bFullText bResult bSupportsSQL
84359>>>>>>>        Handle hoServer
84359>>>>>>>        
84359>>>>>>>        Get Server to hoServer
84360>>>>>>>        Get Data_File  to iFile
84361>>>>>>>        
84361>>>>>>>        If ((hoServer <> 0) and (iFile <> 0)) Begin
84363>>>>>>>            
84363>>>>>>>            Get peSuggestionMode to iMode
84364>>>>>>>            Get pbFullText to bFullText
84365>>>>>>>            
84365>>>>>>>            If (iMode = smFind) Begin
84367>>>>>>>                If (not(bFullText)) Begin
84369>>>>>>>                    Send SuggestionsFindIncremental sSearch (&aSuggestions)
84370>>>>>>>                End
84370>>>>>>>>
84370>>>>>>>                Else Begin
84371>>>>>>>                    Get SupportsSQLFilters of hoServer to bSupportsSQL
84372>>>>>>>                    If (bSupportsSQL) Begin
84374>>>>>>>                        Send SuggestionsSQLFullText sSearch (&aSuggestions)
84375>>>>>>>                    End
84375>>>>>>>>
84375>>>>>>>                    Else Begin
84376>>>>>>>                        Send SuggestionsFindFullText sSearch (&aSuggestions)
84377>>>>>>>                    End
84377>>>>>>>>
84377>>>>>>>                End
84377>>>>>>>>
84377>>>>>>>            End
84377>>>>>>>>
84377>>>>>>>            Else If (iMode = smValidationTable) Begin
84380>>>>>>>                Send SuggestionsValidation sSearch (&aSuggestions) bFullText
84381>>>>>>>            End
84381>>>>>>>>
84381>>>>>>>        End
84381>>>>>>>>
84381>>>>>>>    End_Procedure
84382>>>>>>>    
84382>>>>>>>    Procedure OnSelectSuggestion String sSearch tSuggestion Suggestion
84384>>>>>>>        Handle hoServer
84384>>>>>>>        Integer iFile iField iMode
84384>>>>>>>        Boolean bFind
84384>>>>>>>        RowID rRowId
84384>>>>>>>        
84384>>>>>>>        Get Server to hoServer
84385>>>>>>>        Get Data_File  to iFile
84386>>>>>>>        Get Data_Field to iField       
84387>>>>>>>        
84387>>>>>>>        If ((hoServer <> 0) and (iFile <> 0)) Begin
84389>>>>>>>            Get peSuggestionMode to iMode
84390>>>>>>>            
84390>>>>>>>            If (iMode = smFind) Begin
84392>>>>>>>                Get pbFindOnSelect to bFind
84393>>>>>>>                If (bFind) Begin
84395>>>>>>>                    Move (DeserializeRowID(Suggestion.sRowId)) to rRowId    
84396>>>>>>>                    
84396>>>>>>>                    If (not(IsNullRowID(rRowId))) Begin
84398>>>>>>>                        Send FindByRowId of hoServer iFile rRowId
84399>>>>>>>                    End
84399>>>>>>>>
84399>>>>>>>                End
84399>>>>>>>>
84399>>>>>>>                Else Begin
84400>>>>>>>                    Set Value to Suggestion.aValues[0]
84401>>>>>>>                    Set Item_Changed_State to True
84402>>>>>>>                End
84402>>>>>>>>
84402>>>>>>>            End
84402>>>>>>>>
84402>>>>>>>            Else If (imode = smValidationTable) Begin
84405>>>>>>>                Set Value to Suggestion.sRowId
84406>>>>>>>                Set Item_Changed_State to True
84407>>>>>>>            End
84407>>>>>>>>
84407>>>>>>>            
84407>>>>>>>        End
84407>>>>>>>>
84407>>>>>>>    End_Procedure
84408>>>>>>>    
84408>>>>>>>    // Return true if Suggestion should be invoked. Can be augmented
84408>>>>>>>    Function ShouldSuggestion String sValue Boolean bChanged Returns Boolean
84410>>>>>>>        Integer iStartAtChar
84410>>>>>>>        Get piStartAtChar to iStartAtChar
84411>>>>>>>        Function_Return (bChanged and Length(sValue)>=iStartAtChar)
84412>>>>>>>    End_Function
84413>>>>>>>    
84413>>>>>>>    
84413>>>>>>>End_Class
84414>>>>>>>
84414>>>>>>>
84414>>>>>>>// This contains logic that deals with the Windows object. It relies on the interface in 
84414>>>>>>>// sSuggestion_mixin, which means it must be mixed in as a sibling of this object (as is done
84414>>>>>>>// in dbSuggestionForm or as a child of this object (as is done in cDbCJGridColumnSuggestion), which
84414>>>>>>>// means messages are resolved via delegation. sSuggestion_mixin does not send messages to this class.
84414>>>>>>>// Note that cSuggestion_mixin and cSuggestionControl_mixin are designed so they can be mixed in at
84414>>>>>>>// the same level or mixed in such that cSuggestionControl_mixin is in the child object and cSuggestion_mixin
84414>>>>>>>// is in the parent
84414>>>>>>> 
84414>>>>>>>Class cSuggestionControl_mixin is a Mixin
84415>>>>>>>    
84415>>>>>>>    Procedure Define_cSuggestionControl_mixin
84417>>>>>>>        
84417>>>>>>>        Property Integer piTimeOutTicks 0
84418>>>>>>>        
84418>>>>>>>        On_Key kEnter Send SelectSuggestion
84419>>>>>>>        On_Key Key_Escape Send DeActivateSuggestionList
84420>>>>>>>        On_Key Key_Up_Arrow Send Up
84421>>>>>>>        On_Key Key_Down_Arrow Send Down
84422>>>>>>>
84422>>>>>>>    End_Procedure
84423>>>>>>>
84423>>>>>>>    Procedure AdjustSuggestionListSize Integer iLines
84425>>>>>>>        Integer i  iX iMax iY
84425>>>>>>>        String sTxt
84425>>>>>>>        Boolean bFullWidth
84425>>>>>>>        For i from 0 to (iLines-1)
84431>>>>>>>>
84431>>>>>>>            Get Line of ghoSuggestionList i to sTxt
84432>>>>>>>            Get Text_Extent of ghoSuggestionList sTxt to iX
84433>>>>>>>            Move (Low(iX) max iMax) to iMax
84434>>>>>>>            Move (Hi(iX)) to iY
84435>>>>>>>        Loop
84436>>>>>>>>
84436>>>>>>>        Move (iMax + 20) to imax
84437>>>>>>>        Get pbFullWidth to bFullWidth
84438>>>>>>>        If bFullWidth Begin
84440>>>>>>>            Move (iMax max (Low(GuiSize(Self)))) to iMax
84441>>>>>>>        End
84441>>>>>>>>
84441>>>>>>>        If (iLines) Begin
84443>>>>>>>            Set GuiSize of ghoSuggestionList to (iY*(iLines)+8) iMax
84444>>>>>>>            Send SelectRow of ghoSuggestionList 0 // go to first line
84445>>>>>>>        End
84445>>>>>>>>
84445>>>>>>>        Else Begin
84446>>>>>>>            Set GuiSize of ghoSuggestionList to (Hi(GuiSize(Self))) (low(GuiSize(Self)))
84447>>>>>>>        End
84447>>>>>>>>
84447>>>>>>>    End_Procedure
84448>>>>>>>    
84448>>>>>>>    // show all suggestions
84448>>>>>>>    Procedure ShowSuggestions
84450>>>>>>>        tSuggestion[] aResults
84450>>>>>>>        tSuggestion[] aResults
84451>>>>>>>        Integer i iLines
84451>>>>>>>        String sSearch 
84451>>>>>>>        Get pSearchResults to aResults
84452>>>>>>>        Get Value to sSearch
84453>>>>>>>        Send Delete_Data of ghoSuggestionList
84454>>>>>>>        Move (SizeOfArray(aResults)) to iLines
84455>>>>>>>        For i from 0 to (iLines-1)
84461>>>>>>>>
84461>>>>>>>            Send ShowSuggestion aResults[i] sSearch
84462>>>>>>>            If ((iLines-1)<>i) Begin
84464>>>>>>>                Send AppendTextLn of ghoSuggestionList ""
84465>>>>>>>            End
84465>>>>>>>>
84465>>>>>>>        Loop
84466>>>>>>>>
84466>>>>>>>        Send AdjustSuggestionListSize iLines
84467>>>>>>>    End_Procedure
84468>>>>>>>
84468>>>>>>>    Procedure FindSuggestions 
84470>>>>>>>        String sSearch
84470>>>>>>>        tSuggestion[] aResults
84470>>>>>>>        tSuggestion[] aResults
84471>>>>>>>        String[] aParams
84472>>>>>>>        Get Value to sSearch
84473>>>>>>>        Send OnFindSuggestions sSearch (&aResults)
84474>>>>>>>        Set pSearchResults to aResults
84475>>>>>>>        // if an error was raised, the suggestion list will be gone
84475>>>>>>>        If (ghoSuggestionList) Begin
84477>>>>>>>            Send ShowSuggestions
84478>>>>>>>        End
84478>>>>>>>>
84478>>>>>>>    End_Procedure
84479>>>>>>>
84479>>>>>>>    Procedure SelectSuggestion 
84481>>>>>>>        String sSearch
84481>>>>>>>        tSuggestion[] aData
84481>>>>>>>        tSuggestion[] aData
84482>>>>>>>        Integer iSelRow
84482>>>>>>>        If ghoSuggestionList Begin
84484>>>>>>>            Get SelectedRow of ghoSuggestionList to iSelRow
84485>>>>>>>            Get Value to sSearch
84486>>>>>>>            Get pSearchResults to aData        
84487>>>>>>>            Send DeActivateSuggestionList
84488>>>>>>>            Send CancelEditIfGrid
84489>>>>>>>            If (iSelRow>=0 and SizeOfArray(aData)>iSelRow) Begin
84491>>>>>>>                Send OnSelectSuggestion sSearch aData[iSelRow] 
84492>>>>>>>            End
84492>>>>>>>>
84492>>>>>>>        End
84492>>>>>>>>
84492>>>>>>>        Else Begin
84493>>>>>>>            Send Default_Action
84494>>>>>>>        End
84494>>>>>>>>
84494>>>>>>>    End_Procedure
84495>>>>>>>    
84495>>>>>>>    Procedure CancelEditIfGrid
84497>>>>>>>        // do nothing with forms, remember
84497>>>>>>>        // to replace or augment with grid to
84497>>>>>>>        // cancel the edit control
84497>>>>>>>    End_Procedure
84498>>>>>>>
84498>>>>>>>    
84498>>>>>>>    Function ParentForSuggestion Returns Handle
84500>>>>>>>        Handle hoMain hoMainPanel
84500>>>>>>>
84500>>>>>>>        // we must have an application object and a main panel object
84500>>>>>>>        If ghoApplication Begin
84502>>>>>>>            Get phoMainPanel of ghoApplication to hoMainPanel
84503>>>>>>>        End
84503>>>>>>>>
84503>>>>>>>        If (hoMainPanel=0 or Self<=Desktop) Begin
84505>>>>>>>            Function_Return 0
84506>>>>>>>        End
84506>>>>>>>>
84506>>>>>>>
84506>>>>>>>        Move Self to hoMain
84507>>>>>>>        Repeat
84507>>>>>>>>
84507>>>>>>>            Get Parent of hoMain to hoMain
84508>>>>>>>        Until (hoMain=Desktop or Block_Mouse_State(hoMain) or hoMainPanel=hoMain)
84510>>>>>>>
84510>>>>>>>        Function_Return (If(hoMain>Desktop,hoMain,0))
84511>>>>>>>        
84511>>>>>>>    End_Function
84512>>>>>>>    
84512>>>>>>>    Procedure ActivateSuggestionList
84514>>>>>>>        Handle hoView hcSuggest
84514>>>>>>>        Get ParentForSuggestion to hoView
84515>>>>>>>        If hoView Begin
84517>>>>>>>            Get phcSuggestionListClass to hcSuggest
84518>>>>>>>            Get CreateNamed of hoView hcSuggest "oSuggestList" to ghoSuggestionList
84519>>>>>>>            Send InitList of ghoSuggestionList Self
84520>>>>>>>            Set Focus_Mode of ghoSuggestionList to Focusable
84521>>>>>>>            Set phoOwner of ghoSuggestionList to Self
84522>>>>>>>            Send Add_Focus of ghoSuggestionList hoView
84523>>>>>>>        End
84523>>>>>>>>
84523>>>>>>>    End_Procedure
84524>>>>>>>    
84524>>>>>>>    Procedure DeActivateSuggestionList
84526>>>>>>>        If ghoSuggestionList Begin
84528>>>>>>>            Send DeactivateList of ghoSuggestionList
84529>>>>>>>        End
84529>>>>>>>>
84529>>>>>>>    End_Procedure
84530>>>>>>>    
84530>>>>>>>    // augment to kill suggest list if focus is not moving to it  
84530>>>>>>>    // customized for grid
84530>>>>>>>    Procedure OnKillFocus
84532>>>>>>>        // note focus has already changed here
84532>>>>>>>        If (ghoSuggestionList) Begin
84534>>>>>>>            If (Focus(Self)<>ghoSuggestionList) Begin
84536>>>>>>>                Send DeActivateSuggestionList
84537>>>>>>>                Forward Send OnKillFocus
84539>>>>>>>            End
84539>>>>>>>>
84539>>>>>>>            Else Begin
84540>>>>>>>                // giving focus to the suggestion list here
84540>>>>>>>            End
84540>>>>>>>>
84540>>>>>>>        End
84540>>>>>>>>
84540>>>>>>>        Else Begin
84541>>>>>>>            Forward Send OnKillFocus
84543>>>>>>>        End
84543>>>>>>>>
84543>>>>>>>    End_Procedure
84544>>>>>>>    
84544>>>>>>>    Procedure Up
84546>>>>>>>        If (Focus(Desktop) = Self and ghoSuggestionList) Begin
84548>>>>>>>           Send ScrollUp of ghoSuggestionList
84549>>>>>>>        End
84549>>>>>>>>
84549>>>>>>>    End_Procedure
84550>>>>>>>
84550>>>>>>>    Procedure Down
84552>>>>>>>        If (Focus(Desktop) = Self and ghoSuggestionList) Begin
84554>>>>>>>           Send ScrollDown of ghoSuggestionList
84555>>>>>>>        End
84555>>>>>>>>
84555>>>>>>>    End_Procedure
84556>>>>>>>    
84556>>>>>>>
84556>>>>>>>    Procedure Key Integer iKey
84558>>>>>>>        Integer iEndTicks
84558>>>>>>>        
84558>>>>>>>        If (Focus(Desktop) <> Self) Begin
84560>>>>>>>          Forward Send Key iKey
84562>>>>>>>          Procedure_Return
84563>>>>>>>        End
84563>>>>>>>>
84563>>>>>>>        
84563>>>>>>>        Send DeActivateSuggestionList
84564>>>>>>>        Move (GetTickCount()) to iEndTicks
84565>>>>>>>        // record the time of key press
84565>>>>>>>        If (piTimeOutTicks(Self) = 0) Begin
84567>>>>>>>         
84567>>>>>>>            If (ghoSuggestionTimer=0) Begin
84569>>>>>>>               Send CreateSuggestionTimer
84570>>>>>>>            End
84570>>>>>>>>
84570>>>>>>>         
84570>>>>>>>            Set pbEnabled of ghoSuggestionTimer to True
84571>>>>>>>            Set phoTimerOwner of ghoSuggestionTimer to Self
84572>>>>>>>        End
84572>>>>>>>>
84572>>>>>>>        Set piTimeOutTicks to iEndTicks
84573>>>>>>>        
84573>>>>>>>        Forward Send Key iKey
84575>>>>>>>    End_Procedure
84576>>>>>>>    
84576>>>>>>>    Procedure CreateSuggestionTimer
84578>>>>>>>        Handle hoMainPanel
84578>>>>>>>        // we must have an application object and a main panel object
84578>>>>>>>        If ghoApplication Begin
84580>>>>>>>            Get phoMainPanel of ghoApplication to hoMainPanel
84581>>>>>>>        End
84581>>>>>>>>
84581>>>>>>>        If (hoMainPanel=0) Begin
84583>>>>>>>            Error DFERR_PROGRAM "Auto-suggest requires an application object and a main panel object"
84584>>>>>>>>
84584>>>>>>>            Procedure_Return
84585>>>>>>>        End
84585>>>>>>>>
84585>>>>>>>        Get CreateNamed of hoMainPanel (RefClass(cSuggestionTimer)) "oSuggestionTimer" to ghoSuggestionTimer
84586>>>>>>>    End_Procedure
84587>>>>>>>  
84587>>>>>>>    // sent by Auto Suggest Timer. Invoke suggestion list as needed
84587>>>>>>>    Procedure OnSuggestionTimer
84589>>>>>>>        Boolean bDoIt
84589>>>>>>>        Integer iEndTicks iStartTicks iTicks iTimeOut iChanged
84589>>>>>>>        String sValue
84589>>>>>>>        
84589>>>>>>>        If (Focus(Desktop) <> Self) Begin
84591>>>>>>>            // focus out of whack. Stop the timer
84591>>>>>>>            Set pbEnabled of ghoSuggestionTimer to False
84592>>>>>>>            Send DeActivateSuggestionList   
84593>>>>>>>            Procedure_Return
84594>>>>>>>        End                                
84594>>>>>>>>
84594>>>>>>>
84594>>>>>>>        Get piTimeOutTicks to iStartTicks
84595>>>>>>>        If (iStartTicks <> 0) Begin           
84597>>>>>>>            Move (GetTickCount()) to iEndTicks 
84598>>>>>>>            Move (iEndTicks - iStartTicks) to iTicks
84599>>>>>>>            // If tick count rolled over
84599>>>>>>>            If (iTicks < 0) Begin
84601>>>>>>>                Move (-iTicks) to iTicks 
84602>>>>>>>            End
84602>>>>>>>>
84602>>>>>>>        End
84602>>>>>>>>
84602>>>>>>>        Get piPopupTimeout to iTimeOut
84603>>>>>>>        If (iTicks >= iTimeOut) Begin
84605>>>>>>>            // If time delay has been met, launch autocomplete
84605>>>>>>>            Set pbEnabled  of ghoSuggestionTimer to False
84606>>>>>>>            Get Value to sValue
84607>>>>>>>            Get Item_Changed_State 0 to iChanged
84608>>>>>>>            Get ShouldSuggestion sValue iChanged to bDoIt
84609>>>>>>>            If bDoIt Begin
84611>>>>>>>                Send ActivateSuggestionList
84612>>>>>>>                Send FindSuggestions
84613>>>>>>>                Set Visible_State of ghoSuggestionList to True
84614>>>>>>>            End
84614>>>>>>>>
84614>>>>>>>            Set piTimeOutTicks to 0
84615>>>>>>>        End
84615>>>>>>>>
84615>>>>>>>    End_Procedure
84616>>>>>>>
84616>>>>>>>End_Class
84617>>>>>>>
84617>>>>>
84617>>>>>Class DbSuggestionForm is a dbForm
84618>>>>>    
84618>>>>>    Import_Class_Protocol cSuggestionControl_mixin
84619>>>>>    Import_Class_Protocol cSuggestion_mixin
84620>>>>>    
84620>>>>>    Procedure Construct_Object
84622>>>>>        Forward Send Construct_Object
84624>>>>>        Send Define_cSuggestionControl_mixin
84625>>>>>        Send Define_cSuggestion_mixin    
84626>>>>>    End_Procedure
84627>>>>>    
84627>>>>>End_Class
84628>>>>>
84628>>>Use cDbCJGridColumnSuggestion.pkg
Including file: cDbCJGridColumnSuggestion.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cDbCJGridColumnSuggestion.pkg)
84628>>>>>Use WinSuggestion.pkg
84628>>>>>Use cDbCJGridColumn.pkg
84628>>>>>Use cDbCJGridColumnEdit.pkg
84628>>>>>
84628>>>>>// This is the edit control that gets embedded in cDbCJGridColumnSuggestion object.
84628>>>>>
84628>>>>>Class cDbCJGridColumnSuggestionEdit is a cDbCJGridColumnEdit
84629>>>>>
84629>>>>>    Import_Class_Protocol cSuggestionControl_mixin
84630>>>>>
84630>>>>>    Procedure Construct_Object
84632>>>>>        Forward Send Construct_Object
84634>>>>>        Send Define_cSuggestionControl_mixin
84635>>>>>    End_Procedure
84636>>>>>    
84636>>>>>    // Called when closing a suggestion form. With grids we must also make sure that the
84636>>>>>    // edit is canceled. 
84636>>>>>    Procedure CancelEditIfGrid
84638>>>>>        Send CancelEdit
84639>>>>>    End_Procedure
84640>>>>>    
84640>>>>>End_Class
84641>>>>>
84641>>>>>// A cDbCJGridColumnSuggestion would be dropped inside of cDbCJGrid.
84641>>>>>
84641>>>>>Class cDbCJGridColumnSuggestion is a cDbCJGridColumn
84642>>>>>    
84642>>>>>    Import_Class_Protocol cSuggestion_mixin            
84643>>>>>    
84643>>>>>    Procedure Construct_Object
84645>>>>>        Forward Send Construct_Object
84647>>>>>
84647>>>>>        Send Define_cSuggestion_mixin
84648>>>>>        Set phcEditClass to (RefClass(cDbCJGridColumnSuggestionEdit))
84649>>>>>    End_Procedure
84650>>>>>    
84650>>>>>End_Class
84651>>>
84651>>>Use Customer.DD
84651>>>Use Vendor.DD
84651>>>Use dfTabDlg.pkg
84651>>>
84651>>>
84651>>>Deferred_View Activate_oDemoSuggestionForm for ;Object oDemoSuggestionForm is a dbView
84676>>>
84676>>>    Set Border_Style to Border_Thick
84677>>>    Set Size to 227 300
84678>>>    Set Location to 2 2
84679>>>    Set Label to "Suggestion Forms and Grids"
84680>>>
84680>>>    Object oSuggestionsTP is a dbTabDialogView
84682>>>        Set Size to 208 284
84683>>>        Set Location to 10 7
84684>>>
84684>>>        Object oVendor_DD is a Vendor_DataDictionary
84686>>>        End_Object
84687>>>    
84687>>>        Object oCustomer_DD is a Customer_DataDictionary
84689>>>            Procedure Field_defaults
84692>>>                Forward Send Field_Defaults
84694>>>                Set Field_Changed_Value   Field Customer.State to ""
84695>>>            End_Procedure
84696>>>        End_Object
84697>>>    
84697>>>        Set Main_DD to oCustomer_DD
84698>>>        Set Server to oCustomer_DD
84699>>>
84699>>>        Object oSuggestionForms is a dbTabView
84701>>>            Set Label to 'dbSuggestionForm'
84702>>>
84702>>>            Object oLabel1 is a TextBox
84704>>>                Set Auto_Size_State to False
84705>>>                Set Size to 10 237
84706>>>                Set Location to 17 16
84707>>>                Set Label to "Data bound, incremental, starting at character 1"
84708>>>                Set FontWeight to fw_Bold
84709>>>            End_Object
84710>>>            Object oSuggestionForm2 is a dbSuggestionForm
84712>>>                Set Location to 28 74
84713>>>                Entry_Item Customer.Customer_Number
84714>>>                Set size to 14 45
84715>>>                Set Label to "Customer Num:"
84716>>>                Set piStartAtChar to 1
84717>>>            End_Object
84718>>>            Object oSuggestionForm1 is a dbSuggestionForm
84720>>>                Set Location to 44 74
84721>>>                Entry_Item Customer.Name
84722>>>                Set size to 14 146
84723>>>                Set Label to "Customer Name:"
84724>>>                Set piStartAtChar to 1
84725>>>            End_Object
84726>>>            Object oLabel3 is a TextBox
84728>>>                Set Auto_Size_State to False
84729>>>                Set Size to 9 211
84730>>>                Set Location to 77 17
84731>>>                Set Label to "Validation Table, incremental, starting at character 1"
84732>>>                Set FontWeight to fw_Bold
84733>>>            End_Object
84734>>>            Object oSuggestionForm4 is a dbSuggestionForm
84736>>>                Set Location to 89 74
84737>>>                Entry_Item Customer.State
84738>>>                Set Size to 14 50
84739>>>                Set Label to "Customer State:"
84740>>>                Set peSuggestionMode to smValidationTable
84741>>>                Set piStartAtChar to 1
84742>>>            End_Object
84743>>>            Object oLabel2 is a TextBox
84745>>>                Set Auto_Size_State to False
84746>>>                Set Size to 10 199
84747>>>                Set Location to 120 16
84748>>>                Set Label to "Data bound, full text, starting at character 2"
84749>>>                Set FontWeight to fw_Bold
84750>>>            End_Object
84751>>>            
84751>>>            Object oSuggestionForm3 is a dbSuggestionForm
84753>>>                Set Location to 137 74
84754>>>                Entry_Item Vendor.Name
84755>>>                Set Server to oVendor_DD
84756>>>                Set Size to 14 100
84757>>>                Set pbFullText to True
84758>>>                Set Label to "Vendor name:"
84759>>>            End_Object
84760>>>
84760>>>            Object oLabel3 is a TextBox
84762>>>                Set Auto_Size_State to False
84763>>>                Set Size to 10 199
84764>>>                Set Location to 158 16
84765>>>                Set Label to "Custom Suggestion List"
84766>>>                Set FontWeight to fw_Bold
84767>>>            End_Object
84768>>>            
84768>>>            // this shows how to create you own custom suggestion list
84768>>>            Object oSuggestionForm5 is a dbSuggestionForm
84770>>>                Set Location to 175 74
84771>>>                Set Label to "Custom Id:"
84772>>>                Set Size to 14 100
84773>>>                Set peSuggestionMode to smCustom
84774>>>                Set piStartAtChar to 1
84775>>>
84775>>>                // even though we handle searching manually in OnFindSuggestions, pbFullText
84775>>>                // is still used to determine the display and bolding of matched text. Setting
84775>>>                // this true tells it we are matching anywhere within the string.
84775>>>                // Since this is a custom list, it is the developer's job to make sure that
84775>>>                // OnFindSuggestions follows these rules as well.
84775>>>                Set pbFullText to True
84776>>>                
84776>>>                // augment to create an arbitrary list of Ids to be used for our search
84776>>>                Property String[] pCustomIds
84778>>>                
84778>>>                // augment to create a list of Ids
84778>>>                Procedure Activating
84781>>>                    String[] sIds
84782>>>                    Forward Send Activating
84784>>>                    Move "JSON" to sIds[0]
84785>>>                    Move "XML" to sIds[1]
84786>>>                    Move "SQL" to sIds[2]
84787>>>                    Move "SQLExpress" to sIds[3]
84788>>>                    Move "SQLServer" to sIds[4]
84789>>>                    Move "DF" to sIds[5]
84790>>>                    Move "XQuery" to sIds[6]
84791>>>                    Move "JScript" to sIds[7]
84792>>>                    Move "Java" to sIds[8]
84793>>>                    Move "UTF-8" to sIds[9]
84794>>>                    Move "UTF-16" to sIds[10]
84795>>>                    Set pCustomIds to (SortArray(sIds,Desktop,RefFunc(DFSTRICMP)))
84796>>>                End_Procedure
84797>>>                
84797>>>                // custom code to find all matches for the search
84797>>>                // You can write whatever code you want here to find matched items
84797>>>                Procedure OnFindSuggestions String sSearch tSuggestion[] ByRef aSuggestions
84800>>>                    String[] sIds
84801>>>                    Integer i iLen iIds iCount
84801>>>                    Move (Lowercase(sSearch)) to sSearch
84802>>>                    Move (Length(sSearch)) to iLen
84803>>>                    Get pCustomIds to sIds
84804>>>                    Move (SizeOfArray(sIds)-1) to iIds
84805>>>                    For i from 0 to iIds
84811>>>>
84811>>>                        If (Lowercase(sIds[i]) contains sSearch) Begin
84813>>>                            Move sIds[i] to aSuggestions[iCount].sRowId
84814>>>                            Move sIds[i] to aSuggestions[iCount].aValues[0]
84815>>>                            Increment iCount
84816>>>                        End
84816>>>>
84816>>>                    Loop
84817>>>>
84817>>>                End_Procedure
84818>>>
84818>>>                Procedure OnSelectSuggestion String sSearch tSuggestion Suggestion
84821>>>                    Set Value to Suggestion.sRowId
84822>>>                    Set Item_Changed_State to True
84823>>>                End_Procedure
84824>>>
84824>>>            
84824>>>            End_Object
84825>>>        End_Object
84826>>>
84826>>>        Object oSuggestionGrid is a dbTabView
84828>>>
84828>>>            Set Label to "cDbCJGridColumnSuggestion"
84829>>>
84829>>>            Object oCustomer_DD is a Customer_DataDictionary
84831>>>            End_Object
84832>>>        
84832>>>            Set Main_DD to oCustomer_DD
84833>>>            Set Server to oCustomer_DD
84834>>>        
84834>>>            Object oDbCJGrid1 is a cDbCJGrid
84836>>>                Set Size to 177 268
84837>>>                Set Location to 7 7
84838>>>                Set Ordering to 1
84839>>>                Set Verify_Save_msg to (RefFunc(Save_Confirmation))
84840>>>                
84840>>>                Object oCustomer_Customer_Number is a cDbCJGridColumnSuggestion
84842>>>                    Entry_Item Customer.Customer_Number
84843>>>                    Set piWidth to 73
84844>>>                    Set psCaption to "Number"
84845>>>                    Set piStartAtChar to 1
84846>>>                End_Object
84847>>>        
84847>>>                // normally you would not use a suggestion list with a grid's main 
84847>>>                // file. It would be more useful when selecting a parent.
84847>>>                Object oCustomer_Name is a cDbCJGridColumnSuggestion
84849>>>                    Entry_Item Customer.Name
84850>>>                    Set piWidth to 358
84851>>>                    Set psCaption to "Customer Name"
84852>>>                    Set pbFullText to True
84853>>>                    Set piStartAtChar to 1
84854>>>                End_Object
84855>>>        
84855>>>                Object oCustomer_State is a cDbCJGridColumnSuggestion
84857>>>                    Entry_Item Customer.State
84858>>>                    Set piWidth to 105
84859>>>                    Set psCaption to "State"
84860>>>                    Set peSuggestionMode to smValidationTable
84861>>>                    Set piStartAtChar to 1
84862>>>                End_Object
84863>>>            End_Object
84864>>>
84864>>>        End_Object
84865>>>        
84865>>>    End_Object
84866>>>        
84866>>>        
84866>>>Cd_End_Object
84868>>>>
84868>        Use DemoButtonTest.vw
Including file: DemoButtonTest.vw    (C:\Test\Order Entry git\AppSrc\DemoButtonTest.vw)
84868>>>Use Windows.pkg
84868>>>Use DFClient.pkg
84868>>>Use cImageList32.pkg
84868>>>Use cSplitButton.pkg
84868>>>Use cCommandLinkButton.pkg
Including file: cCommandLinkButton.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cCommandLinkButton.pkg)
84868>>>>>// cCommandLinkButton class
84868>>>>>
84868>>>>>// This requires version 6 of common controls (vista or windows server 2008). If used with
84868>>>>>// older versions you will just get a regular great big button.
84868>>>>> 
84868>>>>>Use Windows.pkg
84868>>>>>Use CharTranslate.pkg
84868>>>>>
84868>>>>>Class cCommandLinkButton is a Button
84869>>>>>
84869>>>>>        Procedure Construct_Object
84871>>>>>            Forward Send Construct_Object
84873>>>>>            Property String psPrivateNote
84874>>>>>        End_Procedure
84875>>>>>        
84875>>>>>        Procedure Set psNote String sNote
84877>>>>>            Boolean bSupported
84877>>>>>            Set psPrivateNote to sNote
84878>>>>>            Get IsExControlSupported to bSupported
84879>>>>>            If bSupported Begin
84881>>>>>                Send SetWinNote
84882>>>>>            End
84882>>>>>>
84882>>>>>        End_Procedure
84883>>>>>        
84883>>>>>        Procedure SetWinNote
84885>>>>>            String sNote
84885>>>>>            Handle hWnd
84885>>>>>            Integer i
84885>>>>>            Address aVar
84885>>>>>            Get Form_Window_Handle 0 to hWnd
84886>>>>>            If hWnd Begin
84888>>>>>                Get psNote to sNote
84889>>>>>                Move (OemToUtf16Buffer(AddressOf(sNote),Length(sNote))) to aVar
84890>>>>>                Move (SendMessage(hwnd, BCM_SETNOTE, 0, aVar)) to i
84891>>>>>                Move (Free(aVar)) to i 
84892>>>>>            End
84892>>>>>>
84892>>>>>        End_Procedure
84893>>>>>        
84893>>>>>        
84893>>>>>        Function psNote Returns String
84895>>>>>            Function_Return (psPrivateNote(Self))
84896>>>>>        End_Function
84897>>>>>        
84897>>>>>
84897>>>>>        Procedure Page Integer iState
84899>>>>>            Integer i hWnd
84899>>>>>            Boolean bSupported
84899>>>>>            Get IsExControlSupported to bSupported
84900>>>>>            If (iState=1 and bSupported) Begin
84902>>>>>                Get form_style i to i
84903>>>>>                Set Form_Style 0 to (i ior (BS_COMMANDLINK + BS_FLAT))
84904>>>>>                Forward Send Page iState
84906>>>>>                Send SetWinNote
84907>>>>>            End
84907>>>>>>
84907>>>>>            Else Begin
84908>>>>>                Forward Send Page iState
84910>>>>>            End
84910>>>>>>
84910>>>>>        End_Procedure        
84911>>>>>
84911>>>>>End_Class
84912>>>Use cCJStandardMenuItemClasses.pkg
84912>>>
84912>>>
84912>>>Deferred_View Activate_oButtonTest for ;Object oButtonTest is a dbView
84937>>>
84937>>>    Set Border_Style to Border_Thick
84938>>>    Set Size to 212 300
84939>>>    Set Location to 2 3
84940>>>    Set Label to "Button Samples"
84941>>>
84941>>>    Object oTextBox1 is a TextBox
84943>>>        Set Size to 9 110
84944>>>        Set Location to 8 10
84945>>>        Set Label to 'Buttons that use Text and Images'
84946>>>    End_Object
84947>>>
84947>>>    Object oTextButton is a Button
84949>>>        Set Location to 20 11
84950>>>        Set Label to 'Save'
84951>>>    
84951>>>        Procedure OnClick
84954>>>        End_Procedure
84955>>>    
84955>>>    End_Object
84956>>>
84956>>>    Object oTextAndImageButton is a Button
84958>>>        Set Location to 20 71
84959>>>        Set Label to 'Save'
84960>>>        Set psImage to "ActionSave.ico"
84961>>>
84961>>>        Procedure OnClick
84964>>>        End_Procedure
84965>>>    
84965>>>    End_Object
84966>>>
84966>>>    Object oImageButton is a Button
84968>>>        Set Size to 14 27
84969>>>        Set Location to 20 131
84970>>>        Set psImage to "ActionSave.ico"
84971>>>        Set peImageAlign to Button_ImageList_Align_Center
84972>>>
84972>>>        Procedure OnClick
84975>>>        End_Procedure
84976>>>    
84976>>>    End_Object
84977>>>
84977>>>    Object oTextAndImageTopButton is a Button
84979>>>        Set Size to 26 50
84980>>>        Set Location to 20 168
84981>>>        Set Label to 'Save'
84982>>>        Set psImage to "ActionSave.ico"
84983>>>        Set peImageAlign to Button_ImageList_Align_Top
84984>>>        Set piImageMarginTop to 10
84985>>>
84985>>>        Procedure OnClick
84988>>>        End_Procedure
84989>>>    
84989>>>    End_Object
84990>>>
84990>>>    Object oTextAndImageBottomButton is a Button
84992>>>        Set Size to 26 50
84993>>>        Set Location to 20 226
84994>>>        Set Label to 'Save'
84995>>>        Set psImage to "ActionSave.ico"
84996>>>        Set peImageAlign to Button_ImageList_Align_Bottom
84997>>>        Set piImageMarginBottom to 10
84998>>>
84998>>>        Procedure OnClick
85001>>>        End_Procedure
85002>>>    
85002>>>    End_Object
85003>>>
85003>>>    Object oTextBox1 is a TextBox
85005>>>        Set Size to 9 110
85006>>>        Set Location to 51 10
85007>>>        Set Label to 'Buttons with drop down menus'
85008>>>    End_Object
85009>>>
85009>>>    // this is a button with down arrow button on the right that invokes
85009>>>    // a context menu inside of OnClick
85009>>>    Object oDropDownButton is a Button
85011>>>        Set Size to 14 58
85012>>>        Set Location to 65 10
85013>>>        Set Label to "Select"
85014>>>        Set psImage to "Down16.bmp"
85015>>>        Set peImageAlign to Button_ImageList_Align_Right
85016>>>
85016>>>        Procedure OnClick
85019>>>            // OnDropDown is defined to popup menu in phoButtonPopup
85019>>>            Send OnDropDown
85020>>>        End_Procedure
85021>>>        
85021>>>        Object oButtonMenu is a cCJContextMenu
85023>>>            
85023>>>            Object oMenuItem1 is a cCJMenuItem
85025>>>                Set psCaption to "Save"
85026>>>                Set psImage to "ActionSaveRecord.ico"
85027>>>                Procedure OnExecute Variant vCommandBarControl
85030>>>                End_Procedure
85031>>>            End_Object
85032>>>            
85032>>>            Object oMenuItem2 is a cCJMenuItem
85034>>>                Set psCaption to "Clear"
85035>>>                Set psImage to "ActionClear.ico"
85036>>>                Procedure OnExecute Variant vCommandBarControl
85039>>>                End_Procedure
85040>>>            End_Object
85041>>>            
85041>>>            Object oMenuItem3 is a cCJMenuItem
85043>>>                Set psCaption to "Delete"
85044>>>                Set psImage to "ActionDeleteRecord.ico"
85045>>>                Procedure OnExecute Variant vCommandBarControl
85048>>>                End_Procedure
85049>>>            End_Object
85050>>>
85050>>>        End_Object
85051>>>        // Binds OnDropDown to this menu
85051>>>        Set phoButtonPopup to oButtonMenu 
85052>>>
85052>>>    End_Object
85053>>>
85053>>>    // this is split button (Vista or greater required), where OnClick and
85053>>>    // OnDropDown are two events. OnDropDown automatically invokes phoButtonPopup
85053>>>    
85053>>>    Object oSplitButton is a cSplitButton
85055>>>        Set Size to 14 53
85056>>>        Set Location to 65 76
85057>>>        Set Label to 'Save'
85058>>>        Set psImage to "ActionSaveRecord.ico"
85059>>>    
85059>>>        Procedure OnClick
85062>>>        End_Procedure
85063>>>        
85063>>>        Object oButtonMenu is a cCJContextMenu
85065>>>            
85065>>>            Object oMenuItem1 is a cCJMenuItem
85067>>>                Set psCaption to "Set to Save"
85068>>>                Procedure OnExecute Variant vCommandBarControl
85071>>>                    Delegate Set label to "Save"
85073>>>                    Delegate Set psImage to "ActionSaveRecord.ico"
85075>>>                End_Procedure
85076>>>            End_Object
85077>>>            
85077>>>            Object oMenuItem2 is a cCJMenuItem
85079>>>                Set psCaption to "Set to Clear"
85080>>>                Procedure OnExecute Variant vCommandBarControl
85083>>>                    Delegate Set label  to "Clear"
85085>>>                    Delegate Set psImage to  "ActionClear.ico"
85087>>>                End_Procedure
85088>>>            End_Object
85089>>>            
85089>>>            Object oMenuItem3 is a cCJMenuItem
85091>>>                Set psCaption to "Set to Delete"
85092>>>                Procedure OnExecute Variant vCommandBarControl
85095>>>                    Delegate Set label  to "Delete"
85097>>>                    Delegate Set psImage to  "ActionDeleteRecord.ico"
85099>>>                End_Procedure
85100>>>            End_Object
85101>>>
85101>>>            Object oMenuItem4 is a cCJMenuItem
85103>>>                Set psCaption to "Set to Select"
85104>>>                Procedure OnExecute Variant vCommandBarControl
85107>>>                    Delegate Set label  to "Select"
85109>>>                    Delegate Set psImage to  ""
85111>>>                End_Procedure
85112>>>            End_Object
85113>>>
85113>>>        End_Object
85114>>>
85114>>>        Set phoButtonPopup to oButtonMenu 
85115>>>
85115>>>    End_Object
85116>>>
85116>>>    Object oTextBox2 is a TextBox
85118>>>        Set Size to 9 115
85119>>>        Set Location to 51 166
85120>>>        Set Label to "Button using an external image list"
85121>>>    End_Object
85122>>>    
85122>>>    // button have 6 image states. We will provide a different image
85122>>>    // for each of these states
85122>>>    Object oImageList is a cImageList32
85124>>>        Set piMaxImages to 6
85125>>>        Set piImageHeight to 16
85126>>>        Set piImageWidth to 16
85127>>>        Procedure OnCreate
85130>>>            Integer iIndex
85130>>>            // for buttons either create 1 image or 6
85130>>>            // if 6, they are normal, hot, pressed, disabled, defaulted, stylus-hot
85130>>>            Get AddImage "ClosFold.bmp" to iIndex
85131>>>            Get AddImage "OpenFold.bmp" to iIndex
85132>>>            Get AddImage "OpenFold.bmp" to iIndex
85133>>>            Get AddImage "ClosFold.bmp" to iIndex
85134>>>            Get AddImage "OpenFold.bmp" to iIndex
85135>>>            Get AddImage "ClosFold.bmp" to iIndex
85136>>>        End_Procedure
85137>>>    End_Object
85138>>>
85138>>>    // this attaches to an external imageist with 6 images. Because this
85138>>>    // uses an external imagelist you will not see the image modeled in the Studio
85138>>>    Object oMultiImageButton is a Button
85140>>>        Set Location to 65 194
85141>>>        Set phoExternalButtonImageList to oImageList
85142>>>        Set peImageAlign to Button_ImageList_Align_Center
85143>>>        
85143>>>        Procedure OnClick
85146>>>        End_Procedure
85147>>>
85147>>>    End_Object
85148>>>
85148>>>    // CommandLinkButtons work with Vista or greater required
85148>>>    Object oCommandLinkButtonGroup is a Group
85150>>>        Set Size to 115 258
85151>>>        Set Location to 90 10
85152>>>        Set Label to "CommandLink Buttons"
85153>>>
85153>>>        Object oCommandLinkStandard is a cCommandLinkButton
85155>>>            Set Location to 11 9
85156>>>            Set Size to 34 239
85157>>>            Set Label to 'CommandLink Choice 1'
85158>>>            Set psNote to "This is a normal command link button with the standard command link image"
85159>>>    
85159>>>            Procedure OnClick
85162>>>            End_Procedure
85163>>>            
85163>>>        End_Object
85164>>>
85164>>>        Object oCommandLinkShield is a cCommandLinkButton
85166>>>            Set Location to 44 9
85167>>>            Set Size to 34 239
85168>>>            Set Label to 'CommandLink Choice 2'
85169>>>            Set psNote to "This is a command link button using the Windows elevated shield image"
85170>>>            Set pbShield to True
85171>>>    
85171>>>            Procedure OnClick
85174>>>            End_Procedure
85175>>>            
85175>>>        End_Object
85176>>>
85176>>>        Object oCommandLinkCustom is a cCommandLinkButton
85178>>>            Set Location to 78 9
85179>>>            Set Size to 34 239
85180>>>            Set Label to 'CommandLink Choice 3'
85181>>>            Set psNote to "This is a command link with a custom image. This image just happens to be larger"
85182>>>            Set psImage to "DF32.bmp"
85183>>>            Set piImageSize to 48
85184>>>
85184>>>            Procedure OnClick
85187>>>            End_Procedure
85188>>>            
85188>>>        End_Object
85189>>>
85189>>>    End_Object
85190>>>
85190>>>
85190>>>Cd_End_Object
85192>>>>
85192>              Use DemoCalendarControl.vw
Including file: DemoCalendarControl.vw    (C:\Test\Order Entry git\AppSrc\DemoCalendarControl.vw)
85192>>>Use Windows.pkg
85192>>>Use DFClient.pkg
85192>>>
85192>>>Use MonthCalendarPrompt.dg
85192>>>Use cTextEdit.pkg
85192>>>
85192>>>Activate_View Activate_oDemoCalendarControl for oDemoCalendarControl
85202>>>>
85202>>>Object oDemoCalendarControl is a dbView
85204>>>
85204>>>    Set Border_Style to Border_Thick
85205>>>    Set Size to 148 196
85206>>>    Set Location to 2 2
85207>>>    Set Label to "Calendar Control Sample"
85208>>>
85208>>>    // Simplest case example, just set the prompt_object
85208>>>    Object oDateFormTest is a Form
85210>>>        Set Location to 16 89
85211>>>        Set Size to 13 66
85212>>>        Set Label to "Date Select Test:"
85213>>>
85213>>>        Set Prompt_Object to oMonthCalendarPrompt
85214>>>        Set Prompt_Button_Mode to PB_PromptOn
85215>>>
85215>>>    End_Object
85216>>>
85216>>>    Object oDateRangeGroup is a Group
85218>>>
85218>>>        Set Label to "Selecting Date Range"
85219>>>        Set Size to 74 165
85220>>>        Set Location to 39 23
85221>>>        
85221>>>        Object oFromDate is a Form
85223>>>            Set Label to "From:"
85224>>>            Set Location to 29 66
85225>>>            Set Size to 13 66
85226>>>            Set Prompt_Button_Mode to PB_PromptOn
85227>>>            Set Prompt_Object to oMonthCalendarPrompt
85228>>>            
85228>>>            Procedure Prompt_Callback Integer hoPrompt
85231>>>                Send DateRangeCallback hoPrompt
85232>>>            End_Procedure
85233>>>        End_Object
85234>>>        
85234>>>        Object oToDate is a Form
85236>>>            Set Label to "To:"
85237>>>            Set Location to 50 66
85238>>>            Set Size to 13 66
85239>>>            Set Prompt_Button_Mode to PB_PromptOn
85240>>>            
85240>>>            Procedure Prompt
85243>>>                Send Popup to oMonthCalendarPrompt
85244>>>            End_Procedure
85245>>>            
85245>>>            Procedure Prompt_Callback Integer hoPrompt
85248>>>                Send DateRangeCallback hoPrompt
85249>>>            End_Procedure
85250>>>        End_Object
85251>>>
85251>>>              Object oTextBox1 is a TextBox
85253>>>                        Set Size to 10 154
85254>>>                        Set Location to 11 3
85255>>>                        Set Label to "(select initial date and drag the mouse to end date)"
85256>>>              End_Object
85257>>>        
85257>>>        
85257>>>        // Since these two date forms are using the same logic, we delegate to here
85257>>>        // and let the group handle the inititalization and update
85257>>>        
85257>>>        // this is the callback set in DateRangeCallback
85257>>>        Procedure DoDateUpdate Integer hoSel Date dDate1 Date dDate2
85260>>>            Set Value of oFromDate to dDate1
85261>>>            Set Value of oToDate to dDate2
85262>>>        End_Procedure
85263>>>        
85263>>>        // This is the first callback. Make this multi-select, 
85263>>>        // no click select, show week numbers, don't show today stuff.   
85263>>>        // also set the callback to call DoDateUpdate (which will delegate to here)
85263>>>        Procedure DateRangeCallback Integer hoPrompt
85266>>>            Date dDate1 dDate2
85266>>>            
85266>>>            Set pbMultiSelect of hoPrompt to True
85267>>>            Set peMouseSelectOk of hoPrompt to msoNone
85268>>>            Set phmPromptUpdateCallback of hoPrompt to (RefProc(DoDateUpdate))
85269>>>            
85269>>>            Set pbWeekNumbers of hoPrompt to True
85270>>>            Set pbNoToday of hoPrompt to True
85271>>>            Set pbNoTodayCircle of hoPrompt to True
85272>>>            
85272>>>            Get Value of oFromDate to dDate1
85273>>>            Get Value of oToDate to dDate2
85274>>>            Set pdSeedValue of hoPrompt to dDate1 
85275>>>            Set pdSeedValue2 of hoPrompt to dDate2 
85276>>>        End_Procedure
85277>>>    End_Object
85278>>>
85278>>>    Object oDateTextBox is a TextBox
85280>>>        Set Size to 10 34
85281>>>        Set Location to 123 56
85282>>>        Set Label to '1/30/2016'
85283>>>        Procedure Activating 
85286>>>            Set Label to (Date(CurrentDateTime()))
85287>>>            Forward Send Activating
85289>>>        End_Procedure
85290>>>    End_Object
85291>>>
85291>>>    Object oButton1 is a Button
85293>>>        Set Location to 121 100
85294>>>        Set Label to 'Change'
85295>>>        
85295>>>        Procedure Prompt_Callback Integer hoPrompt
85298>>>            Date dDate
85298>>>            Get Value of oDateTextBox to dDate
85299>>>            Set peUpdateMode of hoPrompt to umPromptCustom
85300>>>            Set pdSeedValue of hoPrompt to dDate
85301>>>            Set phmPromptUpdateCallback of hoPrompt to (RefProc(DoDateUpdate))
85302>>>        End_Procedure
85303>>>
85303>>>        Procedure DoDateUpdate Integer hoSel Date dDate1 Date dDate2
85306>>>            Set Value of oDateTextBox to dDate1
85307>>>        End_Procedure
85308>>>    
85308>>>        Procedure OnClick
85311>>>            Send Popup of oMonthCalendarPrompt
85312>>>        End_Procedure
85313>>>    
85313>>>    End_Object
85314>>>    
85314>>>End_Object
85315>        Use DemoParentCombos.vw
Including file: DemoParentCombos.vw    (C:\Test\Order Entry git\AppSrc\DemoParentCombos.vw)
85315>>>Use dfClient.pkg
85315>>>Use DataDict.pkg
85315>>>Use dfEntry.pkg
85315>>>Use dfSpnEnt.pkg
85315>>>Use dfCEntry.pkg
85315>>>Use dfTable.pkg
85315>>>Use Windows.pkg
85315>>>Use Vendor.DD
85315>>>Use Invt.DD
85315>>>Use Customer.DD
85315>>>Use SalesP.DD
85315>>>Use OrderHea.DD
85315>>>Use OrderDtl.DD
85315>>>Use cDbCJGrid.pkg
85315>>>Use cCJGridColumnRowIndicator.pkg
85315>>>Use DbParentCombo.pkg
Including file: dbParentCombo.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\dbParentCombo.pkg)
85315>>>>>Use Dfcentry.pkg
85315>>>>>
85315>>>>>// Combo for parents. 
85315>>>>>Class dbParentCombo is a dbComboForm
85316>>>>>    Procedure Construct_Object
85318>>>>>        Forward Send Construct_Object
85320>>>>>        
85320>>>>>        // Show a psEmptyItemDescription. If Entry_State is false, you probably
85320>>>>>        // want this false as well
85320>>>>>        Property Boolean pbAddEmptyItem True        
85321>>>>>        Property String psEmptyItemDescription DD_BLANK_CODE_DESCRIPTION
85322>>>>>        
85322>>>>>        // if true, the list is refilled each time the combo takes the focus
85322>>>>>        // making it more dynamic. You can manually refill a list sending ComboRefill
85322>>>>>        Property Boolean pbRefillOnFocus False
85323>>>>>        
85323>>>>>        // object maintained. If it detects that the list does not contain a parent it
85323>>>>>        // will set this true to force a refill on the next focus 
85323>>>>>        Property Boolean pbNeedsRefill False
85324>>>>>        
85324>>>>>        // make sure these properties are what we want
85324>>>>>        Set Code_Display_Mode to CB_Code_Display_Description
85325>>>>>        Set Undefined_Display_Mode to CB_ERR_UPDATE_WINDOW_VALUE // don't change
85326>>>>>        Set Undefined_Save_Mode    to CB_ERR_UPDATE_WINDOW_VALUE // don't change
85327>>>>>        
85327>>>>>        // in general this will work best with a non-editable combo
85327>>>>>        // but the other style works as well
85327>>>>>        Set Entry_State 0 to False
85328>>>>>        // its ok to change this - when default it displays in Combo_Index order
85328>>>>>        Set Combo_Sort_State to True
85329>>>>>    End_Procedure
85330>>>>>    
85330>>>>>    // augment to fill list when paged (instead of doing earlier)
85330>>>>>    Procedure Page_Object Boolean bPage
85332>>>>>        If bPage Begin
85334>>>>>            Send ComboRefill
85335>>>>>        End
85335>>>>>>
85335>>>>>        Forward Send Page_Object bPage
85337>>>>>    End_Procedure
85338>>>>>
85338>>>>>    
85338>>>>>    // Augmentation to handle optional combo refill on set focus
85338>>>>>    Procedure Notify_Focus_Change Integer Fg
85340>>>>>        Boolean bReFillOnFocus bNeedsRefill
85340>>>>>        Forward Send Notify_Focus_Change Fg
85342>>>>>        If Fg Begin
85344>>>>>            Get pbNeedsRefill to bNeedsRefill
85345>>>>>            Get pbRefillOnFocus to bReFillOnFocus
85346>>>>>            If (bRefillOnFocus or bNeedsRefill) Begin
85348>>>>>                Send ComboRefill
85349>>>>>            End
85349>>>>>>
85349>>>>>        End
85349>>>>>>
85349>>>>>    End_Procedure
85350>>>>>    
85350>>>>>    // Refill combo list, while maintaining current value
85350>>>>>    Procedure ComboRefill
85352>>>>>        String sValue
85352>>>>>        Set Deferred_State to True
85353>>>>>        Get Value 0 to sValue
85354>>>>>        Send Combo_Fill_List
85355>>>>>        Set Deferred_State to False
85356>>>>>        Set Combo_data_object to (Combo_Data_Object(Self))
85357>>>>>        Set Local_Value 0 to sValue
85358>>>>>    End_Procedure
85359>>>>>    
85359>>>>>    // Augment to  init and fill the list with all parents.
85359>>>>>    Procedure Combo_Fill_List
85361>>>>>        Handle hoServer hoDD
85361>>>>>        Integer iFile iField iIndex
85361>>>>>        String sDescription sData
85361>>>>>        Boolean bAddEmptyItem
85361>>>>>        Boolean bOldRelate bNeedsRelate
85361>>>>>        RowID riID
85361>>>>>        
85361>>>>>        Get Server to hoServer
85362>>>>>        Get Data_File to iFile
85363>>>>>        Get Data_Field to iField
85364>>>>>        Get Combo_Index to iIndex
85365>>>>>        Get pbAddEmptyItem to bAddEmptyItem
85366>>>>>        Send Combo_Delete_Data
85367>>>>>        
85367>>>>>        If (hoServer and iFile) Begin
85369>>>>>    
85369>>>>>            Get Data_Set of hoServer iFile to hoDD
85370>>>>>            
85370>>>>>            If (hoDD) Begin
85372>>>>>                Set Relational_State to True
85373>>>>>                If (bAddEmptyItem) Begin
85375>>>>>                    Get psEmptyItemDescription to sDescription
85376>>>>>                    Send Combo_Add_Blank_Item sDescription
85377>>>>>                    Set Data_Only_State to True // this got cleared - we don't care about dummy item
85378>>>>>                End
85378>>>>>>
85378>>>>>                
85378>>>>>                If (iIndex <= 0) Begin
85380>>>>>                    Get_Attribute DF_FIELD_INDEX of iFile iField to iIndex
85383>>>>>                End
85383>>>>>>
85383>>>>>                // optimize relates. Only do it if needed
85383>>>>>                Get No_Relate_State of hoDD to bOldRelate
85384>>>>>                Get DDOConstraintNeedsRelate of hoDD iIndex to bNeedsRelate
85385>>>>>                Set No_Relate_State of hoDD to (not(bNeedsRelate))
85386>>>>>                Send Request_Read of hoDD FIRST_RECORD iFile iIndex
85387>>>>>                While (Found)
85391>>>>>                    Send AddParentItemFromRecord  
85392>>>>>                    Send Locate_Next of hoDD
85393>>>>>                 Loop
85394>>>>>>
85394>>>>>                Set No_Relate_State of hoDD to bOldRelate
85395>>>>>            End
85395>>>>>>
85395>>>>>        End
85395>>>>>>
85395>>>>>        If (not(hoDD)) Begin
85397>>>>>            Error DFERR_PROGRAM "Invalid use of DbParentCombo"            
85398>>>>>>
85398>>>>>        End
85398>>>>>>
85398>>>>>        Set pbNeedsRefill to False
85399>>>>>    End_Procedure
85400>>>>>    
85400>>>>>    Procedure AddParentItemFromRecord
85402>>>>>        Integer iFile iField iItems
85402>>>>>        String sData sDescription
85402>>>>>        RowID riID
85402>>>>>        
85402>>>>>        Get Data_File to iFile
85403>>>>>        Get Data_Field to iField
85404>>>>>        Move (GetRowID(iFile)) to riID
85405>>>>>        Get_Field_Value iFile iField to sData
85408>>>>>        Move (Trim(sData)) to sData 
85409>>>>>        Move sData to sDescription
85410>>>>>        // user hook to customize the combo description
85410>>>>>        Send OnDefineDescription (&sDescription)
85411>>>>>        Get Combo_Item_Count to iItems
85412>>>>>        Send ComboFillItem iItems sData sDescription iFile riID
85413>>>>>        Increment iItems
85414>>>>>    End_Procedure
85415>>>>>    
85415>>>>>    // Hook to customize a combo item's description.
85415>>>>>    Procedure OnDefineDescription String ByRef sDescription
85417>>>>>    End_Procedure
85418>>>>>    
85418>>>>>    // augment to test that we found a match and if not add it to the list
85418>>>>>    Procedure Display_Description String DataVal
85420>>>>>        String sValue
85420>>>>>        Integer iItem
85420>>>>>        Move (Trim(DataVal)) to DataVal // must be trimmed for Combo_Item_Matching below
85421>>>>>        Get Data_to_Description DataVal to sValue
85422>>>>>        // Test that the combo item exists. We assume that a missing combo item means the list is out of date.
85422>>>>>        // If so, add the missing item and mark that we probably need to do a refill next chance we get.
85422>>>>>        If (DataVal<>"") Begin
85424>>>>>            Get Combo_Item_Matching sValue to iItem
85425>>>>>            If (iItem=-1) Begin
85427>>>>>                Send AddParentItemFromRecord
85428>>>>>                Set pbNeedsRefill to True
85429>>>>>                // now it should work
85429>>>>>                Get Data_to_Description DataVal to sValue
85430>>>>>            End
85430>>>>>>
85430>>>>>        End
85430>>>>>>
85430>>>>>        Set Value item 0 to sValue
85431>>>>>    End_Procedure
85432>>>>>    
85432>>>>>    // cancel so the list is not built upon attach to DDO. Attach upon activation
85432>>>>>    Procedure combo_initialize_list
85434>>>>>    End_Procedure
85435>>>>>    
85435>>>>>    
85435>>>>>End_Class
85436>>>Use MonthCalendarPrompt.dg
85436>>>
85436>>>Activate_View Activate_oDemoParentCombos for oDemoParentCombos
85446>>>>
85446>>>Object oDemoParentCombos is a dbView
85448>>>    Set Border_Style to Border_Thick
85449>>>    Set Maximize_Icon to True
85450>>>    Set Label to "Parent Combo Demo"
85451>>>    Set Location to 2 3
85452>>>    Set Size to 174 383
85453>>>    Set piMinSize to 174 383
85454>>>    
85454>>>
85454>>>    Object Vendor_DD is a Vendor_DataDictionary
85456>>>    End_Object    // Vendor_DD
85457>>>
85457>>>    Object Invt_DD is a Invt_DataDictionary
85459>>>        Set DDO_Server to Vendor_DD
85460>>>    End_Object    // Invt_DD
85461>>>
85461>>>    Object Customer_DD is a Customer_DataDictionary
85463>>>    End_Object    // Customer_DD
85464>>>
85464>>>    Object SalesP_DD is a Salesp_DataDictionary
85466>>>    End_Object    // SalesP_DD
85467>>>
85467>>>    Object OrderHea_DD is a OrderHea_DataDictionary
85469>>>        Set DDO_Server to Customer_DD
85470>>>        Set DDO_Server to SalesP_DD
85471>>>        
85471>>>        // this lets you save a new OrderHea from within OrderDtl.
85471>>>        Set Allow_Foreign_New_Save_State to True
85472>>>        
85472>>>    End_Object    // OrderHea_DD
85473>>>    
85473>>>    Object OrderDtl_DD is a OrderDtl_DataDictionary
85475>>>        Set DDO_Server to OrderHea_DD
85476>>>        Set DDO_Server to Invt_DD
85477>>>        Set Constrain_File to OrderHea.File_Number
85478>>>    End_Object    // OrderDtl_DD
85479>>>
85479>>>    Set Main_DD to OrderHea_DD
85480>>>    Set Server to OrderHea_DD
85481>>>    
85481>>>    Object oDbContainer3d1 is a dbContainer3d
85483>>>        Set Size to 85 377
85484>>>        Set Location to 2 3
85485>>>        Set peAnchors to anTopLeftRight
85486>>>        
85486>>>        
85486>>>        Object oOrderHea_Order_Number is a dbForm
85488>>>            Entry_Item OrderHea.Order_Number
85489>>>            Set Label to "Order Number:"
85490>>>            Set Size to 13 42
85491>>>            Set Location to 4 63
85492>>>            Set peAnchors to anTopLeft
85493>>>            Set Label_Col_Offset to 2
85494>>>            Set Label_Justification_Mode to jMode_Right
85495>>>            
85495>>>        End_Object    // oOrderHea_Order_Number
85496>>>
85496>>>        Object oOrderHea_Customer_Number is a DbParentCombo
85498>>>            Entry_Item Customer.Customer_Number
85499>>>            Set Label to "Customer Number:"
85500>>>            Set Size to 13 42
85501>>>            Set Location to 4 201
85502>>>            Set peAnchors to anTopRight
85503>>>            Set Label_Col_Offset to 2
85504>>>            Set Label_Justification_Mode to jMode_Right
85505>>>            Set psEmptyItemDescription to "???"
85506>>>            // with numbers, not sorting may be preferred
85506>>>            Set Combo_Sort_State to False
85507>>>            // anytime this takes the focus, refill the combo. If the list is very
85507>>>            // large you may not want this. However, if the list is very large you
85507>>>            // may not want parent combos.
85507>>>            Set pbRefillOnFocus to True
85508>>>        End_Object
85509>>>
85509>>>        Object oOrderHea_Order_Date is a dbForm
85511>>>            Entry_Item OrderHea.Order_Date
85512>>>            Set Label to "Order Date:"
85513>>>            Set Size to 13 67
85514>>>            Set Location to 4 299
85515>>>            Set peAnchors to anTopRight
85516>>>            Set Label_Col_Offset to 2
85517>>>            Set Label_Justification_Mode to jMode_Right
85518>>>            
85518>>>            Set Prompt_Object to oMonthCalendarPrompt
85519>>>            Set Prompt_Button_Mode to PB_PromptOn
85520>>>        End_Object    // oOrderHea_Order_Date
85521>>>
85521>>>        Object oCustomer_Name is a dbForm
85523>>>            Entry_Item Customer.Name
85524>>>            Set Label to "Customer Name:"
85525>>>            Set Size to 13 180
85526>>>            Set Location to 18 63
85527>>>            Set peAnchors to anTopLeftRight
85528>>>            Set Label_Col_Offset to 2
85529>>>            Set Label_Justification_Mode to jMode_Right
85530>>>        End_Object    // oCustomer_Name
85531>>>
85531>>>        Object oCustomer_Address is a dbForm
85533>>>            Entry_Item Customer.Address
85534>>>            Set Label to "Street Address:"
85535>>>            Set Size to 13 180
85536>>>            Set Location to 34 63
85537>>>            Set peAnchors to anTopLeftRight
85538>>>            Set Label_Col_Offset to 2
85539>>>            Set Label_Justification_Mode to jMode_Right
85540>>>        End_Object    // oCustomer_Address
85541>>>
85541>>>        Object oCustomer_City is a dbForm
85543>>>            Entry_Item Customer.City
85544>>>            Set Label to "City/State/Zip:"
85545>>>            Set Size to 13 84
85546>>>            Set Location to 49 63
85547>>>            Set peAnchors to anTopLeftRight
85548>>>            Set Label_Col_Offset to 2
85549>>>            Set Label_Justification_Mode to jMode_Right
85550>>>        End_Object    // oCustomer_City
85551>>>
85551>>>        Object oCustomer_State is a dbForm
85553>>>            Entry_Item Customer.State
85554>>>            Set Size to 13 20
85555>>>            Set Location to 49 155
85556>>>            Set peAnchors to anTopRight
85557>>>        End_Object    // oCustomer_State
85558>>>
85558>>>        Object oCustomer_Zip is a dbForm
85560>>>            Entry_Item Customer.Zip
85561>>>            Set Size to 13 60
85562>>>            Set Location to 49 183
85563>>>            Set peAnchors to anTopRight
85564>>>        End_Object    // oCustomer_Zip
85565>>>
85565>>>        Object oOrderHea_Ordered_By is a dbForm
85567>>>            Entry_Item OrderHea.Ordered_By
85568>>>            Set Label to "Ordered By:"
85569>>>            Set Size to 13 67
85570>>>            Set Location to 34 299
85571>>>            Set peAnchors to anTopRight
85572>>>            Set Label_Col_Offset to 2
85573>>>            Set Label_Justification_Mode to jMode_Right
85574>>>        End_Object    // oOrderHea_Ordered_By
85575>>>
85575>>>        Object oOrderHea_Salesperson_ID is a DbParentCombo
85577>>>            Entry_Item Salesp.Id
85578>>>            Set Label to "Sold by:"
85579>>>            Set Size to 11 90
85580>>>            Set Location to 49 276
85581>>>            Set peAnchors to anTopRight
85582>>>            Set Label_Col_Offset to 2
85583>>>            Set Label_Justification_Mode to jMode_Right
85584>>>            Set psEmptyItemDescription to "<none>"
85585>>>            
85585>>>            Procedure OnDefineDescription String ByRef sDescription
85588>>>                Move (trim(Salesp.ID) + " - " * SalesP.Name) to sDescription
85589>>>            End_Procedure
85590>>>        End_Object    // oOrderHea_Salesperson_ID
85591>>>
85591>>>        Object oOrderHea_Terms is a dbComboForm
85593>>>            Entry_Item OrderHea.Terms
85594>>>            Set Label to "Terms:"
85595>>>            Set Size to 13 85
85596>>>            Set Location to 64 63
85597>>>            Set peAnchors to anTopLeft
85598>>>            Set Form_Border to 0
85599>>>            Set Label_Col_Offset to 2
85600>>>            Set Label_Justification_Mode to jMode_Right
85601>>>            Set Entry_State to False
85602>>>
85602>>>        End_Object    // oOrderHea_Terms
85603>>>
85603>>>        Object oOrderHea_Ship_Via is a dbComboForm
85605>>>            Entry_Item OrderHea.Ship_Via
85606>>>            Set Label to "Ship Via:"
85607>>>            Set Size to 13 103
85608>>>            Set Location to 64 183
85609>>>            Set peAnchors to anTopRight
85610>>>            Set Form_Border to 0
85611>>>            Set Label_Col_Offset to 2
85612>>>            Set Label_Justification_Mode to jMode_Right
85613>>>            Set Entry_State to False
85614>>>            
85614>>>
85614>>>        End_Object    // oOrderHea_Ship_Via
85615>>>
85615>>>    End_Object    // oDbContainer3d1
85616>>>
85616>>>    Object oOrderDtl_Grid is a cDbCJGrid
85618>>>        Set Server to OrderDtl_DD
85619>>>        Set Ordering to 1
85620>>>        Set Size to 63 377
85621>>>        Set Location to 90 3
85622>>>        Set peAnchors to anAll
85623>>>        Set pbAllowInsertRow to False
85624>>>        Set pbRestoreLayout to False
85625>>>        Set psLayoutSection to "OrderView_oOrderDtl_Grid2"
85626>>>        Set piLayoutBuild to 6
85627>>>        Set pbHeaderPrompts to True
85628>>>
85628>>>        On_Key Key_F11 Send Request_InsertRow
85629>>>
85629>>>        Object oMark is a cCJGridColumnRowIndicator
85631>>>        End_Object
85632>>>        
85632>>>        Object oInvt_Item_ID is a cDbCJGridColumn
85634>>>            Entry_Item Invt.Item_ID
85635>>>            Set piWidth to 91
85636>>>            Set psCaption to "Item ID"
85637>>>            Set psImage to "ActionPrompt.ico"
85638>>>        End_Object
85639>>>
85639>>>        Object oInvt_Description is a cDbCJGridColumn
85641>>>            Entry_Item Invt.Description
85642>>>            Set piWidth to 213
85643>>>            Set psCaption to "Description"
85644>>>        End_Object
85645>>>
85645>>>        Object oInvt_Unit_Price is a cDbCJGridColumn
85647>>>            Entry_Item Invt.Unit_Price
85648>>>            Set piWidth to 53
85649>>>            Set psCaption to "Unit Price"
85650>>>        End_Object
85651>>>
85651>>>        Object oOrderDtl_Qty_Ordered is a cDbCJGridColumn
85653>>>            Entry_Item OrderDtl.Qty_Ordered
85654>>>            Set piWidth to 50
85655>>>            Set psCaption to "Quantity"
85656>>>        End_Object
85657>>>
85657>>>        Object oOrderDtl_Price is a cDbCJGridColumn
85659>>>            Entry_Item OrderDtl.Price
85660>>>            Set piWidth to 62
85661>>>            Set psCaption to "Price"
85662>>>        End_Object
85663>>>
85663>>>        Object oOrderDtl_Extended_Price is a cDbCJGridColumn
85665>>>            Entry_Item OrderDtl.Extended_Price
85666>>>            Set piWidth to 81
85667>>>            Set psCaption to "Total"
85668>>>        End_Object
85669>>>        
85669>>>    End_Object    // oOrderDtl_Grid
85670>>>
85670>>>    Object oOrderHea_Order_Total is a dbForm
85672>>>        Entry_Item OrderHea.Order_Total
85673>>>        Set Label to "Order Total:"
85674>>>        Set Size to 13 60
85675>>>        Set Location to 156 307
85676>>>        Set peAnchors to anBottomRight
85677>>>        Set Label_Col_Offset to 3
85678>>>        Set Label_Justification_Mode to jMode_Right
85679>>>    End_Object    // oOrderHea_Order_Total
85680>>>
85680>>>    Object oPrintBtn is a Button
85682>>>        Set Label to "Print Order"
85683>>>        Set Location to 156 3
85684>>>        Set peAnchors to anBottomLeft
85685>>>        Set psToolTip to "Print preview of current order"
85686>>>
85686>>>        Procedure OnClick
85689>>>            Delegate Send PrintCurrentOrder // defined in view object
85691>>>        End_Procedure  // OnClick
85692>>>        
85692>>>    End_Object    // oPrintBtn
85693>>>
85693>>>
85693>>>    // Change:   Create custom confirmation messages for save and delete
85693>>>    //           We must create the new functions and assign verify messages
85693>>>    //           to them.
85693>>>    Function Confirm_Delete_Order Returns Integer
85696>>>        Integer iRetVal
85696>>>        Get Confirm "Delete Entire Order?" to iRetVal
85697>>>        Function_Return iRetVal
85698>>>    End_Function
85699>>>    
85699>>>    // Only confirm on the saving of new records
85699>>>    Function Confirm_Save_Order Returns Integer
85702>>>        Integer iNoSave iSrvr
85702>>>        Boolean bOld
85702>>>        Get Server to iSrvr
85703>>>        Get HasRecord of iSrvr to bOld
85704>>>        If not bOld Begin
85706>>>            Get Confirm "Save this NEW order header?" to iNoSave
85707>>>        End
85707>>>>
85707>>>        Function_Return iNoSave
85708>>>    End_Function
85709>>>    
85709>>>    // Define alternate confirmation Messages
85709>>>    Set Verify_Save_MSG       to (RefFunc(Confirm_Save_Order))
85710>>>    Set Verify_Delete_MSG     to (RefFunc(Confirm_Delete_Order))
85711>>>    Set Auto_Clear_DEO_State  to False // don't clear Header on save
85712>>>    
85712>>>    
85712>>>    // print the current order. This message will be sent
85712>>>    // by the print button
85712>>>    Procedure PrintCurrentOrder
85715>>>        Integer hDD iNum
85715>>>        Get Server to hDD // this will be the OrderHea DD
85716>>>        If (HasRecord(hDD)) Begin // only do this if record exists
85718>>>            Get Field_Current_Value of hDD Field OrderHea.Order_Number to iNum
85719>>>//            Send PrintOrder of oOrder_Report iNum
85719>>>            Send Info_Box "This is just a stub and this invoice is not actually being printed" ("Print Order " + String(iNum))
85720>>>        End
85720>>>>
85720>>>    End_Procedure
85721>>>    
85721>>>    // refresh is sent to containers. We will use that to control the print button and only
85721>>>    // enable it when an order exists
85721>>>    Procedure Refresh Integer eMode
85724>>>        Boolean bRec
85724>>>        Handle hoServer
85724>>>        Get Server to hoServer
85725>>>        Get HasRecord of hoServer to bRec
85726>>>        Set Enabled_State of oPrintBtn to bRec
85727>>>    End_Procedure
85728>>>
85728>>>End_Object
85729>    
85729>        Procedure Activate_About
85732>            Send DoAbout "Order Entry Sample Application" "18.2.1.0" "Copyright (c) 2016 Data Access Corporation" "Data Access Worldwide" ""
85733>        End_Procedure
85734>    
85734>    End_Object
85735>
85735>
85735>End_Object
85736>
85736>// open Order Entry view on application startup
85736>Send Activate_oOrderEntryView of (oClientArea(oMain))
85737>Start_UI
85738>
Summary
Memory Available: 2147483646
Total Warnings : 0
Total Errors   : 0
Total Symbols  : 47273
Total Resources: 0
Total Commands : 85737
Total Windows  : 5
Total Pages    : 4
Static Data    : 536725
Message area   : 609465
Total Blocks   : 30620
